/**
 * oclazyload - Load modules on demand (lazy load) with angularJS
 * @version v1.0.10
 * @link https://github.com/ocombe/ocLazyLoad
 * @license MIT
 * @author Olivier Combe <olivier.combe@gmail.com>
 */
(function (angular, window) {
    'use strict';

    var regModules = ['ng', 'oc.lazyLoad'],
        regInvokes = {},
        regConfigs = [],
        modulesToLoad = [],
        
    realModules = [],
        
    recordDeclarations = [],
        broadcast = angular.noop,
        runBlocks = {},
        justLoaded = [];

    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);

    ocLazyLoad.provider('$ocLazyLoad', ["$controllerProvider", "$provide", "$compileProvider", "$filterProvider", "$injector", "$animateProvider", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {
        var modules = {},
            providers = {
            $controllerProvider: $controllerProvider,
            $compileProvider: $compileProvider,
            $filterProvider: $filterProvider,
            $provide: $provide, 
            $injector: $injector,
            $animateProvider: $animateProvider
        },
            debug = false,
            events = false,
            moduleCache = [],
            modulePromises = {};

        moduleCache.push = function (value) {
            if (this.indexOf(value) === -1) {
                Array.prototype.push.apply(this, arguments);
            }
        };

        this.config = function (config) {
            
            if (angular.isDefined(config.modules)) {
                if (angular.isArray(config.modules)) {
                    angular.forEach(config.modules, function (moduleConfig) {
                        modules[moduleConfig.name] = moduleConfig;
                    });
                } else {
                    modules[config.modules.name] = config.modules;
                }
            }

            if (angular.isDefined(config.debug)) {
                debug = config.debug;
            }

            if (angular.isDefined(config.events)) {
                events = config.events;
            }
        };

        /**
         * Get the list of existing registered modules
         * @param element
         */
        this._init = function _init(element) {
            
            if (modulesToLoad.length === 0) {
                var elements = [element],
                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
                    NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/,
                    append = function append(elm) {
                    return elm && elements.push(elm);
                };

                angular.forEach(names, function (name) {
                    names[name] = true;
                    append(document.getElementById(name));
                    name = name.replace(':', '\\:');
                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {
                        angular.forEach(element[0].querySelectorAll('.' + name), append);
                        angular.forEach(element[0].querySelectorAll('.' + name + '\\:'), append);
                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);
                    }
                });

                angular.forEach(elements, function (elm) {
                    if (modulesToLoad.length === 0) {
                        var className = ' ' + element.className + ' ';
                        var match = NG_APP_CLASS_REGEXP.exec(className);
                        if (match) {
                            modulesToLoad.push((match[2] || '').replace(/\s+/g, ','));
                        } else {
                            angular.forEach(elm.attributes, function (attr) {
                                if (modulesToLoad.length === 0 && names[attr.name]) {
                                    modulesToLoad.push(attr.value);
                                }
                            });
                        }
                    }
                });
            }

            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {
                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');
            }

            var addReg = function addReg(moduleName) {
                if (regModules.indexOf(moduleName) === -1) {
                    
                    regModules.push(moduleName);
                    var mainModule = angular.module(moduleName);

                    
                    _invokeQueue(null, mainModule._invokeQueue, moduleName);
                    _invokeQueue(null, mainModule._configBlocks, moduleName); 

                    angular.forEach(mainModule.requires, addReg);
                }
            };

            angular.forEach(modulesToLoad, function (moduleName) {
                addReg(moduleName);
            });

            modulesToLoad = []; 
            recordDeclarations.pop(); 
        };

        /**
         * Like JSON.stringify but that doesn't throw on circular references
         * @param obj
         */
        var stringify = function stringify(obj) {
            try {
                return JSON.stringify(obj);
            } catch (e) {
                var cache = [];
                return JSON.stringify(obj, function (key, value) {
                    if (angular.isObject(value) && value !== null) {
                        if (cache.indexOf(value) !== -1) {
                            
                            return;
                        }
                        
                        cache.push(value);
                    }
                    return value;
                });
            }
        };

        var hashCode = function hashCode(str) {
            var hash = 0,
                i,
                chr,
                len;
            if (str.length == 0) {
                return hash;
            }
            for (i = 0, len = str.length; i < len; i++) {
                chr = str.charCodeAt(i);
                hash = (hash << 5) - hash + chr;
                hash |= 0; 
            }
            return hash;
        };

        function _register(providers, registerModules, params) {
            if (registerModules) {
                var k,
                    moduleName,
                    moduleFn,
                    tempRunBlocks = [];
                for (k = registerModules.length - 1; k >= 0; k--) {
                    moduleName = registerModules[k];
                    if (!angular.isString(moduleName)) {
                        moduleName = getModuleName(moduleName);
                    }
                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {
                        continue;
                    }
                    
                    var newModule = regModules.indexOf(moduleName) === -1;
                    moduleFn = ngModuleFct(moduleName);
                    if (newModule) {
                        regModules.push(moduleName);
                        _register(providers, moduleFn.requires, params);
                    }
                    if (moduleFn._runBlocks.length > 0) {
                        
                        runBlocks[moduleName] = [];
                        while (moduleFn._runBlocks.length > 0) {
                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());
                        }
                    }
                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {
                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);
                    }
                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);
                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); 
                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);
                    registerModules.pop();
                    justLoaded.push(moduleName);
                }
                
                var instanceInjector = providers.getInstanceInjector();
                angular.forEach(tempRunBlocks, function (fn) {
                    instanceInjector.invoke(fn);
                });
            }
        }

        function _registerInvokeList(args, moduleName) {
            var invokeList = args[2][0],
                type = args[1],
                newInvoke = false;
            if (angular.isUndefined(regInvokes[moduleName])) {
                regInvokes[moduleName] = {};
            }
            if (angular.isUndefined(regInvokes[moduleName][type])) {
                regInvokes[moduleName][type] = {};
            }
            var onInvoke = function onInvoke(invokeName, invoke) {
                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {
                    regInvokes[moduleName][type][invokeName] = [];
                }
                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {
                    newInvoke = true;
                    regInvokes[moduleName][type][invokeName].push(invoke);
                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);
                }
            };

            function checkHashes(potentialNew, invokes) {
                var isNew = true,
                    newHash;
                if (invokes.length) {
                    newHash = signature(potentialNew);
                    angular.forEach(invokes, function (invoke) {
                        isNew = isNew && signature(invoke) !== newHash;
                    });
                }
                return isNew;
            }

            function signature(data) {
                if (angular.isArray(data)) {
                    
                    return hashCode(data.toString());
                } else if (angular.isObject(data)) {
                    
                    return hashCode(stringify(data));
                } else {
                    if (angular.isDefined(data) && data !== null) {
                        return hashCode(data.toString());
                    } else {
                        
                        return data;
                    }
                }
            }

            if (angular.isString(invokeList)) {
                onInvoke(invokeList, args[2][1]);
            } else if (angular.isObject(invokeList)) {
                angular.forEach(invokeList, function (invoke, key) {
                    if (angular.isString(invoke)) {
                        
                        onInvoke(invoke, invokeList[1]);
                    } else {
                        
                        onInvoke(key, invoke);
                    }
                });
            } else {
                return false;
            }
            return newInvoke;
        }

        function _invokeQueue(providers, queue, moduleName, reconfig) {
            if (!queue) {
                return;
            }

            var i, len, args, provider;
            for (i = 0, len = queue.length; i < len; i++) {
                args = queue[i];
                if (angular.isArray(args)) {
                    if (providers !== null) {
                        if (providers.hasOwnProperty(args[0])) {
                            provider = providers[args[0]];
                        } else {
                            throw new Error('unsupported provider ' + args[0]);
                        }
                    }
                    var isNew = _registerInvokeList(args, moduleName);
                    if (args[1] !== 'invoke') {
                        if (isNew && angular.isDefined(provider)) {
                            provider[args[1]].apply(provider, args[2]);
                        }
                    } else {
                        
                        var callInvoke = function callInvoke(fct) {
                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);
                            if (invoked === -1 || reconfig) {
                                if (invoked === -1) {
                                    regConfigs.push(moduleName + '-' + fct);
                                }
                                if (angular.isDefined(provider)) {
                                    provider[args[1]].apply(provider, args[2]);
                                }
                            }
                        };
                        if (angular.isFunction(args[2][0])) {
                            callInvoke(args[2][0]);
                        } else if (angular.isArray(args[2][0])) {
                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {
                                if (angular.isFunction(args[2][0][j])) {
                                    callInvoke(args[2][0][j]);
                                }
                            }
                        }
                    }
                }
            }
        }

        function getModuleName(module) {
            var moduleName = null;
            if (angular.isString(module)) {
                moduleName = module;
            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {
                moduleName = module.name;
            }
            return moduleName;
        }

        function moduleExists(moduleName) {
            if (!angular.isString(moduleName)) {
                return false;
            }
            try {
                return ngModuleFct(moduleName);
            } catch (e) {
                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {
                    return false;
                }
            }
        }

        this.$get = ["$log", "$rootElement", "$rootScope", "$cacheFactory", "$q", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {
            var instanceInjector,
                filesCache = $cacheFactory('ocLazyLoad');

            if (!debug) {
                $log = {};
                $log['error'] = angular.noop;
                $log['warn'] = angular.noop;
                $log['info'] = angular.noop;
            }

            
            providers.getInstanceInjector = function () {
                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();
            };

            broadcast = function broadcast(eventName, params) {
                if (events) {
                    $rootScope.$broadcast(eventName, params);
                }
                if (debug) {
                    $log.info(eventName, params);
                }
            };

            function reject(e) {
                var deferred = $q.defer();
                $log.error(e.message);
                deferred.reject(e);
                return deferred.promise;
            }

            return {
                _broadcast: broadcast,

                _$log: $log,

                /**
                 * Returns the files cache used by the loaders to store the files currently loading
                 * @returns {*}
                 */
                _getFilesCache: function getFilesCache() {
                    return filesCache;
                },

                /**
                 * Let the service know that it should monitor angular.module because files are loading
                 * @param watch boolean
                 */
                toggleWatch: function toggleWatch(watch) {
                    if (watch) {
                        recordDeclarations.push(true);
                    } else {
                        recordDeclarations.pop();
                    }
                },

                /**
                 * Let you get a module config object
                 * @param moduleName String the name of the module
                 * @returns {*}
                 */
                getModuleConfig: function getModuleConfig(moduleName) {
                    if (!angular.isString(moduleName)) {
                        throw new Error('You need to give the name of the module to get');
                    }
                    if (!modules[moduleName]) {
                        return null;
                    }
                    return angular.copy(modules[moduleName]);
                },

                /**
                 * Let you define a module config object
                 * @param moduleConfig Object the module config object
                 * @returns {*}
                 */
                setModuleConfig: function setModuleConfig(moduleConfig) {
                    if (!angular.isObject(moduleConfig)) {
                        throw new Error('You need to give the module config object to set');
                    }
                    modules[moduleConfig.name] = moduleConfig;
                    return moduleConfig;
                },

                /**
                 * Returns the list of loaded modules
                 * @returns {string[]}
                 */
                getModules: function getModules() {
                    return regModules;
                },

                /**
                 * Let you check if a module has been loaded into Angular or not
                 * @param modulesNames String/Object a module name, or a list of module names
                 * @returns {boolean}
                 */
                isLoaded: function isLoaded(modulesNames) {
                    var moduleLoaded = function moduleLoaded(module) {
                        var isLoaded = regModules.indexOf(module) > -1;
                        if (!isLoaded) {
                            isLoaded = !!moduleExists(module);
                        }
                        return isLoaded;
                    };
                    if (angular.isString(modulesNames)) {
                        modulesNames = [modulesNames];
                    }
                    if (angular.isArray(modulesNames)) {
                        var i, len;
                        for (i = 0, len = modulesNames.length; i < len; i++) {
                            if (!moduleLoaded(modulesNames[i])) {
                                return false;
                            }
                        }
                        return true;
                    } else {
                        throw new Error('You need to define the module(s) name(s)');
                    }
                },

                /**
                 * Given a module, return its name
                 * @param module
                 * @returns {String}
                 */
                _getModuleName: getModuleName,

                /**
                 * Returns a module if it exists
                 * @param moduleName
                 * @returns {module}
                 */
                _getModule: function getModule(moduleName) {
                    try {
                        return ngModuleFct(moduleName);
                    } catch (e) {
                        
                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {
                            e.message = 'The module "' + stringify(moduleName) + '" that you are trying to load does not exist. ' + e.message;
                        }
                        throw e;
                    }
                },

                /**
                 * Check if a module exists and returns it if it does
                 * @param moduleName
                 * @returns {boolean}
                 */
                moduleExists: moduleExists,

                /**
                 * Load the dependencies, and might try to load new files depending on the config
                 * @param moduleName (String or Array of Strings)
                 * @param localParams
                 * @returns {*}
                 * @private
                 */
                _loadDependencies: function _loadDependencies(moduleName, localParams) {
                    var loadedModule,
                        requires,
                        diff,
                        promisesList = [],
                        self = this;

                    moduleName = self._getModuleName(moduleName);

                    if (moduleName === null) {
                        return $q.when();
                    } else {
                        try {
                            loadedModule = self._getModule(moduleName);
                        } catch (e) {
                            return reject(e);
                        }
                        
                        requires = self.getRequires(loadedModule);
                    }

                    angular.forEach(requires, function (requireEntry) {
                        
                        
                        if (angular.isString(requireEntry)) {
                            var config = self.getModuleConfig(requireEntry);
                            if (config === null) {
                                moduleCache.push(requireEntry); 
                                return;
                            }
                            requireEntry = config;
                            
                            config.name = undefined;
                        }

                        
                        if (self.moduleExists(requireEntry.name)) {
                            
                            diff = requireEntry.files.filter(function (n) {
                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;
                            });

                            
                            if (diff.length !== 0) {
                                self._$log.warn('Module "', moduleName, '" attempted to redefine configuration for dependency. "', requireEntry.name, '"\n Additional Files Loaded:', diff);
                            }

                            
                            if (angular.isDefined(self.filesLoader)) {
                                
                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {
                                    return self._loadDependencies(requireEntry);
                                }));
                            } else {
                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));
                            }
                            return;
                        } else if (angular.isArray(requireEntry)) {
                            var files = [];
                            angular.forEach(requireEntry, function (entry) {
                                
                                var config = self.getModuleConfig(entry);
                                if (config === null) {
                                    files.push(entry);
                                } else if (config.files) {
                                    files = files.concat(config.files);
                                }
                            });
                            if (files.length > 0) {
                                requireEntry = {
                                    files: files
                                };
                            }
                        } else if (angular.isObject(requireEntry)) {
                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {
                                
                                self.setModuleConfig(requireEntry);
                                moduleCache.push(requireEntry['name']);
                            }
                        }

                        
                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {
                            if (angular.isDefined(self.filesLoader)) {
                                
                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {
                                    return self._loadDependencies(requireEntry);
                                }));
                            } else {
                                return reject(new Error('Error: the module "' + requireEntry.name + '" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));
                            }
                        }
                    });

                    
                    return $q.all(promisesList);
                },

                /**
                 * Inject new modules into Angular
                 * @param moduleName
                 * @param localParams
                 * @param real
                 */
                inject: function inject(moduleName) {
                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

                    var self = this,
                        deferred = $q.defer();
                    if (angular.isDefined(moduleName) && moduleName !== null) {
                        if (angular.isArray(moduleName)) {
                            var promisesList = [];
                            angular.forEach(moduleName, function (module) {
                                promisesList.push(self.inject(module, localParams, real));
                            });
                            return $q.all(promisesList);
                        } else {
                            self._addToLoadList(self._getModuleName(moduleName), true, real);
                        }
                    }
                    if (modulesToLoad.length > 0) {
                        var res = modulesToLoad.slice(); 
                        var loadNext = function loadNext(moduleName) {
                            moduleCache.push(moduleName);
                            modulePromises[moduleName] = deferred.promise;
                            self._loadDependencies(moduleName, localParams).then(function success() {
                                try {
                                    justLoaded = [];
                                    _register(providers, moduleCache, localParams);
                                } catch (e) {
                                    self._$log.error(e.message);
                                    deferred.reject(e);
                                    return;
                                }

                                if (modulesToLoad.length > 0) {
                                    loadNext(modulesToLoad.shift()); 
                                } else {
                                        deferred.resolve(res); 
                                    }
                            }, function error(err) {
                                deferred.reject(err);
                            });
                        };

                        
                        loadNext(modulesToLoad.shift());
                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {
                        return modulePromises[localParams.name];
                    } else {
                        deferred.resolve();
                    }
                    return deferred.promise;
                },

                /**
                 * Get the list of required modules/services/... for this module
                 * @param module
                 * @returns {Array}
                 */
                getRequires: function getRequires(module) {
                    var requires = [];
                    angular.forEach(module.requires, function (requireModule) {
                        if (regModules.indexOf(requireModule) === -1) {
                            requires.push(requireModule);
                        }
                    });
                    return requires;
                },

                /**
                 * Invoke the new modules & component by their providers
                 * @param providers
                 * @param queue
                 * @param moduleName
                 * @param reconfig
                 * @private
                 */
                _invokeQueue: _invokeQueue,

                /**
                 * Check if a module has been invoked and registers it if not
                 * @param args
                 * @param moduleName
                 * @returns {boolean} is new
                 */
                _registerInvokeList: _registerInvokeList,

                /**
                 * Register a new module and loads it, executing the run/config blocks if needed
                 * @param providers
                 * @param registerModules
                 * @param params
                 * @private
                 */
                _register: _register,

                /**
                 * Add a module name to the list of modules that will be loaded in the next inject
                 * @param name
                 * @param force
                 * @private
                 */
                _addToLoadList: _addToLoadList,

                /**
                 * Unregister modules (you shouldn't have to use this)
                 * @param modules
                 */
                _unregister: function _unregister(modules) {
                    if (angular.isDefined(modules)) {
                        if (angular.isArray(modules)) {
                            angular.forEach(modules, function (module) {
                                regInvokes[module] = undefined;
                            });
                        }
                    }
                }
            };
        }];

        
        this._init(angular.element(window.document));
    }]);

    var bootstrapFct = angular.bootstrap;
    angular.bootstrap = function (element, modules, config) {
        
        regModules = ['ng', 'oc.lazyLoad'];
        regInvokes = {};
        regConfigs = [];
        modulesToLoad = [];
        realModules = [];
        recordDeclarations = [];
        broadcast = angular.noop;
        runBlocks = {};
        justLoaded = [];
        
        angular.forEach(modules.slice(), function (module) {
            _addToLoadList(module, true, true);
        });
        return bootstrapFct(element, modules, config);
    };

    var _addToLoadList = function _addToLoadList(name, force, real) {
        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {
            modulesToLoad.push(name);
            if (real) {
                realModules.push(name);
            }
        }
    };

    var ngModuleFct = angular.module;
    angular.module = function (name, requires, configFn) {
        _addToLoadList(name, false, true);
        return ngModuleFct(name, requires, configFn);
    };

    
    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
        module.exports = 'oc.lazyLoad';
    }
})(angular, window);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').directive('ocLazyLoad', ["$ocLazyLoad", "$compile", "$animate", "$parse", "$timeout", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {
        return {
            restrict: 'A',
            terminal: true,
            priority: 1000,
            compile: function compile(element, attrs) {
                
                var content = element[0].innerHTML;
                element.html('');

                return function ($scope, $element, $attr) {
                    var model = $parse($attr.ocLazyLoad);
                    $scope.$watch(function () {
                        return model($scope) || $attr.ocLazyLoad; 
                    }, function (moduleName) {
                        if (angular.isDefined(moduleName)) {
                            $ocLazyLoad.load(moduleName).then(function () {
                                
                                
                                
                                $animate.enter(content, $element);
                                
                                $compile($element.contents())($scope);
                            });
                        }
                    }, true);
                };
            }
        };
    }]);
})(angular);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').config(["$provide", function ($provide) {
        $provide.decorator('$ocLazyLoad', ["$delegate", "$q", "$window", "$interval", function ($delegate, $q, $window, $interval) {
            var uaCssChecked = false,
                useCssLoadPatch = false,
                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];

            /**
             * Load a js/css file
             * @param type
             * @param path
             * @param params
             * @returns promise
             */
            $delegate.buildElement = function buildElement(type, path, params) {
                var deferred = $q.defer(),
                    el,
                    loaded,
                    filesCache = $delegate._getFilesCache(),
                    cacheBuster = function cacheBuster(url) {
                    var dc = new Date().getTime();
                    if (url.indexOf('?') >= 0) {
                        if (url.substring(0, url.length - 1) === '&') {
                            return url + '_dc=' + dc;
                        }
                        return url + '&_dc=' + dc;
                    } else {
                        return url + '?_dc=' + dc;
                    }
                };

                
                
                
                if (angular.isUndefined(filesCache.get(path))) {
                    filesCache.put(path, deferred.promise);
                }

                
                switch (type) {
                    case 'css':
                        el = $window.document.createElement('link');
                        el.type = 'text/css';
                        el.rel = 'stylesheet';
                        el.href = params.cache === false ? cacheBuster(path) : path;
                        break;
                    case 'js':
                        el = $window.document.createElement('script');
                        el.src = params.cache === false ? cacheBuster(path) : path;
                        break;
                    default:
                        filesCache.remove(path);
                        deferred.reject(new Error('Requested type "' + type + '" is not known. Could not inject "' + path + '"'));
                        break;
                }
                el.onload = el['onreadystatechange'] = function (e) {
                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;
                    el.onload = el['onreadystatechange'] = null;
                    loaded = 1;
                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);
                    deferred.resolve(el);
                };
                el.onerror = function () {
                    filesCache.remove(path);
                    deferred.reject(new Error('Unable to load ' + path));
                };
                el.async = params.serie ? 0 : 1;

                var insertBeforeElem = anchor.lastChild;
                if (params.insertBefore) {
                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));
                    if (element && element.length > 0) {
                        insertBeforeElem = element[0];
                    }
                }
                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);

                /*
                 The event load or readystatechange doesn't fire in:
                 - PhantomJS 1.9 (headless webkit browser)
                 - iOS < 6       (default mobile browser)
                 - Android < 4.4 (default mobile browser)
                 - Safari < 6    (desktop browser)
                 */
                if (type == 'css') {
                    if (!uaCssChecked) {
                        var ua = $window.navigator.userAgent.toLowerCase();

                        if (ua.indexOf('phantomjs/1.9') > -1) {
                            
                            useCssLoadPatch = true;
                        } else if (/iP(hone|od|ad)/.test($window.navigator.platform)) {
                            
                            var v = $window.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));
                            useCssLoadPatch = iOSVersion < 6;
                        } else if (ua.indexOf('android') > -1) {
                            
                            var androidVersion = parseFloat(ua.slice(ua.indexOf('android') + 8));
                            useCssLoadPatch = androidVersion < 4.4;
                        } else if (ua.indexOf('safari') > -1) {
                            
                            var versionMatch = ua.match(/version\/([\.\d]+)/i);
                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;
                        }
                    }

                    if (useCssLoadPatch) {
                        var tries = 1000; 
                        var interval = $interval(function () {
                            try {
                                el.sheet.cssRules;
                                $interval.cancel(interval);
                                el.onload();
                            } catch (e) {
                                if (--tries <= 0) {
                                    el.onerror();
                                }
                            }
                        }, 20);
                    }
                }

                return deferred.promise;
            };

            return $delegate;
        }]);
    }]);
})(angular);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').config(["$provide", function ($provide) {
        $provide.decorator('$ocLazyLoad', ["$delegate", "$q", function ($delegate, $q) {
            /**
             * The function that loads new files
             * @param config
             * @param params
             * @returns {*}
             */
            $delegate.filesLoader = function filesLoader(config) {
                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                var cssFiles = [],
                    templatesFiles = [],
                    jsFiles = [],
                    promises = [],
                    cachePromise = null,
                    filesCache = $delegate._getFilesCache();

                $delegate.toggleWatch(true); 

                angular.extend(params, config);

                var pushFile = function pushFile(path) {
                    var file_type = null,
                        m;
                    if (angular.isObject(path)) {
                        file_type = path.type;
                        path = path.path;
                    }
                    cachePromise = filesCache.get(path);
                    if (angular.isUndefined(cachePromise) || params.cache === false) {

                        
                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {
                            
                            file_type = m[1];
                            path = path.substr(m[1].length + 1, path.length); 
                        }

                        if (!file_type) {
                            if ((m = /[.](css|less|html|htm|js)?((\?|#).*)?$/.exec(path)) !== null) {
                                
                                file_type = m[1];
                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {
                                
                                file_type = 'js';
                            } else {
                                $delegate._$log.error('File type could not be determined. ' + path);
                                return;
                            }
                        }

                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {
                            cssFiles.push(path);
                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {
                            templatesFiles.push(path);
                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {
                            jsFiles.push(path);
                        } else {
                            $delegate._$log.error('File type is not valid. ' + path);
                        }
                    } else if (cachePromise) {
                        promises.push(cachePromise);
                    }
                };

                if (params.serie) {
                    pushFile(params.files.shift());
                } else {
                    angular.forEach(params.files, function (path) {
                        pushFile(path);
                    });
                }

                if (cssFiles.length > 0) {
                    var cssDeferred = $q.defer();
                    $delegate.cssLoader(cssFiles, function (err) {
                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {
                            $delegate._$log.error(err);
                            cssDeferred.reject(err);
                        } else {
                            cssDeferred.resolve();
                        }
                    }, params);
                    promises.push(cssDeferred.promise);
                }

                if (templatesFiles.length > 0) {
                    var templatesDeferred = $q.defer();
                    $delegate.templatesLoader(templatesFiles, function (err) {
                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {
                            $delegate._$log.error(err);
                            templatesDeferred.reject(err);
                        } else {
                            templatesDeferred.resolve();
                        }
                    }, params);
                    promises.push(templatesDeferred.promise);
                }

                if (jsFiles.length > 0) {
                    var jsDeferred = $q.defer();
                    $delegate.jsLoader(jsFiles, function (err) {
                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty("ocLazyLoadLoader") || $delegate.jsLoader.hasOwnProperty("requirejs"))) {
                            $delegate._$log.error(err);
                            jsDeferred.reject(err);
                        } else {
                            jsDeferred.resolve();
                        }
                    }, params);
                    promises.push(jsDeferred.promise);
                }

                if (promises.length === 0) {
                    var deferred = $q.defer(),
                        err = "Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.";
                    $delegate._$log.error(err);
                    deferred.reject(err);
                    return deferred.promise;
                } else if (params.serie && params.files.length > 0) {
                    return $q.all(promises).then(function () {
                        return $delegate.filesLoader(config, params);
                    });
                } else {
                    return $q.all(promises)['finally'](function (res) {
                        $delegate.toggleWatch(false); 
                        return res;
                    });
                }
            };

            /**
             * Load a module or a list of modules into Angular
             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either
             * @param params Object optional parameters
             * @returns promise
             */
            $delegate.load = function (originalModule) {
                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                var self = this,
                    config = null,
                    deferredList = [],
                    deferred = $q.defer(),
                    errText;

                
                var module = angular.copy(originalModule);
                var params = angular.copy(originalParams);

                
                if (angular.isArray(module)) {
                    
                    angular.forEach(module, function (m) {
                        deferredList.push(self.load(m, params));
                    });

                    
                    $q.all(deferredList).then(function (res) {
                        deferred.resolve(res);
                    }, function (err) {
                        deferred.reject(err);
                    });

                    return deferred.promise;
                }

                
                if (angular.isString(module)) {
                    config = self.getModuleConfig(module);
                    if (!config) {
                        config = {
                            files: [module]
                        };
                    }
                } else if (angular.isObject(module)) {
                    
                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {
                        config = {
                            files: [module]
                        };
                    } else {
                        config = self.setModuleConfig(module);
                    }
                }

                if (config === null) {
                    var moduleName = self._getModuleName(module);
                    errText = 'Module "' + (moduleName || 'unknown') + '" is not configured, cannot load.';
                    $delegate._$log.error(errText);
                    deferred.reject(new Error(errText));
                    return deferred.promise;
                } else {
                    
                    if (angular.isDefined(config.template)) {
                        if (angular.isUndefined(config.files)) {
                            config.files = [];
                        }
                        if (angular.isString(config.template)) {
                            config.files.push(config.template);
                        } else if (angular.isArray(config.template)) {
                            config.files.concat(config.template);
                        }
                    }
                }

                var localParams = angular.extend({}, params, config);

                
                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {
                    return $delegate.inject(config.name, localParams, true);
                }

                $delegate.filesLoader(config, localParams).then(function () {
                    $delegate.inject(null, localParams).then(function (res) {
                        deferred.resolve(res);
                    }, function (err) {
                        deferred.reject(err);
                    });
                }, function (err) {
                    deferred.reject(err);
                });

                return deferred.promise;
            };

            
            return $delegate;
        }]);
    }]);
})(angular);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').config(["$provide", function ($provide) {
        $provide.decorator('$ocLazyLoad', ["$delegate", "$q", function ($delegate, $q) {
            /**
             * cssLoader function
             * @type Function
             * @param paths array list of css files to load
             * @param callback to call when everything is loaded. We use a callback and not a promise
             * @param params object config parameters
             * because the user can overwrite cssLoader and it will probably not use promises :(
             */
            $delegate.cssLoader = function (paths, callback, params) {
                var promises = [];
                angular.forEach(paths, function (path) {
                    promises.push($delegate.buildElement('css', path, params));
                });
                $q.all(promises).then(function () {
                    callback();
                }, function (err) {
                    callback(err);
                });
            };
            $delegate.cssLoader.ocLazyLoadLoader = true;

            return $delegate;
        }]);
    }]);
})(angular);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').config(["$provide", function ($provide) {
        $provide.decorator('$ocLazyLoad', ["$delegate", "$q", function ($delegate, $q) {
            /**
             * jsLoader function
             * @type Function
             * @param paths array list of js files to load
             * @param callback to call when everything is loaded. We use a callback and not a promise
             * @param params object config parameters
             * because the user can overwrite jsLoader and it will probably not use promises :(
             */
            $delegate.jsLoader = function (paths, callback, params) {
                var promises = [];
                angular.forEach(paths, function (path) {
                    promises.push($delegate.buildElement('js', path, params));
                });
                $q.all(promises).then(function () {
                    callback();
                }, function (err) {
                    callback(err);
                });
            };
            $delegate.jsLoader.ocLazyLoadLoader = true;

            return $delegate;
        }]);
    }]);
})(angular);
(function (angular) {
    'use strict';

    angular.module('oc.lazyLoad').config(["$provide", function ($provide) {
        $provide.decorator('$ocLazyLoad', ["$delegate", "$templateCache", "$q", "$http", function ($delegate, $templateCache, $q, $http) {
            /**
             * templatesLoader function
             * @type Function
             * @param paths array list of css files to load
             * @param callback to call when everything is loaded. We use a callback and not a promise
             * @param params object config parameters for $http
             * because the user can overwrite templatesLoader and it will probably not use promises :(
             */
            $delegate.templatesLoader = function (paths, callback, params) {
                var promises = [],
                    filesCache = $delegate._getFilesCache();

                angular.forEach(paths, function (url) {
                    var deferred = $q.defer();
                    promises.push(deferred.promise);
                    $http.get(url, params).then(function (response) {
                        var data = response.data;
                        if (angular.isString(data) && data.length > 0) {
                            angular.forEach(angular.element(data), function (node) {
                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {
                                    $templateCache.put(node.id, node.innerHTML);
                                }
                            });
                        }
                        if (angular.isUndefined(filesCache.get(url))) {
                            filesCache.put(url, true);
                        }
                        deferred.resolve();
                    })['catch'](function (response) {
                        deferred.reject(new Error('Unable to load template file "' + url + '": ' + response.data));
                    });
                });
                return $q.all(promises).then(function () {
                    callback();
                }, function (err) {
                    callback(err);
                });
            };
            $delegate.templatesLoader.ocLazyLoadLoader = true;

            return $delegate;
        }]);
    }]);
})(angular);

if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement, fromIndex) {
                var k;

                
                
                if (this == null) {
                        throw new TypeError('"this" is null or not defined');
                }

                var O = Object(this);

                
                
                
                var len = O.length >>> 0;

                
                if (len === 0) {
                        return -1;
                }

                
                
                var n = +fromIndex || 0;

                if (Math.abs(n) === Infinity) {
                        n = 0;
                }

                
                if (n >= len) {
                        return -1;
                }

                
                
                
                k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

                
                while (k < len) {
                        if (k in O && O[k] === searchElement) {
                                return k;
                        }
                        k++;
                }
                return -1;
        };
}
'use strict';
var app = angular.module('huatek.filters', []).filter('range', function() {
    return function(input, total) {
        total = parseInt(total);
        for (var i = 0; i < total; i++)
            input.push(i);
        return input;
    };
}).filter("resover", function() {
    return function(input, dataMap) {
        return dataMap.get(input);
    }
}).filter("priceFilter", function() { /*价格数据过滤器-暂时没用到此过滤器 2017-10-27*/
    var filterFunction = function(priceVal) {
        if (priceVal == 0 || !priceVal) {
            return "0.0000";
        } else {
            /*var decimalFormat = new DecimalFormat();
            decimalFormat.applyPattern("00.00");*/
            return roundMethod(priceVal, 4);
        }
    };
    return filterFunction;
});
var customDirective = angular.module('huatek.directives', []);
/*! ngstorage 0.3.6 | Copyright (c) 2015 Gias Kay Lee | MIT License */!function(a,b){"use strict";return"function"==typeof define&&define.amd?void define("ngStorage",["angular"],function(a){return b(a)}):b(a)}("undefined"==typeof angular?null:angular,function(a){"use strict";function b(b){return["$rootScope","$window","$log","$timeout",function(c,d,e,f){function g(a){var b;try{b=d[a]}catch(c){b=!1}if(b&&"localStorage"===a){var e="__"+Math.round(1e7*Math.random());try{localStorage.setItem(e,e),localStorage.removeItem(e)}catch(c){b=!1}}return b}var h,i,j=g(b)||(e.warn("This browser does not support Web Storage!"),{setItem:function(){},getItem:function(){}}),k={$default:function(b){for(var c in b)a.isDefined(k[c])||(k[c]=b[c]);return k},$reset:function(a){for(var b in k)"$"===b[0]||delete k[b]&&j.removeItem("ngStorage-"+b);return k.$default(a)}};try{j=d[b],j.length}catch(l){e.warn("This browser does not support Web Storage!"),j={}}for(var m,n=0,o=j.length;o>n;n++)(m=j.key(n))&&"ngStorage-"===m.slice(0,10)&&(k[m.slice(10)]=a.fromJson(j.getItem(m)));return h=a.copy(k),c.$watch(function(){var b;i||(i=f(function(){if(i=null,!a.equals(k,h)){b=a.copy(h),a.forEach(k,function(c,d){a.isDefined(c)&&"$"!==d[0]&&j.setItem("ngStorage-"+d,a.toJson(c)),delete b[d]});for(var c in b)j.removeItem("ngStorage-"+c);h=a.copy(k)}},100,!1))}),"localStorage"===b&&d.addEventListener&&d.addEventListener("storage",function(b){"ngStorage-"===b.key.slice(0,10)&&(b.newValue?k[b.key.slice(10)]=a.fromJson(b.newValue):delete k[b.key.slice(10)],h=a.copy(k),c.$apply())}),k}]}a.module("ngStorage",[]).factory("$localStorage",b("localStorage")).factory("$sessionStorage",b("sessionStorage"))});
angular.module('cgBusy',[]);


angular.module('cgBusy').factory('_cgBusyTrackerFactory',['$timeout','$q',function($timeout,$q){

    return function(){

        var tracker = {};
        tracker.promises = [];
        tracker.delayPromise = null;
        tracker.durationPromise = null;
        tracker.delayJustFinished = false;

        tracker.reset = function(options){
            tracker.minDuration = options.minDuration;

            tracker.promises = [];
            angular.forEach(options.promises,function(p){
                if (!p || p.$cgBusyFulfilled) {
                    return;
                }
                addPromiseLikeThing(p);
            });

            if (tracker.promises.length === 0) {
                
                return;
            }

            tracker.delayJustFinished = false;
            if (options.delay) {
                tracker.delayPromise = $timeout(function(){
                    tracker.delayPromise = null;
                    tracker.delayJustFinished = true;
                },parseInt(options.delay,10));
            }
            if (options.minDuration) {
                tracker.durationPromise = $timeout(function(){
                    tracker.durationPromise = null;
                },parseInt(options.minDuration,10) + (options.delay ? parseInt(options.delay,10) : 0));
            }            
        };

        tracker.isPromise = function(promiseThing){
            var then = promiseThing && (promiseThing.then || promiseThing.$then ||
                (promiseThing.$promise && promiseThing.$promise.then));

            return typeof then !== 'undefined';            
        };

        tracker.callThen = function(promiseThing,success,error){
            var promise;
            if (promiseThing.then || promiseThing.$then){
                promise = promiseThing;
            } else if (promiseThing.$promise){
                promise = promiseThing.$promise;
            } else if (promiseThing.denodeify){
                promise = $q.when(promiseThing);
            }
                       
            var then = (promise.then || promise.$then);

            then.call(promise,success,error);
        };

        var addPromiseLikeThing = function(promise){

            if (!tracker.isPromise(promise)) {
                throw new Error('cgBusy expects a promise (or something that has a .promise or .$promise');
            }

            if (tracker.promises.indexOf(promise) !== -1){
                return;
            }
            tracker.promises.push(promise);

            tracker.callThen(promise, function(){
                promise.$cgBusyFulfilled = true;
                if (tracker.promises.indexOf(promise) === -1) {
                    return;
                }
                tracker.promises.splice(tracker.promises.indexOf(promise),1);
            },function(){
                promise.$cgBusyFulfilled = true;
                if (tracker.promises.indexOf(promise) === -1) {
                    return;
                }
                tracker.promises.splice(tracker.promises.indexOf(promise),1);
            });
        };

        tracker.active = function(){
            if (tracker.delayPromise){
                return false;
            }

            if (!tracker.delayJustFinished){
                if (tracker.durationPromise){
                    return true;
                }
                return tracker.promises.length > 0;
            } else {
                
                
                
                tracker.delayJustFinished = false;
                if (tracker.promises.length === 0) {
                    tracker.durationPromise = null;
                }
                return tracker.promises.length > 0;
            }
        };

        return tracker;

    };
}]);

angular.module('cgBusy').value('cgBusyDefaults',{});

angular.module('cgBusy').directive('cgBusy',['$compile','$templateCache','cgBusyDefaults','$http','_cgBusyTrackerFactory',
    function($compile,$templateCache,cgBusyDefaults,$http,_cgBusyTrackerFactory){
        return {
            restrict: 'A',
            link: function(scope, element, attrs, fn) {

                
                var position = element.css('position');
                if (position === 'static' || position === '' || typeof position === 'undefined'){
                    element.css('position','relative');
                }

                var templateElement;
                var backdropElement;
                var currentTemplate;
                var templateScope;
                var backdrop;
                var tracker = _cgBusyTrackerFactory();

                var defaults = {
                    templateUrl: 'static/js/directives/thirdPart/angularBusy/4.1.4/angular-busy.html',
                    delay:0,
                    minDuration:0,
                    backdrop: true,
                    message:'Please Wait...',
                    wrapperClass: 'cg-busy cg-busy-animation'
                };

                angular.extend(defaults,cgBusyDefaults);

                scope.$watchCollection(attrs.cgBusy,function(options){

                    if (!options) {
                        options = {promise:null};
                    }

                    if (angular.isString(options)) {
                        throw new Error('Invalid value for cg-busy. cgBusy no longer accepts string ids to represent promises/trackers.');
                    }

                    
                    if (angular.isArray(options) || tracker.isPromise(options)) {
                        options = {promise:options};
                    }

                    options = angular.extend(angular.copy(defaults),options);

                    if (!options.templateUrl){
                        options.templateUrl = defaults.templateUrl;
                    }

                    if (!angular.isArray(options.promise)){
                        options.promise = [options.promise];
                    }

                    
                    
                    
                    
                    

                    if (!templateScope) {
                        templateScope = scope.$new();
                    }

                    templateScope.$message = options.message;

                    if (!angular.equals(tracker.promises,options.promise)) {
                        tracker.reset({
                            promises:options.promise,
                            delay:options.delay,
                            minDuration: options.minDuration
                        });
                    }

                    templateScope.$cgBusyIsActive = function() {
                        return tracker.active();
                    };


                    if (!templateElement || currentTemplate !== options.templateUrl || backdrop !== options.backdrop) {

                        if (templateElement) {
                            templateElement.remove();
                        }
                        if (backdropElement){
                            backdropElement.remove();
                        }

                        currentTemplate = options.templateUrl;
                        backdrop = options.backdrop;

                        $http.get(currentTemplate,{cache: $templateCache}).then(function(indicatorTemplate){

                            options.backdrop = typeof options.backdrop === 'undefined' ? true : options.backdrop;

                            if (options.backdrop){
                                var backdrop = '<div class="cg-busy cg-busy-backdrop cg-busy-backdrop-animation ng-hide" ng-show="$cgBusyIsActive()"></div>';
                                backdropElement = $compile(backdrop)(templateScope);
                                element.append(backdropElement);
                            }

                            var template = '<div class="'+options.wrapperClass+' ng-hide" ng-show="$cgBusyIsActive()">' + indicatorTemplate.data + '</div>';
                            templateElement = $compile(template)(templateScope);

                            angular.element(templateElement.children()[0])
                                .css('position','absolute')
                                .css('top',0)
                                .css('left',0)
                                .css('right',0)
                                .css('bottom',0);
                            element.append(templateElement);

                        }, function(data){
                            throw new Error('Template specified for cgBusy ('+options.templateUrl+') could not be loaded. ' + data);
                        });
                    }

                },true);
            }
        };
    }
]);

/*! ng-dialog - v1.2.0 (https://github.com/likeastore/ngDialog) */
!function(a,b){"undefined"!=typeof module&&module.exports?(b("undefined"==typeof angular?require("angular"):angular),module.exports="ngDialog"):"function"==typeof define&&define.amd?define(["angular"],b):b(a.angular)}(this,function(a){"use strict";var b=a.module("ngDialog",[]),c=a.element,d=a.isDefined,e=(document.body||document.documentElement).style,f=d(e.animation)||d(e.WebkitAnimation)||d(e.MozAnimation)||d(e.MsAnimation)||d(e.OAnimation),g="animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend",h="a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]",i="ngdialog-disabled-animation",j={html:!1,body:!1},k={},l=[],m=[],n=!1,o=!1,p=[],q="legacy",r="1.0.0+";return b.provider("ngDialog",function(){var b=this.defaults={className:"ngdialog-theme-default",appendClassName:"",disableAnimation:!1,plain:!1,showClose:!0,closeByDocument:!0,closeByEscape:!0,closeByNavigation:!1,appendTo:!1,preCloseCallback:!1,onOpenCallback:!1,overlay:!0,cache:!0,trapFocus:!0,preserveFocus:!0,ariaAuto:!0,ariaRole:null,ariaLabelledById:null,ariaLabelledBySelector:null,ariaDescribedById:null,ariaDescribedBySelector:null,bodyClassName:"ngdialog-open",width:null,height:null};this.setForceHtmlReload=function(a){j.html=a||!1},this.setForceBodyReload=function(a){j.body=a||!1},this.setDefaults=function(c){a.extend(b,c)},this.setOpenOnePerName=function(a){o=a||!1};var d,e=0,s=0,t={};this.$get=["$document","$templateCache","$compile","$q","$http","$rootScope","$timeout","$window","$controller","$injector",function(u,v,w,x,y,z,A,B,C,D){var E=[],F={onDocumentKeydown:function(a){27===a.keyCode&&G.close("$escape")},activate:function(a){var b=a.data("$ngDialogOptions");b.trapFocus&&(a.on("keydown",F.onTrapFocusKeydown),E.body.on("keydown",F.onTrapFocusKeydown))},deactivate:function(a){a.off("keydown",F.onTrapFocusKeydown),E.body.off("keydown",F.onTrapFocusKeydown)},deactivateAll:function(b){a.forEach(b,function(b){var c=a.element(b);F.deactivate(c)})},setBodyPadding:function(a){var b=parseInt(E.body.css("padding-right")||0,10);E.body.css("padding-right",b+a+"px"),E.body.data("ng-dialog-original-padding",b),z.$broadcast("ngDialog.setPadding",a)},resetBodyPadding:function(){var a=E.body.data("ng-dialog-original-padding");a?E.body.css("padding-right",a+"px"):E.body.css("padding-right",""),z.$broadcast("ngDialog.setPadding",0)},performCloseDialog:function(a,b){var c=a.data("$ngDialogOptions"),e=a.attr("id"),h=k[e];if(F.deactivate(a),h){if("undefined"!=typeof B.Hammer){var i=h.hammerTime;i.off("tap",d),i.destroy&&i.destroy(),delete h.hammerTime}else a.unbind("click");1===s&&E.body.unbind("keydown",F.onDocumentKeydown),a.hasClass("ngdialog-closing")||(s-=1);var j=a.data("$ngDialogPreviousFocus");j&&j.focus&&j.focus(),z.$broadcast("ngDialog.closing",a,b),s=s<0?0:s,f&&!c.disableAnimation?(h.$destroy(),a.unbind(g).bind(g,function(){F.closeDialogElement(a,b)}).addClass("ngdialog-closing")):(h.$destroy(),F.closeDialogElement(a,b)),t[e]&&(t[e].resolve({id:e,value:b,$dialog:a,remainingDialogs:s}),delete t[e]),k[e]&&delete k[e],l.splice(l.indexOf(e),1),l.length||(E.body.unbind("keydown",F.onDocumentKeydown),n=!1),0==s&&(d=void 0)}},closeDialogElement:function(a,b){var c=a.data("$ngDialogOptions");a.remove(),m.splice(m.indexOf(c.bodyClassName),1),m.indexOf(c.bodyClassName)===-1&&(E.html.removeClass(c.bodyClassName),E.body.removeClass(c.bodyClassName)),0===s&&F.resetBodyPadding(),z.$broadcast("ngDialog.closed",a,b)},closeDialog:function(b,c){var d=b.data("$ngDialogPreCloseCallback");if(d&&a.isFunction(d)){var e=d.call(b,c);if(a.isObject(e))e.closePromise?e.closePromise.then(function(){F.performCloseDialog(b,c)},function(){return!1}):e.then(function(){F.performCloseDialog(b,c)},function(){return!1});else{if(e===!1)return!1;F.performCloseDialog(b,c)}}else F.performCloseDialog(b,c)},onTrapFocusKeydown:function(b){var c,d=a.element(b.currentTarget);if(d.hasClass("ngdialog"))c=d;else if(c=F.getActiveDialog(),null===c)return;var e=9===b.keyCode,f=b.shiftKey===!0;e&&F.handleTab(c,b,f)},handleTab:function(a,b,c){var d=F.getFocusableElements(a);if(0===d.length)return void(document.activeElement&&document.activeElement.blur&&document.activeElement.blur());var e=document.activeElement,f=Array.prototype.indexOf.call(d,e),g=f===-1,h=0===f,i=f===d.length-1,j=!1;c?(g||h)&&(d[d.length-1].focus(),j=!0):(g||i)&&(d[0].focus(),j=!0),j&&(b.preventDefault(),b.stopPropagation())},autoFocus:function(a){var b=a[0],d=b.querySelector("*[autofocus]");if(null===d||(d.focus(),document.activeElement!==d)){var e=F.getFocusableElements(a);if(e.length>0)return void e[0].focus();var f=F.filterVisibleElements(b.querySelectorAll("h1,h2,h3,h4,h5,h6,p,span"));if(f.length>0){var g=f[0];c(g).attr("tabindex","-1").css("outline","0"),g.focus()}}},getFocusableElements:function(a){var b=a[0],c=b.querySelectorAll(h),d=F.filterTabbableElements(c);return F.filterVisibleElements(d)},filterTabbableElements:function(a){for(var b=[],d=0;d<a.length;d++){var e=a[d];"-1"!==c(e).attr("tabindex")&&b.push(e)}return b},filterVisibleElements:function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c];(d.offsetWidth>0||d.offsetHeight>0)&&b.push(d)}return b},getActiveDialog:function(){var a=document.querySelectorAll(".ngdialog");return 0===a.length?null:c(a[a.length-1])},applyAriaAttributes:function(a,b){if(b.ariaAuto){if(!b.ariaRole){var c=F.getFocusableElements(a).length>0?"dialog":"alertdialog";b.ariaRole=c}b.ariaLabelledBySelector||(b.ariaLabelledBySelector="h1,h2,h3,h4,h5,h6"),b.ariaDescribedBySelector||(b.ariaDescribedBySelector="article,section,p")}b.ariaRole&&a.attr("role",b.ariaRole),F.applyAriaAttribute(a,"aria-labelledby",b.ariaLabelledById,b.ariaLabelledBySelector),F.applyAriaAttribute(a,"aria-describedby",b.ariaDescribedById,b.ariaDescribedBySelector)},applyAriaAttribute:function(a,b,d,e){if(d)return void a.attr(b,d);if(e){var f=a.attr("id"),g=a[0].querySelector(e);if(!g)return;var h=f+"-"+b;return c(g).attr("id",h),a.attr(b,h),h}},detectUIRouter:function(){return D.has("$transitions")?r:!!D.has("$state")&&q},getRouterLocationEventName:function(){return F.detectUIRouter()?"$stateChangeStart":"$locationChangeStart"}},G={__PRIVATE__:F,open:function(f){function g(b,c){var c=c||{};return c.headers=c.headers||{},a.extend(c.headers,{Accept:"text/html"}),z.$broadcast("ngDialog.templateLoading",b),y.get(b,c).then(function(a){return z.$broadcast("ngDialog.templateLoaded",b),a.data||""})}function h(b){return b?a.isString(b)&&q.plain?b:"boolean"!=typeof q.cache||q.cache?g(b,{cache:v}):g(b,{cache:!1}):"Empty template"}var j=null;if(f=f||{},!(o&&f.name&&(j=f.name.toLowerCase().replace(/\s/g,"-")+"-dialog",this.isOpen(j)))){var q=a.copy(b),r=++e;j=j||"ngdialog"+r,l.push(j),"undefined"!=typeof q.data&&("undefined"==typeof f.data&&(f.data={}),f.data=a.merge(a.copy(q.data),f.data)),a.extend(q,f);var u;t[j]=u=x.defer();var H;k[j]=H=a.isObject(q.scope)?q.scope.$new():z.$new();var I,J,K,L=a.extend({},q.resolve);return a.forEach(L,function(b,c){L[c]=a.isString(b)?D.get(b):D.invoke(b,null,null,c)}),x.all({template:h(q.template||q.templateUrl),locals:x.all(L)}).then(function(b){var e=b.template,f=b.locals;q.showClose&&(e+='<button aria-label="Dismiss" class="ngdialog-close"></button>');var g=q.overlay?"":" ngdialog-no-overlay";if(I=c('<div id="'+j+'" class="ngdialog'+g+'"></div>'),I.html(q.overlay?'<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">'+e+"</div>":'<div class="ngdialog-content" role="document">'+e+"</div>"),I.data("$ngDialogOptions",q),H.ngDialogId=j,q.data&&a.isString(q.data)){var h=q.data.replace(/^\s*/,"")[0];H.ngDialogData="{"===h||"["===h?a.fromJson(q.data):new String(q.data),H.ngDialogData.ngDialogId=j}else q.data&&a.isObject(q.data)&&(H.ngDialogData=q.data,H.ngDialogData.ngDialogId=j);if(q.className&&I.addClass(q.className),q.appendClassName&&I.addClass(q.appendClassName),q.width&&(K=I[0].querySelector(".ngdialog-content"),a.isString(q.width)?K.style.width=q.width:K.style.width=q.width+"px"),q.height&&(K=I[0].querySelector(".ngdialog-content"),a.isString(q.height)?K.style.height=q.height:K.style.height=q.height+"px"),q.disableAnimation&&I.addClass(i),J=q.appendTo&&a.isString(q.appendTo)?a.element(document.querySelector(q.appendTo)):E.body,F.applyAriaAttributes(I,q),[{name:"$ngDialogPreCloseCallback",value:q.preCloseCallback},{name:"$ngDialogOnOpenCallback",value:q.onOpenCallback}].forEach(function(b){if(b.value){var c;a.isFunction(b.value)?c=b.value:a.isString(b.value)&&H&&(a.isFunction(H[b.value])?c=H[b.value]:H.$parent&&a.isFunction(H.$parent[b.value])?c=H.$parent[b.value]:z&&a.isFunction(z[b.value])&&(c=z[b.value])),c&&I.data(b.name,c)}}),H.closeThisDialog=function(a){F.closeDialog(I,a)},q.controller&&(a.isString(q.controller)||a.isArray(q.controller)||a.isFunction(q.controller))){var k;q.controllerAs&&a.isString(q.controllerAs)&&(k=q.controllerAs);var l=C(q.controller,a.extend(f,{$scope:H,$element:I}),!0,k);q.bindToController&&a.extend(l.instance,{ngDialogId:H.ngDialogId,ngDialogData:H.ngDialogData,closeThisDialog:H.closeThisDialog,confirm:H.confirm}),"function"==typeof l?I.data("$ngDialogControllerController",l()):I.data("$ngDialogControllerController",l)}if(A(function(){var b=document.querySelectorAll(".ngdialog");F.deactivateAll(b),w(I)(H);var c=B.innerWidth-E.body.prop("clientWidth");E.html.addClass(q.bodyClassName),E.body.addClass(q.bodyClassName),m.push(q.bodyClassName);var d=c-(B.innerWidth-E.body.prop("clientWidth"));d>0&&F.setBodyPadding(d),J.append(I),F.activate(I),q.trapFocus&&F.autoFocus(I),q.name?z.$broadcast("ngDialog.opened",{dialog:I,name:q.name}):z.$broadcast("ngDialog.opened",I);var e=I.data("$ngDialogOnOpenCallback");e&&a.isFunction(e)&&e.call(I)}),n||(E.body.bind("keydown",F.onDocumentKeydown),n=!0),q.closeByNavigation&&p.push(I),q.preserveFocus&&I.data("$ngDialogPreviousFocus",document.activeElement),d=function(a){var b=!!q.closeByDocument&&c(a.target).hasClass("ngdialog-overlay"),d=c(a.target).hasClass("ngdialog-close");(b||d)&&G.close(I.attr("id"),d?"$closeButton":"$document")},"undefined"!=typeof B.Hammer){var o=H.hammerTime=B.Hammer(I[0]);o.on("tap",d)}else I.bind("click",d);return s+=1,G}),{id:j,closePromise:u.promise,close:function(a){F.closeDialog(I,a)}}}},openConfirm:function(d){var e=x.defer(),f=a.copy(b);d=d||{},"undefined"!=typeof f.data&&("undefined"==typeof d.data&&(d.data={}),d.data=a.merge(a.copy(f.data),d.data)),a.extend(f,d),f.scope=a.isObject(f.scope)?f.scope.$new():z.$new(),f.scope.confirm=function(a){e.resolve(a);var b=c(document.getElementById(g.id));F.performCloseDialog(b,a)};var g=G.open(f);if(g)return g.closePromise.then(function(a){return a?e.reject(a.value):e.reject()}),e.promise},isOpen:function(a){var b=c(document.getElementById(a));return b.length>0},close:function(a,b){var d=c(document.getElementById(a));if(d.length)F.closeDialog(d,b);else if("$escape"===a){var e=l[l.length-1];d=c(document.getElementById(e)),d.data("$ngDialogOptions").closeByEscape&&F.closeDialog(d,"$escape")}else G.closeAll(b);return G},closeAll:function(a){for(var b=document.querySelectorAll(".ngdialog"),d=b.length-1;d>=0;d--){var e=b[d];F.closeDialog(c(e),a)}},getOpenDialogs:function(){return l},getDefaults:function(){return b}};a.forEach(["html","body"],function(a){if(E[a]=u.find(a),j[a]){var b=F.getRouterLocationEventName();z.$on(b,function(){E[a]=u.find(a)})}});var H=F.detectUIRouter();if(H===r){var I=D.get("$transitions");I.onStart({},function(a){for(;p.length>0;){var b=p.pop();if(F.closeDialog(b)===!1)return!1}})}else{var J=H===q?"$stateChangeStart":"$locationChangeStart";z.$on(J,function(a){for(;p.length>0;){var b=p.pop();F.closeDialog(b)===!1&&a.preventDefault()}})}return G}]}),b.directive("ngDialog",["ngDialog",function(b){return{restrict:"A",scope:{ngDialogScope:"="},link:function(c,d,e){d.on("click",function(d){d.preventDefault();var f=a.isDefined(c.ngDialogScope)?c.ngDialogScope:"noScope";a.isDefined(e.ngDialogClosePrevious)&&b.close(e.ngDialogClosePrevious);var g=b.getDefaults();b.open({template:e.ngDialog,className:e.ngDialogClass||g.className,appendClassName:e.ngDialogAppendClass,controller:e.ngDialogController,controllerAs:e.ngDialogControllerAs,bindToController:e.ngDialogBindToController,disableAnimation:e.ngDialogDisableAnimation,scope:f,data:e.ngDialogData,showClose:"false"!==e.ngDialogShowClose&&("true"===e.ngDialogShowClose||g.showClose),closeByDocument:"false"!==e.ngDialogCloseByDocument&&("true"===e.ngDialogCloseByDocument||g.closeByDocument),closeByEscape:"false"!==e.ngDialogCloseByEscape&&("true"===e.ngDialogCloseByEscape||g.closeByEscape),overlay:"false"!==e.ngDialogOverlay&&("true"===e.ngDialogOverlay||g.overlay),preCloseCallback:e.ngDialogPreCloseCallback||g.preCloseCallback,onOpenCallback:e.ngDialogOnOpenCallback||g.onOpenCallback,bodyClassName:e.ngDialogBodyClass||g.bodyClassName})})}}}]),b});
angular.module("gettext", []), angular.module("gettext").constant("gettext", function(a) { return a }), angular.module("gettext").factory("gettextCatalog", ["gettextPlurals", "gettextFallbackLanguage", "$http", "$cacheFactory", "$interpolate", "$rootScope", function(a, b, c, d, e, f) {
    function g() { f.$broadcast("gettextLanguageChanged") } var h, i = "$$noContext",
        j = '<span id="test" title="test" class="tested">test</span>',
        k = angular.element("<span>" + j + "</span>").html() !== j,
        l = function(a) { return h.debug && h.currentLanguage !== h.baseLanguage ? h.debugPrefix + a : a },
        m = function(a) { return h.showTranslatedMarkers ? h.translatedMarkerPrefix + a + h.translatedMarkerSuffix : a }; return h = { debug: !1, debugPrefix: "[MISSING]: ", showTranslatedMarkers: !1, translatedMarkerPrefix: "[", translatedMarkerSuffix: "]", strings: {}, baseLanguage: "en", currentLanguage: "en", cache: d("strings"), setCurrentLanguage: function(a) { this.currentLanguage = a, g() }, getCurrentLanguage: function() { return this.currentLanguage }, setStrings: function(b, c) { this.strings[b] || (this.strings[b] = {}); var d = a(b, 1); for (var e in c) { var f = c[e]; if (k && (e = angular.element("<span>" + e + "</span>").html()), angular.isString(f) || angular.isArray(f)) { var h = {};
                    h[i] = f, f = h } for (var j in f) { var l = f[j];
                    angular.isArray(l) || (f[j] = [], f[j][d] = l) } this.strings[b][e] = f } g() }, getStringFormFor: function(b, c, d, e) { if (!b) return null; var f = this.strings[b] || {},
                g = f[c] || {},
                h = g[e || i] || []; return h[a(b, d)] }, getString: function(a, c, d) { var f = b(this.currentLanguage); return a = this.getStringFormFor(this.currentLanguage, a, 1, d) || this.getStringFormFor(f, a, 1, d) || l(a), a = c ? e(a)(c) : a, m(a) }, getPlural: function(a, c, d, f, g) { var h = b(this.currentLanguage); return c = this.getStringFormFor(this.currentLanguage, c, a, g) || this.getStringFormFor(h, c, a, g) || l(1 === a ? c : d), f && (f.$count = a, c = e(c)(f)), m(c) }, loadRemote: function(a) { return c({ method: "GET", url: a, cache: h.cache }).then(function(a) { var b = a.data; for (var c in b) h.setStrings(c, b[c]); return a }) } } }]), angular.module("gettext").directive("translate", ["gettextCatalog", "$parse", "$animate", "$compile", "$window", "gettextUtil", function(a, b, c, d, e, f) {
    function g(a) { return f.lcFirst(a.replace(j, "")) }

    function h(a, b, c) { var d = Object.keys(b).filter(function(a) { return f.startsWith(a, j) && a !== j }); if (!d.length) return null; var e = angular.extend({}, a),
            h = []; return d.forEach(function(d) { var f = a.$watch(b[d], function(a) { var b = g(d);
                e[b] = a, c(e) });
            h.push(f) }), a.$on("$destroy", function() { h.forEach(function(a) { a() }) }), e } var i = parseInt((/msie (\d+)/.exec(angular.lowercase(e.navigator.userAgent)) || [])[1], 10),
        j = "translateParams"; return { restrict: "AE", terminal: !0, compile: function(e, g) { f.assert(!g.translatePlural || g.translateN, "translate-n", "translate-plural"), f.assert(!g.translateN || g.translatePlural, "translate-plural", "translate-n"); var j = f.trim(e.html()),
                k = g.translatePlural,
                l = g.translateContext; return 8 >= i && "<!--IE fix-->" === j.slice(-13) && (j = j.slice(0, -13)), { post: function(e, g, i) {
                    function m(b) { b = b || null; var h;
                        k ? (e = o || (o = e.$new()), e.$count = n(e), h = a.getPlural(e.$count, j, k, b, l)) : h = a.getString(j, b, l); var i = g.contents(); if (0 !== i.length) { if (h === f.trim(i.html())) return void(p && d(i)(e)); var m = angular.element("<span>" + h + "</span>");
                            d(m.contents())(e); var q = m.contents();
                            c.enter(q, g), c.leave(i) } } var n = b(i.translateN),
                        o = null,
                        p = !0,
                        q = h(e, i, m);
                    m(q), p = !1, i.translateN && e.$watch(i.translateN, function() { m(q) }), e.$on("gettextLanguageChanged", function() { m(q) }) } } } } }]), angular.module("gettext").factory("gettextFallbackLanguage", function() { var a = {},
        b = /([^_]+)_[^_]+$/; return function(c) { if (a[c]) return a[c]; var d = b.exec(c); return d ? (a[c] = d[1], d[1]) : null } }), angular.module("gettext").filter("translate", ["gettextCatalog", function(a) {
    function b(b, c) { return a.getString(b, null, c) } return b.$stateful = !0, b }]), angular.module("gettext").factory("gettextPlurals", function() {
    function a(a) { return b[a] || (b[a] = a.split(/\-|_/).shift()), b[a] } var b = { pt_BR: "pt_BR", "pt-BR": "pt_BR" }; return function(b, c) { switch (a(b)) {
            case "ay":
            case "bo":
            case "cgg":
            case "dz":
            case "fa":
            case "id":
            case "ja":
            case "jbo":
            case "ka":
            case "kk":
            case "km":
            case "ko":
            case "ky":
            case "lo":
            case "ms":
            case "my":
            case "sah":
            case "su":
            case "th":
            case "tt":
            case "ug":
            case "vi":
            case "wo":
            case "zh":
                return 0;
            case "is":
                return c % 10 != 1 || c % 100 == 11 ? 1 : 0;
            case "jv":
                return 0 != c ? 1 : 0;
            case "mk":
                return 1 == c || c % 10 == 1 ? 0 : 1;
            case "ach":
            case "ak":
            case "am":
            case "arn":
            case "br":
            case "fil":
            case "fr":
            case "gun":
            case "ln":
            case "mfe":
            case "mg":
            case "mi":
            case "oc":
            case "pt_BR":
            case "tg":
            case "ti":
            case "tr":
            case "uz":
            case "wa":
            case "zh":
                return c > 1 ? 1 : 0;
            case "lv":
                return c % 10 == 1 && c % 100 != 11 ? 0 : 0 != c ? 1 : 2;
            case "lt":
                return c % 10 == 1 && c % 100 != 11 ? 0 : c % 10 >= 2 && (10 > c % 100 || c % 100 >= 20) ? 1 : 2;
            case "be":
            case "bs":
            case "hr":
            case "ru":
            case "sr":
            case "uk":
                return c % 10 == 1 && c % 100 != 11 ? 0 : c % 10 >= 2 && 4 >= c % 10 && (10 > c % 100 || c % 100 >= 20) ? 1 : 2;
            case "mnk":
                return 0 == c ? 0 : 1 == c ? 1 : 2;
            case "ro":
                return 1 == c ? 0 : 0 == c || c % 100 > 0 && 20 > c % 100 ? 1 : 2;
            case "pl":
                return 1 == c ? 0 : c % 10 >= 2 && 4 >= c % 10 && (10 > c % 100 || c % 100 >= 20) ? 1 : 2;
            case "cs":
            case "sk":
                return 1 == c ? 0 : c >= 2 && 4 >= c ? 1 : 2;
            case "sl":
                return c % 100 == 1 ? 1 : c % 100 == 2 ? 2 : c % 100 == 3 || c % 100 == 4 ? 3 : 0;
            case "mt":
                return 1 == c ? 0 : 0 == c || c % 100 > 1 && 11 > c % 100 ? 1 : c % 100 > 10 && 20 > c % 100 ? 2 : 3;
            case "gd":
                return 1 == c || 11 == c ? 0 : 2 == c || 12 == c ? 1 : c > 2 && 20 > c ? 2 : 3;
            case "cy":
                return 1 == c ? 0 : 2 == c ? 1 : 8 != c && 11 != c ? 2 : 3;
            case "kw":
                return 1 == c ? 0 : 2 == c ? 1 : 3 == c ? 2 : 3;
            case "ga":
                return 1 == c ? 0 : 2 == c ? 1 : 7 > c ? 2 : 11 > c ? 3 : 4;
            case "ar":
                return 0 == c ? 0 : 1 == c ? 1 : 2 == c ? 2 : c % 100 >= 3 && 10 >= c % 100 ? 3 : c % 100 >= 11 ? 4 : 5;
            default:
                return 1 != c ? 1 : 0 } } }), angular.module("gettext").factory("gettextUtil", function() {
    function a(a, b, c) { if (!a) throw new Error("You should add a " + b + " attribute whenever you add a " + c + " attribute.") }

    function b(a, b) { return 0 === a.indexOf(b) }

    function c(a) { var b = a.charAt(0).toLowerCase(); return b + a.substr(1) } var d = function() { return String.prototype.trim ? function(a) { return "string" == typeof a ? a.trim() : a } : function(a) { return "string" == typeof a ? a.replace(/^\s*/, "").replace(/\s*$/, "") : a } }(); return { trim: d, assert: a, startsWith: b, lcFirst: c } });
/*! angular-highlightjs
version: 0.6.2
build date: 2016-08-19
author: Chih-Hsuan Fan
https://github.com/pc035860/angular-highlightjs.git */
!function(a,b){"object"==typeof exports||"object"==typeof module&&module.exports?module.exports=b(require("angular"),require("highlight.js")):"function"==typeof define&&define.amd?define(["angular","hljs"],b):a.returnExports=b(a.angular,a.hljs)}(this,function(a,b){function c(b){return function(c){switch(c){case"escape":return a.isDefined(b.hljsEscape)?b.hljsEscape:b.escape;case"no-escape":return a.isDefined(b.hljsNoEscape)?b.hljsNoEscape:b.noEscape;case"onhighlight":return a.isDefined(b.hljsOnhighlight)?b.hljsOnhighlight:b.onhighlight}}}function d(b){var c=!0;return a.forEach(["source","include"],function(a){b[a]&&(c=!1)}),c}var e=a.module("hljs",[]);e.provider("hljsService",function(){var c={};return{setOptions:function(b){a.extend(c,b)},getOptions:function(){return a.copy(c)},$get:function(){return(b.configure||a.noop)(c),b}}}),e.factory("hljsCache",["$cacheFactory",function(a){return a("hljsCache")}]),e.controller("HljsCtrl",["hljsCache","hljsService","$interpolate","$window",function(b,c,d,e){function f(a,b,c){var d;return function(){var f=this,g=arguments,h=function(){d=null,c||a.apply(f,g)},i=c&&!d;e.clearTimeout(d),d=e.setTimeout(h,b),i&&a.apply(f,g)}}function g(a,b){var c=b?"\\\\$&":"\\$&";return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,c)}function h(a){for(var b,c=[],d=new RegExp(q,"g"),e="",f=0;null!==(b=d.exec(a));)e+=a.substring(f,b.index)+r,f=b.index+b[0].length,c.push(b[0]);return e+=a.substr(f),{code:e,tokens:c}}function i(a,b){for(var c,d=new RegExp(r,"g"),e="",f=0;null!==(c=d.exec(a));)e+=a.substring(f,c.index)+b.shift(),f=c.index+c[0].length;return e+=a.substr(f)}var j=this,k=null,l=null,m=null,n=!1,o=null,p=null,q=g(d.startSymbol())+"((.|\\s)+?)"+g(d.endSymbol()),r="∫";j.init=function(a){k=a},j.setInterpolateScope=function(a){n=a,m&&j.highlight(m)},j.setLanguage=function(a){l=a,m&&j.highlight(m)},j.highlightCallback=function(a){p=a},j._highlight=function(e){if(k){var f,g,q;if(m=e,n&&(q=h(e),e=q.code),l?(g=j._cacheKey(l,!!n,e),f=b.get(g),f||(f=c.highlight(l,c.fixMarkup(e),!0),b.put(g,f))):(g=j._cacheKey(!!n,e),f=b.get(g),f||(f=c.highlightAuto(c.fixMarkup(e)),b.put(g,f))),e=f.value,n){(o||a.noop)(),q&&(e=i(e,q.tokens));var r=d(e);o=n.$watch(r,function(a,b){a!==b&&k.html(a)}),n.$apply(),k.html(r(n))}else k.html(e);k.addClass(f.language),null!==p&&a.isFunction(p)&&p()}},j.highlight=f(j._highlight,17),j.clear=function(){k&&(m=null,k.text(""))},j.release=function(){k=null,n=null,(o||a.noop)(),o=null},j._cacheKey=function(){var a=Array.prototype.slice.call(arguments),b="!angular-highlightjs!";return a.join(b)}}]);var f,g,h,i,j;return f=["$parse",function(b){return{restrict:"EA",controller:"HljsCtrl",compile:function(e){var f=e[0].innerHTML.replace(/^(\r\n|\r|\n)/m,""),g=e[0].textContent.replace(/^(\r\n|\r|\n)/m,"");return e.html('<pre><code class="hljs"></code></pre>'),function(e,h,i,j){var k,l=c(i);if(a.isDefined(l("escape"))?k=b(l("escape")):a.isDefined(l("no-escape"))&&(k=b("false")),j.init(h.find("code")),l("onhighlight")&&j.highlightCallback(function(){e.$eval(l("onhighlight"))}),(f||g)&&d(i)){var m;m=k&&!k(e)?g:f,j.highlight(m)}e.$on("$destroy",function(){j.release()})}}}}],h=function(b){return function(){return{require:"?hljs",restrict:"A",link:function(c,d,e,f){f&&e.$observe(b,function(b){a.isDefined(b)&&f.setLanguage(b)})}}}},g=function(a){return function(){return{require:"?hljs",restrict:"A",link:function(b,c,d,e){e&&b.$watch(d[a],function(a,c){(a||a!==c)&&e.setInterpolateScope(a?b:null)})}}}},i=function(a){return function(){return{require:"?hljs",restrict:"A",link:function(b,c,d,e){e&&b.$watch(d[a],function(a){a?e.highlight(a):e.clear()})}}}},j=function(b){return["$http","$templateCache","$q",function(c,d,e){return{require:"?hljs",restrict:"A",compile:function(f,g){var h=g[b];return function(b,f,g,i){var j=0;i&&b.$watch(h,function(b){var f=++j;if(b&&a.isString(b)){var g,h;g=d.get(b),g||(h=e.defer(),c.get(b,{cache:d,transformResponse:function(a){return a}}).success(function(a){f===j&&h.resolve(a)}).error(function(){f===j&&i.clear(),h.resolve()}),g=h.promise),e.when(g).then(function(b){b&&(a.isArray(b)?b=b[1]:a.isObject(b)&&(b=b.data),b=b.replace(/^(\r\n|\r|\n)/m,""),i.highlight(b))})}else i.clear()})}}}}]},function(b){b.directive("hljs",f),a.forEach(["interpolate","hljsInterpolate","compile","hljsCompile"],function(a){b.directive(a,g(a))}),a.forEach(["language","hljsLanguage"],function(a){b.directive(a,h(a))}),a.forEach(["source","hljsSource"],function(a){b.directive(a,i(a))}),a.forEach(["include","hljsInclude"],function(a){b.directive(a,j(a))})}(e),"hljs"});
/*!
 * ui-grid - v3.1.0 - 2016-01-19
 * Copyright (c) 2016 ; License: MIT 
 */

!
function() {
    "use strict";
    angular.module("ui.grid.i18n", []),
    angular.module("ui.grid", ["ui.grid.i18n"])
} (),
function() {
    "use strict";
    angular.module("ui.grid").constant("uiGridConstants", {
        LOG_DEBUG_MESSAGES: !0,
        LOG_WARN_MESSAGES: !0,
        LOG_ERROR_MESSAGES: !0,
        CUSTOM_FILTERS: /CUSTOM_FILTERS/g,
        COL_FIELD: /COL_FIELD/g,
        MODEL_COL_FIELD: /MODEL_COL_FIELD/g,
        TOOLTIP: /title=\"TOOLTIP\"/g,
        DISPLAY_CELL_TEMPLATE: /DISPLAY_CELL_TEMPLATE/g,
        TEMPLATE_REGEXP: /<.+>/,
        FUNC_REGEXP: /(\([^)]*\))?$/,
        DOT_REGEXP: /\./g,
        APOS_REGEXP: /'/g,
        BRACKET_REGEXP: /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
        COL_CLASS_PREFIX: "ui-grid-col",
        events: {
            GRID_SCROLL: "uiGridScroll",
            COLUMN_MENU_SHOWN: "uiGridColMenuShown",
            ITEM_DRAGGING: "uiGridItemDragStart",
            COLUMN_HEADER_CLICK: "uiGridColumnHeaderClick"
        },
        keymap: {
            TAB: 9,
            STRG: 17,
            CAPSLOCK: 20,
            CTRL: 17,
            CTRLRIGHT: 18,
            CTRLR: 18,
            SHIFT: 16,
            RETURN: 13,
            ENTER: 13,
            BACKSPACE: 8,
            BCKSP: 8,
            ALT: 18,
            ALTR: 17,
            ALTRIGHT: 17,
            SPACE: 32,
            WIN: 91,
            MAC: 91,
            FN: null,
            PG_UP: 33,
            PG_DOWN: 34,
            UP: 38,
            DOWN: 40,
            LEFT: 37,
            RIGHT: 39,
            ESC: 27,
            DEL: 46,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123
        },
        ASC: "asc",
        DESC: "desc",
        filter: {
            STARTS_WITH: 2,
            ENDS_WITH: 4,
            EXACT: 8,
            CONTAINS: 16,
            GREATER_THAN: 32,
            GREATER_THAN_OR_EQUAL: 64,
            LESS_THAN: 128,
            LESS_THAN_OR_EQUAL: 256,
            NOT_EQUAL: 512,
            SELECT: "select",
            INPUT: "input"
        },
        aggregationTypes: {
            sum: 2,
            count: 4,
            avg: 8,
            min: 16,
            max: 32
        },
        CURRENCY_SYMBOLS: ["ƒ", "$", "£", "$", "¤", "¥", "៛", "₩", "₱", "฿", "₫"],
        scrollDirection: {
            UP: "up",
            DOWN: "down",
            LEFT: "left",
            RIGHT: "right",
            NONE: "none"
        },
        dataChange: {
            ALL: "all",
            EDIT: "edit",
            ROW: "row",
            COLUMN: "column",
            OPTIONS: "options"
        },
        scrollbars: {
            NEVER: 0,
            ALWAYS: 1
        }
    })
} (),
angular.module("ui.grid").directive("uiGridCell", ["$compile", "$parse", "gridUtil", "uiGridConstants",
function(a, b, c, d) {
    var e = {
        priority: 0,
        scope: !1,
        require: "?^uiGrid",
        compile: function() {
            return {
                pre: function(b, e, f, g) {
                    function h() {
                        var a = b.col.compiledElementFn;
                        a(b,
                        function(a, b) {
                            e.append(a)
                        })
                    }
                    if (g && b.col.compiledElementFn) h();
                    else if (g && !b.col.compiledElementFn) b.col.getCompiledElementFn().then(function(a) {
                        a(b,
                        function(a, b) {
                            e.append(a)
                        })
                    });
                    else {
                        var i = b.col.cellTemplate.replace(d.MODEL_COL_FIELD, "row.entity." + c.preEval(b.col.field)).replace(d.COL_FIELD, "grid.getCellValue(row, col)"),
                        j = a(i)(b);
                        e.append(j)
                    }
                },
                post: function(a, b, c, e) {
                    var f = a.col.getColClass(!1);
                    b.addClass(f);
                    var g, h = function(c) {
                        var d = b;
                        g && (d.removeClass(g), g = null),
                        g = angular.isFunction(a.col.cellClass) ? a.col.cellClass(a.grid, a.row, a.col, a.rowRenderIndex, a.colRenderIndex) : a.col.cellClass,
                        d.addClass(g)
                    };
                    a.col.cellClass && h();
                    var i = a.grid.registerDataChangeCallback(h, [d.dataChange.COLUMN, d.dataChange.EDIT]),
                    j = function(c, d) {
                        if (c !== d) { (g || a.col.cellClass) && h();
                            var e = a.col.getColClass(!1);
                            e !== f && (b.removeClass(f), b.addClass(e), f = e)
                        }
                    },
                    k = a.$watch("row", j),
                    l = function() {
                        i(),
                        k()
                    };
                    a.$on("$destroy", l),
                    b.on("$destroy", l)
                }
            }
        }
    };
    return e
}]),
function() {
    angular.module("ui.grid").service("uiGridColumnMenuService", ["i18nService", "uiGridConstants", "gridUtil",
    function(a, b, c) {
        var d = {
            initialize: function(a, b) {
                a.grid = b.grid,
                b.columnMenuScope = a,
                a.menuShown = !1
            },
            setColMenuItemWatch: function(a) {
                var b = a.$watch("col.menuItems",
                function(b, c) {
                    "undefined" != typeof b && b && angular.isArray(b) ? (b.forEach(function(b) {
                        "undefined" != typeof b.context && b.context || (b.context = {}),
                        b.context.col = a.col
                    }), a.menuItems = a.defaultMenuItems.concat(b)) : a.menuItems = a.defaultMenuItems
                });
                a.$on("$destroy", b)
            },
            sortable: function(a) {
                return a.grid.options.enableSorting && "undefined" != typeof a.col && a.col && a.col.enableSorting ? !0 : !1
            },
            isActiveSort: function(a, b) {
                return "undefined" != typeof a.col && "undefined" != typeof a.col.sort && "undefined" != typeof a.col.sort.direction && a.col.sort.direction === b
            },
            suppressRemoveSort: function(a) {
                return a.col && a.col.suppressRemoveSort ? !0 : !1
            },
            hideable: function(a) {
                return "undefined" != typeof a.col && a.col && a.col.colDef && a.col.colDef.enableHiding === !1 ? !1 : !0
            },
            getDefaultMenuItems: function(c) {
                return [{
                    title: a.getSafeText("sort.ascending"),
                    icon: "ui-grid-icon-sort-alt-up",
                    action: function(a) {
                        a.stopPropagation(),
                        c.sortColumn(a, b.ASC)
                    },
                    shown: function() {
                        return d.sortable(c)
                    },
                    active: function() {
                        return d.isActiveSort(c, b.ASC)
                    }
                },
                {
                    title: a.getSafeText("sort.descending"),
                    icon: "ui-grid-icon-sort-alt-down",
                    action: function(a) {
                        a.stopPropagation(),
                        c.sortColumn(a, b.DESC)
                    },
                    shown: function() {
                        return d.sortable(c)
                    },
                    active: function() {
                        return d.isActiveSort(c, b.DESC)
                    }
                },
                {
                    title: a.getSafeText("sort.remove"),
                    icon: "ui-grid-icon-cancel",
                    action: function(a) {
                        a.stopPropagation(),
                        c.unsortColumn()
                    },
                    shown: function() {
                        return d.sortable(c) && "undefined" != typeof c.col && "undefined" != typeof c.col.sort && "undefined" != typeof c.col.sort.direction && null !== c.col.sort.direction && !d.suppressRemoveSort(c)
                    }
                },
                {
                    title: a.getSafeText("column.hide"),
                    icon: "ui-grid-icon-cancel",
                    shown: function() {
                        return d.hideable(c)
                    },
                    action: function(a) {
                        a.stopPropagation(),
                        c.hideColumn()
                    }
                },
                {
                    title: a.getSafeText("columnMenu.close"),
                    screenReaderOnly: !0,
                    shown: function() {
                        return ! 0
                    },
                    action: function(a) {
                        a.stopPropagation()
                    }
                }]
            },
            getColumnElementPosition: function(a, b, d) {
                var e = {};
                return e.left = d[0].offsetLeft,
                e.top = d[0].offsetTop,
                e.parentLeft = d[0].offsetParent.offsetLeft,
                e.offset = 0,
                b.grid.options.offsetLeft && (e.offset = b.grid.options.offsetLeft),
                e.height = c.elementHeight(d, !0),
                e.width = c.elementWidth(d, !0),
                e
            },
            repositionMenu: function(a, b, d, e, f) {
                var g = e[0].querySelectorAll(".ui-grid-menu"),
                h = b.renderContainer ? b.renderContainer: "body",
                i = (b.grid.renderContainers[h], c.closestElm(f, ".ui-grid-render-container")),
                j = i.getBoundingClientRect().left - a.grid.element[0].getBoundingClientRect().left,
                k = i.querySelectorAll(".ui-grid-viewport")[0].scrollLeft,
                l = b.lastMenuWidth ? b.lastMenuWidth: a.lastMenuWidth ? a.lastMenuWidth: 170,
                m = b.lastMenuPaddingRight ? b.lastMenuPaddingRight: a.lastMenuPaddingRight ? a.lastMenuPaddingRight: 10;
                if (0 !== g.length) {
                    var n = g[0].querySelectorAll(".ui-grid-menu-mid");
                    0 === n.length || angular.element(n).hasClass("ng-hide") || (l = c.elementWidth(g, !0), a.lastMenuWidth = l, b.lastMenuWidth = l, m = parseInt(c.getStyles(angular.element(g)[0]).paddingRight, 10), a.lastMenuPaddingRight = m, b.lastMenuPaddingRight = m)
                }
                var o = d.left + j - k + d.parentLeft + d.width - l + m;
                o < d.offset && (o = d.offset),
                e.css("left", o + "px"),
                e.css("top", d.top + d.height + "px")
            }
        };
        return d
    }]).directive("uiGridColumnMenu", ["$timeout", "gridUtil", "uiGridConstants", "uiGridColumnMenuService", "$document",
    function(a, b, c, d, e) {
        var f = {
            priority: 0,
            scope: !0,
            require: "^uiGrid",
            templateUrl: "ui-grid/uiGridColumnMenu",
            replace: !0,
            link: function(f, g, h, i) {
                d.initialize(f, i),
                f.defaultMenuItems = d.getDefaultMenuItems(f),
                f.menuItems = f.defaultMenuItems,
                d.setColMenuItemWatch(f),
                f.showMenu = function(a, b, c) {
                    f.col = a;
                    var e = d.getColumnElementPosition(f, a, b);
                    f.menuShown ? (f.colElement = b, f.colElementPosition = e, f.hideThenShow = !0, f.$broadcast("hide-menu", {
                        originalEvent: c
                    })) : (f.menuShown = !0, d.repositionMenu(f, a, e, g, b), f.colElement = b, f.colElementPosition = e, f.$broadcast("show-menu", {
                        originalEvent: c
                    }))
                },
                f.hideMenu = function(a) {
                    f.menuShown = !1,
                    a || f.$broadcast("hide-menu")
                },
                f.$on("menu-hidden",
                function() {
                    f.hideThenShow ? (delete f.hideThenShow, d.repositionMenu(f, f.col, f.colElementPosition, g, f.colElement), f.$broadcast("show-menu"), f.menuShown = !0) : (f.hideMenu(!0), f.col && b.focus.bySelector(e, ".ui-grid-header-cell." + f.col.getColClass() + " .ui-grid-column-menu-button", f.col.grid, !1))
                }),
                f.$on("menu-shown",
                function() {
                    a(function() {
                        d.repositionMenu(f, f.col, f.colElementPosition, g, f.colElement),
                        delete f.colElementPosition,
                        delete f.columnElement
                    },
                    200)
                }),
                f.sortColumn = function(a, b) {
                    a.stopPropagation(),
                    f.grid.sortColumn(f.col, b, !0).then(function() {
                        f.grid.refresh(),
                        f.hideMenu()
                    })
                },
                f.unsortColumn = function() {
                    f.col.unsort(),
                    f.grid.refresh(),
                    f.hideMenu()
                };
                var j = function() {
                    a(function() {
                        var a, c = function() {
                            return b.focus.byId("grid-menu", f.grid)
                        };
                        f.grid.columns.some(function(b, c) {
                            return angular.equals(b, f.col) ? (a = c, !0) : void 0
                        });
                        var d;
                        if (f.grid.columns.some(function(b, c) {
                            if (!b.visible) return ! 1;
                            if (a > c) d = b;
                            else {
                                if (c > a && !d) return d = b,
                                !0;
                                if (c > a && d) return ! 0
                            }
                        }), d) {
                            var g = d.getColClass();
                            b.focus.bySelector(e, ".ui-grid-header-cell." + g + " .ui-grid-header-cell-primary-focus", !0).then(angular.noop,
                            function(a) {
                                return "canceled" !== a ? c() : void 0
                            })
                        } else c()
                    })
                };
                f.hideColumn = function() {
                    f.col.colDef.visible = !1,
                    f.col.visible = !1,
                    f.grid.queueGridRefresh(),
                    f.hideMenu(),
                    f.grid.api.core.notifyDataChange(c.dataChange.COLUMN),
                    f.grid.api.core.raise.columnVisibilityChanged(f.col),
                    j()
                }
            },
            controller: ["$scope",
            function(a) {
                var b = this;
                a.$watch("menuItems",
                function(a, c) {
                    b.menuItems = a
                })
            }]
        };
        return f
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFilter", ["$compile", "$templateCache", "i18nService", "gridUtil",
    function(a, b, c, d) {
        return {
            compile: function() {
                return {
                    pre: function(b, c, d, e) {
                        b.col.updateFilters = function(d) {
                            if (c.children().remove(), d) {
                                var e = b.col.filterHeaderTemplate;
                                c.append(a(e)(b))
                            }
                        },
                        b.$on("$destroy",
                        function() {
                            delete b.col.updateFilters
                        })
                    },
                    post: function(a, b, e, f) {
                        a.aria = c.getSafeText("headerCell.aria"),
                        a.removeFilter = function(a, c) {
                            a.term = null,
                            d.focus.bySelector(b, ".ui-grid-filter-input-" + c)
                        }
                    }
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooterCell", ["$timeout", "gridUtil", "uiGridConstants", "$compile",
    function(a, b, c, d) {
        var e = {
            priority: 0,
            scope: {
                col: "=",
                row: "=",
                renderIndex: "="
            },
            replace: !0,
            require: "^uiGrid",
            compile: function(a, b, e) {
                return {
                    pre: function(a, b, c, e) {
                        var f = d(a.col.footerCellTemplate)(a);
                        b.append(f)
                    },
                    post: function(a, b, d, e) {
                        a.grid = e.grid;
                        var f = a.col.getColClass(!1);
                        b.addClass(f);
                        var g, h = function(c) {
                            var d = b;
                            g && (d.removeClass(g), g = null),
                            g = angular.isFunction(a.col.footerCellClass) ? a.col.footerCellClass(a.grid, a.row, a.col, a.rowRenderIndex, a.colRenderIndex) : a.col.footerCellClass,
                            d.addClass(g)
                        };
                        a.col.footerCellClass && h(),
                        a.col.updateAggregationValue();
                        var i = a.grid.registerDataChangeCallback(h, [c.dataChange.COLUMN]);
                        a.grid.api.core.on.rowsRendered(a, a.col.updateAggregationValue),
                        a.grid.api.core.on.rowsRendered(a, h),
                        a.$on("$destroy", i)
                    }
                }
            }
        };
        return e
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooter", ["$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout",
    function(a, b, c, d, e) {
        return {
            restrict: "EA",
            replace: !0,
            require: ["^uiGrid", "^uiGridRenderContainer"],
            scope: !0,
            compile: function(a, c) {
                return {
                    pre: function(a, c, e, f) {
                        var g = f[0],
                        h = f[1];
                        a.grid = g.grid,
                        a.colContainer = h.colContainer,
                        h.footer = c;
                        var i = a.grid.options.footerTemplate;
                        d.getTemplate(i).then(function(d) {
                            var e = angular.element(d),
                            f = b(e)(a);
                            if (c.append(f), h) {
                                var g = c[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                                g && (h.footerViewport = g)
                            }
                        })
                    },
                    post: function(a, b, c, e) {
                        var f = e[0],
                        g = e[1];
                        f.grid;
                        d.disableAnimations(b),
                        g.footer = b;
                        var h = b[0].getElementsByClassName("ui-grid-footer-viewport")[0];
                        h && (g.footerViewport = h)
                    }
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGridFooter", ["$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout",
    function(a, b, c, d, e) {
        return {
            restrict: "EA",
            replace: !0,
            require: "^uiGrid",
            scope: !0,
            compile: function(a, c) {
                return {
                    pre: function(a, c, e, f) {
                        a.grid = f.grid;
                        var g = a.grid.options.gridFooterTemplate;
                        d.getTemplate(g).then(function(d) {
                            var e = angular.element(d),
                            f = b(e)(a);
                            c.append(f)
                        })
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridGroupPanel", ["$compile", "uiGridConstants", "gridUtil",
    function(a, b, c) {
        var d = "ui-grid/ui-grid-group-panel";
        return {
            restrict: "EA",
            replace: !0,
            require: "?^uiGrid",
            scope: !1,
            compile: function(b, e) {
                return {
                    pre: function(b, e, f, g) {
                        var h = b.grid.options.groupPanelTemplate || d;
                        c.getTemplate(h).then(function(c) {
                            var d = angular.element(c),
                            f = a(d)(b);
                            e.append(f)
                        })
                    },
                    post: function(a, b, c, d) {
                        b.bind("$destroy",
                        function() {})
                    }
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeaderCell", ["$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "ScrollEvent", "i18nService",
    function(a, b, c, d, e, f, g, h) {
        var i = 500,
        j = 500,
        k = {
            priority: 0,
            scope: {
                col: "=",
                row: "=",
                renderIndex: "="
            },
            require: ["^uiGrid", "^uiGridRenderContainer"],
            replace: !0,
            compile: function() {
                return {
                    pre: function(b, c, d) {
                        var e = a(b.col.headerCellTemplate)(b);
                        c.append(e)
                    },
                    post: function(a, c, e, g) {
                        var k = g[0],
                        l = g[1];
                        a.i18n = {
                            headerCell: h.getSafeText("headerCell"),
                            sort: h.getSafeText("sort")
                        },
                        a.isSortPriorityVisible = function() {
                            return a.col.sort.priority && a.grid.columns.some(function(b, c) {
                                return b.sort.priority && b !== a.col
                            })
                        },
                        a.getSortDirectionAriaLabel = function() {
                            var b = a.col,
                            c = b.sort.direction === f.ASC ? a.i18n.sort.ascending: b.sort.direction === f.DESC ? a.i18n.sort.descending: a.i18n.sort.none,
                            d = c;
                            return a.isSortPriorityVisible() && (d = d + ". " + a.i18n.headerCell.priority + " " + b.sort.priority),
                            d
                        },
                        a.grid = k.grid,
                        a.renderContainer = k.grid.renderContainers[l.containerId];
                        var m = a.col.getColClass(!1);
                        c.addClass(m),
                        a.menuShown = !1,
                        a.asc = f.ASC,
                        a.desc = f.DESC;
                        var n, o, p = (angular.element(c[0].querySelectorAll(".ui-grid-header-cell-menu")), angular.element(c[0].querySelectorAll(".ui-grid-cell-contents"))),
                        q = [];
                        a.downFn = function(e) {
                            e.stopPropagation(),
                            "undefined" != typeof e.originalEvent && void 0 !== e.originalEvent && (e = e.originalEvent),
                            e.button && 0 !== e.button || (o = e.pageX, a.mousedownStartTime = (new Date).getTime(), a.mousedownTimeout = b(function() {},
                            i), a.mousedownTimeout.then(function() {
                                a.colMenu && k.columnMenuScope.showMenu(a.col, c, e)
                            }), k.fireEvent(f.events.COLUMN_HEADER_CLICK, {
                                event: e,
                                columnName: a.col.colDef.name
                            }), a.offAllEvents(), "touchstart" === e.type ? (d.on("touchend", a.upFn), d.on("touchmove", a.moveFn)) : "mousedown" === e.type && (d.on("mouseup", a.upFn), d.on("mousemove", a.moveFn)))
                        },
                        a.upFn = function(c) {
                            c.stopPropagation(),
                            b.cancel(a.mousedownTimeout),
                            a.offAllEvents(),
                            a.onDownEvents(c.type);
                            var d = (new Date).getTime(),
                            e = d - a.mousedownStartTime;
                            e > i || a.sortable && a.handleClick(c)
                        },
                        a.moveFn = function(c) {
                            var d = c.pageX - o;
                            0 !== d && (b.cancel(a.mousedownTimeout), a.offAllEvents(), a.onDownEvents(c.type))
                        },
                        a.clickFn = function(b) {
                            b.stopPropagation(),
                            p.off("click", a.clickFn)
                        },
                        a.offAllEvents = function() {
                            p.off("touchstart", a.downFn),
                            p.off("mousedown", a.downFn),
                            d.off("touchend", a.upFn),
                            d.off("mouseup", a.upFn),
                            d.off("touchmove", a.moveFn),
                            d.off("mousemove", a.moveFn),
                            p.off("click", a.clickFn)
                        },
                        a.onDownEvents = function(c) {
                            switch (c) {
                            case "touchmove":
                            case "touchend":
                                p.on("click", a.clickFn),
                                p.on("touchstart", a.downFn),
                                b(function() {
                                    p.on("mousedown", a.downFn)
                                },
                                j);
                                break;
                            case "mousemove":
                            case "mouseup":
                                p.on("click", a.clickFn),
                                p.on("mousedown", a.downFn),
                                b(function() {
                                    p.on("touchstart", a.downFn)
                                },
                                j);
                                break;
                            default:
                                p.on("click", a.clickFn),
                                p.on("touchstart", a.downFn),
                                p.on("mousedown", a.downFn)
                            }
                        };
                        var r = function(d) {
                            var e = c;
                            n && (e.removeClass(n), n = null),
                            n = angular.isFunction(a.col.headerCellClass) ? a.col.headerCellClass(a.grid, a.row, a.col, a.rowRenderIndex, a.colRenderIndex) : a.col.headerCellClass,
                            e.addClass(n),
                            b(function() {
                                var b = a.grid.renderContainers.right ? a.grid.renderContainers.right: a.grid.renderContainers.body;
                                a.isLastCol = a.col === b.visibleColumnCache[b.visibleColumnCache.length - 1]
                            }),
                            k.grid.options.enableSorting && a.col.enableSorting ? a.sortable = !0 : a.sortable = !1;
                            var g = a.filterable;
                            k.grid.options.enableFiltering && a.col.enableFiltering ? a.filterable = !0 : a.filterable = !1,
                            g !== a.filterable && ("undefined" != typeof a.col.updateFilters && a.col.updateFilters(a.filterable), a.filterable ? (a.col.filters.forEach(function(b, c) {
                                q.push(a.$watch("col.filters[" + c + "].term",
                                function(a, b) {
                                    a !== b && (k.grid.api.core.raise.filterChanged(), k.grid.api.core.notifyDataChange(f.dataChange.COLUMN), k.grid.queueGridRefresh())
                                }))
                            }), a.$on("$destroy",
                            function() {
                                q.forEach(function(a) {
                                    a()
                                })
                            })) : q.forEach(function(a) {
                                a()
                            })),
                            a.col.grid.options && a.col.grid.options.enableColumnMenus !== !1 && a.col.colDef && a.col.colDef.enableColumnMenu !== !1 ? a.colMenu = !0 : a.colMenu = !1,
                            a.offAllEvents(),
                            (a.sortable || a.colMenu) && (a.onDownEvents(), a.$on("$destroy",
                            function() {
                                a.offAllEvents()
                            }))
                        };
                        r();
                        var s = a.grid.registerDataChangeCallback(r, [f.dataChange.COLUMN]);
                        a.$on("$destroy", s),
                        a.handleClick = function(b) {
                            var c = !1;
                            b.shiftKey && (c = !0),
                            k.grid.sortColumn(a.col, c).then(function() {
                                k.columnMenuScope && k.columnMenuScope.hideMenu(),
                                k.grid.refresh()
                            })
                        },
                        a.toggleMenu = function(b) {
                            b.stopPropagation(),
                            k.columnMenuScope.menuShown && k.columnMenuScope.col === a.col ? k.columnMenuScope.hideMenu() : k.columnMenuScope.showMenu(a.col, c)
                        }
                    }
                }
            }
        };
        return k
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeader", ["$templateCache", "$compile", "uiGridConstants", "gridUtil", "$timeout", "ScrollEvent",
    function(a, b, c, d, e, f) {
        var g = "ui-grid/ui-grid-header",
        h = "ui-grid/ui-grid-no-header";
        return {
            restrict: "EA",
            replace: !0,
            require: ["^uiGrid", "^uiGridRenderContainer"],
            scope: !0,
            compile: function(a, c) {
                return {
                    pre: function(a, c, e, i) {
                        function j() {
                            m.header = m.colContainer.header = c;
                            var a = c[0].getElementsByClassName("ui-grid-header-canvas");
                            a.length > 0 ? m.headerCanvas = m.colContainer.headerCanvas = a[0] : m.headerCanvas = null
                        }
                        function k(a) {
                            if (!l.grid.isScrollingHorizontally) {
                                var b = d.normalizeScrollLeft(m.headerViewport, l.grid),
                                c = m.colContainer.scrollHorizontal(b),
                                e = new f(l.grid, null, m.colContainer, f.Sources.ViewPortScroll);
                                e.newScrollLeft = b,
                                c > -1 && (e.x = {
                                    percentage: c
                                }),
                                l.grid.scrollContainers(null, e)
                            }
                        }
                        var l = i[0],
                        m = i[1];
                        a.grid = l.grid,
                        a.colContainer = m.colContainer,
                        j();
                        var n;
                        n = a.grid.options.showHeader ? a.grid.options.headerTemplate ? a.grid.options.headerTemplate: g: h,
                        d.getTemplate(n).then(function(d) {
                            var e = angular.element(d),
                            f = b(e)(a);
                            if (c.replaceWith(f), c = f, j(), m) {
                                var g = c[0].getElementsByClassName("ui-grid-header-viewport")[0];
                                g && (m.headerViewport = g, angular.element(g).on("scroll", k), a.$on("$destroy",
                                function() {
                                    angular.element(g).off("scroll", k)
                                }))
                            }
                            a.grid.queueRefresh()
                        })
                    },
                    post: function(a, b, c, e) {
                        function f() {
                            var a = h.colContainer.visibleColumnCache,
                            b = "",
                            c = 0;
                            return a.forEach(function(a) {
                                b += a.getColClassDefinition(),
                                c += a.drawnWidth
                            }),
                            h.colContainer.canvasWidth = c,
                            b
                        }
                        var g = e[0],
                        h = e[1];
                        g.grid;
                        d.disableAnimations(b),
                        h.header = b;
                        var i = b[0].getElementsByClassName("ui-grid-header-viewport")[0];
                        i && (h.headerViewport = i),
                        g && g.grid.registerStyleComputation({
                            priority: 15,
                            func: f
                        })
                    }
                }
            }
        }
    }])
} (),
function() {
    angular.module("ui.grid").service("uiGridGridMenuService", ["gridUtil", "i18nService", "uiGridConstants",
    function(a, b, c) {
        var d = {
            initialize: function(a, b) {
                b.gridMenuScope = a,
                a.grid = b,
                a.registeredMenuItems = [],
                a.$on("$destroy",
                function() {
                    a.grid && a.grid.gridMenuScope && (a.grid.gridMenuScope = null),
                    a.grid && (a.grid = null),
                    a.registeredMenuItems && (a.registeredMenuItems = null)
                }),
                a.registeredMenuItems = [],
                b.api.registerMethod("core", "addToGridMenu", d.addToGridMenu),
                b.api.registerMethod("core", "removeFromGridMenu", d.removeFromGridMenu)
            },
            addToGridMenu: function(b, c) {
                angular.isArray(c) ? b.gridMenuScope ? (b.gridMenuScope.registeredMenuItems = b.gridMenuScope.registeredMenuItems ? b.gridMenuScope.registeredMenuItems: [], b.gridMenuScope.registeredMenuItems = b.gridMenuScope.registeredMenuItems.concat(c)) : a.logError("Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid") : a.logError("addToGridMenu: menuItems must be an array, and is not, not adding any items")
            },
            removeFromGridMenu: function(b, c) {
                var d = -1;
                b && b.gridMenuScope && b.gridMenuScope.registeredMenuItems.forEach(function(b, e) {
                    b.id === c && (d > -1 ? a.logError("removeFromGridMenu: found multiple items with the same id, removing only the last") : d = e)
                }),
                d > -1 && b.gridMenuScope.registeredMenuItems.splice(d, 1)
            },
            getMenuItems: function(c) {
                var e = [];
                c.grid.options.gridMenuCustomItems && (angular.isArray(c.grid.options.gridMenuCustomItems) ? e = e.concat(c.grid.options.gridMenuCustomItems) : a.logError("gridOptions.gridMenuCustomItems must be an array, and is not"));
                var f = [{
                    title: b.getSafeText("gridMenu.clearAllFilters"),
                    action: function(a) {
                        c.grid.clearAllFilters(void 0, !0, void 0)
                    },
                    shown: function() {
                        return c.grid.options.enableFiltering
                    },
                    order: 100
                }];
                return e = e.concat(f),
                e = e.concat(c.registeredMenuItems),
                c.grid.options.gridMenuShowHideColumns !== !1 && (e = e.concat(d.showHideColumns(c))),
                e.sort(function(a, b) {
                    return a.order - b.order
                }),
                e
            },
            showHideColumns: function(a) {
                var c = [];
                return a.grid.options.columnDefs && 0 !== a.grid.options.columnDefs.length && 0 !== a.grid.columns.length ? (c.push({
                    title: b.getSafeText("gridMenu.columns"),
                    order: 300
                }), a.grid.options.gridMenuTitleFilter = a.grid.options.gridMenuTitleFilter ? a.grid.options.gridMenuTitleFilter: function(a) {
                    return a
                },
                a.grid.options.columnDefs.forEach(function(b, e) {
                    if (b.enableHiding !== !1) {
                        var f = {
                            icon: "ui-grid-icon-ok",
                            action: function(a) {
                                a.stopPropagation(),
                                d.toggleColumnVisibility(this.context.gridCol)
                            },
                            shown: function() {
                                return this.context.gridCol.colDef.visible === !0 || void 0 === this.context.gridCol.colDef.visible
                            },
                            context: {
                                gridCol: a.grid.getColumn(b.name || b.field)
                            },
                            leaveOpen: !0,
                            order: 301 + 2 * e
                        };
                        d.setMenuItemTitle(f, b, a.grid),
                        c.push(f),
                        f = {
                            icon: "ui-grid-icon-cancel",
                            action: function(a) {
                                a.stopPropagation(),
                                d.toggleColumnVisibility(this.context.gridCol)
                            },
                            shown: function() {
                                return ! (this.context.gridCol.colDef.visible === !0 || void 0 === this.context.gridCol.colDef.visible)
                            },
                            context: {
                                gridCol: a.grid.getColumn(b.name || b.field)
                            },
                            leaveOpen: !0,
                            order: 301 + 2 * e + 1
                        },
                        d.setMenuItemTitle(f, b, a.grid),
                        c.push(f)
                    }
                }), c) : c
            },
            setMenuItemTitle: function(b, c, d) {
                var e = d.options.gridMenuTitleFilter(c.displayName || a.readableColumnName(c.name) || c.field);
                "string" == typeof e ? b.title = e: e.then ? (b.title = "", e.then(function(a) {
                    b.title = a
                },
                function(a) {
                    b.title = a
                })) : (a.logError("Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config"), b.title = "badconfig")
            },
            toggleColumnVisibility: function(a) {
                a.colDef.visible = !(a.colDef.visible === !0 || void 0 === a.colDef.visible),
                a.grid.refresh(),
                a.grid.api.core.notifyDataChange(c.dataChange.COLUMN),
                a.grid.api.core.raise.columnVisibilityChanged(a)
            }
        };
        return d
    }]).directive("uiGridMenuButton", ["gridUtil", "uiGridConstants", "uiGridGridMenuService", "i18nService",
    function(a, b, c, d) {
        return {
            priority: 0,
            scope: !0,
            require: ["^uiGrid"],
            templateUrl: "ui-grid/ui-grid-menu-button",
            replace: !0,
            link: function(b, e, f, g) {
                var h = g[0];
                b.i18n = {
                    aria: d.getSafeText("gridMenu.aria")
                },
                c.initialize(b, h.grid),
                b.shown = !1,
                b.toggleMenu = function() {
                    b.shown ? (b.$broadcast("hide-menu"), b.shown = !1) : (b.menuItems = c.getMenuItems(b), b.$broadcast("show-menu"), b.shown = !0)
                },
                b.$on("menu-hidden",
                function() {
                    b.shown = !1,
                    a.focus.bySelector(e, ".ui-grid-icon-container")
                })
            }
        }
    }])
} (),
function() {
    angular.module("ui.grid").directive("uiGridMenu", ["$compile", "$timeout", "$window", "$document", "gridUtil", "uiGridConstants", "i18nService",
    function(a, b, c, d, e, f, g) {
        var h = {
            priority: 0,
            scope: {
                menuItems: "=",
                autoHide: "=?"
            },
            require: "?^uiGrid",
            templateUrl: "ui-grid/uiGridMenu",
            replace: !1,
            link: function(a, d, h, i) {
                var j;
                a.dynamicStyles = "",
                i && (j = i.grid.gridHeight - 30, a.dynamicStyles = [".grid" + i.grid.id + " .ui-grid-menu-mid {", "max-height: " + j + "px;", "}"].join(" ")),
                a.i18n = {
                    close: g.getSafeText("columnMenu.close")
                },
                a.showMenu = function(c, f) {
                    a.shown ? a.shownMid || (a.shownMid = !0, a.$emit("menu-shown")) : (a.shown = !0, b(function() {
                        a.shownMid = !0,
                        a.$emit("menu-shown")
                    }));
                    var g = "click";
                    f && f.originalEvent && f.originalEvent.type && "touchstart" === f.originalEvent.type && (g = f.originalEvent.type),
                    angular.element(document).off("click touchstart", k),
                    b(function() {
                        angular.element(document).on(g, k)
                    }),
                    e.focus.bySelector(d, "button[type=button]", !0)
                },
                a.hideMenu = function(c, d) {
                    a.shown && (a.shownMid = !1, b(function() {
                        a.shownMid || (a.shown = !1, a.$emit("menu-hidden"))
                    },
                    200)),
                    angular.element(document).off("click touchstart", k)
                },
                a.$on("hide-menu",
                function(b, c) {
                    a.hideMenu(b, c)
                }),
                a.$on("show-menu",
                function(b, c) {
                    a.showMenu(b, c)
                });
                var k = function() {
                    a.shown && a.$apply(function() {
                        a.hideMenu()
                    })
                }; ("undefined" == typeof a.autoHide || void 0 === a.autoHide) && (a.autoHide = !0),
                a.autoHide && angular.element(c).on("resize", k),
                a.$on("$destroy",
                function() {
                    angular.element(document).off("click touchstart", k)
                }),
                a.$on("$destroy",
                function() {
                    angular.element(c).off("resize", k)
                }),
                i && a.$on("$destroy", i.grid.api.core.on.scrollBegin(a, k)),
                a.$on("$destroy", a.$on(f.events.ITEM_DRAGGING, k))
            },
            controller: ["$scope", "$element", "$attrs",
            function(a, b, c) {}]
        };
        return h
    }]).directive("uiGridMenuItem", ["gridUtil", "$compile", "i18nService",
    function(a, b, c) {
        var d = {
            priority: 0,
            scope: {
                name: "=",
                active: "=",
                action: "=",
                icon: "=",
                shown: "=",
                context: "=",
                templateUrl: "=",
                leaveOpen: "=",
                screenReaderOnly: "="
            },
            require: ["?^uiGrid", "^uiGridMenu"],
            templateUrl: "ui-grid/uiGridMenuItem",
            replace: !1,
            compile: function(d, e) {
                return {
                    pre: function(c, d, e, f) {
                        f[0],
                        f[1];
                        c.templateUrl && a.getTemplate(c.templateUrl).then(function(a) {
                            var e = angular.element(a),
                            f = b(e)(c);
                            d.replaceWith(f)
                        })
                    },
                    post: function(b, d, e, f) {
                        var g = f[0];
                        f[1]; ("undefined" == typeof b.shown || null === b.shown) && (b.shown = function() {
                            return ! 0
                        }),
                        b.itemShown = function() {
                            var a = {};
                            return b.context && (a.context = b.context),
                            "undefined" != typeof g && g && (a.grid = g.grid),
                            b.shown.call(a)
                        },
                        b.itemAction = function(c, e) {
                            if (a.logDebug("itemAction"), c.stopPropagation(), "function" == typeof b.action) {
                                var f = {};
                                b.context && (f.context = b.context),
                                "undefined" != typeof g && g && (f.grid = g.grid),
                                b.action.call(f, c, e),
                                b.leaveOpen ? a.focus.bySelector(angular.element(a.closestElm(d, ".ui-grid-menu-items")), "button[type=button]", !0) : b.$emit("hide-menu")
                            }
                        },
                        b.i18n = c.get()
                    }
                }
            }
        };
        return d
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid");
    angular.forEach([{
        tag: "Src",
        method: "attr"
    },
    {
        tag: "Text",
        method: "text"
    },
    {
        tag: "Href",
        method: "attr"
    },
    {
        tag: "Class",
        method: "addClass"
    },
    {
        tag: "Html",
        method: "html"
    },
    {
        tag: "Alt",
        method: "attr"
    },
    {
        tag: "Style",
        method: "css"
    },
    {
        tag: "Value",
        method: "attr"
    },
    {
        tag: "Id",
        method: "attr"
    },
    {
        tag: "Id",
        directiveName: "IdGrid",
        method: "attr",
        appendGridId: !0
    },
    {
        tag: "Title",
        method: "attr"
    },
    {
        tag: "Label",
        method: "attr",
        aria: !0
    },
    {
        tag: "Labelledby",
        method: "attr",
        aria: !0
    },
    {
        tag: "Labelledby",
        directiveName: "LabelledbyGrid",
        appendGridId: !0,
        method: "attr",
        aria: !0
    },
    {
        tag: "Describedby",
        method: "attr",
        aria: !0
    },
    {
        tag: "Describedby",
        directiveName: "DescribedbyGrid",
        appendGridId: !0,
        method: "attr",
        aria: !0
    }],
    function(b) {
        var c = "uiGridOneBind",
        d = (b.aria ? c + "Aria": c) + (b.directiveName ? b.directiveName: b.tag);
        a.directive(d, ["gridUtil",
        function(a) {
            return {
                restrict: "A",
                require: ["?uiGrid", "?^uiGrid"],
                link: function(c, e, f, g) {
                    var h = function(b) {
                        var e;
                        if (c.grid) e = c.grid;
                        else if (c.col && c.col.grid) e = c.col.grid;
                        else if (!g.some(function(a) {
                            return a && a.grid ? (e = a.grid, !0) : void 0
                        })) throw a.logError("[" + d + "] A valid grid could not be found to bind id. Are you using this directive within the correct scope? Trying to generate id: [gridID]-" + b),
                        new Error("No valid grid could be found");
                        if (e) {
                            var f = new RegExp(e.id.toString());
                            f.test(b) || (b = e.id.toString() + "-" + b)
                        }
                        return b
                    },
                    i = c.$watch(f[d],
                    function(a) {
                        if (a) {
                            if (b.appendGridId) {
                                var c = null;
                                angular.forEach(a.split(" "),
                                function(a) {
                                    c = (c ? c + " ": "") + h(a)
                                }),
                                a = c
                            }
                            switch (b.method) {
                            case "attr":
                                b.aria ? e[b.method]("aria-" + b.tag.toLowerCase(), a) : e[b.method](b.tag.toLowerCase(), a);
                                break;
                            case "addClass":
                                if (angular.isObject(a) && !angular.isArray(a)) {
                                    var d = [],
                                    f = !1;
                                    if (angular.forEach(a,
                                    function(a, b) {
                                        null !== a && "undefined" != typeof a && (f = !0, a && d.push(b))
                                    }), !f) return;
                                    a = d
                                }
                                if (!a) return;
                                e.addClass(angular.isArray(a) ? a.join(" ") : a);
                                break;
                            default:
                                e[b.method](a)
                            }
                            i()
                        }
                    },
                    !0)
                }
            }
        }])
    })
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid");
    a.directive("uiGridRenderContainer", ["$timeout", "$document", "uiGridConstants", "gridUtil", "ScrollEvent",
    function(a, b, c, d, e) {
        return {
            replace: !0,
            transclude: !0,
            templateUrl: "ui-grid/uiGridRenderContainer",
            require: ["^uiGrid", "uiGridRenderContainer"],
            scope: {
                containerId: "=",
                rowContainerName: "=",
                colContainerName: "=",
                bindScrollHorizontal: "=",
                bindScrollVertical: "=",
                enableVerticalScrollbar: "=",
                enableHorizontalScrollbar: "="
            },
            controller: "uiGridRenderContainer as RenderContainer",
            compile: function() {
                return {
                    pre: function(a, b, c, d) {
                        var e = d[0],
                        f = d[1],
                        g = a.grid = e.grid;
                        if (!a.rowContainerName) throw "No row render container name specified";
                        if (!a.colContainerName) throw "No column render container name specified";
                        if (!g.renderContainers[a.rowContainerName]) throw "Row render container '" + a.rowContainerName + "' is not registered.";
                        if (!g.renderContainers[a.colContainerName]) throw "Column render container '" + a.colContainerName + "' is not registered.";
                        var h = a.rowContainer = g.renderContainers[a.rowContainerName],
                        i = a.colContainer = g.renderContainers[a.colContainerName];
                        f.containerId = a.containerId,
                        f.rowContainer = h,
                        f.colContainer = i
                    },
                    post: function(a, b, c, f) {
                        function g() {
                            var b = "",
                            c = l.canvasWidth,
                            d = l.getViewportWidth(),
                            e = k.getCanvasHeight(),
                            f = k.getViewportHeight();
                            l.needsHScrollbarPlaceholder() && (f -= j.scrollbarHeight);
                            var g, i;
                            return g = i = l.getHeaderViewportWidth(),
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-canvas { width: " + c + "px; height: " + e + "px; }",
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-header-canvas { width: " + (c + j.scrollbarWidth) + "px; }",
                            b += o.explicitHeaderCanvasHeight ? "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-header-canvas { height: " + o.explicitHeaderCanvasHeight + "px; }": "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-header-canvas { height: inherit; }",
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-viewport { width: " + d + "px; height: " + f + "px; }",
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-header-viewport { width: " + g + "px; }",
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-footer-canvas { width: " + (c + j.scrollbarWidth) + "px; }",
                            b += "\n .grid" + h.grid.id + " .ui-grid-render-container-" + a.containerId + " .ui-grid-footer-viewport { width: " + i + "px; }"
                        }
                        var h = f[0],
                        i = f[1],
                        j = h.grid,
                        k = i.rowContainer,
                        l = i.colContainer,
                        m = null,
                        n = null,
                        o = j.renderContainers[a.containerId];
                        b.addClass("ui-grid-render-container-" + a.containerId),
                        d.on.mousewheel(b,
                        function(a) {
                            var b = new e(j, k, l, e.Sources.RenderContainerMouseWheel);
                            if (0 !== a.deltaY) {
                                var c = -1 * a.deltaY * a.deltaFactor;
                                m = i.viewport[0].scrollTop,
                                b.verticalScrollLength = k.getVerticalScrollLength();
                                var f = (m + c) / b.verticalScrollLength;
                                f >= 1 && m < b.verticalScrollLength && (i.viewport[0].scrollTop = b.verticalScrollLength),
                                0 > f ? f = 0 : f > 1 && (f = 1),
                                b.y = {
                                    percentage: f,
                                    pixels: c
                                }
                            }
                            if (0 !== a.deltaX) {
                                var g = a.deltaX * a.deltaFactor;
                                n = d.normalizeScrollLeft(i.viewport, j),
                                b.horizontalScrollLength = l.getCanvasWidth() - l.getViewportWidth();
                                var h = (n + g) / b.horizontalScrollLength;
                                0 > h ? h = 0 : h > 1 && (h = 1),
                                b.x = {
                                    percentage: h,
                                    pixels: g
                                }
                            }
                            0 !== a.deltaY && (b.atTop(m) || b.atBottom(m)) || 0 !== a.deltaX && (b.atLeft(n) || b.atRight(n)) || (a.preventDefault(), a.stopPropagation(), b.fireThrottledScrollingEvent("", b))
                        }),
                        b.bind("$destroy",
                        function() {
                            b.unbind("keydown"),
                            ["touchstart", "touchmove", "touchend", "keydown", "wheel", "mousewheel", "DomMouseScroll", "MozMousePixelScroll"].forEach(function(a) {
                                b.unbind(a)
                            })
                        }),
                        h.grid.registerStyleComputation({
                            priority: 6,
                            func: g
                        })
                    }
                }
            }
        }
    }]),
    a.controller("uiGridRenderContainer", ["$scope", "gridUtil",
    function(a, b) {}])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridRow", ["gridUtil",
    function(a) {
        return {
            replace: !0,
            require: ["^uiGrid", "^uiGridRenderContainer"],
            scope: {
                row: "=uiGridRow",
                rowRenderIndex: "="
            },
            compile: function() {
                return {
                    pre: function(a, b, c, d) {
                        function e() {
                            a.row.getRowTemplateFn.then(function(c) {
                                var d = a.$new();
                                c(d,
                                function(a, c) {
                                    h && (h.remove(), i.$destroy()),
                                    b.empty().append(a),
                                    h = a,
                                    i = d
                                })
                            })
                        }
                        var f = d[0],
                        g = d[1];
                        f.grid;
                        a.grid = f.grid,
                        a.colContainer = g.colContainer;
                        var h, i;
                        e(),
                        a.$watch("row.getRowTemplateFn",
                        function(a, b) {
                            a !== b && e()
                        })
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    angular.module("ui.grid").directive("uiGridStyle", ["gridUtil", "$interpolate",
    function(a, b) {
        return {
            link: function(a, c, d, e) {
                var f = b(c.text(), !0);
                f && a.$watch(f,
                function(a) {
                    c.text(a)
                })
            }
        }
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridViewport", ["gridUtil", "ScrollEvent", "uiGridConstants", "$log",
    function(a, b, c, d) {
        return {
            replace: !0,
            scope: {},
            controllerAs: "Viewport",
            templateUrl: "ui-grid/uiGridViewport",
            require: ["^uiGrid", "^uiGridRenderContainer"],
            link: function(c, d, e, f) {
                function g(e) {
                    var f = d[0].scrollTop,
                    g = a.normalizeScrollLeft(d, p),
                    h = n.scrollVertical(f),
                    i = o.scrollHorizontal(g),
                    j = new b(p, n, o, b.Sources.ViewPortScroll);
                    j.newScrollLeft = g,
                    j.newScrollTop = f,
                    i > -1 && (j.x = {
                        percentage: i
                    }),
                    h > -1 && (j.y = {
                        percentage: h
                    }),
                    p.scrollContainers(c.$parent.containerId, j)
                }
                function h(a) {
                    m.prevScrollArgs = a;
                    var b = a.getNewScrollTop(n, m.viewport);
                    d[0].scrollTop = b
                }
                function i(b) {
                    m.prevScrollArgs = b;
                    var c = b.getNewScrollLeft(o, m.viewport);
                    d[0].scrollLeft = a.denormalizeScrollLeft(m.viewport, c, p)
                }
                function j(b) {
                    var c = b.getNewScrollLeft(o, m.viewport);
                    m.headerViewport && (m.headerViewport.scrollLeft = a.denormalizeScrollLeft(m.viewport, c, p));
                }
                function k(b) {
                    var c = b.getNewScrollLeft(o, m.viewport);
                    m.footerViewport && (m.footerViewport.scrollLeft = a.denormalizeScrollLeft(m.viewport, c, p))
                }
                var l = f[0],
                m = f[1];
                c.containerCtrl = m;
                var n = m.rowContainer,
                o = m.colContainer,
                p = l.grid;
                c.grid = l.grid,
                c.rowContainer = m.rowContainer,
                c.colContainer = m.colContainer,
                m.viewport = d,
                d.on("scroll", g);
                c.$parent.bindScrollVertical && p.addVerticalScrollSync(c.$parent.containerId, h),
                c.$parent.bindScrollHorizontal && (p.addHorizontalScrollSync(c.$parent.containerId, i), p.addHorizontalScrollSync(c.$parent.containerId + "header", j), p.addHorizontalScrollSync(c.$parent.containerId + "footer", k))
            },
            controller: ["$scope",
            function(a) {
                this.rowStyle = function(b) {
                    var c = a.rowContainer,
                    d = a.colContainer,
                    e = {};
                    if (0 === b && 0 !== c.currentTopRow) {
                        var f = c.currentTopRow * c.grid.options.rowHeight;
                        e["margin-top"] = f + "px"
                    }
                    return 0 !== d.currentFirstColumn && (d.grid.isRTL() ? e["margin-right"] = d.columnOffset + "px": e["margin-left"] = d.columnOffset + "px"),
                    e
                }
            }]
        }
    }])
} (),
function() {
    angular.module("ui.grid").directive("uiGridVisible",
    function() {
        return function(a, b, c) {
            a.$watch(c.uiGridVisible,
            function(a) {
                b[a ? "removeClass": "addClass"]("ui-grid-invisible")
            })
        }
    })
} (),
function() {
    "use strict";
    function a(a, b, c, d, e, f) {
        return {
            templateUrl: "ui-grid/ui-grid",
            scope: {
                uiGrid: "="
            },
            replace: !0,
            transclude: !0,
            controller: "uiGridController",
            compile: function() {
                return {
                    post: function(a, b, g, h) {
                        function i() {
                            b[0].offsetWidth <= 0 && p > q ? (setTimeout(i, o), q++) : c(k)
                        }
                        function j() {
                            angular.element(d).on("resize", m),
                            b.on("$destroy",
                            function() {
                                angular.element(d).off("resize", m)
                            }),
                            a.$watch(function() {
                                return n.hasLeftContainer()
                            },
                            function(a, b) {
                                a !== b && n.refreshCanvas(!0)
                            }),
                            a.$watch(function() {
                                return n.hasRightContainer()
                            },
                            function(a, b) {
                                a !== b && n.refreshCanvas(!0)
                            })
                        }
                        function k() {
                            n.gridWidth = a.gridWidth = e.elementWidth(b),
                            n.canvasWidth = h.grid.gridWidth,
                            n.gridHeight = a.gridHeight = e.elementHeight(b),
                            n.gridHeight <= n.options.rowHeight && n.options.enableMinHeightCheck && l(),
                            n.refreshCanvas(!0)
                        }
                        function l() {
                            var c = n.options.minRowsToShow * n.options.rowHeight,
                            d = n.options.showHeader ? n.options.headerRowHeight: 0,
                            g = n.calcFooterHeight(),
                            h = 0;
                            n.options.enableHorizontalScrollbar === f.scrollbars.ALWAYS && (h = e.getScrollbarWidth());
                            var i = 0;
                            if (angular.forEach(n.options.columnDefs,
                            function(a) {
                                a.hasOwnProperty("filter") ? 1 > i && (i = 1) : a.hasOwnProperty("filters") && i < a.filters.length && (i = a.filters.length)
                            }), n.options.enableFiltering) {
                                var j = n.options.columnDefs.every(function(a) {
                                    return a.enableFiltering === !1
                                });
                                j || i++
                            }
                            var k = i * d,
                            l = d + c + g + h + k;
                            b.css("height", l + "px"),
                            n.gridHeight = a.gridHeight = e.elementHeight(b)
                        }
                        function m(c) {
                            n.gridWidth = a.gridWidth = e.elementWidth(b),
                            n.gridHeight = a.gridHeight = e.elementHeight(b),
                            n.refreshCanvas(!0)
                        }
                        var n = h.grid;
                        h.scrollbars = [],
                        n.element = b;
                        var o = 100,
                        p = 20,
                        q = 0;
                        j(),
                        k(),
                        n.renderingComplete(),
                        i()
                    }
                }
            }
        }
    }
    angular.module("ui.grid").controller("uiGridController", ["$scope", "$element", "$attrs", "gridUtil", "$q", "uiGridConstants", "$templateCache", "gridClassFactory", "$timeout", "$parse", "$compile",
    function(a, b, c, d, e, f, g, h, i, j, k) {
        function l(a, b) {
            a && a !== b && (n.grid.options.columnDefs = a, n.grid.buildColumns({
                orderByColumnDefs: !0
            }).then(function() {
                n.grid.preCompileCellTemplates(),
                n.grid.callDataChangeCallbacks(f.dataChange.COLUMN)
            }))
        }
        function m(b) {
            var d = [];
            if (n.grid.options.fastWatch && (b = angular.isString(a.uiGrid.data) ? n.grid.appScope[a.uiGrid.data] : a.uiGrid.data), p = b, b) {
                var g = n.grid.columns.length > (n.grid.rowHeaderColumns ? n.grid.rowHeaderColumns.length: 0); ! g && !c.uiGridColumns && 0 === n.grid.options.columnDefs.length && b.length > 0 && n.grid.buildColumnDefsFromData(b),
                !g && (n.grid.options.columnDefs.length > 0 || b.length > 0) && d.push(n.grid.buildColumns().then(function() {
                    n.grid.preCompileCellTemplates()
                })),
                e.all(d).then(function() {
                    n.grid.modifyRows(p).then(function() {
                        n.grid.redrawInPlace(!0),
                        a.$evalAsync(function() {
                            n.grid.refreshCanvas(!0),
                            n.grid.callDataChangeCallbacks(f.dataChange.ROW)
                        })
                    })
                })
            }
        }
        var n = this;
        n.grid = h.createGrid(a.uiGrid),
        n.grid.appScope = n.grid.appScope || a.$parent,
        b.addClass("grid" + n.grid.id),
        n.grid.rtl = "rtl" === d.getStyles(b[0]).direction,
        a.grid = n.grid,
        c.uiGridColumns && c.$observe("uiGridColumns",
        function(a) {
            n.grid.options.columnDefs = a,
            n.grid.buildColumns().then(function() {
                n.grid.preCompileCellTemplates(),
                n.grid.refreshCanvas(!0)
            })
        });
        var o = [];
        n.grid.options.fastWatch ? (n.uiGrid = a.uiGrid, angular.isString(a.uiGrid.data) ? (o.push(a.$parent.$watch(a.uiGrid.data, m)), o.push(a.$parent.$watch(function() {
            return n.grid.appScope[a.uiGrid.data] ? n.grid.appScope[a.uiGrid.data].length: void 0
        },
        m))) : (o.push(a.$parent.$watch(function() {
            return a.uiGrid.data
        },
        m)), o.push(a.$parent.$watch(function() {
            return a.uiGrid.data.length
        },
        m))), o.push(a.$parent.$watch(function() {
            return a.uiGrid.columnDefs
        },
        l)), o.push(a.$parent.$watch(function() {
            return a.uiGrid.columnDefs.length
        },
        l))) : (angular.isString(a.uiGrid.data) ? o.push(a.$parent.$watchCollection(a.uiGrid.data, m)) : o.push(a.$parent.$watchCollection(function() {
            return a.uiGrid.data
        },
        m)), o.push(a.$parent.$watchCollection(function() {
            return a.uiGrid.columnDefs
        },
        l)));
        var p, q = a.$watch(function() {
            return n.grid.styleComputations
        },
        function() {
            n.grid.refreshCanvas(!0)
        });
        a.$on("$destroy",
        function() {
            o.forEach(function(a) {
                a()
            }),
            q()
        }),
        n.fireEvent = function(b, c) { ("undefined" == typeof c || void 0 === c) && (c = {}),
            ("undefined" == typeof c.grid || void 0 === c.grid) && (c.grid = n.grid),
            a.$broadcast(b, c)
        },
        n.innerCompile = function(b) {
            k(b)(a)
        }
    }]),
    angular.module("ui.grid").directive("uiGrid", a),
    a.$inject = ["$compile", "$templateCache", "$timeout", "$window", "gridUtil", "uiGridConstants"]
} (),
function() {
    "use strict";
    angular.module("ui.grid").directive("uiGridPinnedContainer", ["gridUtil",
    function(a) {
        return {
            restrict: "EA",
            replace: !0,
            template: '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
            scope: {
                side: "=uiGridPinnedContainer"
            },
            require: "^uiGrid",
            compile: function() {
                return {
                    post: function(a, b, c, d) {
                        function e() {
                            var a = this,
                            b = 0;
                            a.visibleColumnCache.forEach(function(a) {
                                b += a.drawnWidth
                            });
                            var c = a.getViewportAdjustment();
                            return b += c.width
                        }
                        function f() {
                            if ("left" === a.side || "right" === a.side) {
                                for (var b = h.renderContainers[a.side].visibleColumnCache, c = 0, d = 0; d < b.length; d++) {
                                    var e = b[d];
                                    c += e.drawnWidth || e.width || 0
                                }
                                return c
                            }
                        }
                        function g() {
                            var c = "";
                            return ("left" === a.side || "right" === a.side) && (i = f(), b.attr("style", null), c += ".grid" + h.id + " .ui-grid-pinned-container-" + a.side + ", .grid" + h.id + " .ui-grid-pinned-container-" + a.side + " .ui-grid-render-container-" + a.side + " .ui-grid-viewport { width: " + i + "px; } "),
                            c
                        }
                        var h = d.grid,
                        i = 0;
                        b.addClass("ui-grid-pinned-container-" + a.side),
                        ("left" === a.side || "right" === a.side) && (h.renderContainers[a.side].getViewportWidth = e),
                        h.renderContainers.body.registerViewportAdjuster(function(b) {
                            return i = f(),
                            b.width -= i,
                            b.side = a.side,
                            b
                        }),
                        h.registerStyleComputation({
                            priority: 15,
                            func: g
                        })
                    }
                }
            }
        }
    }])
} (),
function() {
    angular.module("ui.grid").factory("Grid", ["$q", "$compile", "$parse", "gridUtil", "uiGridConstants", "GridOptions", "GridColumn", "GridRow", "GridApi", "rowSorter", "rowSearcher", "GridRenderContainer", "$timeout", "ScrollEvent",
    function(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        function o() {}
        var p = function(a) {
            function b(a) {
                g.isScrollingVertically = !1,
                g.api.core.raise.scrollEnd(a),
                g.scrollDirection = e.scrollDirection.NONE
            }
            function c(a) {
                g.isScrollingHorizontally = !1,
                g.api.core.raise.scrollEnd(a),
                g.scrollDirection = e.scrollDirection.NONE
            }
            var g = this;
            if (void 0 === a || "undefined" == typeof a.id || !a.id) throw new Error("No ID provided. An ID must be given when creating a grid.");
            if (!/^[_a-zA-Z0-9-]+$/.test(a.id)) throw new Error("Grid id '" + a.id + '" is invalid. It must follow CSS selector syntax rules.');
            g.id = a.id,
            delete a.id,
            g.options = f.initialize(a),
            g.appScope = g.options.appScopeProvider,
            g.headerHeight = g.options.headerRowHeight,
            g.footerHeight = g.calcFooterHeight(),
            g.columnFooterHeight = g.calcColumnFooterHeight(),
            g.rtl = !1,
            g.gridHeight = 0,
            g.gridWidth = 0,
            g.columnBuilders = [],
            g.rowBuilders = [],
            g.rowsProcessors = [],
            g.columnsProcessors = [],
            g.styleComputations = [],
            g.viewportAdjusters = [],
            g.rowHeaderColumns = [],
            g.dataChangeCallbacks = {},
            g.verticalScrollSyncCallBackFns = {},
            g.horizontalScrollSyncCallBackFns = {},
            g.renderContainers = {},
            g.renderContainers.body = new l("body", g),
            g.cellValueGetterCache = {},
            g.getRowTemplateFn = null,
            g.rows = [],
            g.columns = [],
            g.isScrollingVertically = !1,
            g.isScrollingHorizontally = !1,
            g.scrollDirection = e.scrollDirection.NONE,
            g.disableScrolling = !1;
            var h = d.debounce(b, g.options.scrollDebounce),
            k = d.debounce(b, 0),
            m = d.debounce(c, g.options.scrollDebounce),
            n = d.debounce(c, 0);
            g.flagScrollingVertically = function(a) {
                g.isScrollingVertically || g.isScrollingHorizontally || g.api.core.raise.scrollBegin(a),
                g.isScrollingVertically = !0,
                0 !== g.options.scrollDebounce && a.withDelay ? h(a) : k(a)
            },
            g.flagScrollingHorizontally = function(a) {
                g.isScrollingVertically || g.isScrollingHorizontally || g.api.core.raise.scrollBegin(a),
                g.isScrollingHorizontally = !0,
                0 !== g.options.scrollDebounce && a.withDelay ? m(a) : n(a)
            },
            g.scrollbarHeight = 0,
            g.scrollbarWidth = 0,
            g.options.enableHorizontalScrollbar === e.scrollbars.ALWAYS && (g.scrollbarHeight = d.getScrollbarWidth()),
            g.options.enableVerticalScrollbar === e.scrollbars.ALWAYS && (g.scrollbarWidth = d.getScrollbarWidth()),
            g.api = new i(g),
            g.api.registerMethod("core", "refresh", this.refresh),
            g.api.registerMethod("core", "queueGridRefresh", this.queueGridRefresh),
            g.api.registerMethod("core", "refreshRows", this.refreshRows),
            g.api.registerMethod("core", "queueRefresh", this.queueRefresh),
            g.api.registerMethod("core", "handleWindowResize", this.handleWindowResize),
            g.api.registerMethod("core", "addRowHeaderColumn", this.addRowHeaderColumn),
            g.api.registerMethod("core", "scrollToIfNecessary",
            function(a, b) {
                return g.scrollToIfNecessary(a, b)
            }),
            g.api.registerMethod("core", "scrollTo",
            function(a, b) {
                return g.scrollTo(a, b)
            }),
            g.api.registerMethod("core", "registerRowsProcessor", this.registerRowsProcessor),
            g.api.registerMethod("core", "registerColumnsProcessor", this.registerColumnsProcessor),
            g.api.registerMethod("core", "sortHandleNulls", j.handleNulls),
            g.api.registerEvent("core", "sortChanged"),
            g.api.registerEvent("core", "columnVisibilityChanged"),
            g.api.registerMethod("core", "notifyDataChange", this.notifyDataChange),
            g.api.registerMethod("core", "clearAllFilters", this.clearAllFilters),
            g.registerDataChangeCallback(g.columnRefreshCallback, [e.dataChange.COLUMN]),
            g.registerDataChangeCallback(g.processRowsCallback, [e.dataChange.EDIT]),
            g.registerDataChangeCallback(g.updateFooterHeightCallback, [e.dataChange.OPTIONS]),
            g.registerStyleComputation({
                priority: 10,
                func: g.getFooterStyles
            })
        };
        return p.prototype.calcFooterHeight = function() {
            if (!this.hasFooter()) return 0;
            var a = 0;
            return this.options.showGridFooter && (a += this.options.gridFooterHeight),
            a += this.calcColumnFooterHeight()
        },
        p.prototype.calcColumnFooterHeight = function() {
            var a = 0;
            return this.options.showColumnFooter && (a += this.options.columnFooterHeight),
            a
        },
        p.prototype.getFooterStyles = function() {
            var a = ".grid" + this.id + " .ui-grid-footer-aggregates-row { height: " + this.options.columnFooterHeight + "px; }";
            return a += " .grid" + this.id + " .ui-grid-footer-info { height: " + this.options.gridFooterHeight + "px; }"
        },
        p.prototype.hasFooter = function() {
            return this.options.showGridFooter || this.options.showColumnFooter
        },
        p.prototype.isRTL = function() {
            return this.rtl
        },
        p.prototype.registerColumnBuilder = function(a) {
            this.columnBuilders.push(a)
        },
        p.prototype.buildColumnDefsFromData = function(a) {
            this.options.columnDefs = d.getColumnsFromData(a, this.options.excludeProperties)
        },
        p.prototype.registerRowBuilder = function(a) {
            this.rowBuilders.push(a)
        },
        p.prototype.registerDataChangeCallback = function(a, b, c) {
            var f = d.nextUid();
            b || (b = [e.dataChange.ALL]),
            Array.isArray(b) || d.logError("Expected types to be an array or null in registerDataChangeCallback, value passed was: " + b),
            this.dataChangeCallbacks[f] = {
                callback: a,
                types: b,
                _this: c
            };
            var g = this,
            h = function() {
                delete g.dataChangeCallbacks[f]
            };
            return h
        },
        p.prototype.callDataChangeCallbacks = function(a, b) {
            angular.forEach(this.dataChangeCallbacks,
            function(b, c) { ( - 1 !== b.types.indexOf(e.dataChange.ALL) || -1 !== b.types.indexOf(a) || a === e.dataChange.ALL) && (b._this ? b.callback.apply(b._this, this) : b.callback(this))
            },
            this)
        },
        p.prototype.notifyDataChange = function(a) {
            var b = e.dataChange;
            a === b.ALL || a === b.COLUMN || a === b.EDIT || a === b.ROW || a === b.OPTIONS ? this.callDataChangeCallbacks(a) : d.logError("Notified of a data change, but the type was not recognised, so no action taken, type was: " + a)
        },
        p.prototype.columnRefreshCallback = function(a) {
            a.buildColumns(),
            a.queueGridRefresh()
        },
        p.prototype.processRowsCallback = function(a) {
            a.queueGridRefresh()
        },
        p.prototype.updateFooterHeightCallback = function(a) {
            a.footerHeight = a.calcFooterHeight(),
            a.columnFooterHeight = a.calcColumnFooterHeight()
        },
        p.prototype.getColumn = function(a) {
            var b = this.columns.filter(function(b) {
                return b.colDef.name === a
            });
            return b.length > 0 ? b[0] : null
        },
        p.prototype.getColDef = function(a) {
            var b = this.options.columnDefs.filter(function(b) {
                return b.name === a
            });
            return b.length > 0 ? b[0] : null
        },
        p.prototype.assignTypes = function() {
            var a = this;
            a.options.columnDefs.forEach(function(b, c) {
                if (!b.type) {
                    var e = new g(b, c, a),
                    f = a.rows.length > 0 ? a.rows[0] : null;
                    f ? b.type = d.guessType(a.getCellValue(f, e)) : b.type = "string"
                }
            })
        },
        p.prototype.isRowHeaderColumn = function(a) {
            return - 1 !== this.rowHeaderColumns.indexOf(a)
        },
        p.prototype.addRowHeaderColumn = function(a) {
            var b = this,
            c = new g(a, d.nextUid(), b);
            c.isRowHeader = !0,
            b.isRTL() ? (b.createRightContainer(), c.renderContainer = "right") : (b.createLeftContainer(), c.renderContainer = "left"),
            b.columnBuilders[0](a, c, b.options).then(function() {
                c.enableFiltering = !1,
                c.enableSorting = !1,
                c.enableHiding = !1,
                b.rowHeaderColumns.push(c),
                b.buildColumns().then(function() {
                    b.preCompileCellTemplates(),
                    b.queueGridRefresh()
                })
            })
        },
        p.prototype.getOnlyDataColumns = function() {
            var a = this,
            b = [];
            return a.columns.forEach(function(c) { - 1 === a.rowHeaderColumns.indexOf(c) && b.push(c)
            }),
            b
        },
        p.prototype.buildColumns = function(b) {
            var c = {
                orderByColumnDefs: !1
            };
            angular.extend(c, b);
            var e, f = this,
            h = [],
            i = f.rowHeaderColumns.length;
            for (e = 0; e < f.columns.length; e++) f.getColDef(f.columns[e].name) || (f.columns.splice(e, 1), e--);
            if (f.rowHeaderColumns.forEach(function(a) {
                f.columns.unshift(a)
            }), f.options.columnDefs.forEach(function(a, b) {
                f.preprocessColDef(a);
                var c = f.getColumn(a.name);
                c ? c.updateColumnDef(a, !1) : (c = new g(a, d.nextUid(), f), f.columns.splice(b + i, 0, c)),
                f.columnBuilders.forEach(function(b) {
                    h.push(b.call(f, a, c, f.options))
                })
            }), c.orderByColumnDefs) {
                var j = f.columns.slice(0),
                k = Math.min(f.options.columnDefs.length, f.columns.length);
                for (e = 0; k > e; e++) f.columns[e + i].name !== f.options.columnDefs[e].name ? j[e + i] = f.getColumn(f.options.columnDefs[e].name) : j[e + i] = f.columns[e + i];
                f.columns.length = 0,
                Array.prototype.splice.apply(f.columns, [0, 0].concat(j))
            }
            return a.all(h).then(function() {
                f.rows.length > 0 && f.assignTypes()
            })
        },
        p.prototype.preCompileCellTemplates = function() {
            var a = this,
            c = function(c) {
                var d = c.cellTemplate.replace(e.MODEL_COL_FIELD, a.getQualifiedColField(c));
                d = d.replace(e.COL_FIELD, "grid.getCellValue(row, col)");
                var f = b(d);
                c.compiledElementFn = f,
                c.compiledElementFnDefer && c.compiledElementFnDefer.resolve(c.compiledElementFn)
            };
            this.columns.forEach(function(a) {
                a.cellTemplate ? c(a) : a.cellTemplatePromise && a.cellTemplatePromise.then(function() {
                    c(a)
                })
            })
        },
        p.prototype.getQualifiedColField = function(a) {
            return "row.entity." + d.preEval(a.field)
        },
        p.prototype.createLeftContainer = function() {
            this.hasLeftContainer() || (this.renderContainers.left = new l("left", this, {
                disableColumnOffset: !0
            }))
        },
        p.prototype.createRightContainer = function() {
            this.hasRightContainer() || (this.renderContainers.right = new l("right", this, {
                disableColumnOffset: !0
            }))
        },
        p.prototype.hasLeftContainer = function() {
            return void 0 !== this.renderContainers.left
        },
        p.prototype.hasRightContainer = function() {
            return void 0 !== this.renderContainers.right
        },
        p.prototype.preprocessColDef = function(a) {
            var b = this;
            if (!a.field && !a.name) throw new Error("colDef.name or colDef.field property is required");
            if (void 0 === a.name && void 0 !== a.field) {
                for (var c = a.field,
                d = 2; b.getColumn(c);) c = a.field + d.toString(),
                d++;
                a.name = c
            }
        },
        p.prototype.newInN = function(a, b, c, d) {
            for (var e = this,
            f = [], g = 0; g < b.length; g++) {
                for (var h = d ? b[g][d] : b[g], i = !1, j = 0; j < a.length; j++) {
                    var k = c ? a[j][c] : a[j];
                    if (e.options.rowEquality(h, k)) {
                        i = !0;
                        break
                    }
                }
                i || f.push(h)
            }
            return f
        },
        p.prototype.getRow = function(a, b) {
            var c = this;
            b = "undefined" == typeof b ? c.rows: b;
            var d = b.filter(function(b) {
                return c.options.rowEquality(b.entity, a)
            });
            return d.length > 0 ? d[0] : null
        },
        p.prototype.modifyRows = function(b) {
            var c = this,
            d = c.rows.slice(0),
            e = c.rowHashMap || c.createRowHashMap();
            c.rowHashMap = c.createRowHashMap(),
            c.rows.length = 0,
            b.forEach(function(a, b) {
                var f;
                f = c.options.enableRowHashing ? e.get(a) : c.getRow(a, d),
                f || (f = c.processRowBuilders(new h(a, b, c))),
                c.rows.push(f),
                c.rowHashMap.put(a, f)
            }),
            c.assignTypes();
            var f = a.when(c.processRowsProcessors(c.rows)).then(function(a) {
                return c.setVisibleRows(a)
            }),
            g = a.when(c.processColumnsProcessors(c.columns)).then(function(a) {
                return c.setVisibleColumns(a)
            });
            return a.all([f, g])
        },
        p.prototype.addRows = function(a) {
            for (var b = this,
            c = b.rows.length,
            d = 0; d < a.length; d++) {
                var e = b.processRowBuilders(new h(a[d], d + c, b));
                if (b.options.enableRowHashing) {
                    var f = b.rowHashMap.get(e.entity);
                    f && (f.row = e)
                }
                b.rows.push(e)
            }
        },
        p.prototype.processRowBuilders = function(a) {
            var b = this;
            return b.rowBuilders.forEach(function(c) {
                c.call(b, a, b.options)
            }),
            a
        },
        p.prototype.registerStyleComputation = function(a) {
            this.styleComputations.push(a)
        },
        p.prototype.registerRowsProcessor = function(a, b) {
            if (!angular.isFunction(a)) throw "Attempt to register non-function rows processor: " + a;
            this.rowsProcessors.push({
                processor: a,
                priority: b
            }),
            this.rowsProcessors.sort(function(a, b) {
                return a.priority - b.priority
            })
        },
        p.prototype.removeRowsProcessor = function(a) {
            var b = -1;
            this.rowsProcessors.forEach(function(c, d) {
                c.processor === a && (b = d)
            }),
            -1 !== b && this.rowsProcessors.splice(b, 1)
        },
        p.prototype.processRowsProcessors = function(b) {
            function c(b, e) {
                var g = d.rowsProcessors[b].processor;
                return a.when(g.call(d, e, d.columns)).then(function(a) {
                    if (!a) throw "Processor at index " + b + " did not return a set of renderable rows";
                    if (!angular.isArray(a)) throw "Processor at index " + b + " did not return an array";
                    return b++,
                    b <= d.rowsProcessors.length - 1 ? c(b, a) : void f.resolve(a)
                })
            }
            var d = this,
            e = b.slice(0);
            if (0 === d.rowsProcessors.length) return a.when(e);
            var f = a.defer();
            return c(0, e),
            f.promise
        },
        p.prototype.setVisibleRows = function(a) {
            var b = this;
            for (var c in b.renderContainers) {
                var d = b.renderContainers[c];
                d.canvasHeightShouldUpdate = !0,
                "undefined" == typeof d.visibleRowCache ? d.visibleRowCache = [] : d.visibleRowCache.length = 0
            }
            for (var e = 0; e < a.length; e++) {
                var f = a[e],
                g = "undefined" != typeof f.renderContainer && f.renderContainer ? f.renderContainer: "body";
                f.visible && b.renderContainers[g].visibleRowCache.push(f)
            }
            b.api.core.raise.rowsRendered(this.api)
        },
        p.prototype.registerColumnsProcessor = function(a, b) {
            if (!angular.isFunction(a)) throw "Attempt to register non-function rows processor: " + a;
            this.columnsProcessors.push({
                processor: a,
                priority: b
            }),
            this.columnsProcessors.sort(function(a, b) {
                return a.priority - b.priority
            })
        },
        p.prototype.removeColumnsProcessor = function(a) {
            var b = this.columnsProcessors.indexOf(a);
            "undefined" != typeof b && void 0 !== b && this.columnsProcessors.splice(b, 1)
        },
        p.prototype.processColumnsProcessors = function(b) {
            function c(b, g) {
                var h = d.columnsProcessors[b].processor;
                return a.when(h.call(d, g, d.rows)).then(function(a) {
                    if (!a) throw "Processor at index " + b + " did not return a set of renderable rows";
                    if (!angular.isArray(a)) throw "Processor at index " + b + " did not return an array";
                    return b++,
                    b <= d.columnsProcessors.length - 1 ? c(b, e) : void f.resolve(e)
                })
            }
            var d = this,
            e = b.slice(0);
            if (0 === d.columnsProcessors.length) return a.when(e);
            var f = a.defer();
            return c(0, e),
            f.promise
        },
        p.prototype.setVisibleColumns = function(a) {
            var b = this;
            for (var c in b.renderContainers) {
                var d = b.renderContainers[c];
                d.visibleColumnCache.length = 0
            }
            for (var e = 0; e < a.length; e++) {
                var f = a[e];
                f.visible && ("undefined" != typeof f.renderContainer && f.renderContainer ? b.renderContainers[f.renderContainer].visibleColumnCache.push(f) : b.renderContainers.body.visibleColumnCache.push(f))
            }
        },
        p.prototype.handleWindowResize = function(a) {
            var b = this;
            return b.gridWidth = d.elementWidth(b.element),
            b.gridHeight = d.elementHeight(b.element),
            b.queueRefresh()
        },
        p.prototype.queueRefresh = function() {
            var a = this;
            return a.refreshCanceller && m.cancel(a.refreshCanceller),
            a.refreshCanceller = m(function() {
                a.refreshCanvas(!0)
            }),
            a.refreshCanceller.then(function() {
                a.refreshCanceller = null
            }),
            a.refreshCanceller
        },
        p.prototype.queueGridRefresh = function() {
            var a = this;
            return a.gridRefreshCanceller && m.cancel(a.gridRefreshCanceller),
            a.gridRefreshCanceller = m(function() {
                a.refresh(!0)
            }),
            a.gridRefreshCanceller.then(function() {
                a.gridRefreshCanceller = null
            }),
            a.gridRefreshCanceller
        },
        p.prototype.updateCanvasHeight = function() {
            var a = this;
            for (var b in a.renderContainers) if (a.renderContainers.hasOwnProperty(b)) {
                var c = a.renderContainers[b];
                c.canvasHeightShouldUpdate = !0
            }
        },
        p.prototype.buildStyles = function() {
            var a = this;
            a.customStyles = "",
            a.styleComputations.sort(function(a, b) {
                return null === a.priority ? 1 : null === b.priority ? -1 : null === a.priority && null === b.priority ? 0 : a.priority - b.priority
            }).forEach(function(b) {
                var c = b.func.call(a);
                angular.isString(c) && (a.customStyles += "\n" + c)
            })
        },
        p.prototype.minColumnsToRender = function() {
            var a = this,
            b = this.getViewportWidth(),
            c = 0,
            d = 0;
            return a.columns.forEach(function(e, f) {
                if (b > d) d += e.drawnWidth,
                c++;
                else {
                    for (var g = 0,
                    h = f; h >= f - c; h--) g += a.columns[h].drawnWidth;
                    b > g && c++
                }
            }),
            c
        },
        p.prototype.getBodyHeight = function() {
            var a = this.getViewportHeight();
            return a
        },
        p.prototype.getViewportHeight = function() {
            var a = this,
            b = this.gridHeight - this.headerHeight - this.footerHeight,
            c = a.getViewportAdjustment();
            return b += c.height
        },
        p.prototype.getViewportWidth = function() {
            var a = this,
            b = this.gridWidth,
            c = a.getViewportAdjustment();
            return b += c.width
        },
        p.prototype.getHeaderViewportWidth = function() {
            var a = this.getViewportWidth();
            return a
        },
        p.prototype.addVerticalScrollSync = function(a, b) {
            this.verticalScrollSyncCallBackFns[a] = b
        },
        p.prototype.addHorizontalScrollSync = function(a, b) {
            this.horizontalScrollSyncCallBackFns[a] = b
        },
        p.prototype.scrollContainers = function(a, b) {
            if (b.y) {
                var c = ["body", "left", "right"];
                this.flagScrollingVertically(b),
                "body" === a ? c = ["left", "right"] : "left" === a ? c = ["body", "right"] : "right" === a && (c = ["body", "left"]);
                for (var d = 0; d < c.length; d++) {
                    var e = c[d];
                    this.verticalScrollSyncCallBackFns[e] && this.verticalScrollSyncCallBackFns[e](b)
                }
            }
            if (b.x) {
                var f = ["body", "bodyheader", "bodyfooter"];
                this.flagScrollingHorizontally(b),
                "body" === a && (f = ["bodyheader", "bodyfooter"]);
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    this.horizontalScrollSyncCallBackFns[h] && this.horizontalScrollSyncCallBackFns[h](b)
                }
            }
        },
        p.prototype.registerViewportAdjuster = function(a) {
            this.viewportAdjusters.push(a)
        },
        p.prototype.removeViewportAdjuster = function(a) {
            var b = this.viewportAdjusters.indexOf(a);
            "undefined" != typeof b && void 0 !== b && this.viewportAdjusters.splice(b, 1)
        },
        p.prototype.getViewportAdjustment = function() {
            var a = this,
            b = {
                height: 0,
                width: 0
            };
            return a.viewportAdjusters.forEach(function(a) {
                b = a.call(this, b)
            }),
            b
        },
        p.prototype.getVisibleRowCount = function() {
            return this.renderContainers.body.visibleRowCache.length
        },
        p.prototype.getVisibleRows = function() {
            return this.renderContainers.body.visibleRowCache
        },
        p.prototype.getVisibleColumnCount = function() {
            return this.renderContainers.body.visibleColumnCache.length
        },
        p.prototype.searchRows = function(a) {
            return k.search(this, a, this.columns)
        },
        p.prototype.sortByColumn = function(a) {
            return j.sort(this, a, this.columns)
        },
        p.prototype.getCellValue = function(a, b) {
            return "undefined" != typeof a.entity["$$" + b.uid] ? a.entity["$$" + b.uid].rendered: this.options.flatEntityAccess && "undefined" != typeof b.field ? a.entity[b.field] : (b.cellValueGetterCache || (b.cellValueGetterCache = c(a.getEntityQualifiedColField(b))), b.cellValueGetterCache(a))
        },
        p.prototype.getCellDisplayValue = function(a, b) {
            if (!b.cellDisplayGetterCache) {
                var d = b.cellFilter ? " | " + b.cellFilter: "";
                "undefined" != typeof a.entity["$$" + b.uid] ? b.cellDisplayGetterCache = c(a.entity["$$" + b.uid].rendered + d) : this.options.flatEntityAccess && "undefined" != typeof b.field ? b.cellDisplayGetterCache = c(a.entity[b.field] + d) : b.cellDisplayGetterCache = c(a.getEntityQualifiedColField(b) + d)
            }
            return b.cellDisplayGetterCache(a)
        },
        p.prototype.getNextColumnSortPriority = function() {
            var a = this,
            b = 0;
            return a.columns.forEach(function(a) {
                a.sort && a.sort.priority && a.sort.priority > b && (b = a.sort.priority)
            }),
            b + 1
        },
        p.prototype.resetColumnSorting = function(a) {
            var b = this;
            b.columns.forEach(function(b) {
                b === a || b.suppressRemoveSort || (b.sort = {})
            })
        },
        p.prototype.getColumnSorting = function() {
            var a, b = this,
            c = [];
            return a = b.columns.slice(0),
            a.sort(j.prioritySort).forEach(function(a) {
                a.sort && "undefined" != typeof a.sort.direction && a.sort.direction && (a.sort.direction === e.ASC || a.sort.direction === e.DESC) && c.push(a)
            }),
            c
        },
        p.prototype.sortColumn = function(b, c, d) {
            var e = this,
            f = null;
            if ("undefined" == typeof b || !b) throw new Error("No column parameter provided");
            if ("boolean" == typeof c ? d = c: f = c, d ? b.sort.priority || (b.sort.priority = e.getNextColumnSortPriority()) : (e.resetColumnSorting(b), b.sort.priority = 0, b.sort.priority = e.getNextColumnSortPriority()), f) b.sort.direction = f;
            else {
                var g = b.sortDirectionCycle.indexOf(b.sort.direction ? b.sort.direction: null);
                g = (g + 1) % b.sortDirectionCycle.length,
                b.colDef && b.suppressRemoveSort && !b.sortDirectionCycle[g] && (g = (g + 1) % b.sortDirectionCycle.length),
                b.sortDirectionCycle[g] ? b.sort.direction = b.sortDirectionCycle[g] : b.sort = {}
            }
            return e.api.core.raise.sortChanged(e, e.getColumnSorting()),
            a.when(b)
        },
        p.prototype.renderingComplete = function() {
            angular.isFunction(this.options.onRegisterApi) && this.options.onRegisterApi(this.api),
            this.api.core.raise.renderingComplete(this.api)
        },
        p.prototype.createRowHashMap = function() {
            var a = this,
            b = new o;
            return b.grid = a,
            b
        },
        p.prototype.refresh = function(b) {
            var c = this,
            d = c.processRowsProcessors(c.rows).then(function(a) {
                c.setVisibleRows(a)
            }),
            e = c.processColumnsProcessors(c.columns).then(function(a) {
                c.setVisibleColumns(a)
            });
            return a.all([d, e]).then(function() {
                c.redrawInPlace(b),
                c.refreshCanvas(!0)
            })
        },
        p.prototype.refreshRows = function() {
            var a = this;
            return a.processRowsProcessors(a.rows).then(function(b) {
                a.setVisibleRows(b),
                a.redrawInPlace(),
                a.refreshCanvas(!0)
            })
        },
        p.prototype.refreshCanvas = function(b) {
            var c = this;
            b && c.buildStyles();
            var e = a.defer(),
            f = [];
            for (var g in c.renderContainers) if (c.renderContainers.hasOwnProperty(g)) {
                var h = c.renderContainers[g];
                if (null === h.canvasWidth || isNaN(h.canvasWidth)) continue; (h.header || h.headerCanvas) && (h.explicitHeaderHeight = h.explicitHeaderHeight || null, h.explicitHeaderCanvasHeight = h.explicitHeaderCanvasHeight || null, f.push(h))
            }
            return f.length > 0 ? (b && c.buildStyles(), m(function() {
                var a, g, h = !1,
                i = 0,
                j = 0,
                k = function(a, b) {
                    return a !== b && (h = !0),
                    b
                };
                for (a = 0; a < f.length; a++) if (g = f[a], null !== g.canvasWidth && !isNaN(g.canvasWidth)) {
                    if (g.header) {
                        var l = g.headerHeight = k(g.headerHeight, parseInt(d.outerElementHeight(g.header), 10)),
                        m = d.getBorderSize(g.header, "top"),
                        n = d.getBorderSize(g.header, "bottom"),
                        o = parseInt(l - m - n, 10);
                        o = 0 > o ? 0 : o,
                        g.innerHeaderHeight = o,
                        !g.explicitHeaderHeight && o > i && (i = o)
                    }
                    if (g.headerCanvas) {
                        var p = g.headerCanvasHeight = k(g.headerCanvasHeight, parseInt(d.outerElementHeight(g.headerCanvas), 10)); ! g.explicitHeaderCanvasHeight && p > j && (j = p)
                    }
                }
                for (a = 0; a < f.length; a++) g = f[a],
                i > 0 && "undefined" != typeof g.headerHeight && null !== g.headerHeight && (g.explicitHeaderHeight || g.headerHeight < i) && (g.explicitHeaderHeight = k(g.explicitHeaderHeight, i)),
                j > 0 && "undefined" != typeof g.headerCanvasHeight && null !== g.headerCanvasHeight && (g.explicitHeaderCanvasHeight || g.headerCanvasHeight < j) && (g.explicitHeaderCanvasHeight = k(g.explicitHeaderCanvasHeight, j));
                b && h && c.buildStyles(),
                e.resolve()
            })) : m(function() {
                e.resolve()
            }),
            e.promise
        },
        p.prototype.redrawInPlace = function(a) {
            var b = this;
            for (var c in b.renderContainers) {
                var d = b.renderContainers[c];
                a ? (d.adjustRows(d.prevScrollTop, null), d.adjustColumns(d.prevScrollLeft, null)) : (d.adjustRows(null, d.prevScrolltopPercentage), d.adjustColumns(null, d.prevScrollleftPercentage))
            }
        },
        p.prototype.hasLeftContainerColumns = function() {
            return this.hasLeftContainer() && this.renderContainers.left.renderedColumns.length > 0
        },
        p.prototype.hasRightContainerColumns = function() {
            return this.hasRightContainer() && this.renderContainers.right.renderedColumns.length > 0
        },
        p.prototype.scrollToIfNecessary = function(b, c) {
            var d = this,
            e = new n(d, "uiGrid.scrollToIfNecessary"),
            f = d.renderContainers.body.visibleRowCache,
            g = d.renderContainers.body.visibleColumnCache,
            h = d.renderContainers.body.prevScrollTop + d.headerHeight;
            h = 0 > h ? 0 : h;
            var i = d.renderContainers.body.prevScrollLeft,
            j = d.renderContainers.body.prevScrollTop + d.gridHeight - d.renderContainers.body.headerHeight - d.footerHeight - d.scrollbarWidth,
            k = d.renderContainers.body.prevScrollLeft + Math.ceil(d.renderContainers.body.getViewportWidth());
            if (null !== b) {
                var l = f.indexOf(b),
                m = d.renderContainers.body.getCanvasHeight() - d.renderContainers.body.getViewportHeight(),
                o = l * d.options.rowHeight + d.headerHeight;
                o = 0 > o ? 0 : o;
                var p, q;
                h > o ? (p = d.renderContainers.body.prevScrollTop - (h - o), q = p / m, e.y = {
                    percentage: q
                }) : o > j && (p = o - j + d.renderContainers.body.prevScrollTop, q = p / m, e.y = {
                    percentage: q
                })
            }
            if (null !== c) {
                for (var r = g.indexOf(c), s = d.renderContainers.body.getCanvasWidth() - d.renderContainers.body.getViewportWidth(), t = 0, u = 0; r > u; u++) {
                    var v = g[u];
                    t += v.drawnWidth
                }
                t = 0 > t ? 0 : t;
                var w = t + c.drawnWidth;
                w = 0 > w ? 0 : w;
                var x, y;
                i > t ? (x = d.renderContainers.body.prevScrollLeft - (i - t), y = x / s, y = y > 1 ? 1 : y, e.x = {
                    percentage: y
                }) : w > k && (x = w - k + d.renderContainers.body.prevScrollLeft, y = x / s, y = y > 1 ? 1 : y, e.x = {
                    percentage: y
                })
            }
            var z = a.defer();
            if (e.y || e.x) {
                e.withDelay = !1,
                d.scrollContainers("", e);
                var A = d.api.core.on.scrollEnd(null,
                function() {
                    z.resolve(e),
                    A()
                })
            } else z.resolve();
            return z.promise
        },
        p.prototype.scrollTo = function(a, b) {
            var c = null,
            d = null;
            return null !== a && "undefined" != typeof a && (c = this.getRow(a)),
            null !== b && "undefined" != typeof b && (d = this.getColumn(b.name ? b.name: b.field)),
            this.scrollToIfNecessary(c, d)
        },
        p.prototype.clearAllFilters = function(a, b, c) {
            return void 0 === a && (a = !0),
            void 0 === b && (b = !1),
            void 0 === c && (c = !1),
            this.columns.forEach(function(a) {
                a.filters.forEach(function(a) {
                    a.term = void 0,
                    b && (a.condition = void 0),
                    c && (a.flags = void 0)
                })
            }),
            a ? this.refreshRows() : void 0
        },
        o.prototype = {
            put: function(a, b) {
                this[this.grid.options.rowIdentity(a)] = b
            },
            get: function(a) {
                return this[this.grid.options.rowIdentity(a)]
            },
            remove: function(a) {
                var b = this[a = this.grid.options.rowIdentity(a)];
                return delete this[a],
                b
            }
        },
        p
    }])
} (),
function() {
    angular.module("ui.grid").factory("GridApi", ["$q", "$rootScope", "gridUtil", "uiGridConstants", "GridRow", "uiGridGridMenuService",
    function(a, b, c, d, e, f) {
        function g(a, c, d, e) {
            return b.$on(a,
            function(a) {
                var b = Array.prototype.slice.call(arguments);
                b.splice(0, 1),
                c.apply(e ? e: d.api, b)
            })
        }
        var h = function(a) {
            this.grid = a,
            this.listeners = [],
            this.registerEvent("core", "renderingComplete"),
            this.registerEvent("core", "filterChanged"),
            this.registerMethod("core", "setRowInvisible", e.prototype.setRowInvisible),
            this.registerMethod("core", "clearRowInvisible", e.prototype.clearRowInvisible),
            this.registerMethod("core", "getVisibleRows", this.grid.getVisibleRows),
            this.registerEvent("core", "rowsVisibleChanged"),
            this.registerEvent("core", "rowsRendered"),
            this.registerEvent("core", "scrollBegin"),
            this.registerEvent("core", "scrollEnd"),
            this.registerEvent("core", "canvasHeightChanged")
        };
        return h.prototype.suppressEvents = function(a, b) {
            var c = this,
            d = angular.isArray(a) ? a: [a],
            e = c.listeners.filter(function(a) {
                return d.some(function(b) {
                    return a.handler === b
                })
            });
            e.forEach(function(a) {
                a.dereg()
            }),
            b(),
            e.forEach(function(a) {
                a.dereg = g(a.eventId, a.handler, c.grid, a._this)
            })
        },
        h.prototype.registerEvent = function(a, d) {
            var e = this;
            e[a] || (e[a] = {});
            var f = e[a];
            f.on || (f.on = {},
            f.raise = {});
            var h = e.grid.id + a + d;
            f.raise[d] = function() {
                b.$emit.apply(b, [h].concat(Array.prototype.slice.call(arguments)))
            },
            f.on[d] = function(b, f, i) {
                if (null !== b && "undefined" == typeof b.$on) return void c.logError("asked to listen on " + a + ".on." + d + " but scope wasn't passed in the input parameters.  It is legitimate to pass null, but you've passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering");
                var j = g(h, f, e.grid, i),
                k = {
                    handler: f,
                    dereg: j,
                    eventId: h,
                    scope: b,
                    _this: i
                };
                e.listeners.push(k);
                var l = function() {
                    k.dereg();
                    var a = e.listeners.indexOf(k);
                    e.listeners.splice(a, 1);
                };
                return b && b.$on("$destroy",
                function() {
                    l()
                }),
                l
            }
        },
        h.prototype.registerEventsFromObject = function(a) {
            var b = this,
            c = [];
            angular.forEach(a,
            function(a, b) {
                var d = {
                    name: b,
                    events: []
                };
                angular.forEach(a,
                function(a, b) {
                    d.events.push(b)
                }),
                c.push(d)
            }),
            c.forEach(function(a) {
                a.events.forEach(function(c) {
                    b.registerEvent(a.name, c)
                })
            })
        },
        h.prototype.registerMethod = function(a, b, d, e) {
            this[a] || (this[a] = {});
            var f = this[a];
            f[b] = c.createBoundedWrapper(e || this.grid, d)
        },
        h.prototype.registerMethodsFromObject = function(a, b) {
            var c = this,
            d = [];
            angular.forEach(a,
            function(a, b) {
                var c = {
                    name: b,
                    methods: []
                };
                angular.forEach(a,
                function(a, b) {
                    c.methods.push({
                        name: b,
                        fn: a
                    })
                }),
                d.push(c)
            }),
            d.forEach(function(a) {
                a.methods.forEach(function(d) {
                    c.registerMethod(a.name, d.name, d.fn, b)
                })
            })
        },
        h
    }])
} (),
function() {
    angular.module("ui.grid").factory("GridColumn", ["gridUtil", "uiGridConstants", "i18nService",
    function(a, b, c) {
        function d(a, c, d) {
            var e = this;
            e.grid = d,
            e.uid = c,
            e.updateColumnDef(a, !0),
            e.aggregationValue = void 0,
            e.updateAggregationValue = function() {
                if (!e.aggregationType) return void(e.aggregationValue = void 0);
                var a = 0,
                c = e.grid.getVisibleRows(),
                d = function() {
                    var a = [];
                    return c.forEach(function(b) {
                        var c = e.grid.getCellValue(b, e),
                        d = Number(c);
                        isNaN(d) || a.push(d)
                    }),
                    a
                };
                angular.isFunction(e.aggregationType) ? e.aggregationValue = e.aggregationType(c, e) : e.aggregationType === b.aggregationTypes.count ? e.aggregationValue = e.grid.getVisibleRowCount() : e.aggregationType === b.aggregationTypes.sum ? (d().forEach(function(b) {
                    a += b
                }), e.aggregationValue = a) : e.aggregationType === b.aggregationTypes.avg ? (d().forEach(function(b) {
                    a += b
                }), a /= d().length, e.aggregationValue = a) : e.aggregationType === b.aggregationTypes.min ? e.aggregationValue = Math.min.apply(null, d()) : e.aggregationType === b.aggregationTypes.max ? e.aggregationValue = Math.max.apply(null, d()) : e.aggregationValue = " "
            },
            this.getAggregationValue = function() {
                return e.aggregationValue
            }
        }
        return d.prototype.hideColumn = function() {
            this.colDef.visible = !1
        },
        d.prototype.setPropertyOrDefault = function(a, b, c) {
            var d = this;
            "undefined" != typeof a[b] && a[b] ? d[b] = a[b] : "undefined" != typeof d[b] ? d[b] = d[b] : d[b] = c ? c: {}
        },
        d.prototype.updateColumnDef = function(c, d) {
            var e = this;
            if (e.colDef = c, void 0 === c.name) throw new Error("colDef.name is required for column at index " + e.grid.options.columnDefs.indexOf(c));
            if (e.displayName = void 0 === c.displayName ? a.readableColumnName(c.name) : c.displayName, !angular.isNumber(e.width) || !e.hasCustomWidth || c.allowCustomWidthOverride) {
                var f = c.width,
                g = "Cannot parse column width '" + f + "' for column named '" + c.name + "'";
                if (e.hasCustomWidth = !1, angular.isString(f) || angular.isNumber(f)) if (angular.isString(f)) if (a.endsWith(f, "%")) {
                    var h = f.replace(/%/g, ""),
                    i = parseInt(h, 10);
                    if (isNaN(i)) throw new Error(g);
                    e.width = f
                } else if (f.match(/^(\d+)$/)) e.width = parseInt(f.match(/^(\d+)$/)[1], 10);
                else {
                    if (!f.match(/^\*+$/)) throw new Error(g);
                    e.width = f
                } else e.width = f;
                else e.width = "*"
            } ["minWidth", "maxWidth"].forEach(function(a) {
                var b = c[a],
                d = "Cannot parse column " + a + " '" + b + "' for column named '" + c.name + "'";
                if (angular.isString(b) || angular.isNumber(b)) if (angular.isString(b)) {
                    if (!b.match(/^(\d+)$/)) throw new Error(d);
                    e[a] = parseInt(b.match(/^(\d+)$/)[1], 10)
                } else e[a] = b;
                else e[a] = "minWidth" === a ? 30 : 9e3
            }),
            e.field = void 0 === c.field ? c.name: c.field,
            "string" != typeof e.field && a.logError("Field is not a string, this is likely to break the code, Field is: " + e.field),
            e.name = c.name,
            e.displayName = void 0 === c.displayName ? a.readableColumnName(c.name) : c.displayName,
            e.aggregationType = angular.isDefined(c.aggregationType) ? c.aggregationType: null,
            e.footerCellTemplate = angular.isDefined(c.footerCellTemplate) ? c.footerCellTemplate: null,
            "undefined" == typeof c.cellTooltip || c.cellTooltip === !1 ? e.cellTooltip = !1 : c.cellTooltip === !0 ? e.cellTooltip = function(a, b) {
                return e.grid.getCellValue(a, b)
            }: "function" == typeof c.cellTooltip ? e.cellTooltip = c.cellTooltip: e.cellTooltip = function(a, b) {
                return b.colDef.cellTooltip
            },
            "undefined" == typeof c.headerTooltip || c.headerTooltip === !1 ? e.headerTooltip = !1 : c.headerTooltip === !0 ? e.headerTooltip = function(a) {
                return a.displayName
            }: "function" == typeof c.headerTooltip ? e.headerTooltip = c.headerTooltip: e.headerTooltip = function(a) {
                return a.colDef.headerTooltip
            },
            e.footerCellClass = c.footerCellClass,
            e.cellClass = c.cellClass,
            e.headerCellClass = c.headerCellClass,
            e.cellFilter = c.cellFilter ? c.cellFilter: "",
            e.sortCellFiltered = c.sortCellFiltered ? !0 : !1,
            e.filterCellFiltered = c.filterCellFiltered ? !0 : !1,
            e.headerCellFilter = c.headerCellFilter ? c.headerCellFilter: "",
            e.footerCellFilter = c.footerCellFilter ? c.footerCellFilter: "",
            e.visible = a.isNullOrUndefined(c.visible) || c.visible,
            e.headerClass = c.headerClass,
            e.enableSorting = "undefined" != typeof c.enableSorting ? c.enableSorting: !0,
            e.sortingAlgorithm = c.sortingAlgorithm,
            e.sortDirectionCycle = "undefined" != typeof c.sortDirectionCycle ? c.sortDirectionCycle: [null, b.ASC, b.DESC],
            "undefined" == typeof e.suppressRemoveSort && (e.suppressRemoveSort = "undefined" != typeof c.suppressRemoveSort ? c.suppressRemoveSort: !1),
            e.enableFiltering = "undefined" != typeof c.enableFiltering ? c.enableFiltering: !0,
            e.setPropertyOrDefault(c, "menuItems", []),
            d && e.setPropertyOrDefault(c, "sort");
            var j = [];
            c.filter ? j.push(c.filter) : c.filters ? j = c.filters: j.push({}),
            d ? (e.setPropertyOrDefault(c, "filter"), e.setPropertyOrDefault(c, "filters", j)) : e.filters.length === j.length && e.filters.forEach(function(a, b) {
                "undefined" != typeof j[b].placeholder && (a.placeholder = j[b].placeholder),
                "undefined" != typeof j[b].ariaLabel && (a.ariaLabel = j[b].ariaLabel),
                "undefined" != typeof j[b].flags && (a.flags = j[b].flags),
                "undefined" != typeof j[b].type && (a.type = j[b].type),
                "undefined" != typeof j[b].selectOptions && (a.selectOptions = j[b].selectOptions)
            })
        },
        d.prototype.unsort = function() {
            this.sort = {},
            this.grid.api.core.raise.sortChanged(this.grid, this.grid.getColumnSorting())
        },
        d.prototype.getColClass = function(a) {
            var c = b.COL_CLASS_PREFIX + this.uid;
            return a ? "." + c: c
        },
        d.prototype.isPinnedLeft = function() {
            return "left" === this.renderContainer
        },
        d.prototype.isPinnedRight = function() {
            return "right" === this.renderContainer
        },
        d.prototype.getColClassDefinition = function() {
            return " .grid" + this.grid.id + " " + this.getColClass(!0) + " { min-width: " + this.drawnWidth + "px; max-width: " + this.drawnWidth + "px; }"
        },
        d.prototype.getRenderContainer = function() {
            var a = this,
            b = a.renderContainer;
            return (null === b || "" === b || void 0 === b) && (b = "body"),
            a.grid.renderContainers[b]
        },
        d.prototype.showColumn = function() {
            this.colDef.visible = !0
        },
        d.prototype.getAggregationText = function() {
            var a = this;
            if (a.colDef.aggregationHideLabel) return "";
            if (a.colDef.aggregationLabel) return a.colDef.aggregationLabel;
            switch (a.colDef.aggregationType) {
            case b.aggregationTypes.count:
                return c.getSafeText("aggregation.count");
            case b.aggregationTypes.sum:
                return c.getSafeText("aggregation.sum");
            case b.aggregationTypes.avg:
                return c.getSafeText("aggregation.avg");
            case b.aggregationTypes.min:
                return c.getSafeText("aggregation.min");
            case b.aggregationTypes.max:
                return c.getSafeText("aggregation.max");
            default:
                return ""
            }
        },
        d.prototype.getCellTemplate = function() {
            var a = this;
            return a.cellTemplatePromise
        },
        d.prototype.getCompiledElementFn = function() {
            var a = this;
            return a.compiledElementFnDefer.promise
        },
        d
    }])
} (),
function() {
    angular.module("ui.grid").factory("GridOptions", ["gridUtil", "uiGridConstants",
    function(a, b) {
        return {
            initialize: function(c) {
                return c.onRegisterApi = c.onRegisterApi || angular.noop(),
                c.data = c.data || [],
                c.columnDefs = c.columnDefs || [],
                c.excludeProperties = c.excludeProperties || ["$$hashKey"],
                c.enableRowHashing = c.enableRowHashing !== !1,
                c.rowIdentity = c.rowIdentity ||
                function(b) {
                    return a.hashKey(b)
                },
                c.getRowIdentity = c.getRowIdentity ||
                function(a) {
                    return a.$$hashKey
                },
                c.flatEntityAccess = c.flatEntityAccess === !0,
                c.showHeader = "undefined" != typeof c.showHeader ? c.showHeader: !0,
                c.showHeader ? c.headerRowHeight = "undefined" != typeof c.headerRowHeight ? c.headerRowHeight: 30 : c.headerRowHeight = 0,
                c.rowHeight = c.rowHeight || 30,
                c.minRowsToShow = "undefined" != typeof c.minRowsToShow ? c.minRowsToShow: 10,
                c.showGridFooter = c.showGridFooter === !0,
                c.showColumnFooter = c.showColumnFooter === !0,
                c.columnFooterHeight = "undefined" != typeof c.columnFooterHeight ? c.columnFooterHeight: 30,
                c.gridFooterHeight = "undefined" != typeof c.gridFooterHeight ? c.gridFooterHeight: 30,
                c.columnWidth = "undefined" != typeof c.columnWidth ? c.columnWidth: 50,
                c.maxVisibleColumnCount = "undefined" != typeof c.maxVisibleColumnCount ? c.maxVisibleColumnCount: 200,
                c.virtualizationThreshold = "undefined" != typeof c.virtualizationThreshold ? c.virtualizationThreshold: 20,
                c.columnVirtualizationThreshold = "undefined" != typeof c.columnVirtualizationThreshold ? c.columnVirtualizationThreshold: 10,
                c.excessRows = "undefined" != typeof c.excessRows ? c.excessRows: 4,
                c.scrollThreshold = "undefined" != typeof c.scrollThreshold ? c.scrollThreshold: 4,
                c.excessColumns = "undefined" != typeof c.excessColumns ? c.excessColumns: 4,
                c.horizontalScrollThreshold = "undefined" != typeof c.horizontalScrollThreshold ? c.horizontalScrollThreshold: 2,
                c.aggregationCalcThrottle = "undefined" != typeof c.aggregationCalcThrottle ? c.aggregationCalcThrottle: 500,
                c.wheelScrollThrottle = "undefined" != typeof c.wheelScrollThrottle ? c.wheelScrollThrottle: 70,
                c.scrollDebounce = "undefined" != typeof c.scrollDebounce ? c.scrollDebounce: 300,
                c.enableSorting = c.enableSorting !== !1,
                c.enableFiltering = c.enableFiltering === !0,
                c.enableColumnMenus = c.enableColumnMenus !== !1,
                c.enableVerticalScrollbar = "undefined" != typeof c.enableVerticalScrollbar ? c.enableVerticalScrollbar: b.scrollbars.ALWAYS,
                c.enableHorizontalScrollbar = "undefined" != typeof c.enableHorizontalScrollbar ? c.enableHorizontalScrollbar: b.scrollbars.ALWAYS,
                c.enableMinHeightCheck = c.enableMinHeightCheck !== !1,
                c.minimumColumnSize = "undefined" != typeof c.minimumColumnSize ? c.minimumColumnSize: 10,
                c.rowEquality = c.rowEquality ||
                function(a, b) {
                    return a === b
                },
                c.headerTemplate = c.headerTemplate || null,
                c.footerTemplate = c.footerTemplate || "ui-grid/ui-grid-footer",
                c.gridFooterTemplate = c.gridFooterTemplate || "ui-grid/ui-grid-grid-footer",
                c.rowTemplate = c.rowTemplate || "ui-grid/ui-grid-row",
                c.appScopeProvider = c.appScopeProvider || null,
                c
            }
        }
    }])
} (),
function() {
    angular.module("ui.grid").factory("GridRenderContainer", ["gridUtil", "uiGridConstants",
    function(a, b) {
        function c(a, b, c) {
            var d = this;
            d.name = a,
            d.grid = b,
            d.visibleRowCache = [],
            d.visibleColumnCache = [],
            d.renderedRows = [],
            d.renderedColumns = [],
            d.prevScrollTop = 0,
            d.prevScrolltopPercentage = 0,
            d.prevRowScrollIndex = 0,
            d.prevScrollLeft = 0,
            d.prevScrollleftPercentage = 0,
            d.prevColumnScrollIndex = 0,
            d.columnStyles = "",
            d.viewportAdjusters = [],
            d.hasHScrollbar = !1,
            d.hasVScrollbar = !1,
            d.canvasHeightShouldUpdate = !0,
            d.$$canvasHeight = 0,
            c && angular.isObject(c) && angular.extend(d, c),
            b.registerStyleComputation({
                priority: 5,
                func: function() {
                    return d.updateColumnWidths(),
                    d.columnStyles
                }
            })
        }
        return c.prototype.reset = function() {
            this.visibleColumnCache.length = 0,
            this.visibleRowCache.length = 0,
            this.renderedRows.length = 0,
            this.renderedColumns.length = 0
        },
        c.prototype.containsColumn = function(a) {
            return - 1 !== this.visibleColumnCache.indexOf(a)
        },
        c.prototype.minRowsToRender = function() {
            for (var a = this,
            b = 0,
            c = 0,
            d = a.getViewportHeight(), e = a.visibleRowCache.length - 1; d > c && e >= 0; e--) c += a.visibleRowCache[e].height,
            b++;
            return b
        },
        c.prototype.minColumnsToRender = function() {
            for (var a = this,
            b = this.getViewportWidth(), c = 0, d = 0, e = 0; e < a.visibleColumnCache.length; e++) {
                var f = a.visibleColumnCache[e];
                if (b > d) d += f.drawnWidth ? f.drawnWidth: 0,
                c++;
                else {
                    for (var g = 0,
                    h = e; h >= e - c; h--) g += a.visibleColumnCache[h].drawnWidth ? a.visibleColumnCache[h].drawnWidth: 0;
                    b > g && c++
                }
            }
            return c
        },
        c.prototype.getVisibleRowCount = function() {
            return this.visibleRowCache.length
        },
        c.prototype.registerViewportAdjuster = function(a) {
            this.viewportAdjusters.push(a)
        },
        c.prototype.removeViewportAdjuster = function(a) {
            var b = this.viewportAdjusters.indexOf(a);
            b > -1 && this.viewportAdjusters.splice(b, 1)
        },
        c.prototype.getViewportAdjustment = function() {
            var a = this,
            b = {
                height: 0,
                width: 0
            };
            return a.viewportAdjusters.forEach(function(a) {
                b = a.call(this, b)
            }),
            b
        },
        c.prototype.getMargin = function(a) {
            var b = this,
            c = 0;
            return b.viewportAdjusters.forEach(function(b) {
                var d = b.call(this, {
                    height: 0,
                    width: 0
                });
                d.side && d.side === a && (c += -1 * d.width)
            }),
            c
        },
        c.prototype.getViewportHeight = function() {
            var a = this,
            b = a.headerHeight ? a.headerHeight: a.grid.headerHeight,
            c = a.grid.gridHeight - b - a.grid.footerHeight,
            d = a.getViewportAdjustment();
            return c += d.height
        },
        c.prototype.getViewportWidth = function() {
            var a = this,
            b = a.grid.gridWidth,
            c = a.getViewportAdjustment();
            return b += c.width
        },
        c.prototype.getHeaderViewportWidth = function() {
            var a = this.getViewportWidth();
            return a
        },
        c.prototype.getCanvasHeight = function() {
            var a = this;
            if (!a.canvasHeightShouldUpdate) return a.$$canvasHeight;
            var b = a.$$canvasHeight;
            return a.$$canvasHeight = 0,
            a.visibleRowCache.forEach(function(b) {
                a.$$canvasHeight += b.height
            }),
            a.canvasHeightShouldUpdate = !1,
            a.grid.api.core.raise.canvasHeightChanged(b, a.$$canvasHeight),
            a.$$canvasHeight
        },
        c.prototype.getVerticalScrollLength = function() {
            return this.getCanvasHeight() - this.getViewportHeight() + this.grid.scrollbarHeight
        },
        c.prototype.getCanvasWidth = function() {
            var a = this,
            b = a.canvasWidth;
            return b
        },
        c.prototype.setRenderedRows = function(a) {
            this.renderedRows.length = a.length;
            for (var b = 0; b < a.length; b++) this.renderedRows[b] = a[b]
        },
        c.prototype.setRenderedColumns = function(a) {
            this.renderedColumns.length = a.length;
            for (var b = 0; b < a.length; b++) this.renderedColumns[b] = a[b];
            this.updateColumnOffset()
        },
        c.prototype.updateColumnOffset = function() {
            for (var a = 0,
            b = 0; b < this.currentFirstColumn; b++) a += this.visibleColumnCache[b].drawnWidth;
            this.columnOffset = a
        },
        c.prototype.scrollVertical = function(a) {
            var c = -1;
            if (a !== this.prevScrollTop) {
                var d = a - this.prevScrollTop;
                d > 0 && (this.grid.scrollDirection = b.scrollDirection.DOWN),
                0 > d && (this.grid.scrollDirection = b.scrollDirection.UP);
                var e = this.getVerticalScrollLength();
                return c = a / e,
                c > 1 && (c = 1),
                0 > c && (c = 0),
                this.adjustScrollVertical(a, c),
                c
            }
        },
        c.prototype.scrollHorizontal = function(a) {
            var c = -1;
            if (a !== this.prevScrollLeft) {
                var d = a - this.prevScrollLeft;
                d > 0 && (this.grid.scrollDirection = b.scrollDirection.RIGHT),
                0 > d && (this.grid.scrollDirection = b.scrollDirection.LEFT);
                var e = this.canvasWidth - this.getViewportWidth();
                return c = 0 !== e ? a / e: 0,
                this.adjustScrollHorizontal(a, c),
                c
            }
        },
        c.prototype.adjustScrollVertical = function(a, b, c) { (this.prevScrollTop !== a || c) && (("undefined" == typeof a || void 0 === a || null === a) && (a = (this.getCanvasHeight() - this.getViewportHeight()) * b), this.adjustRows(a, b, !1), this.prevScrollTop = a, this.prevScrolltopPercentage = b, this.grid.queueRefresh())
        },
        c.prototype.adjustScrollHorizontal = function(a, b, c) { (this.prevScrollLeft !== a || c) && (("undefined" == typeof a || void 0 === a || null === a) && (a = (this.getCanvasWidth() - this.getViewportWidth()) * b), this.adjustColumns(a, b), this.prevScrollLeft = a, this.prevScrollleftPercentage = b, this.grid.queueRefresh())
        },
        c.prototype.adjustRows = function(a, b, c) {
            var d = this,
            e = d.minRowsToRender(),
            f = d.visibleRowCache,
            g = f.length - e;
            "undefined" != typeof b && null !== b || !a || (b = a / d.getVerticalScrollLength());
            var h = Math.ceil(Math.min(g, g * b));
            h > g && (h = g);
            var i = [];
            if (f.length > d.grid.options.virtualizationThreshold) {
                if ("undefined" != typeof a && null !== a) {
                    if (!d.grid.suppressParentScrollDown && d.prevScrollTop < a && h < d.prevRowScrollIndex + d.grid.options.scrollThreshold && g > h) return;
                    if (!d.grid.suppressParentScrollUp && d.prevScrollTop > a && h > d.prevRowScrollIndex - d.grid.options.scrollThreshold && g > h) return
                }
                var j = {},
                k = {};
                j = Math.max(0, h - d.grid.options.excessRows),
                k = Math.min(f.length, h + e + d.grid.options.excessRows),
                i = [j, k]
            } else {
                var l = d.visibleRowCache.length;
                i = [0, Math.max(l, e + d.grid.options.excessRows)]
            }
            d.updateViewableRowRange(i),
            d.prevRowScrollIndex = h
        },
        c.prototype.adjustColumns = function(a, b) {
            var c = this,
            d = c.minColumnsToRender(),
            e = c.visibleColumnCache,
            f = e.length - d;
            if (("undefined" == typeof b || null === b) && a) {
                var g = c.getCanvasWidth() - c.getViewportWidth();
                b = a / g
            }
            var h = Math.ceil(Math.min(f, f * b));
            h > f && (h = f);
            var i = [];
            if (e.length > c.grid.options.columnVirtualizationThreshold && c.getCanvasWidth() > c.getViewportWidth()) {
                var j = Math.max(0, h - c.grid.options.excessColumns),
                k = Math.min(e.length, h + d + c.grid.options.excessColumns);
                i = [j, k]
            } else {
                var l = c.visibleColumnCache.length;
                i = [0, Math.max(l, d + c.grid.options.excessColumns)]
            }
            c.updateViewableColumnRange(i),
            c.prevColumnScrollIndex = h
        },
        c.prototype.updateViewableRowRange = function(a) {
            var b = this.visibleRowCache.slice(a[0], a[1]);
            this.currentTopRow = a[0],
            this.setRenderedRows(b)
        },
        c.prototype.updateViewableColumnRange = function(a) {
            var b = this.visibleColumnCache.slice(a[0], a[1]);
            this.currentFirstColumn = a[0],
            this.setRenderedColumns(b)
        },
        c.prototype.headerCellWrapperStyle = function() {
            var a = this;
            if (0 !== a.currentFirstColumn) {
                var b = a.columnOffset;
                return a.grid.isRTL() ? {
                    "margin-right": b + "px"
                }: {
                    "margin-left": b + "px"
                }
            }
            return null
        },
        c.prototype.updateColumnWidths = function() {
            var b = this,
            c = [],
            d = 0,
            e = 0,
            f = "",
            g = b.grid.getViewportWidth() - b.grid.scrollbarWidth,
            h = [];
            angular.forEach(b.grid.renderContainers,
            function(a, b) {
                h = h.concat(a.visibleColumnCache)
            }),
            h.forEach(function(b, f) {
                var h = 0;
                b.visible && (angular.isNumber(b.width) ? (h = parseInt(b.width, 10), e += h, b.drawnWidth = h) : a.endsWith(b.width, "%") ? (h = parseInt(parseInt(b.width.replace(/%/g, ""), 10) / 100 * g), h > b.maxWidth && (h = b.maxWidth), h < b.minWidth && (h = b.minWidth), e += h, b.drawnWidth = h) : angular.isString(b.width) && -1 !== b.width.indexOf("*") && (d += b.width.length, c.push(b)))
            });
            var i = g - e;
            if (c.length > 0) {
                var j = i / d;
                c.forEach(function(a) {
                    var b = parseInt(a.width.length * j, 10);
                    b > a.maxWidth && (b = a.maxWidth),
                    b < a.minWidth && (b = a.minWidth),
                    e += b,
                    a.drawnWidth = b
                })
            }
            for (var k = function(a) {
                a.drawnWidth < a.maxWidth && l > 0 && (a.drawnWidth++, e++, l--, m = !0)
            },
            l = g - e, m = !0; l > 0 && m;) m = !1,
            c.forEach(k);
            var n = function(a) {
                a.drawnWidth > a.minWidth && o > 0 && (a.drawnWidth--, e--, o--, m = !0)
            },
            o = e - g;
            for (m = !0; o > 0 && m;) m = !1,
            c.forEach(n);
            var p = 0;
            b.visibleColumnCache.forEach(function(a) {
                a.visible && (p += a.drawnWidth)
            }),
            h.forEach(function(a) {
                f += a.getColClassDefinition()
            }),
            b.canvasWidth = p,
            this.columnStyles = f
        },
        c.prototype.needsHScrollbarPlaceholder = function() {
            return this.grid.options.enableHorizontalScrollbar && !this.hasHScrollbar && !this.grid.disableScrolling
        },
        c.prototype.getViewportStyle = function() {
            var a = this,
            c = {};
            return a.hasHScrollbar = !1,
            a.hasVScrollbar = !1,
            a.grid.disableScrolling ? (c["overflow-x"] = "hidden", c["overflow-y"] = "hidden", c) : ("body" === a.name ? (a.hasHScrollbar = a.grid.options.enableHorizontalScrollbar !== b.scrollbars.NEVER, a.grid.isRTL() ? a.grid.hasLeftContainerColumns() || (a.hasVScrollbar = a.grid.options.enableVerticalScrollbar !== b.scrollbars.NEVER) : a.grid.hasRightContainerColumns() || (a.hasVScrollbar = a.grid.options.enableVerticalScrollbar !== b.scrollbars.NEVER)) : "left" === a.name ? a.hasVScrollbar = a.grid.isRTL() ? a.grid.options.enableVerticalScrollbar !== b.scrollbars.NEVER: !1 : a.hasVScrollbar = a.grid.isRTL() ? !1 : a.grid.options.enableVerticalScrollbar !== b.scrollbars.NEVER, c["overflow-x"] = a.hasHScrollbar ? "scroll": "hidden", c["overflow-y"] = a.hasVScrollbar ? "scroll": "hidden", c)
        },
        c
    }])
} (),
function() {
    angular.module("ui.grid").factory("GridRow", ["gridUtil",
    function(a) {
        function b(b, c, d) {
            this.grid = d,
            this.entity = b,
            this.uid = a.nextUid(),
            this.visible = !0,
            this.$$height = d.options.rowHeight
        }
        return Object.defineProperty(b.prototype, "height", {
            get: function() {
                return this.$$height
            },
            set: function(a) {
                a !== this.$$height && (this.grid.updateCanvasHeight(), this.$$height = a)
            }
        }),
        b.prototype.getQualifiedColField = function(a) {
            return "row." + this.getEntityQualifiedColField(a)
        },
        b.prototype.getEntityQualifiedColField = function(b) {
            return a.preEval("entity." + b.field)
        },
        b.prototype.setRowInvisible = function(a) {
            a && a.setThisRowInvisible && a.setThisRowInvisible("user")
        },
        b.prototype.clearRowInvisible = function(a) {
            a && a.clearThisRowInvisible && a.clearThisRowInvisible("user")
        },
        b.prototype.setThisRowInvisible = function(a, b) {
            this.invisibleReason || (this.invisibleReason = {}),
            this.invisibleReason[a] = !0,
            this.evaluateRowVisibility(b)
        },
        b.prototype.clearThisRowInvisible = function(a, b) {
            "undefined" != typeof this.invisibleReason && delete this.invisibleReason[a],
            this.evaluateRowVisibility(b)
        },
        b.prototype.evaluateRowVisibility = function(a) {
            var b = !0;
            "undefined" != typeof this.invisibleReason && angular.forEach(this.invisibleReason,
            function(a, c) {
                a && (b = !1)
            }),
            ("undefined" == typeof this.visible || this.visible !== b) && (this.visible = b, a || (this.grid.queueGridRefresh(), this.grid.api.core.raise.rowsVisibleChanged(this)))
        },
        b
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").factory("GridRowColumn", ["$parse", "$filter",
    function(a, b) {
        var c = function d(a, b) {
            if (! (this instanceof d)) throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
            this.row = a,
            this.col = b
        };
        return c.prototype.getIntersectionValueRaw = function() {
            var b = a(this.row.getEntityQualifiedColField(this.col)),
            c = this.row;
            return b(c)
        },
        c.prototype.getIntersectionValueFiltered = function() {
            var a = this.getIntersectionValueRaw();
            if (this.col.cellFilter && "" !== this.col.cellFilter) {
                var c = function(a) {
                    try {
                        return b(a)
                    } catch(c) {
                        return null
                    }
                },
                d = c(this.col.cellFilter);
                if (d) a = d(a);
                else {
                    var e, f = /([^:]*):([^:]*):?([\s\S]+)?/;
                    null !== (e = f.exec(this.col.cellFilter)) && (a = b(e[1])(a, e[2], e[3]))
                }
            }
            return a
        },
        c
    }])
} (),
function() {
    angular.module("ui.grid").factory("ScrollEvent", ["gridUtil",
    function(a) {
        function b(b, c, d, e) {
            var f = this;
            if (!b) throw new Error("grid argument is required");
            f.grid = b,
            f.source = e,
            f.withDelay = !0,
            f.sourceRowContainer = c,
            f.sourceColContainer = d,
            f.newScrollLeft = null,
            f.newScrollTop = null,
            f.x = null,
            f.y = null,
            f.verticalScrollLength = -9999999,
            f.horizontalScrollLength = -999999,
            f.fireThrottledScrollingEvent = a.throttle(function(a) {
                f.grid.scrollContainers(a, f)
            },
            f.grid.options.wheelScrollThrottle, {
                trailing: !0
            })
        }
        return b.prototype.getNewScrollLeft = function(b, c) {
            var d = this;
            if (!d.newScrollLeft) {
                var e, f = b.getCanvasWidth() - b.getViewportWidth(),
                g = a.normalizeScrollLeft(c, d.grid);
                if ("undefined" != typeof d.x.percentage && void 0 !== d.x.percentage) e = d.x.percentage;
                else {
                    if ("undefined" == typeof d.x.pixels || void 0 === d.x.pixels) throw new Error("No percentage or pixel value provided for scroll event X axis");
                    e = d.x.percentage = (g + d.x.pixels) / f
                }
                return Math.max(0, e * f)
            }
            return d.newScrollLeft
        },
        b.prototype.getNewScrollTop = function(a, b) {
            var c = this;
            if (!c.newScrollTop) {
                var d, e = a.getVerticalScrollLength(),
                f = b[0].scrollTop;
                if ("undefined" != typeof c.y.percentage && void 0 !== c.y.percentage) d = c.y.percentage;
                else {
                    if ("undefined" == typeof c.y.pixels || void 0 === c.y.pixels) throw new Error("No percentage or pixel value provided for scroll event Y axis");
                    d = c.y.percentage = (f + c.y.pixels) / e
                }
                return Math.max(0, d * e)
            }
            return c.newScrollTop
        },
        b.prototype.atTop = function(a) {
            return this.y && (0 === this.y.percentage || this.verticalScrollLength < 0) && 0 === a
        },
        b.prototype.atBottom = function(a) {
            return this.y && (1 === this.y.percentage || 0 === this.verticalScrollLength) && a > 0
        },
        b.prototype.atLeft = function(a) {
            return this.x && (0 === this.x.percentage || this.horizontalScrollLength < 0) && 0 === a
        },
        b.prototype.atRight = function(a) {
            return this.x && (1 === this.x.percentage || 0 === this.horizontalScrollLength) && a > 0
        },
        b.Sources = {
            ViewPortScroll: "ViewPortScroll",
            RenderContainerMouseWheel: "RenderContainerMouseWheel",
            RenderContainerTouchMove: "RenderContainerTouchMove",
            Other: 99
        },
        b
    }])
} (),
function() {
    "use strict";
    angular.module("ui.grid").service("gridClassFactory", ["gridUtil", "$q", "$compile", "$templateCache", "uiGridConstants", "Grid", "GridColumn", "GridRow",
    function(a, b, c, d, e, f, g, h) {
        var i = {
            createGrid: function(d) {
                d = "undefined" != typeof d ? d: {},
                d.id = a.newId();
                var e = new f(d);
                if (e.options.rowTemplate) {
                    var g = b.defer();
                    e.getRowTemplateFn = g.promise,
                    a.getTemplate(e.options.rowTemplate).then(function(a) {
                        var b = c(a);
                        g.resolve(b)
                    },
                    function(a) {
                        throw new Error("Couldn't fetch/use row template '" + e.options.rowTemplate + "'")
                    })
                }
                return e.registerColumnBuilder(i.defaultColumnBuilder),
                e.registerRowBuilder(i.rowTemplateAssigner),
                e.registerRowsProcessor(function(a) {
                    return a.forEach(function(a) {
                        a.evaluateRowVisibility(!0)
                    },
                    50),
                    a
                }),
                e.registerColumnsProcessor(function(a) {
                    return a.forEach(function(a) {
                        a.visible = !0
                    }),
                    a
                },
                50),
                e.registerColumnsProcessor(function(a) {
                    return a.forEach(function(a) {
                        a.colDef.visible === !1 && (a.visible = !1)
                    }),
                    a
                },
                50),
                e.registerRowsProcessor(e.searchRows, 100),
                e.options.externalSort && angular.isFunction(e.options.externalSort) ? e.registerRowsProcessor(e.options.externalSort, 200) : e.registerRowsProcessor(e.sortByColumn, 200),
                e
            },
            defaultColumnBuilder: function(c, d, f) {
                var g = [],
                h = function(b, f, h, i, j) {
                    c[b] ? d[f] = c[b] : d[f] = h,
                    g.push(a.getTemplate(d[f]).then(function(a) {
                        angular.isFunction(a) && (a = a());
                        var c = "cellTooltip" === j ? "col.cellTooltip(row,col)": "col.headerTooltip(col)";
                        j && d[j] === !1 ? a = a.replace(e.TOOLTIP, "") : j && d[j] && (a = a.replace(e.TOOLTIP, 'title="{{' + c + ' CUSTOM_FILTERS }}"')),
                        i ? d[b] = a.replace(e.CUSTOM_FILTERS,
                        function() {
                            return d[i] ? "|" + d[i] : ""
                        }) : d[b] = a
                    },
                    function(a) {
                        throw new Error("Couldn't fetch/use colDef." + b + " '" + c[b] + "'")
                    }))
                };
                return h("cellTemplate", "providedCellTemplate", "ui-grid/uiGridCell", "cellFilter", "cellTooltip"),
                d.cellTemplatePromise = g[0],
                h("headerCellTemplate", "providedHeaderCellTemplate", "ui-grid/uiGridHeaderCell", "headerCellFilter", "headerTooltip"),
                h("footerCellTemplate", "providedFooterCellTemplate", "ui-grid/uiGridFooterCell", "footerCellFilter"),
                h("filterHeaderTemplate", "providedFilterHeaderTemplate", "ui-grid/ui-grid-filter"),
                d.compiledElementFnDefer = b.defer(),
                b.all(g)
            },
            rowTemplateAssigner: function(d) {
                var e = this;
                if (d.rowTemplate) {
                    var f = b.defer();
                    d.getRowTemplateFn = f.promise,
                    a.getTemplate(d.rowTemplate).then(function(a) {
                        var b = c(a);
                        f.resolve(b)
                    },
                    function(a) {
                        throw new Error("Couldn't fetch/use row template '" + d.rowTemplate + "'")
                    })
                } else d.rowTemplate = e.options.rowTemplate,
                d.getRowTemplateFn = e.getRowTemplateFn;
                return d.getRowTemplateFn
            }
        };
        return i
    }])
} (),
function() {
    function a(a) {
        return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
    }
    var b = angular.module("ui.grid");
    b.service("rowSearcher", ["gridUtil", "uiGridConstants",
    function(b, c) {
        var d = c.filter.CONTAINS,
        e = {};
        return e.getTerm = function(a) {
            if ("undefined" == typeof a.term) return a.term;
            var b = a.term;
            return "string" == typeof b && (b = b.trim()),
            b
        },
        e.stripTerm = function(b) {
            var c = e.getTerm(b);
            return "string" == typeof c ? a(c.replace(/(^\*|\*$)/g, "")) : c
        },
        e.guessCondition = function(a) {
            if ("undefined" == typeof a.term || !a.term) return d;
            var b = e.getTerm(a);
            if (/\*/.test(b)) {
                var c = "";
                a.flags && a.flags.caseSensitive || (c += "i");
                var f = b.replace(/(\\)?\*/g,
                function(a, b) {
                    return b ? a: "[\\s\\S]*?"
                });
                return new RegExp("^" + f + "$", c)
            }
            return d
        },
        e.setupFilters = function(a) {
            for (var d = [], f = a.length, g = 0; f > g; g++) {
                var h = a[g];
                if (h.noTerm || !b.isNullOrUndefined(h.term)) {
                    var i = {},
                    j = "";
                    h.flags && h.flags.caseSensitive || (j += "i"),
                    b.isNullOrUndefined(h.term) || (i.term = e.stripTerm(h)),
                    h.condition ? i.condition = h.condition: i.condition = e.guessCondition(h),
                    i.flags = angular.extend({
                        caseSensitive: !1,
                        date: !1
                    },
                    h.flags),
                    i.condition === c.filter.STARTS_WITH && (i.startswithRE = new RegExp("^" + i.term, j)),
                    i.condition === c.filter.ENDS_WITH && (i.endswithRE = new RegExp(i.term + "$", j)),
                    i.condition === c.filter.CONTAINS && (i.containsRE = new RegExp(i.term, j)),
                    i.condition === c.filter.EXACT && (i.exactRE = new RegExp("^" + i.term + "$", j)),
                    d.push(i)
                }
            }
            return d
        },
        e.runColumnFilter = function(a, b, d, e) {
            var f, g = typeof e.condition,
            h = e.term;
            if (f = d.filterCellFiltered ? a.getCellDisplayValue(b, d) : a.getCellValue(b, d), e.condition instanceof RegExp) return e.condition.test(f);
            if ("function" === g) return e.condition(h, f, b, d);
            if (e.startswithRE) return e.startswithRE.test(f);
            if (e.endswithRE) return e.endswithRE.test(f);
            if (e.containsRE) return e.containsRE.test(f);
            if (e.exactRE) return e.exactRE.test(f);
            if (e.condition === c.filter.NOT_EQUAL) {
                var i = new RegExp("^" + h + "$");
                return ! i.exec(f)
            }
            if ("number" == typeof f && "string" == typeof h) {
                var j = parseFloat(h.replace(/\\\./, ".").replace(/\\\-/, "-"));
                isNaN(j) || (h = j)
            }
            return e.flags.date === !0 && (f = new Date(f), h = new Date(h.replace(/\\/g, ""))),
            e.condition === c.filter.GREATER_THAN ? f > h: e.condition === c.filter.GREATER_THAN_OR_EQUAL ? f >= h: e.condition === c.filter.LESS_THAN ? h > f: e.condition === c.filter.LESS_THAN_OR_EQUAL ? h >= f: !0
        },
        e.searchColumn = function(a, b, c, d) {
            if (a.options.useExternalFiltering) return ! 0;
            for (var f = d.length,
            g = 0; f > g; g++) {
                var h = d[g],
                i = e.runColumnFilter(a, b, c, h);
                if (!i) return ! 1
            }
            return ! 0
        },
        e.search = function(a, c, d) {
            if (c) {
                if (!a.options.enableFiltering) return c;
                for (var f = [], g = d.length, h = function(a) {
                    var c = !1;
                    return a.forEach(function(a) { (!b.isNullOrUndefined(a.term) && "" !== a.term || a.noTerm) && (c = !0)
                    }),
                    c
                },
                i = 0; g > i; i++) {
                    var j = d[i];
                    "undefined" != typeof j.filters && h(j.filters) && f.push({
                        col: j,
                        filters: e.setupFilters(j.filters)
                    })
                }
                if (f.length > 0) {
                    for (var k = function(a, b, c, d) {
                        b.visible && !e.searchColumn(a, b, c, d) && (b.visible = !1)
                    },
                    l = function(a, b) {
                        for (var d = c.length,
                        e = 0; d > e; e++) k(a, c[e], b.col, b.filters)
                    },
                    m = f.length, n = 0; m > n; n++) l(a, f[n]);
                    a.api.core.raise.rowsVisibleChanged && a.api.core.raise.rowsVisibleChanged()
                }
                return c
            }
        },
        e
    }])
} (),
function() {
    var a = angular.module("ui.grid");
    a.service("rowSorter", ["$parse", "uiGridConstants",
    function(a, b) {
        var c = "(" + b.CURRENCY_SYMBOLS.map(function(a) {
            return "\\" + a
        }).join("|") + ")?",
        d = (new RegExp("^[-+]?" + c + "[\\d,.]+" + c + "%?$"), {
            colSortFnCache: {}
        });
        return d.guessSortFn = function(a) {
            switch (a) {
            case "number":
                return d.sortNumber;
            case "numberStr":
                return d.sortNumberStr;
            case "boolean":
                return d.sortBool;
            case "string":
                return d.sortAlpha;
            case "date":
                return d.sortDate;
            case "object":
                return d.basicSort;
            default:
                throw new Error("No sorting function found for type:" + a)
            }
        },
        d.handleNulls = function(a, b) {
            if (!a && 0 !== a && a !== !1 || !b && 0 !== b && b !== !1) {
                if (!a && 0 !== a && a !== !1 && !b && 0 !== b && b !== !1) return 0;
                if (!a && 0 !== a && a !== !1) return 1;
                if (!b && 0 !== b && b !== !1) return - 1
            }
            return null
        },
        d.basicSort = function(a, b) {
            var c = d.handleNulls(a, b);
            return null !== c ? c: a === b ? 0 : b > a ? -1 : 1
        },
        d.sortNumber = function(a, b) {
            var c = d.handleNulls(a, b);
            return null !== c ? c: a - b
        },
        d.sortNumberStr = function(a, b) {
            var c = d.handleNulls(a, b);
            if (null !== c) return c;
            var e, f, g = !1,
            h = !1;
            return e = parseFloat(a.replace(/[^0-9.-]/g, "")),
            isNaN(e) && (g = !0),
            f = parseFloat(b.replace(/[^0-9.-]/g, "")),
            isNaN(f) && (h = !0),
            g && h ? 0 : g ? 1 : h ? -1 : e - f
        },
        d.sortAlpha = function(a, b) {
            var c = d.handleNulls(a, b);
            if (null !== c) return c;
            var e = a.toString().toLowerCase(),
            f = b.toString().toLowerCase();
            return e === f ? 0 : e.localeCompare(f)
        },
        d.sortDate = function(a, b) {
            var c = d.handleNulls(a, b);
            if (null !== c) return c;
            a instanceof Date || (a = new Date(a)),
            b instanceof Date || (b = new Date(b));
            var e = a.getTime(),
            f = b.getTime();
            return e === f ? 0 : f > e ? -1 : 1
        },
        d.sortBool = function(a, b) {
            var c = d.handleNulls(a, b);
            return null !== c ? c: a && b ? 0 : a || b ? a ? 1 : -1 : 0
        },
        d.getSortFn = function(a, b, c) {
            var e;
            return d.colSortFnCache[b.colDef.name] ? e = d.colSortFnCache[b.colDef.name] : void 0 !== b.sortingAlgorithm ? (e = b.sortingAlgorithm, d.colSortFnCache[b.colDef.name] = b.sortingAlgorithm) : b.sortCellFiltered && b.cellFilter ? (e = d.sortAlpha, d.colSortFnCache[b.colDef.name] = e) : (e = d.guessSortFn(b.colDef.type), e ? d.colSortFnCache[b.colDef.name] = e: e = d.sortAlpha),
            e
        },
        d.prioritySort = function(a, b) {
            return void 0 !== a.sort.priority && void 0 !== b.sort.priority ? a.sort.priority < b.sort.priority ? -1 : a.sort.priority === b.sort.priority ? 0 : 1 : a.sort.priority || 0 === a.sort.priority ? -1 : b.sort.priority || 0 === b.sort.priority ? 1 : 0
        },
        d.sort = function(a, c, e) {
            if (c) {
                if (a.options.useExternalSorting) return c;
                var f = [];
                if (e.forEach(function(a) { ! a.sort || a.sort.ignoreSort || !a.sort.direction || a.sort.direction !== b.ASC && a.sort.direction !== b.DESC || f.push(a)
                }), f = f.sort(d.prioritySort), 0 === f.length) return c;
                var g, h, i = function(a, b) {
                    a.entity.$$uiGridIndex = b
                };
                c.forEach(i);
                var j = c.slice(0),
                k = function(c, e) {
                    for (var i, k = 0,
                    l = 0; 0 === k && l < f.length;) {
                        g = f[l],
                        h = f[l].sort.direction,
                        i = d.getSortFn(a, g, j);
                        var m, n;
                        g.sortCellFiltered ? (m = a.getCellDisplayValue(c, g), n = a.getCellDisplayValue(e, g)) : (m = a.getCellValue(c, g), n = a.getCellValue(e, g)),
                        k = i(m, n, c, e, h),
                        l++
                    }
                    return 0 === k ? c.entity.$$uiGridIndex - e.entity.$$uiGridIndex: h === b.ASC ? k: 0 - k
                },
                l = c.sort(k),
                m = function(a, b) {
                    delete a.entity.$$uiGridIndex
                };
                return c.forEach(m),
                l
            }
        },
        d
    }])
} (),
function() {
    function a(a) {
        var b = a;
        return "undefined" != typeof b.length && b.length && (b = a[0]),
        b.ownerDocument.defaultView.getComputedStyle(b, null)
    }
    function b(a, b, c, d, e) {
        for (var f = c === (d ? "border": "content") ? 4 : "width" === b ? 1 : 0, g = 0, h = ["Top", "Right", "Bottom", "Left"]; 4 > f; f += 2) {
            var i = h[f];
            if ("margin" === c) {
                var j = parseFloat(e[c + i]);
                isNaN(j) || (g += j)
            }
            if (d) {
                if ("content" === c) {
                    var k = parseFloat(e["padding" + i]);
                    isNaN(k) || (g -= k)
                }
                if ("margin" !== c) {
                    var l = parseFloat(e["border" + i + "Width"]);
                    isNaN(l) || (g -= l)
                }
            } else {
                var m = parseFloat(e["padding" + i]);
                if (isNaN(m) || (g += m), "padding" !== c) {
                    var n = parseFloat(e["border" + i + "Width"]);
                    isNaN(n) || (g += n)
                }
            }
        }
        return g
    }
    function c(c, d, e) {
        var f, h = !0,
        i = a(c),
        j = "border-box" === i.boxSizing;
        if (0 >= f || null == f) {
            if (f = i[d], (0 > f || null == f) && (f = c.style[d]), g.test(f)) return f;
            h = j && !0,
            f = parseFloat(f) || 0;
        }
        var k = f + b(c, d, e || (j ? "border": "content"), h, i);
        return k
    }
    function d(b) {
        b = angular.element(b)[0];
        var c = b.parentElement;
        return c || (c = document.getElementsByTagName("body")[0]),
        parseInt(a(c).fontSize) || parseInt(a(b).fontSize) || 16
    }
    var e, f = angular.module("ui.grid");
    "function" != typeof Function.prototype.bind && (e = function() {
        var a = Array.prototype.slice;
        return function(b) {
            var c = this,
            d = a.call(arguments, 1);
            return d.length ?
            function() {
                return arguments.length ? c.apply(b, d.concat(a.call(arguments))) : c.apply(b, d)
            }: function() {
                return arguments.length ? c.apply(b, arguments) : c.call(b)
            }
        }
    });
    var g = new RegExp("^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$", "i"),
    h = /^(block|none|table(?!-c[ea]).+)/,
    i = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    },
    j = ["0", "0", "0", "0"],
    k = "uiGrid-";
    f.service("gridUtil", ["$log", "$window", "$document", "$http", "$templateCache", "$timeout", "$interval", "$injector", "$q", "$interpolate", "uiGridConstants",
    function(f, g, l, m, n, o, p, q, r, s, t) {
        function u(a, b) {
            var c = angular.element(this),
            d = 0,
            e = 0,
            f = 0,
            g = 0;
            if (b.originalEvent && (b = b.originalEvent), "detail" in b && (f = -1 * b.detail), "wheelDelta" in b && (f = b.wheelDelta), "wheelDeltaY" in b && (f = b.wheelDeltaY), "wheelDeltaX" in b && (e = -1 * b.wheelDeltaX), "axis" in b && b.axis === b.HORIZONTAL_AXIS && (e = -1 * f, f = 0), d = 0 === f ? e: f, "deltaY" in b && (f = -1 * b.deltaY, d = f), "deltaX" in b && (e = b.deltaX, 0 === f && (d = -1 * e)), 0 !== f || 0 !== e) {
                if (1 === b.deltaMode) {
                    var h = c.data("mousewheel-line-height");
                    d *= h,
                    f *= h,
                    e *= h
                } else if (2 === b.deltaMode) {
                    var i = c.data("mousewheel-page-height");
                    d *= i,
                    f *= i,
                    e *= i
                }
                g = Math.max(Math.abs(f), Math.abs(e)),
                (!z || z > g) && (z = g, w(b, g) && (z /= 40)),
                d = Math[d >= 1 ? "floor": "ceil"](d / z),
                e = Math[e >= 1 ? "floor": "ceil"](e / z),
                f = Math[f >= 1 ? "floor": "ceil"](f / z),
                b.deltaMode = 0;
                var j = {
                    originalEvent: b,
                    deltaX: e,
                    deltaY: f,
                    deltaFactor: z,
                    preventDefault: function() {
                        b.preventDefault()
                    },
                    stopPropagation: function() {
                        b.stopPropagation()
                    }
                };
                y && clearTimeout(y),
                y = setTimeout(v, 200),
                a.call(c[0], j)
            }
        }
        function v() {
            z = null
        }
        function w(a, b) {
            return "mousewheel" === a.type && b % 120 === 0
        }
        var x = {
            augmentWidthOrHeight: b,
            getStyles: a,
            createBoundedWrapper: function(a, b) {
                return function() {
                    return b.apply(a, arguments)
                }
            },
            readableColumnName: function(a) {
                return "undefined" == typeof a || void 0 === a || null === a ? a: ("string" != typeof a && (a = String(a)), a.replace(/_+/g, " ").replace(/^[A-Z]+$/,
                function(a) {
                    return angular.lowercase(angular.uppercase(a.charAt(0)) + a.slice(1))
                }).replace(/([\w\u00C0-\u017F]+)/g,
                function(a) {
                    return angular.uppercase(a.charAt(0)) + a.slice(1)
                }).replace(/(\w+?(?=[A-Z]))/g, "$1 "))
            },
            getColumnsFromData: function(a, b) {
                var c = [];
                if (!a || "undefined" == typeof a[0] || void 0 === a[0]) return [];
                angular.isUndefined(b) && (b = []);
                var d = a[0];
                return angular.forEach(d,
                function(a, d) { - 1 === b.indexOf(d) && c.push({
                        name: d
                    })
                }),
                c
            },
            newId: function() {
                var a = (new Date).getTime();
                return function() {
                    return a += 1
                }
            } (),
            getTemplate: function(a) {
                if (n.get(a)) return x.postProcessTemplate(n.get(a));
                if (a.hasOwnProperty("then")) return a.then(x.postProcessTemplate);
                try {
                    if (angular.element(a).length > 0) return r.when(a).then(x.postProcessTemplate)
                } catch(b) {}
                return x.logDebug("fetching url", a),
                m({
                    method: "GET",
                    url: a
                }).then(function(b) {
                    var c = b.data.trim();
                    return n.put(a, c),
                    c
                },
                function(b) {
                    throw new Error("Could not get template " + a + ": " + b)
                }).then(x.postProcessTemplate)
            },
            postProcessTemplate: function(a) {
                var b = s.startSymbol(),
                c = s.endSymbol();
                return ("{{" !== b || "}}" !== c) && (a = a.replace(/\{\{/g, b), a = a.replace(/\}\}/g, c)),
                r.when(a)
            },
            guessType: function(a) {
                var b = typeof a;
                switch (b) {
                case "number":
                case "boolean":
                case "string":
                    return b;
                default:
                    return angular.isDate(a) ? "date": "object"
                }
            },
            elementWidth: function(a) {},
            elementHeight: function(a) {},
            getScrollbarWidth: function() {
                var a = document.createElement("div");
                a.style.visibility = "hidden",
                a.style.width = "100px",
                a.style.msOverflowStyle = "scrollbar",
                document.body.appendChild(a);
                var b = a.offsetWidth;
                a.style.overflow = "scroll";
                var c = document.createElement("div");
                c.style.width = "100%",
                a.appendChild(c);
                var d = c.offsetWidth;
                return a.parentNode.removeChild(a),
                b - d
            },
            swap: function(a, b, c, d) {
                var e, f, g = {};
                for (f in b) g[f] = a.style[f],
                a.style[f] = b[f];
                e = c.apply(a, d || []);
                for (f in b) a.style[f] = g[f];
                return e
            },
            fakeElement: function(a, b, c, d) {
                var e, f, g = angular.element(a).clone()[0];
                for (f in b) g.style[f] = b[f];
                return angular.element(document.body).append(g),
                e = c.call(g, g),
                angular.element(g).remove(),
                e
            },
            normalizeWheelEvent: function(a) {
                var b, c, d, e = a || window.event,
                f = ([].slice.call(arguments, 1), 0),
                g = 0,
                h = 0,
                i = 0,
                j = 0;
                return e.originalEvent && (e = e.originalEvent),
                e.wheelDelta && (f = e.wheelDelta),
                e.detail && (f = -1 * e.detail),
                h = f,
                void 0 !== e.axis && e.axis === e.HORIZONTAL_AXIS && (h = 0, g = -1 * f),
                e.deltaY && (h = -1 * e.deltaY, f = h),
                e.deltaX && (g = e.deltaX, f = -1 * g),
                void 0 !== e.wheelDeltaY && (h = e.wheelDeltaY),
                void 0 !== e.wheelDeltaX && (g = e.wheelDeltaX),
                i = Math.abs(f),
                (!b || b > i) && (b = i),
                j = Math.max(Math.abs(h), Math.abs(g)),
                (!c || c > j) && (c = j),
                d = f > 0 ? "floor": "ceil",
                f = Math[d](f / b),
                g = Math[d](g / c),
                h = Math[d](h / c),
                {
                    delta: f,
                    deltaX: g,
                    deltaY: h
                }
            },
            isTouchEnabled: function() {
                var a;
                return ("ontouchstart" in g || g.DocumentTouch && l instanceof DocumentTouch) && (a = !0),
                a
            },
            isNullOrUndefined: function(a) {
                return void 0 === a || null === a ? !0 : !1
            },
            endsWith: function(a, b) {
                return a && b && "string" == typeof a ? -1 !== a.indexOf(b, a.length - b.length) : !1
            },
            arrayContainsObjectWithProperty: function(a, b, c) {
                var d = !1;
                return angular.forEach(a,
                function(a) {
                    a[b] === c && (d = !0)
                }),
                d
            },
            numericAndNullSort: function(a, b) {
                return null === a ? 1 : null === b ? -1 : null === a && null === b ? 0 : a - b
            },
            disableAnimations: function(a) {
                var b;
                try {
                    b = q.get("$animate"),
                    angular.version.major > 1 || 1 === angular.version.major && angular.version.minor >= 4 ? b.enabled(a, !1) : b.enabled(!1, a)
                } catch(c) {}
            },
            enableAnimations: function(a) {
                var b;
                try {
                    return b = q.get("$animate"),
                    angular.version.major > 1 || 1 === angular.version.major && angular.version.minor >= 4 ? b.enabled(a, !0) : b.enabled(!0, a),
                    b
                } catch(c) {}
            },
            nextUid: function() {
                for (var a, b = j.length; b;) {
                    if (b--, a = j[b].charCodeAt(0), 57 === a) return j[b] = "A",
                    k + j.join("");
                    if (90 !== a) return j[b] = String.fromCharCode(a + 1),
                    k + j.join("");
                    j[b] = "0"
                }
                return j.unshift("0"),
                k + j.join("")
            },
            hashKey: function(a) {
                var b, c = typeof a;
                return "object" === c && null !== a ? "function" == typeof(b = a.$$hashKey) ? b = a.$$hashKey() : "undefined" != typeof a.$$hashKey && a.$$hashKey ? b = a.$$hashKey: void 0 === b && (b = a.$$hashKey = x.nextUid()) : b = a,
                c + ":" + b
            },
            resetUids: function() {
                j = ["0", "0", "0"]
            },
            logError: function(a) {
                t.LOG_ERROR_MESSAGES && f.error(a)
            },
            logWarn: function(a) {
                t.LOG_WARN_MESSAGES && f.warn(a)
            },
            logDebug: function() {
                t.LOG_DEBUG_MESSAGES && f.debug.apply(f, arguments)
            }
        };
        x.focus = {
            queue: [],
            byId: function(a, b) {
                this._purgeQueue();
                var c = o(function() {
                    var c = (b && b.id ? b.id + "-": "") + a,
                    d = g.document.getElementById(c);
                    d ? d.focus() : x.logWarn("[focus.byId] Element id " + c + " was not found.")
                });
                return this.queue.push(c),
                c
            },
            byElement: function(a) {
                if (!angular.isElement(a)) return x.logWarn("Trying to focus on an element that isn't an element."),
                r.reject("not-element");
                a = angular.element(a),
                this._purgeQueue();
                var b = o(function() {
                    a && a[0].focus()
                });
                return this.queue.push(b),
                b
            },
            bySelector: function(a, b, c) {
                var d = this;
                if (!angular.isElement(a)) throw new Error("The parent element is not an element.");
                a = angular.element(a);
                var e = function() {
                    var c = a[0].querySelector(b);
                    return d.byElement(c)
                };
                if (this._purgeQueue(), c) {
                    var f = o(e);
                    return this.queue.push(o(e)),
                    f
                }
                return e()
            },
            _purgeQueue: function() {
                this.queue.forEach(function(a) {
                    o.cancel(a)
                }),
                this.queue = []
            }
        },
        ["width", "height"].forEach(function(b) {
            var d = angular.uppercase(b.charAt(0)) + b.substr(1);
            x["element" + d] = function(d, e) {
                var f = d;
                if (f && "undefined" != typeof f.length && f.length && (f = d[0]), f) {
                    var g = a(f);
                    return 0 === f.offsetWidth && h.test(g.display) ? x.swap(f, i,
                    function() {
                        return c(f, b, e)
                    }) : c(f, b, e)
                }
                return null
            },
            x["outerElement" + d] = function(a, b) {
                return a ? x["element" + d].call(this, a, b ? "margin": "border") : null
            }
        }),
        x.closestElm = function(a, b) {
            "undefined" != typeof a.length && a.length && (a = a[0]);
            var c; ["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"].some(function(a) {
                return "function" == typeof document.body[a] ? (c = a, !0) : !1
            });
            for (var d; null !== a;) {
                if (d = a.parentElement, null !== d && d[c](b)) return d;
                a = d
            }
            return null
        },
        x.type = function(a) {
            var b = Function.prototype.toString.call(a.constructor);
            return b.match(/function (.*?)\(/)[1]
        },
        x.getBorderSize = function(b, c) {
            "undefined" != typeof b.length && b.length && (b = b[0]);
            var d = a(b);
            c = c ? "border" + c.charAt(0).toUpperCase() + c.slice(1) : "border",
            c += "Width";
            var e = parseInt(d[c], 10);
            return isNaN(e) ? 0 : e
        },
        x.detectBrowser = function() {
            var a = g.navigator.userAgent,
            b = {
                chrome: /chrome/i,
                safari: /safari/i,
                firefox: /firefox/i,
                ie: /internet explorer|trident\//i
            };
            for (var c in b) if (b[c].test(a)) return c;
            return "unknown"
        },
        x.rtlScrollType = function B() {
            if (B.type) return B.type;
            var a = angular.element('<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>')[0],
            b = "reverse";
            return document.body.appendChild(a),
            a.scrollLeft > 0 ? b = "default": (a.scrollLeft = 1, 0 === a.scrollLeft && (b = "negative")),
            angular.element(a).remove(),
            B.type = b,
            b
        },
        x.normalizeScrollLeft = function(a, b) {
            "undefined" != typeof a.length && a.length && (a = a[0]);
            var c = a.scrollLeft;
            if (b.isRTL()) switch (x.rtlScrollType()) {
            case "default":
                return a.scrollWidth - c - a.clientWidth;
            case "negative":
                return Math.abs(c);
            case "reverse":
                return c
            }
            return c
        },
        x.denormalizeScrollLeft = function(a, b, c) {
            if ("undefined" != typeof a.length && a.length && (a = a[0]), c.isRTL()) switch (x.rtlScrollType()) {
            case "default":
                var d = a.scrollWidth - a.clientWidth;
                return d - b;
            case "negative":
                return - 1 * b;
            case "reverse":
                return b
            }
            return b
        },
        x.preEval = function(a) {
            var b = t.BRACKET_REGEXP.exec(a);
            if (b) return (b[1] ? x.preEval(b[1]) : b[1]) + b[2] + (b[3] ? x.preEval(b[3]) : b[3]);
            a = a.replace(t.APOS_REGEXP, "\\'");
            var c = a.split(t.DOT_REGEXP),
            d = [c.shift()];
            return angular.forEach(c,
            function(a) {
                d.push(a.replace(t.FUNC_REGEXP, "']$1"))
            }),
            d.join("['")
        },
        x.debounce = function(a, b, c) {
            function d() {
                g = this,
                f = arguments;
                var d = function() {
                    e = null,
                    c || (h = a.apply(g, f))
                },
                i = c && !e;
                return e && o.cancel(e),
                e = o(d, b),
                i && (h = a.apply(g, f)),
                h
            }
            var e, f, g, h;
            return d.cancel = function() {
                o.cancel(e),
                e = null
            },
            d
        },
        x.throttle = function(a, b, c) {
            function d(b) {
                g = +new Date,
                a.apply(e, f),
                p(function() {
                    h = null
                },
                0, 1)
            }
            c = c || {};
            var e, f, g = 0,
            h = null;
            return function() {
                if (e = this, f = arguments, null === h) {
                    var a = +new Date - g;
                    a > b ? d() : c.trailing && (h = p(d, b - a, 1))
                }
            }
        },
        x.on = {},
        x.off = {},
        x._events = {},
        x.addOff = function(a) {
            x.off[a] = function(b, c) {
                var d = x._events[a].indexOf(c);
                d > 0 && x._events[a].removeAt(d)
            }
        };
        var y, z, A = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"];
        return x.on.mousewheel = function(a, b) {
            if (a && b) {
                var c = angular.element(a);
                c.data("mousewheel-line-height", d(c)),
                c.data("mousewheel-page-height", x.elementHeight(c)),
                c.data("mousewheel-callbacks") || c.data("mousewheel-callbacks", {});
                var f = c.data("mousewheel-callbacks");
                f[b] = (Function.prototype.bind || e).call(u, c[0], b);
                for (var g = A.length; g;) c.on(A[--g], f[b])
            }
        },
        x.off.mousewheel = function(a, b) {
            var c = angular.element(a),
            d = c.data("mousewheel-callbacks"),
            e = d[b];
            if (e) for (var f = A.length; f;) c.off(A[--f], e);
            delete d[b],
            0 === Object.keys(d).length && (c.removeData("mousewheel-line-height"), c.removeData("mousewheel-page-height"), c.removeData("mousewheel-callbacks"))
        },
        x
    }]),
    f.filter("px",
    function() {
        return function(a) {
            return a.match(/^[\d\.]+$/) ? a + "px": a
        }
    })
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            var b = {
                aggregate: {
                    label: "položky"
                },
                groupPanel: {
                    description: "Přesuňte záhlaví zde pro vytvoření skupiny dle sloupce."
                },
                search: {
                    placeholder: "Hledat...",
                    showingItems: "Zobrazuji položky:",
                    selectedItems: "Vybrané položky:",
                    totalItems: "Celkem položek:",
                    size: "Velikost strany:",
                    first: "První strana",
                    next: "Další strana",
                    previous: "Předchozí strana",
                    last: "Poslední strana"
                },
                menu: {
                    text: "Vyberte sloupec:"
                },
                sort: {
                    ascending: "Seřadit od A-Z",
                    descending: "Seřadit od Z-A",
                    remove: "Odebrat seřazení"
                },
                column: {
                    hide: "Schovat sloupec"
                },
                aggregation: {
                    count: "celkem řádků: ",
                    sum: "celkem: ",
                    avg: "avg: ",
                    min: "min.: ",
                    max: "max.: "
                },
                pinning: {
                    pinLeft: "Zamknout vlevo",
                    pinRight: "Zamknout vpravo",
                    unpin: "Odemknout"
                },
                gridMenu: {
                    columns: "Sloupce:",
                    importerTitle: "Importovat soubor",
                    exporterAllAsCsv: "导出所有数据到CSV文件",
                    exporterVisibleAsCsv: "导出当前页数据到CSV文件",
                    exporterSelectedAsCsv: "导出选中数据到CSV文件",
                    exporterAllAsPdf: "导出所有数据到PDF文件",
                    exporterVisibleAsPdf: "导出当前页数据到PDF文件",
                    exporterSelectedAsPdf: "导出选中数据到PDF文件",
                    clearAllFilters: "Odstranit všechny filtry"
                },
                importer: {
                    noHeaders: "Názvy sloupců se nepodařilo získat, obsahuje soubor záhlaví?",
                    noObjects: "Data se nepodařilo zpracovat, obsahuje soubor řádky mimo záhlaví?",
                    invalidCsv: "Soubor nelze zpracovat, jedná se o CSV?",
                    invalidJson: "Soubor nelze zpracovat, je to JSON?",
                    jsonNotArray: "Soubor musí obsahovat json. Ukončuji.."
                },
                pagination: {
                    sizes: "položek na stránku",
                    totalItems: "položek"
                },
                grouping: {
                    group: "Seskupit",
                    ungroup: "Odebrat seskupení",
                    aggregate_count: "Agregace: Count",
                    aggregate_sum: "Agregace: Sum",
                    aggregate_max: "Agregace: Max",
                    aggregate_min: "Agregace: Min",
                    aggregate_avg: "Agregace: Avg",
                    aggregate_remove: "Agregace: Odebrat"
                }
            };
            return a.add("cs", b),
            a.add("cz", b),
            a.add("cs-cz", b),
            a.add("cs-CZ", b),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("da", {
                aggregate: {
                    label: "artikler"
                },
                groupPanel: {
                    description: "Grupér rækker udfra en kolonne ved at trække dens overskift hertil."
                },
                search: {
                    placeholder: "Søg...",
                    showingItems: "Viste rækker:",
                    selectedItems: "Valgte rækker:",
                    totalItems: "Rækker totalt:",
                    size: "Side størrelse:",
                    first: "Første side",
                    next: "Næste side",
                    previous: "Forrige side",
                    last: "Sidste side"
                },
                menu: {
                    text: "Vælg kolonner:"
                },
                sort: {
                    ascending: "Sorter stigende",
                    descending: "Sorter faldende",
                    none: "Sorter ingen",
                    remove: "Fjern sortering"
                },
                column: {
                    hide: "Skjul kolonne"
                },
                aggregation: {
                    count: "antal rækker: ",
                    sum: "sum: ",
                    avg: "gns: ",
                    min: "min: ",
                    max: "max: "
                },
                gridMenu: {
                    columns: "Columns:",
                    importerTitle: "Import file",
                    exporterAllAsCsv: "导出所有数据到CSV文件",
                    exporterVisibleAsCsv: "导出当前页数据到CSV文件",
                    exporterSelectedAsCsv: "导出选中数据CSV文件",
                    exporterAllAsPdf: "导出所有数据到PDF文件",
                    exporterVisibleAsPdf: "导出当前页数据到PDF文件",
                    exporterSelectedAsPdf: "导出选中数据到PDF文件",
                    clearAllFilters: "Clear all filters"
                },
                importer: {
                    noHeaders: "Column names were unable to be derived, does the file have a header?",
                    noObjects: "Objects were not able to be derived, was there data in the file other than headers?",
                    invalidCsv: "File was unable to be processed, is it valid CSV?",
                    invalidJson: "File was unable to be processed, is it valid Json?",
                    jsonNotArray: "Imported json file must contain an array, aborting."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("de", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filter für Spalte",
                        removeFilter: "Filter löschen",
                        columnMenuButtonLabel: "Spaltenmenü"
                    },
                    priority: "Priorität:",
                    filterLabel: "Filter für Spalte: "
                },
                aggregate: {
                    label: "Eintrag"
                },
                groupPanel: {
                    description: "Ziehen Sie eine Spaltenüberschrift hierhin, um nach dieser Spalte zu gruppieren."
                },
                search: {
                    placeholder: "Suche...",
                    showingItems: "Zeige Einträge:",
                    selectedItems: "Ausgewählte Einträge:",
                    totalItems: "Einträge gesamt:",
                    size: "Einträge pro Seite:",
                    first: "Erste Seite",
                    next: "Nächste Seite",
                    previous: "Vorherige Seite",
                    last: "Letzte Seite"
                },
                menu: {
                    text: "Spalten auswählen:"
                },
                sort: {
                    ascending: "aufsteigend sortieren",
                    descending: "absteigend sortieren",
                    none: "keine Sortierung",
                    remove: "Sortierung zurücksetzen"
                },
                column: {
                    hide: "Spalte ausblenden"
                },
                aggregation: {
                    count: "Zeilen insgesamt: ",
                    sum: "gesamt: ",
                    avg: "Durchschnitt: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Links anheften",
                    pinRight: "Rechts anheften",
                    unpin: "Lösen"
                },
                columnMenu: {
                    close: "Schließen"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Tabellenmenü"
                    },
                    columns: "Spalten:",
                    importerTitle: "Datei importieren",
                    exporterAllAsCsv: "Alle Daten als CSV exportieren",
                    exporterVisibleAsCsv: "sichtbare Daten als CSV exportieren",
                    exporterSelectedAsCsv: "markierte Daten als CSV exportieren",
                    exporterAllAsPdf: "Alle Daten als PDF exportieren",
                    exporterVisibleAsPdf: "sichtbare Daten als PDF exportieren",
                    exporterSelectedAsPdf: "markierte Daten als CSV exportieren",
                    clearAllFilters: "Alle Filter zurücksetzen"
                },
                importer: {
                    noHeaders: "Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?",
                    noObjects: "Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei außer den Spaltendefinitionen auch Daten enthalten?",
                    invalidCsv: "Die Datei konnte nicht eingelesen werden, ist es eine gültige CSV-Datei?",
                    invalidJson: "Die Datei konnte nicht eingelesen werden. Enthält sie gültiges JSON?",
                    jsonNotArray: "Die importierte JSON-Datei muß ein Array enthalten. Breche Import ab."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Zum Anfang",
                        pageBack: "Seite zurück",
                        pageSelected: "Ausgwählte Seite",
                        pageForward: "Seite vor",
                        pageToLast: "Zum Ende"
                    },
                    sizes: "Einträge pro Seite",
                    totalItems: "Einträge",
                    through: "bis",
                    of: "von"
                },
                grouping: {
                    group: "Gruppieren",
                    ungroup: "Gruppierung aufheben",
                    aggregate_count: "Agg: Anzahl",
                    aggregate_sum: "Agg: Summe",
                    aggregate_max: "Agg: Maximum",
                    aggregate_min: "Agg: Minimum",
                    aggregate_avg: "Agg: Mittelwert",
                    aggregate_remove: "Aggregation entfernen"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("en", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filter for column",
                        removeFilter: "Remove Filter",
                        columnMenuButtonLabel: "Column Menu"
                    },
                    priority: "Priority:",
                    filterLabel: "Filter for column: "
                },
                aggregate: {
                    label: "items"
                },
                groupPanel: {
                    description: "Drag a column header here and drop it to group by that column."
                },
                search: {
                    placeholder: "Search...",
                    showingItems: "Showing Items:",
                    selectedItems: "Selected Items:",
                    totalItems: "Total Items:",
                    size: "Page Size:",
                    first: "First Page",
                    next: "Next Page",
                    previous: "Previous Page",
                    last: "Last Page"
                },
                menu: {
                    text: "Choose Columns:"
                },
                sort: {
                    ascending: "Sort Ascending",
                    descending: "Sort Descending",
                    none: "Sort None",
                    remove: "Remove Sort"
                },
                column: {
                    hide: "Hide Column"
                },
                aggregation: {
                    count: "total rows: ",
                    sum: "total: ",
                    avg: "avg: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Pin Left",
                    pinRight: "Pin Right",
                    unpin: "Unpin"
                },
                columnMenu: {
                    close: "Close"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Grid Menu"
                    },
                    columns: "Columns:",
                    importerTitle: "Import file",
                    exporterAllAsCsv: "导出所有数据到CSV文件",
                    exporterVisibleAsCsv: "导出当前页数据到CSV文件",
                    exporterSelectedAsCsv: "导出选中数据到CSV文件",
                    exporterAllAsPdf: "导出所有数据到PDF文件",
                    exporterVisibleAsPdf: "导出当前页数据到PDF文件",
                    exporterSelectedAsPdf: "导出选中数据到PDF文件",
                    clearAllFilters: "Clear all filters"
                },
                importer: {
                    noHeaders: "Column names were unable to be derived, does the file have a header?",
                    noObjects: "Objects were not able to be derived, was there data in the file other than headers?",
                    invalidCsv: "File was unable to be processed, is it valid CSV?",
                    invalidJson: "File was unable to be processed, is it valid Json?",
                    jsonNotArray: "Imported json file must contain an array, aborting."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Page to first",
                        pageBack: "Page back",
                        pageSelected: "Selected page",
                        pageForward: "Page forward",
                        pageToLast: "Page to last"
                    },
                    sizes: "行每页",
                    totalItems: "行",
                    through: "through",
                    of: "共"
                },
                grouping: {
                    group: "Group",
                    ungroup: "Ungroup",
                    aggregate_count: "Agg: Count",
                    aggregate_sum: "Agg: Sum",
                    aggregate_max: "Agg: Max",
                    aggregate_min: "Agg: Min",
                    aggregate_avg: "Agg: Avg",
                    aggregate_remove: "Agg: Remove"
                },
                validate: {
                    error: "Error:",
                    minLength: "Value should be at least THRESHOLD characters long.",
                    maxLength: "Value should be at most THRESHOLD characters long.",
                    required: "A value is needed."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("es", {
                aggregate: {
                    label: "Artículos"
                },
                groupPanel: {
                    description: "Arrastre un encabezado de columna aquí y suéltelo para agrupar por esa columna."
                },
                search: {
                    placeholder: "Buscar...",
                    showingItems: "Artículos Mostrados:",
                    selectedItems: "Artículos Seleccionados:",
                    totalItems: "Artículos Totales:",
                    size: "Tamaño de Página:",
                    first: "Primera Página",
                    next: "Página Siguiente",
                    previous: "Página Anterior",
                    last: "Última Página"
                },
                menu: {
                    text: "Elegir columnas:"
                },
                sort: {
                    ascending: "Orden Ascendente",
                    descending: "Orden Descendente",
                    remove: "Sin Ordenar"
                },
                column: {
                    hide: "Ocultar la columna"
                },
                aggregation: {
                    count: "filas totales: ",
                    sum: "total: ",
                    avg: "media: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Fijar a la Izquierda",
                    pinRight: "Fijar a la Derecha",
                    unpin: "Quitar Fijación"
                },
                gridMenu: {
                    columns: "Columnas:",
                    importerTitle: "Importar archivo",
                    exporterAllAsCsv: "Exportar todo como csv",
                    exporterVisibleAsCsv: "Exportar vista como csv",
                    exporterSelectedAsCsv: "Exportar selección como csv",
                    exporterAllAsPdf: "Exportar todo como pdf",
                    exporterVisibleAsPdf: "Exportar vista como pdf",
                    exporterSelectedAsPdf: "Exportar selección como pdf",
                    clearAllFilters: "Limpiar todos los filtros"
                },
                importer: {
                    noHeaders: "No fue posible derivar los nombres de las columnas, ¿tiene encabezados el archivo?",
                    noObjects: "No fue posible obtener registros, ¿contiene datos el archivo, aparte de los encabezados?",
                    invalidCsv: "No fue posible procesar el archivo, ¿es un CSV válido?",
                    invalidJson: "No fue posible procesar el archivo, ¿es un Json válido?",
                    jsonNotArray: "El archivo json importado debe contener un array, abortando."
                },
                pagination: {
                    sizes: "registros por página",
                    totalItems: "registros",
                    of: "de"
                },
                grouping: {
                    group: "Agrupar",
                    ungroup: "Desagrupar",
                    aggregate_count: "Agr: Cont",
                    aggregate_sum: "Agr: Sum",
                    aggregate_max: "Agr: Máx",
                    aggregate_min: "Agr: Min",
                    aggregate_avg: "Agr: Prom",
                    aggregate_remove: "Agr: Quitar"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("fa", {
                aggregate: {
                    label: "قلم"
                },
                groupPanel: {
                    description: "عنوان یک ستون را بگیر و به گروهی از آن ستون رها کن."
                },
                search: {
                    placeholder: "جستجو...",
                    showingItems: "نمایش اقلام:",
                    selectedItems: "قلم‌های انتخاب شده:",
                    totalItems: "مجموع اقلام:",
                    size: "اندازه‌ی صفحه:",
                    first: "اولین صفحه",
                    next: "صفحه‌ی‌بعدی",
                    previous: "صفحه‌ی‌ قبلی",
                    last: "آخرین صفحه"
                },
                menu: {
                    text: "ستون‌های انتخابی:"
                },
                sort: {
                    ascending: "ترتیب صعودی",
                    descending: "ترتیب نزولی",
                    remove: "حذف مرتب کردن"
                },
                column: {
                    hide: "پنهان‌کردن ستون"
                },
                aggregation: {
                    count: "تعداد: ",
                    sum: "مجموع: ",
                    avg: "میانگین: ",
                    min: "کمترین: ",
                    max: "بیشترین: "
                },
                pinning: {
                    pinLeft: "پین کردن سمت چپ",
                    pinRight: "پین کردن سمت راست",
                    unpin: "حذف پین"
                },
                gridMenu: {
                    columns: "ستون‌ها:",
                    importerTitle: "وارد کردن فایل",
                    exporterAllAsCsv: "خروجی تمام داده‌ها در فایل csv",
                    exporterVisibleAsCsv: "خروجی داده‌های قابل مشاهده در فایل csv",
                    exporterSelectedAsCsv: "خروجی داده‌های انتخاب‌شده در فایل csv",
                    exporterAllAsPdf: "خروجی تمام داده‌ها در فایل pdf",
                    exporterVisibleAsPdf: "خروجی داده‌های قابل مشاهده در فایل pdf",
                    exporterSelectedAsPdf: "خروجی داده‌های انتخاب‌شده در فایل pdf",
                    clearAllFilters: "پاک کردن تمام فیلتر"
                },
                importer: {
                    noHeaders: "نام ستون قابل استخراج نیست. آیا فایل عنوان دارد؟",
                    noObjects: "اشیا قابل استخراج نیستند. آیا به جز عنوان‌ها در فایل داده وجود دارد؟",
                    invalidCsv: "فایل قابل پردازش نیست. آیا فرمت  csv  معتبر است؟",
                    invalidJson: "فایل قابل پردازش نیست. آیا فرمت json   معتبر است؟",
                    jsonNotArray: "فایل json وارد شده باید حاوی آرایه باشد. عملیات ساقط شد."
                },
                pagination: {
                    sizes: "اقلام در هر صفحه",
                    totalItems: "اقلام",
                    of: "از"
                },
                grouping: {
                    group: "گروه‌بندی",
                    ungroup: "حذف گروه‌بندی",
                    aggregate_count: "Agg: تعداد",
                    aggregate_sum: "Agg: جمع",
                    aggregate_max: "Agg: بیشینه",
                    aggregate_min: "Agg: کمینه",
                    aggregate_avg: "Agg: میانگین",
                    aggregate_remove: "Agg: حذف"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("fi", {
                aggregate: {
                    label: "rivit"
                },
                groupPanel: {
                    description: "Raahaa ja pudota otsikko tähän ryhmittääksesi sarakkeen mukaan."
                },
                search: {
                    placeholder: "Hae...",
                    showingItems: "Näytetään rivejä:",
                    selectedItems: "Valitut rivit:",
                    totalItems: "Rivejä yht.:",
                    size: "Näytä:",
                    first: "Ensimmäinen sivu",
                    next: "Seuraava sivu",
                    previous: "Edellinen sivu",
                    last: "Viimeinen sivu"
                },
                menu: {
                    text: "Valitse sarakkeet:"
                },
                sort: {
                    ascending: "Järjestä nouseva",
                    descending: "Järjestä laskeva",
                    remove: "Poista järjestys"
                },
                column: {
                    hide: "Piilota sarake"
                },
                aggregation: {
                    count: "Rivejä yht.: ",
                    sum: "Summa: ",
                    avg: "K.a.: ",
                    min: "Min: ",
                    max: "Max: "
                },
                pinning: {
                    pinLeft: "Lukitse vasemmalle",
                    pinRight: "Lukitse oikealle",
                    unpin: "Poista lukitus"
                },
                gridMenu: {
                    columns: "Sarakkeet:",
                    importerTitle: "Tuo tiedosto",
                    exporterAllAsCsv: "Vie tiedot csv-muodossa",
                    exporterVisibleAsCsv: "Vie näkyvä tieto csv-muodossa",
                    exporterSelectedAsCsv: "Vie valittu tieto csv-muodossa",
                    exporterAllAsPdf: "Vie tiedot pdf-muodossa",
                    exporterVisibleAsPdf: "Vie näkyvä tieto pdf-muodossa",
                    exporterSelectedAsPdf: "Vie valittu tieto pdf-muodossa",
                    clearAllFilters: "Puhdista kaikki suodattimet"
                },
                importer: {
                    noHeaders: "Sarakkeen nimiä ei voitu päätellä, onko tiedostossa otsikkoriviä?",
                    noObjects: "Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?",
                    invalidCsv: "Tiedostoa ei voitu käsitellä, oliko se CSV-muodossa?",
                    invalidJson: "Tiedostoa ei voitu käsitellä, oliko se JSON-muodossa?",
                    jsonNotArray: "Tiedosto ei sisältänyt taulukkoa, lopetetaan."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("fr", {
                aggregate: {
                    label: "éléments"
                },
                groupPanel: {
                    description: "Faites glisser une en-tête de colonne ici pour créer un groupe de colonnes."
                },
                search: {
                    placeholder: "Recherche...",
                    showingItems: "Affichage des éléments :",
                    selectedItems: "Éléments sélectionnés :",
                    totalItems: "Nombre total d'éléments:",
                    size: "Taille de page:",
                    first: "Première page",
                    next: "Page Suivante",
                    previous: "Page précédente",
                    last: "Dernière page"
                },
                menu: {
                    text: "Choisir des colonnes :"
                },
                sort: {
                    ascending: "Trier par ordre croissant",
                    descending: "Trier par ordre décroissant",
                    remove: "Enlever le tri"
                },
                column: {
                    hide: "Cacher la colonne"
                },
                aggregation: {
                    count: "lignes totales: ",
                    sum: "total: ",
                    avg: "moy: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Épingler à gauche",
                    pinRight: "Épingler à droite",
                    unpin: "Détacher"
                },
                gridMenu: {
                    columns: "Colonnes:",
                    importerTitle: "Importer un fichier",
                    exporterAllAsCsv: "Exporter toutes les données en CSV",
                    exporterVisibleAsCsv: "Exporter les données visibles en CSV",
                    exporterSelectedAsCsv: "Exporter les données sélectionnées en CSV",
                    exporterAllAsPdf: "Exporter toutes les données en PDF",
                    exporterVisibleAsPdf: "Exporter les données visibles en PDF",
                    exporterSelectedAsPdf: "Exporter les données sélectionnées en PDF",
                    clearAllFilters: "Nettoyez tous les filtres"
                },
                importer: {
                    noHeaders: "Impossible de déterminer le nom des colonnes, le fichier possède-t-il une en-tête ?",
                    noObjects: "Aucun objet trouvé, le fichier possède-t-il des données autres que l'en-tête ?",
                    invalidCsv: "Le fichier n'a pas pu être traité, le CSV est-il valide ?",
                    invalidJson: "Le fichier n'a pas pu être traité, le JSON est-il valide ?",
                    jsonNotArray: "Le fichier JSON importé doit contenir un tableau, abandon."
                },
                pagination: {
                    sizes: "éléments par page",
                    totalItems: "éléments",
                    of: "sur"
                },
                grouping: {
                    group: "Grouper",
                    ungroup: "Dégrouper",
                    aggregate_count: "Agg: Compte",
                    aggregate_sum: "Agg: Somme",
                    aggregate_max: "Agg: Max",
                    aggregate_min: "Agg: Min",
                    aggregate_avg: "Agg: Moy",
                    aggregate_remove: "Agg: Retirer"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("he", {
                aggregate: {
                    label: "items"
                },
                groupPanel: {
                    description: "גרור עמודה לכאן ושחרר בכדי לקבץ עמודה זו."
                },
                search: {
                    placeholder: "חפש...",
                    showingItems: "מציג:",
                    selectedItems: 'סה"כ נבחרו:',
                    totalItems: 'סה"כ רשומות:',
                    size: "תוצאות בדף:",
                    first: "דף ראשון",
                    next: "דף הבא",
                    previous: "דף קודם",
                    last: "דף אחרון"
                },
                menu: {
                    text: "בחר עמודות:"
                },
                sort: {
                    ascending: "סדר עולה",
                    descending: "סדר יורד",
                    remove: "בטל"
                },
                column: {
                    hide: "טור הסתר"
                },
                aggregation: {
                    count: "total rows: ",
                    sum: "total: ",
                    avg: "avg: ",
                    min: "min: ",
                    max: "max: "
                },
                gridMenu: {
                    columns: "Columns:",
                    importerTitle: "Import file",
                    exporterAllAsCsv: "导出所有数据到CSV文件",
                    exporterVisibleAsCsv: "导出当前页数据到CSV文件",
                    exporterSelectedAsCsv: "导出选中数据到CSV文件",
                    exporterAllAsPdf: "导出所有数据到PDF文件",
                    exporterVisibleAsPdf: "导出当前页数据到PDF文件",
                    exporterSelectedAsPdf: "导出选中数据到PDF文件",
                    clearAllFilters: "Clean all filters"
                },
                importer: {
                    noHeaders: "Column names were unable to be derived, does the file have a header?",
                    noObjects: "Objects were not able to be derived, was there data in the file other than headers?",
                    invalidCsv: "File was unable to be processed, is it valid CSV?",
                    invalidJson: "File was unable to be processed, is it valid Json?",
                    jsonNotArray: "Imported json file must contain an array, aborting."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("hy", {
                aggregate: {
                    label: "տվյալներ"
                },
                groupPanel: {
                    description: "Ըստ սյան խմբավորելու համար քաշեք և գցեք վերնագիրն այստեղ։"
                },
                search: {
                    placeholder: "Փնտրում...",
                    showingItems: "Ցուցադրված տվյալներ՝",
                    selectedItems: "Ընտրված:",
                    totalItems: "Ընդամենը՝",
                    size: "Տողերի քանակը էջում՝",
                    first: "Առաջին էջ",
                    next: "Հաջորդ էջ",
                    previous: "Նախորդ էջ",
                    last: "Վերջին էջ"
                },
                menu: {
                    text: "Ընտրել սյուները:"
                },
                sort: {
                    ascending: "Աճման կարգով",
                    descending: "Նվազման կարգով",
                    remove: "Հանել "
                },
                column: {
                    hide: "Թաքցնել սյունը"
                },
                aggregation: {
                    count: "ընդամենը տող՝ ",
                    sum: "ընդամենը՝ ",
                    avg: "միջին՝ ",
                    min: "մին՝ ",
                    max: "մաքս՝ "
                },
                pinning: {
                    pinLeft: "Կպցնել ձախ կողմում",
                    pinRight: "Կպցնել աջ կողմում",
                    unpin: "Արձակել"
                },
                gridMenu: {
                    columns: "Սյուներ:",
                    importerTitle: "Ներմուծել ֆայլ",
                    exporterAllAsCsv: "Արտահանել ամբողջը CSV",
                    exporterVisibleAsCsv: "Արտահանել երևացող տվյալները CSV",
                    exporterSelectedAsCsv: "Արտահանել ընտրված տվյալները CSV",
                    exporterAllAsPdf: "Արտահանել PDF",
                    exporterVisibleAsPdf: "Արտահանել երևացող տվյալները PDF",
                    exporterSelectedAsPdf: "Արտահանել ընտրված տվյալները PDF",
                    clearAllFilters: "Մաքրել բոլոր ֆիլտրերը"
                },
                importer: {
                    noHeaders: "Հնարավոր չեղավ որոշել սյան վերնագրերը։ Արդյո՞ք ֆայլը ունի վերնագրեր։",
                    noObjects: "Հնարավոր չեղավ կարդալ տվյալները։ Արդյո՞ք ֆայլում կան տվյալներ։",
                    invalidCsv: "Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր CSV է։",
                    invalidJson: "Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր Json է։",
                    jsonNotArray: "Ներմուծված json ֆայլը պետք է պարունակի զանգված, կասեցվում է։"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("it", {
                aggregate: {
                    label: "elementi"
                },
                groupPanel: {
                    description: "Trascina un'intestazione all'interno del gruppo della colonna."
                },
                search: {
                    placeholder: "Ricerca...",
                    showingItems: "Mostra:",
                    selectedItems: "Selezionati:",
                    totalItems: "Totali:",
                    size: "Tot Pagine:",
                    first: "Prima",
                    next: "Prossima",
                    previous: "Precedente",
                    last: "Ultima"
                },
                menu: {
                    text: "Scegli le colonne:"
                },
                sort: {
                    ascending: "Asc.",
                    descending: "Desc.",
                    remove: "Annulla ordinamento"
                },
                column: {
                    hide: "Nascondi"
                },
                aggregation: {
                    count: "righe totali: ",
                    sum: "tot: ",
                    avg: "media: ",
                    min: "minimo: ",
                    max: "massimo: "
                },
                pinning: {
                    pinLeft: "Blocca a sx",
                    pinRight: "Blocca a dx",
                    unpin: "Blocca in alto"
                },
                gridMenu: {
                    columns: "Colonne:",
                    importerTitle: "Importa",
                    exporterAllAsCsv: "Esporta tutti i dati in CSV",
                    exporterVisibleAsCsv: "Esporta i dati visibili in CSV",
                    exporterSelectedAsCsv: "Esporta i dati selezionati in CSV",
                    exporterAllAsPdf: "Esporta tutti i dati in PDF",
                    exporterVisibleAsPdf: "Esporta i dati visibili in PDF",
                    exporterSelectedAsPdf: "Esporta i dati selezionati in PDF",
                    clearAllFilters: "Pulire tutti i filtri"
                },
                importer: {
                    noHeaders: "Impossibile reperire i nomi delle colonne, sicuro che siano indicati all'interno del file?",
                    noObjects: "Impossibile reperire gli oggetti, sicuro che siano indicati all'interno del file?",
                    invalidCsv: "Impossibile elaborare il file, sicuro che sia un CSV?",
                    invalidJson: "Impossibile elaborare il file, sicuro che sia un JSON valido?",
                    jsonNotArray: "Errore! Il file JSON da importare deve contenere un array."
                },
                grouping: {
                    group: "Raggruppa",
                    ungroup: "Separa",
                    aggregate_count: "Agg: N. Elem.",
                    aggregate_sum: "Agg: Somma",
                    aggregate_max: "Agg: Massimo",
                    aggregate_min: "Agg: Minimo",
                    aggregate_avg: "Agg: Media",
                    aggregate_remove: "Agg: Rimuovi"
                },
                validate: {
                    error: "Errore:",
                    minLength: "Lunghezza minima pari a THRESHOLD caratteri.",
                    maxLength: "Lunghezza massima pari a THRESHOLD caratteri.",
                    required: "Necessario inserire un valore."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("ja", {
                aggregate: {
                    label: "項目"
                },
                groupPanel: {
                    description: "ここに列ヘッダをドラッグアンドドロップして、その列でグループ化します。"
                },
                search: {
                    placeholder: "検索...",
                    showingItems: "表示中の項目:",
                    selectedItems: "選択した項目:",
                    totalItems: "項目の総数:",
                    size: "ページサイズ:",
                    first: "最初のページ",
                    next: "次のページ",
                    previous: "前のページ",
                    last: "前のページ"
                },
                menu: {
                    text: "列の選択:"
                },
                sort: {
                    ascending: "昇順に並べ替え",
                    descending: "降順に並べ替え",
                    remove: "並べ替えの解除"
                },
                column: {
                    hide: "列の非表示"
                },
                aggregation: {
                    count: "合計行数: ",
                    sum: "合計: ",
                    avg: "平均: ",
                    min: "最小: ",
                    max: "最大: "
                },
                pinning: {
                    pinLeft: "左に固定",
                    pinRight: "右に固定",
                    unpin: "固定解除"
                },
                gridMenu: {
                    columns: "列:",
                    importerTitle: "ファイルのインポート",
                    exporterAllAsCsv: "すべてのデータをCSV形式でエクスポート",
                    exporterVisibleAsCsv: "表示中のデータをCSV形式でエクスポート",
                    exporterSelectedAsCsv: "選択したデータをCSV形式でエクスポート",
                    exporterAllAsPdf: "すべてのデータをPDF形式でエクスポート",
                    exporterVisibleAsPdf: "表示中のデータをPDF形式でエクスポート",
                    exporterSelectedAsPdf: "選択したデータをPDF形式でエクスポート",
                    clearAllFilters: "すべてのフィルタを清掃してください"
                },
                importer: {
                    noHeaders: "列名を取得できません。ファイルにヘッダが含まれていることを確認してください。",
                    noObjects: "オブジェクトを取得できません。ファイルにヘッダ以外のデータが含まれていることを確認してください。",
                    invalidCsv: "ファイルを処理できません。ファイルが有効なCSV形式であることを確認してください。",
                    invalidJson: "ファイルを処理できません。ファイルが有効なJSON形式であることを確認してください。",
                    jsonNotArray: "インポートしたJSONファイルには配列が含まれている必要があります。処理を中止します。"
                },
                pagination: {
                    sizes: "項目/ページ",
                    totalItems: "項目"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("ko", {
                aggregate: {
                    label: "아이템"
                },
                groupPanel: {
                    description: "컬럼으로 그룹핑하기 위해서는 컬럼 헤더를 끌어 떨어뜨려 주세요."
                },
                search: {
                    placeholder: "검색...",
                    showingItems: "항목 보여주기:",
                    selectedItems: "선택 항목:",
                    totalItems: "전체 항목:",
                    size: "페이지 크기:",
                    first: "첫번째 페이지",
                    next: "다음 페이지",
                    previous: "이전 페이지",
                    last: "마지막 페이지"
                },
                menu: {
                    text: "컬럼을 선택하세요:"
                },
                sort: {
                    ascending: "오름차순 정렬",
                    descending: "내림차순 정렬",
                    remove: "소팅 제거"
                },
                column: {
                    hide: "컬럼 제거"
                },
                aggregation: {
                    count: "전체 갯수: ",
                    sum: "전체: ",
                    avg: "평균: ",
                    min: "최소: ",
                    max: "최대: "
                },
                pinning: {
                    pinLeft: "왼쪽 핀",
                    pinRight: "오른쪽 핀",
                    unpin: "핀 제거"
                },
                gridMenu: {
                    columns: "컬럼:",
                    importerTitle: "파일 가져오기",
                    exporterAllAsCsv: "csv로 모든 데이터 내보내기",
                    exporterVisibleAsCsv: "csv로 보이는 데이터 내보내기",
                    exporterSelectedAsCsv: "csv로 선택된 데이터 내보내기",
                    exporterAllAsPdf: "pdf로 모든 데이터 내보내기",
                    exporterVisibleAsPdf: "pdf로 보이는 데이터 내보내기",
                    exporterSelectedAsPdf: "pdf로 선택 데이터 내보내기",
                    clearAllFilters: "모든 필터를 청소"
                },
                importer: {
                    noHeaders: "컬럼명이 지정되어 있지 않습니다. 파일에 헤더가 명시되어 있는지 확인해 주세요.",
                    noObjects: "데이터가 지정되어 있지 않습니다. 데이터가 파일에 있는지 확인해 주세요.",
                    invalidCsv: "파일을 처리할 수 없습니다. 올바른 csv인지 확인해 주세요.",
                    invalidJson: "파일을 처리할 수 없습니다. 올바른 json인지 확인해 주세요.",
                    jsonNotArray: "json 파일은 배열을 포함해야 합니다."
                },
                pagination: {
                    sizes: "페이지당 항목",
                    totalItems: "전체 항목"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("nl", {
                aggregate: {
                    label: "items"
                },
                groupPanel: {
                    description: "Sleep hier een kolomnaam heen om op te groeperen."
                },
                search: {
                    placeholder: "Zoeken...",
                    showingItems: "Getoonde items:",
                    selectedItems: "Geselecteerde items:",
                    totalItems: "Totaal aantal items:",
                    size: "Items per pagina:",
                    first: "Eerste pagina",
                    next: "Volgende pagina",
                    previous: "Vorige pagina",
                    last: "Laatste pagina"
                },
                menu: {
                    text: "Kies kolommen:"
                },
                sort: {
                    ascending: "Sorteer oplopend",
                    descending: "Sorteer aflopend",
                    remove: "Verwijder sortering"
                },
                column: {
                    hide: "Verberg kolom"
                },
                aggregation: {
                    count: "Aantal rijen: ",
                    sum: "Som: ",
                    avg: "Gemiddelde: ",
                    min: "Min: ",
                    max: "Max: "
                },
                pinning: {
                    pinLeft: "Zet links vast",
                    pinRight: "Zet rechts vast",
                    unpin: "Maak los"
                },
                gridMenu: {
                    columns: "Kolommen:",
                    importerTitle: "Importeer bestand",
                    exporterAllAsCsv: "Exporteer alle data als csv",
                    exporterVisibleAsCsv: "Exporteer zichtbare data als csv",
                    exporterSelectedAsCsv: "Exporteer geselecteerde data als csv",
                    exporterAllAsPdf: "Exporteer alle data als pdf",
                    exporterVisibleAsPdf: "Exporteer zichtbare data als pdf",
                    exporterSelectedAsPdf: "Exporteer geselecteerde data als pdf",
                    clearAllFilters: "Reinig alle filters"
                },
                importer: {
                    noHeaders: "Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?",
                    noObjects: "Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?",
                    invalidCsv: "Het bestand kan niet verwerkt worden. Is het een valide csv bestand?",
                    invalidJson: "Het bestand kan niet verwerkt worden. Is het valide json?",
                    jsonNotArray: "Het json bestand moet een array bevatten. De actie wordt geannuleerd."
                },
                pagination: {
                    sizes: "items per pagina",
                    totalItems: "items",
                    of: "van de"
                },
                grouping: {
                    group: "Groepeer",
                    ungroup: "Groepering opheffen",
                    aggregate_count: "Agg: Aantal",
                    aggregate_sum: "Agg: Som",
                    aggregate_max: "Agg: Max",
                    aggregate_min: "Agg: Min",
                    aggregate_avg: "Agg: Gem",
                    aggregate_remove: "Agg: Verwijder"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("pl", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filter dla kolumny",
                        removeFilter: "Usuń filter",
                        columnMenuButtonLabel: "Menu kolumny"
                    },
                    priority: "Prioritet:",
                    filterLabel: "Filtr dla kolumny: "
                },
                aggregate: {
                    label: "pozycji"
                },
                groupPanel: {
                    description: "Przeciągnij nagłówek kolumny tutaj, aby pogrupować według niej."
                },
                search: {
                    placeholder: "Szukaj...",
                    showingItems: "Widoczne pozycje:",
                    selectedItems: "Zaznaczone pozycje:",
                    totalItems: "Wszystkich pozycji:",
                    size: "Rozmiar strony:",
                    first: "Pierwsza strona",
                    next: "Następna strona",
                    previous: "Poprzednia strona",
                    last: "Ostatnia strona"
                },
                menu: {
                    text: "Wybierz kolumny:"
                },
                sort: {
                    ascending: "Sortuj rosnąco",
                    descending: "Sortuj malejąco",
                    none: "Brak sortowania",
                    remove: "Wyłącz sortowanie"
                },
                column: {
                    hide: "Ukryj kolumne"
                },
                aggregation: {
                    count: "Razem pozycji: ",
                    sum: "Razem: ",
                    avg: "Średnia: ",
                    min: "Min: ",
                    max: "Max: "
                },
                pinning: {
                    pinLeft: "Przypnij do lewej",
                    pinRight: "Przypnij do prawej",
                    unpin: "Odepnij"
                },
                columnMenu: {
                    close: "Zamknij"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Menu Grida"
                    },
                    columns: "Kolumny:",
                    importerTitle: "Importuj plik",
                    exporterAllAsCsv: "Eksportuj wszystkie dane do csv",
                    exporterVisibleAsCsv: "Eksportuj widoczne dane do csv",
                    exporterSelectedAsCsv: "Eksportuj zaznaczone dane do csv",
                    exporterAllAsPdf: "Eksportuj wszystkie dane do pdf",
                    exporterVisibleAsPdf: "Eksportuj widoczne dane do pdf",
                    exporterSelectedAsPdf: "Eksportuj zaznaczone dane do pdf",
                    clearAllFilters: "Wyczyść filtry"
                },
                importer: {
                    noHeaders: "Nie udało się wczytać nazw kolumn. Czy plik posiada nagłówek?",
                    noObjects: "Nie udalo się wczytać pozycji. Czy plik zawiera dane??",
                    invalidCsv: "Nie udało się przetworzyć pliku, jest to prawidlowy plik CSV??",
                    invalidJson: "Nie udało się przetworzyć pliku, jest to prawidlowy plik Json?",
                    jsonNotArray: "Importowany plik json musi zawierać tablicę, importowanie przerwane."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Pierwsza strona",
                        pageBack: "Poprzednia strona",
                        pageSelected: "Wybrana strona",
                        pageForward: "Następna strona",
                        pageToLast: "Ostatnia strona"
                    },
                    sizes: "pozycji na stronę",
                    totalItems: "pozycji",
                    through: "do",
                    of: "z"
                },
                grouping: {
                    group: "Grupuj",
                    ungroup: "Rozgrupuj",
                    aggregate_count: "Zbiorczo: Razem",
                    aggregate_sum: "Zbiorczo: Suma",
                    aggregate_max: "Zbiorczo: Max",
                    aggregate_min: "Zbiorczo: Min",
                    aggregate_avg: "Zbiorczo: Średnia",
                    aggregate_remove: "Zbiorczo: Usuń"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("pt-br", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filtro por coluna",
                        removeFilter: "Remover filtro",
                        columnMenuButtonLabel: "Menu coluna"
                    },
                    priority: "Prioridade:",
                    filterLabel: "Filtro por coluna: "
                },
                aggregate: {
                    label: "itens"
                },
                groupPanel: {
                    description: "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                search: {
                    placeholder: "Procurar...",
                    showingItems: "Mostrando os Itens:",
                    selectedItems: "Items Selecionados:",
                    totalItems: "Total de Itens:",
                    size: "Tamanho da Página:",
                    first: "Primeira Página",
                    next: "Próxima Página",
                    previous: "Página Anterior",
                    last: "Última Página"
                },
                menu: {
                    text: "Selecione as colunas:"
                },
                sort: {
                    ascending: "Ordenar Ascendente",
                    descending: "Ordenar Descendente",
                    none: "Nenhuma Ordem",
                    remove: "Remover Ordenação"
                },
                column: {
                    hide: "Esconder coluna"
                },
                aggregation: {
                    count: "total de linhas: ",
                    sum: "total: ",
                    avg: "med: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Fixar Esquerda",
                    pinRight: "Fixar Direita",
                    unpin: "Desprender"
                },
                columnMenu: {
                    close: "Fechar"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Menu Grid"
                    },
                    columns: "Colunas:",
                    importerTitle: "Importar arquivo",
                    exporterAllAsCsv: "Exportar todos os dados como csv",
                    exporterVisibleAsCsv: "Exportar dados visíveis como csv",
                    exporterSelectedAsCsv: "Exportar dados selecionados como csv",
                    exporterAllAsPdf: "Exportar todos os dados como pdf",
                    exporterVisibleAsPdf: "Exportar dados visíveis como pdf",
                    exporterSelectedAsPdf: "Exportar dados selecionados como pdf",
                    clearAllFilters: "Limpar todos os filtros"
                },
                importer: {
                    noHeaders: "Nomes de colunas não puderam ser derivados. O arquivo tem um cabeçalho?",
                    noObjects: "Objetos não puderam ser derivados. Havia dados no arquivo, além dos cabeçalhos?",
                    invalidCsv: "Arquivo não pode ser processado. É um CSV válido?",
                    invalidJson: "Arquivo não pode ser processado. É um Json válido?",
                    jsonNotArray: "Arquivo json importado tem que conter um array. Abortando."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Primeira página",
                        pageBack: "Página anterior",
                        pageSelected: "Página Selecionada",
                        pageForward: "Proxima",
                        pageToLast: "Anterior"
                    },
                    sizes: "itens por página",
                    totalItems: "itens",
                    through: "através dos",
                    of: "de"
                },
                grouping: {
                    group: "Agrupar",
                    ungroup: "Desagrupar",
                    aggregate_count: "Agr: Contar",
                    aggregate_sum: "Agr: Soma",
                    aggregate_max: "Agr: Max",
                    aggregate_min: "Agr: Min",
                    aggregate_avg: "Agr: Med",
                    aggregate_remove: "Agr: Remover"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("pt", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filtro por coluna",
                        removeFilter: "Remover filtro",
                        columnMenuButtonLabel: "Menu coluna"
                    },
                    priority: "Prioridade:",
                    filterLabel: "Filtro por coluna: "
                },
                aggregate: {
                    label: "itens"
                },
                groupPanel: {
                    description: "Arraste e solte uma coluna aqui para agrupar por essa coluna"
                },
                search: {
                    placeholder: "Procurar...",
                    showingItems: "Mostrando os Itens:",
                    selectedItems: "Itens Selecionados:",
                    totalItems: "Total de Itens:",
                    size: "Tamanho da Página:",
                    first: "Primeira Página",
                    next: "Próxima Página",
                    previous: "Página Anterior",
                    last: "Última Página"
                },
                menu: {
                    text: "Selecione as colunas:"
                },
                sort: {
                    ascending: "Ordenar Ascendente",
                    descending: "Ordenar Descendente",
                    none: "Nenhuma Ordem",
                    remove: "Remover Ordenação"
                },
                column: {
                    hide: "Esconder coluna"
                },
                aggregation: {
                    count: "total de linhas: ",
                    sum: "total: ",
                    avg: "med: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Fixar Esquerda",
                    pinRight: "Fixar Direita",
                    unpin: "Desprender"
                },
                columnMenu: {
                    close: "Fechar"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Menu Grid"
                    },
                    columns: "Colunas:",
                    importerTitle: "Importar ficheiro",
                    exporterAllAsCsv: "Exportar todos os dados como csv",
                    exporterVisibleAsCsv: "Exportar dados visíveis como csv",
                    exporterSelectedAsCsv: "Exportar dados selecionados como csv",
                    exporterAllAsPdf: "Exportar todos os dados como pdf",
                    exporterVisibleAsPdf: "Exportar dados visíveis como pdf",
                    exporterSelectedAsPdf: "Exportar dados selecionados como pdf",
                    clearAllFilters: "Limpar todos os filtros"
                },
                importer: {
                    noHeaders: "Nomes de colunas não puderam ser derivados. O ficheiro tem um cabeçalho?",
                    noObjects: "Objetos não puderam ser derivados. Havia dados no ficheiro, além dos cabeçalhos?",
                    invalidCsv: "Ficheiro não pode ser processado. É um CSV válido?",
                    invalidJson: "Ficheiro não pode ser processado. É um Json válido?",
                    jsonNotArray: "Ficheiro json importado tem que conter um array. Interrompendo."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Primeira página",
                        pageBack: "Página anterior",
                        pageSelected: "Página Selecionada",
                        pageForward: "Próxima",
                        pageToLast: "Anterior"
                    },
                    sizes: "itens por página",
                    totalItems: "itens",
                    through: "através dos",
                    of: "de"
                },
                grouping: {
                    group: "Agrupar",
                    ungroup: "Desagrupar",
                    aggregate_count: "Agr: Contar",
                    aggregate_sum: "Agr: Soma",
                    aggregate_max: "Agr: Max",
                    aggregate_min: "Agr: Min",
                    aggregate_avg: "Agr: Med",
                    aggregate_remove: "Agr: Remover"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("ro", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Filtru pentru coloana",
                        removeFilter: "Sterge filtru",
                        columnMenuButtonLabel: "Column Menu"
                    },
                    priority: "Prioritate:",
                    filterLabel: "Filtru pentru coloana:"
                },
                aggregate: {
                    label: "Elemente"
                },
                groupPanel: {
                    description: "Trage un cap de coloana aici pentru a grupa elementele dupa coloana respectiva"
                },
                search: {
                    placeholder: "Cauta...",
                    showingItems: "Arata elementele:",
                    selectedItems: "Elementele selectate:",
                    totalItems: "Total elemente:",
                    size: "Marime pagina:",
                    first: "Prima pagina",
                    next: "Pagina urmatoare",
                    previous: "Pagina anterioara",
                    last: "Ultima pagina"
                },
                menu: {
                    text: "Alege coloane:"
                },
                sort: {
                    ascending: "Ordoneaza crescator",
                    descending: "Ordoneaza descrescator",
                    none: "Fara ordonare",
                    remove: "Sterge ordonarea"
                },
                column: {
                    hide: "Ascunde coloana"
                },
                aggregation: {
                    count: "total linii: ",
                    sum: "total: ",
                    avg: "medie: ",
                    min: "min: ",
                    max: "max: "
                },
                pinning: {
                    pinLeft: "Pin la stanga",
                    pinRight: "Pin la dreapta",
                    unpin: "Sterge pinul"
                },
                columnMenu: {
                    close: "Inchide"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Grid Menu"
                    },
                    columns: "Coloane:",
                    importerTitle: "Incarca fisier",
                    exporterAllAsCsv: "Exporta toate datele ca csv",
                    exporterVisibleAsCsv: "Exporta datele vizibile ca csv",
                    exporterSelectedAsCsv: "Exporta datele selectate ca csv",
                    exporterAllAsPdf: "Exporta toate datele ca pdf",
                    exporterVisibleAsPdf: "Exporta datele vizibile ca pdf",
                    exporterSelectedAsPdf: "Exporta datele selectate ca csv pdf",
                    clearAllFilters: "Sterge toate filtrele"
                },
                importer: {
                    noHeaders: "Numele coloanelor nu a putut fi incarcat, acest fisier are un header?",
                    noObjects: "Datele nu au putut fi incarcate, exista date in fisier in afara numelor de coloane?",
                    invalidCsv: "Fisierul nu a putut fi procesat, ati incarcat un CSV valid ?",
                    invalidJson: "Fisierul nu a putut fi procesat, ati incarcat un Json valid?",
                    jsonNotArray: "Json-ul incarcat trebuie sa contina un array, inchidere."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Prima pagina",
                        pageBack: "O pagina inapoi",
                        pageSelected: "Pagina selectata",
                        pageForward: "O pagina inainte",
                        pageToLast: "Ultima pagina"
                    },
                    sizes: "Elemente per pagina",
                    totalItems: "elemente",
                    through: "prin",
                    of: "of"
                },
                grouping: {
                    group: "Grupeaza",
                    ungroup: "Opreste gruparea",
                    aggregate_count: "Agg: Count",
                    aggregate_sum: "Agg: Sum",
                    aggregate_max: "Agg: Max",
                    aggregate_min: "Agg: Min",
                    aggregate_avg: "Agg: Avg",
                    aggregate_remove: "Agg: Remove"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("ru", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Фильтр столбца",
                        removeFilter: "Удалить фильтр",
                        columnMenuButtonLabel: "Меню столбца"
                    },
                    priority: "Приоритет:",
                    filterLabel: "Фильтр столбца: "
                },
                aggregate: {
                    label: "элементы"
                },
                groupPanel: {
                    description: "Для группировки по столбцу перетащите сюда его название."
                },
                search: {
                    placeholder: "Поиск...",
                    showingItems: "Показать элементы:",
                    selectedItems: "Выбранные элементы:",
                    totalItems: "Всего элементов:",
                    size: "Размер страницы:",
                    first: "Первая страница",
                    next: "Следующая страница",
                    previous: "Предыдущая страница",
                    last: "Последняя страница"
                },
                menu: {
                    text: "Выбрать столбцы:"
                },
                sort: {
                    ascending: "По возрастанию",
                    descending: "По убыванию",
                    none: "Без сортировки",
                    remove: "Убрать сортировку"
                },
                column: {
                    hide: "Спрятать столбец"
                },
                aggregation: {
                    count: "всего строк: ",
                    sum: "итого: ",
                    avg: "среднее: ",
                    min: "мин: ",
                    max: "макс: "
                },
                pinning: {
                    pinLeft: "Закрепить слева",
                    pinRight: "Закрепить справа",
                    unpin: "Открепить"
                },
                columnMenu: {
                    close: "Закрыть"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Меню"
                    },
                    columns: "Столбцы:",
                    importerTitle: "Импортировать файл",
                    exporterAllAsCsv: "Экспортировать всё в CSV",
                    exporterVisibleAsCsv: "Экспортировать видимые данные в CSV",
                    exporterSelectedAsCsv: "Экспортировать выбранные данные в CSV",
                    exporterAllAsPdf: "Экспортировать всё в PDF",
                    exporterVisibleAsPdf: "Экспортировать видимые данные в PDF",
                    exporterSelectedAsPdf: "Экспортировать выбранные данные в PDF",
                    clearAllFilters: "Очистите все фильтры"
                },
                importer: {
                    noHeaders: "Не удалось получить названия столбцов, есть ли в файле заголовок?",
                    noObjects: "Не удалось получить данные, есть ли в файле строки кроме заголовка?",
                    invalidCsv: "Не удалось обработать файл, это правильный CSV-файл?",
                    invalidJson: "Не удалось обработать файл, это правильный JSON?",
                    jsonNotArray: "Импортируемый JSON-файл должен содержать массив, операция отменена."
                },
                pagination: {
                    aria: {
                        pageToFirst: "Первая страница",
                        pageBack: "Предыдущая страница",
                        pageSelected: "Выбранная страница",
                        pageForward: "Следующая страница",
                        pageToLast: "Последняя страница"
                    },
                    sizes: "строк на страницу",
                    totalItems: "строк",
                    through: "по",
                    of: "из"
                },
                grouping: {
                    group: "Группировать",
                    ungroup: "Разгруппировать",
                    aggregate_count: "Группировать: Count",
                    aggregate_sum: "Для группы: Сумма",
                    aggregate_max: "Для группы: Максимум",
                    aggregate_min: "Для группы: Минимум",
                    aggregate_avg: "Для группы: Среднее",
                    aggregate_remove: "Для группы: Пусто"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("sk", {
                aggregate: {
                    label: "items"
                },
                groupPanel: {
                    description: "Pretiahni sem názov stĺpca pre zoskupenie podľa toho stĺpca."
                },
                search: {
                    placeholder: "Hľadaj...",
                    showingItems: "Zobrazujem položky:",
                    selectedItems: "Vybraté položky:",
                    totalItems: "Počet položiek:",
                    size: "Počet:",
                    first: "Prvá strana",
                    next: "Ďalšia strana",
                    previous: "Predchádzajúca strana",
                    last: "Posledná strana"
                },
                menu: {
                    text: "Vyberte stĺpce:"
                },
                sort: {
                    ascending: "Zotriediť vzostupne",
                    descending: "Zotriediť zostupne",
                    remove: "Vymazať triedenie"
                },
                aggregation: {
                    count: "total rows: ",
                    sum: "total: ",
                    avg: "avg: ",
                    min: "min: ",
                    max: "max: "
                },
                gridMenu: {
                    columns: "Columns:",
                    importerTitle: "Import file",
                    exporterAllAsCsv: "导出所有数据到CSV文件",
                    exporterVisibleAsCsv: "导出当前页数据到CSV文件",
                    exporterSelectedAsCsv: "导出选中数据到CSV文件",
                    exporterAllAsPdf: "导出所有数据到PDF文件",
                    exporterVisibleAsPdf: "导出当前页数据到PDF文件",
                    exporterSelectedAsPdf: "导出选中数据到PDF文件",
                    clearAllFilters: "Clear all filters"
                },
                importer: {
                    noHeaders: "Column names were unable to be derived, does the file have a header?",
                    noObjects: "Objects were not able to be derived, was there data in the file other than headers?",
                    invalidCsv: "File was unable to be processed, is it valid CSV?",
                    invalidJson: "File was unable to be processed, is it valid Json?",
                    jsonNotArray: "Imported json file must contain an array, aborting."
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("sv", {
                aggregate: {
                    label: "Artiklar"
                },
                groupPanel: {
                    description: "Dra en kolumnrubrik hit och släpp den för att gruppera efter den kolumnen."
                },
                search: {
                    placeholder: "Sök...",
                    showingItems: "Visar artiklar:",
                    selectedItems: "Valda artiklar:",
                    totalItems: "Antal artiklar:",
                    size: "Sidstorlek:",
                    first: "Första sidan",
                    next: "Nästa sida",
                    previous: "Föregående sida",
                    last: "Sista sidan"
                },
                menu: {
                    text: "Välj kolumner:"
                },
                sort: {
                    ascending: "Sortera stigande",
                    descending: "Sortera fallande",
                    remove: "Inaktivera sortering"
                },
                column: {
                    hide: "Göm kolumn"
                },
                aggregation: {
                    count: "Antal rader: ",
                    sum: "Summa: ",
                    avg: "Genomsnitt: ",
                    min: "Min: ",
                    max: "Max: "
                },
                pinning: {
                    pinLeft: "Fäst vänster",
                    pinRight: "Fäst höger",
                    unpin: "Lösgör"
                },
                gridMenu: {
                    columns: "Kolumner:",
                    importerTitle: "Importera fil",
                    exporterAllAsCsv: "Exportera all data som CSV",
                    exporterVisibleAsCsv: "Exportera synlig data som CSV",
                    exporterSelectedAsCsv: "Exportera markerad data som CSV",
                    exporterAllAsPdf: "Exportera all data som PDF",
                    exporterVisibleAsPdf: "Exportera synlig data som PDF",
                    exporterSelectedAsPdf: "Exportera markerad data som PDF",
                    clearAllFilters: "Rengör alla filter"
                },
                importer: {
                    noHeaders: "Kolumnnamn kunde inte härledas. Har filen ett sidhuvud?",
                    noObjects: "Objekt kunde inte härledas. Har filen data undantaget sidhuvud?",
                    invalidCsv: "Filen kunde inte behandlas, är den en giltig CSV?",
                    invalidJson: "Filen kunde inte behandlas, är den en giltig JSON?",
                    jsonNotArray: "Importerad JSON-fil måste innehålla ett fält. Import avbruten."
                },
                pagination: {
                    sizes: "Artiklar per sida",
                    totalItems: "Artiklar"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("ta", {
                aggregate: {
                    label: "உருப்படிகள்"
                },
                groupPanel: {
                    description: "ஒரு பத்தியை குழுவாக அமைக்க அப்பத்தியின் தலைப்பை இங்கே  இழுத்து வரவும் "
                },
                search: {
                    placeholder: "தேடல் ...",
                    showingItems: "உருப்படிகளை காண்பித்தல்:",
                    selectedItems: "தேர்ந்தெடுக்கப்பட்ட  உருப்படிகள்:",
                    totalItems: "மொத்த உருப்படிகள்:",
                    size: "பக்க அளவு: ",
                    first: "முதல் பக்கம்",
                    next: "அடுத்த பக்கம்",
                    previous: "முந்தைய பக்கம் ",
                    last: "இறுதி பக்கம்"
                },
                menu: {
                    text: "பத்திகளை தேர்ந்தெடு:"
                },
                sort: {
                    ascending: "மேலிருந்து கீழாக",
                    descending: "கீழிருந்து மேலாக",
                    remove: "வரிசையை நீக்கு"
                },
                column: {
                    hide: "பத்தியை மறைத்து வை "
                },
                aggregation: {
                    count: "மொத்த வரிகள்:",
                    sum: "மொத்தம்: ",
                    avg: "சராசரி: ",
                    min: "குறைந்தபட்ச: ",
                    max: "அதிகபட்ச: "
                },
                pinning: {
                    pinLeft: "இடதுபுறமாக தைக்க ",
                    pinRight: "வலதுபுறமாக தைக்க",
                    unpin: "பிரி"
                },
                gridMenu: {
                    columns: "பத்திகள்:",
                    importerTitle: "கோப்பு : படித்தல்",
                    exporterAllAsCsv: "எல்லா தரவுகளையும் கோப்பாக்கு: csv",
                    exporterVisibleAsCsv: "இருக்கும் தரவுகளை கோப்பாக்கு: csv",
                    exporterSelectedAsCsv: "தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: csv",
                    exporterAllAsPdf: "எல்லா தரவுகளையும் கோப்பாக்கு: pdf",
                    exporterVisibleAsPdf: "இருக்கும் தரவுகளை கோப்பாக்கு: pdf",
                    exporterSelectedAsPdf: "தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: pdf",
                    clearAllFilters: "Clear all filters"
                },
                importer: {
                    noHeaders: "பத்தியின் தலைப்புகளை பெற இயலவில்லை, கோப்பிற்கு தலைப்பு உள்ளதா?",
                    noObjects: "இலக்குகளை உருவாக்க முடியவில்லை, கோப்பில் தலைப்புகளை தவிர தரவு ஏதேனும் உள்ளதா? ",
                    invalidCsv: "சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - csv",
                    invalidJson: "சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - json",
                    jsonNotArray: "படித்த கோப்பில் வரிசைகள் உள்ளது, நடைமுறை ரத்து செய் : json"
                },
                pagination: {
                    sizes: "உருப்படிகள் / பக்கம்",
                    totalItems: "உருப்படிகள் "
                },
                grouping: {
                    group: "குழு",
                    ungroup: "பிரி",
                    aggregate_count: "மதிப்பீட்டு : எண்ணு",
                    aggregate_sum: "மதிப்பீட்டு : கூட்டல்",
                    aggregate_max: "மதிப்பீட்டு : அதிகபட்சம்",
                    aggregate_min: "மதிப்பீட்டு : குறைந்தபட்சம்",
                    aggregate_avg: "மதிப்பீட்டு : சராசரி",
                    aggregate_remove: "மதிப்பீட்டு : நீக்கு"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("tr", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "Sütun için filtre",
                        removeFilter: "Filtreyi Kaldır",
                        columnMenuButtonLabel: "Sütun Menüsü"
                    },
                    priority: "Öncelik:",
                    filterLabel: "Sütun için filtre: "
                },
                aggregate: {
                    label: "kayıtlar"
                },
                groupPanel: {
                    description: "Sütuna göre gruplamak için sütun başlığını buraya sürükleyin ve bırakın."
                },
                search: {
                    placeholder: "Arama...",
                    showingItems: "Gösterilen Kayıt:",
                    selectedItems: "Seçili Kayıt:",
                    totalItems: "Toplam Kayıt:",
                    size: "Sayfa Boyutu:",
                    first: "İlk Sayfa",
                    next: "Sonraki Sayfa",
                    previous: "Önceki Sayfa",
                    last: "Son Sayfa"
                },
                menu: {
                    text: "Sütunları Seç:"
                },
                sort: {
                    ascending: "Artan Sırada Sırala",
                    descending: "Azalan Sırada Sırala",
                    none: "Sıralama Yapma",
                    remove: "Sıralamayı Kaldır"
                },
                column: {
                    hide: "Sütunu Gizle"
                },
                aggregation: {
                    count: "toplam satır: ",
                    sum: "toplam: ",
                    avg: "ort: ",
                    min: "min: ",
                    max: "maks: "
                },
                pinning: {
                    pinLeft: "Sola Sabitle",
                    pinRight: "Sağa Sabitle",
                    unpin: "Sabitlemeyi Kaldır"
                },
                columnMenu: {
                    close: "Kapat"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "Tablo Menü"
                    },
                    columns: "Sütunlar:",
                    importerTitle: "Dosya içeri aktar",
                    exporterAllAsCsv: "Bütün veriyi CSV olarak dışarı aktar",
                    exporterVisibleAsCsv: "Görünen veriyi CSV olarak dışarı aktar",
                    exporterSelectedAsCsv: "Seçili veriyi CSV olarak dışarı aktar",
                    exporterAllAsPdf: "Bütün veriyi PDF olarak dışarı aktar",
                    exporterVisibleAsPdf: "Görünen veriyi PDF olarak dışarı aktar",
                    exporterSelectedAsPdf: "Seçili veriyi PDF olarak dışarı aktar",
                    clearAllFilters: "Bütün filtreleri kaldır"
                },
                importer: {
                    noHeaders: "Sütun isimleri üretilemiyor, dosyanın bir başlığı var mı?",
                    noObjects: "Nesneler üretilemiyor, dosyada başlıktan başka bir veri var mı?",
                    invalidCsv: "Dosya işlenemedi, geçerli bir CSV dosyası mı?",
                    invalidJson: "Dosya işlenemedi, geçerli bir Json dosyası mı?",
                    jsonNotArray: "Alınan Json dosyasında bir dizi bulunmalıdır, işlem iptal ediliyor."
                },
                pagination: {
                    aria: {
                        pageToFirst: "İlk sayfaya",
                        pageBack: "Geri git",
                        pageSelected: "Seçili sayfa",
                        pageForward: "İleri git",
                        pageToLast: "Sona git"
                    },
                    sizes: "Sayfadaki nesne sayısı",
                    totalItems: "kayıtlar",
                    through: "",
                    of: ""
                },
                grouping: {
                    group: "Grupla",
                    ungroup: "Gruplama",
                    aggregate_count: "Yekun: Sayı",
                    aggregate_sum: "Yekun: Toplam",
                    aggregate_max: "Yekun: Maks",
                    aggregate_min: "Yekun: Min",
                    aggregate_avg: "Yekun: Ort",
                    aggregate_remove: "Yekun: Sil"
                }
            }),
            a
        }])
    }])
} (),
function() {
    var a = ["uiT", "uiTranslate"],
    b = ["t", "uiTranslate"],
    c = angular.module("ui.grid.i18n");
    c.constant("i18nConstants", {
        MISSING: "[MISSING]",
        UPDATE_EVENT: "$uiI18n",
        LOCALE_DIRECTIVE_ALIAS: "uiI18n",
        DEFAULT_LANG: "en"
    }),
    c.service("i18nService", ["$log", "i18nConstants", "$rootScope",
    function(a, b, c) {
        var d = {
            _langs: {},
            current: null,
            get: function(a) {
                return this._langs[a.toLowerCase()]
            },
            add: function(a, b) {
                var c = a.toLowerCase();
                this._langs[c] || (this._langs[c] = {}),
                angular.extend(this._langs[c], b)
            },
            getAllLangs: function() {
                var a = [];
                if (!this._langs) return a;
                for (var b in this._langs) a.push(b);
                return a
            },
            setCurrent: function(a) {
                this.current = a.toLowerCase()
            },
            getCurrentLang: function() {
                return this.current
            }
        },
        e = {
            add: function(a, b) {
                "object" == typeof a ? angular.forEach(a,
                function(a) {
                    a && d.add(a, b)
                }) : d.add(a, b)
            },
            getAllLangs: function() {
                return d.getAllLangs()
            },
            get: function(a) {
                var b = a ? a: e.getCurrentLang();
                return d.get(b)
            },
            getSafeText: function(a, c) {
                var f = c ? c: e.getCurrentLang(),
                g = d.get(f);
                if (!g) return b.MISSING;
                for (var h = a.split("."), i = g, j = 0; j < h.length; ++j) {
                    if (void 0 === i[h[j]] || null === i[h[j]]) return b.MISSING;
                    i = i[h[j]]
                }
                return i
            },
            setCurrentLang: function(a) {
                a && (d.setCurrent(a), c.$broadcast(b.UPDATE_EVENT))
            },
            getCurrentLang: function() {
                var a = d.getCurrentLang();
                return a || (a = b.DEFAULT_LANG, d.setCurrent(a)),
                a
            }
        };
        return e
    }]);
    var d = function(a, b) {
        return {
            compile: function() {
                return {
                    pre: function(c, d, e) {
                        var f = b.LOCALE_DIRECTIVE_ALIAS,
                        g = c.$eval(e[f]);
                        g ? c.$watch(e[f],
                        function() {
                            a.setCurrentLang(g)
                        }) : e.$$observers && e.$observe(f,
                        function() {
                            a.setCurrentLang(e[f] || b.DEFAULT_LANG)
                        })
                    }
                }
            }
        }
    };
    c.directive("uiI18n", ["i18nService", "i18nConstants", d]);
    var e = function(b, c, d) {
        return {
            restrict: "EA",
            compile: function() {
                return {
                    pre: function(e, f, g) {
                        var h, i = a[0],
                        j = a[1],
                        k = g[i] || g[j] || f.html(),
                        l = d.MISSING + k;
                        if (g.$$observers) {
                            var m = g[i] ? i: j;
                            h = g.$observe(m,
                            function(a) {
                                a && f.html(b(a)(c.getCurrentLang()) || l)
                            })
                        }
                        var n = b(k),
                        o = e.$on(d.UPDATE_EVENT,
                        function(a) {
                            h ? h(g[i] || g[j]) : f.html(n(c.get()) || l)
                        });
                        e.$on("$destroy", o),
                        f.html(n(c.get()) || l)
                    }
                }
            }
        }
    };
    angular.forEach(a,
    function(a) {
        c.directive(a, ["$parse", "i18nService", "i18nConstants", e])
    });
    var f = function(a, b, c) {
        return function(d) {
            var e = a(d);
            return e(b.get()) || c.MISSING + d
        }
    };
    angular.forEach(b,
    function(a) {
        c.filter(a, ["$parse", "i18nService", "i18nConstants", f])
    })
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("zh-cn", {
                headerCell: {
                    aria: {
                        defaultFilterLabel: "列过滤器",
                        removeFilter: "移除过滤器",
                        columnMenuButtonLabel: "列菜单"
                    },
                    priority: "优先级:",
                    filterLabel: "列过滤器: "
                },
                aggregate: {
                    label: "行"
                },
                groupPanel: {
                    description: "拖曳表头到此处进行分组"
                },
                search: {
                    placeholder: "查找",
                    showingItems: "已显示行数：",
                    selectedItems: "已选择行数：",
                    totalItems: "总行数：",
                    size: "每页显示行数：",
                    first: "首页",
                    next: "下一页",
                    previous: "上一页",
                    last: "末页"
                },
                menu: {
                    text: "选择列："
                },
                sort: {
                    ascending: "升序",
                    descending: "降序",
                    none: "无序",
                    remove: "取消排序"
                },
                column: {
                    hide: "隐藏列"
                },
                aggregation: {
                    count: "计数：",
                    sum: "求和：",
                    avg: "均值：",
                    min: "最小值：",
                    max: "最大值："
                },
                pinning: {
                    pinLeft: "左侧固定",
                    pinRight: "右侧固定",
                    unpin: "取消固定"
                },
                columnMenu: {
                    close: "关闭"
                },
                gridMenu: {
                    aria: {
                        buttonLabel: "表格菜单"
                    },
                    columns: "列：",
                    importerTitle: "导入文件",
                    exporterAllAsCsv: "导出全部数据到CSV",
                    exporterVisibleAsCsv: "导出可见数据到CSV",
                    exporterSelectedAsCsv: "导出已选数据到CSV",
                    exporterAllAsPdf: "导出全部数据到PDF",
                    exporterVisibleAsPdf: "导出可见数据到PDF",
                    exporterSelectedAsPdf: "导出已选数据到PDF",
                    clearAllFilters: "清除所有过滤器"
                },
                importer: {
                    noHeaders: "无法获取列名，确定文件包含表头？",
                    noObjects: "无法获取数据，确定文件包含数据？",
                    invalidCsv: "无法处理文件，确定是合法的CSV文件？",
                    invalidJson: "无法处理文件，确定是合法的JSON文件？",
                    jsonNotArray: "导入的文件不是JSON数组！"
                },
                pagination: {
                    aria: {
                        pageToFirst: "第一页",
                        pageBack: "上一页",
                        pageSelected: "当前页",
                        pageForward: "下一页",
                        pageToLast: "最后一页"
                    },
                    sizes: "行每页",
                    totalItems: "行",
                    through: "至",
                    of: "共"
                },
                grouping: {
                    group: "分组",
                    ungroup: "取消分组",
                    aggregate_count: "合计: 计数",
                    aggregate_sum: "合计: 求和",
                    aggregate_max: "合计: 最大",
                    aggregate_min: "合计: 最小",
                    aggregate_avg: "合计: 平均",
                    aggregate_remove: "合计: 移除"
                }
            }),
            a
        }])
    }])
} (),
function() {
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("i18nService", ["$delegate",
        function(a) {
            return a.add("zh-tw", {
                aggregate: {
                    label: "行"
                },
                groupPanel: {
                    description: "拖曳表頭到此處進行分組"
                },
                search: {
                    placeholder: "查找",
                    showingItems: "已顯示行數：",
                    selectedItems: "已選擇行數：",
                    totalItems: "總行數：",
                    size: "每頁顯示行數：",
                    first: "首頁",
                    next: "下壹頁",
                    previous: "上壹頁",
                    last: "末頁"
                },
                menu: {
                    text: "選擇列："
                },
                sort: {
                    ascending: "升序",
                    descending: "降序",
                    remove: "取消排序"
                },
                column: {
                    hide: "隱藏列"
                },
                aggregation: {
                    count: "計數：",
                    sum: "求和：",
                    avg: "均值：",
                    min: "最小值：",
                    max: "最大值："
                },
                pinning: {
                    pinLeft: "左側固定",
                    pinRight: "右側固定",
                    unpin: "取消固定"
                },
                gridMenu: {
                    columns: "列：",
                    importerTitle: "導入文件",
                    exporterAllAsCsv: "導出全部數據到CSV",
                    exporterVisibleAsCsv: "導出可見數據到CSV",
                    exporterSelectedAsCsv: "導出已選數據到CSV",
                    exporterAllAsPdf: "導出全部數據到PDF",
                    exporterVisibleAsPdf: "導出可見數據到PDF",
                    exporterSelectedAsPdf: "導出已選數據到PDF",
                    clearAllFilters: "清除所有过滤器"
                },
                importer: {
                    noHeaders: "無法獲取列名，確定文件包含表頭？",
                    noObjects: "無法獲取數據，確定文件包含數據？",
                    invalidCsv: "無法處理文件，確定是合法的CSV文件？",
                    invalidJson: "無法處理文件，確定是合法的JSON文件？",
                    jsonNotArray: "導入的文件不是JSON數組！"
                },
                pagination: {
                    sizes: "行每頁",
                    totalItems: "行"
                }
            }),
            a
        }])
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.autoResize", ["ui.grid"]);
    a.directive("uiGridAutoResize", ["$timeout", "gridUtil",
    function(a, b) {
        return {
            require: "uiGrid",
            scope: !1,
            link: function(a, c, d, e) {
                function f() {
                    i = b.elementHeight(c),
                    h = b.elementWidth(c)
                }
                function g() {
                    clearTimeout(j),
                    j = setTimeout(function() {
                        var d = b.elementHeight(c),
                        j = b.elementWidth(c);
                        d !== i || j !== h ? (e.grid.gridHeight = d, e.grid.gridWidth = j, a.$apply(function() {
                            e.grid.refresh().then(function() {
                                f(),
                                g()
                            })
                        })) : g()
                    },
                    250)
                }
                var h, i;
                f();
                var j;
                g(),
                a.$on("$destroy",
                function() {
                    clearTimeout(j)
                })
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.cellNav", ["ui.grid"]);
    a.constant("uiGridCellNavConstants", {
        FEATURE_NAME: "gridCellNav",
        CELL_NAV_EVENT: "cellNav",
        direction: {
            LEFT: 0,
            RIGHT: 1,
            UP: 2,
            DOWN: 3,
            PG_UP: 4,
            PG_DOWN: 5
        },
        EVENT_TYPE: {
            KEYDOWN: 0,
            CLICK: 1,
            CLEAR: 2
        }
    }),
    a.factory("uiGridCellNavFactory", ["gridUtil", "uiGridConstants", "uiGridCellNavConstants", "GridRowColumn", "$q",
    function(a, b, c, d, e) {
        var f = function(a, b, c, d) {
            this.rows = a.visibleRowCache,
            this.columns = b.visibleColumnCache,
            this.leftColumns = c ? c.visibleColumnCache: [],
            this.rightColumns = d ? d.visibleColumnCache: [],
            this.bodyContainer = a
        };
        return f.prototype.getFocusableCols = function() {
            var a = this.leftColumns.concat(this.columns, this.rightColumns);
            return a.filter(function(a) {
                return a.colDef.allowCellFocus
            })
        },
        f.prototype.getFocusableRows = function() {
            return this.rows.filter(function(a) {
                return a.allowCellFocus !== !1
            })
        },
        f.prototype.getNextRowCol = function(a, b, d) {
            switch (a) {
            case c.direction.LEFT:
                return this.getRowColLeft(b, d);
            case c.direction.RIGHT:
                return this.getRowColRight(b, d);
            case c.direction.UP:
                return this.getRowColUp(b, d);
            case c.direction.DOWN:
                return this.getRowColDown(b, d);
            case c.direction.PG_UP:
                return this.getRowColPageUp(b, d);
            case c.direction.PG_DOWN:
                return this.getRowColPageDown(b, d)
            }
        },
        f.prototype.initializeSelection = function() {
            var a = this.getFocusableCols(),
            b = this.getFocusableRows();
            if (0 === a.length || 0 === b.length) return null;
            return new d(b[0], a[0])
        },
        f.prototype.getRowColLeft = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a); - 1 === f && (f = 1);
            var h = 0 === f ? c.length - 1 : f - 1;
            return h > f ? 0 === g ? new d(a, c[h]) : new d(e[g - 1], c[h]) : new d(a, c[h])
        },
        f.prototype.getRowColRight = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a); - 1 === f && (f = 0);
            var h = f === c.length - 1 ? 0 : f + 1;
            return f > h ? g === e.length - 1 ? new d(a, c[h]) : new d(e[g + 1], c[h]) : new d(a, c[h])
        },
        f.prototype.getRowColDown = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a);
            return - 1 === f && (f = 0),
            g === e.length - 1 ? new d(a, c[f]) : new d(e[g + 1], c[f])
        },
        f.prototype.getRowColPageDown = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a); - 1 === f && (f = 0);
            var h = this.bodyContainer.minRowsToRender();
            return g >= e.length - h ? new d(e[e.length - 1], c[f]) : new d(e[g + h], c[f])
        },
        f.prototype.getRowColUp = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a);
            return - 1 === f && (f = 0),
            0 === g ? new d(a, c[f]) : new d(e[g - 1], c[f])
        },
        f.prototype.getRowColPageUp = function(a, b) {
            var c = this.getFocusableCols(),
            e = this.getFocusableRows(),
            f = c.indexOf(b),
            g = e.indexOf(a); - 1 === f && (f = 0);
            var h = this.bodyContainer.minRowsToRender();
            return 0 > g - h ? new d(e[0], c[f]) : new d(e[g - h], c[f])
        },
        f
    }]),
    a.service("uiGridCellNavService", ["gridUtil", "uiGridConstants", "uiGridCellNavConstants", "$q", "uiGridCellNavFactory", "GridRowColumn", "ScrollEvent",
    function(a, b, c, d, e, f, g) {
        var h = {
            initializeGrid: function(a) {
                a.registerColumnBuilder(h.cellNavColumnBuilder),
                a.cellNav = {},
                a.cellNav.lastRowCol = null,
                a.cellNav.focusedCells = [],
                h.defaultGridOptions(a.options);
                var b = {
                    events: {
                        cellNav: {
                            navigate: function(a, b) {},
                            viewPortKeyDown: function(a, b) {},
                            viewPortKeyPress: function(a, b) {}
                        }
                    },
                    methods: {
                        cellNav: {
                            scrollToFocus: function(b, c) {
                                return h.scrollToFocus(a, b, c)
                            },
                            getFocusedCell: function() {
                                return a.cellNav.lastRowCol
                            },
                            getCurrentSelection: function() {
                                return a.cellNav.focusedCells
                            },
                            rowColSelectIndex: function(b) {
                                for (var c = -1,
                                d = 0; d < a.cellNav.focusedCells.length; d++) if (a.cellNav.focusedCells[d].col.uid === b.col.uid && a.cellNav.focusedCells[d].row.uid === b.row.uid) {
                                    c = d;
                                    break
                                }
                                return c
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods)
            },
            defaultGridOptions: function(a) {
                a.modifierKeysToMultiSelectCells = a.modifierKeysToMultiSelectCells === !0
            },
            decorateRenderContainers: function(a) {
                var b = a.hasRightContainer() ? a.renderContainers.right: null,
                c = a.hasLeftContainer() ? a.renderContainers.left: null;
                null !== c && (a.renderContainers.left.cellNav = new e(a.renderContainers.body, c, b, a.renderContainers.body)),
                null !== b && (a.renderContainers.right.cellNav = new e(a.renderContainers.body, b, a.renderContainers.body, c)),
                a.renderContainers.body.cellNav = new e(a.renderContainers.body, a.renderContainers.body, c, b)
            },
            getDirection: function(a) {
                return a.keyCode === b.keymap.LEFT || a.keyCode === b.keymap.TAB && a.shiftKey ? c.direction.LEFT: a.keyCode === b.keymap.RIGHT || a.keyCode === b.keymap.TAB ? c.direction.RIGHT: a.keyCode === b.keymap.UP || a.keyCode === b.keymap.ENTER && a.shiftKey ? c.direction.UP: a.keyCode === b.keymap.PG_UP ? c.direction.PG_UP: a.keyCode === b.keymap.DOWN || a.keyCode === b.keymap.ENTER && !a.ctrlKey && !a.altKey ? c.direction.DOWN: a.keyCode === b.keymap.PG_DOWN ? c.direction.PG_DOWN: null
            },
            cellNavColumnBuilder: function(a, b, c) {
                var e = [];
                return a.allowCellFocus = void 0 === a.allowCellFocus ? !0 : a.allowCellFocus,
                d.all(e)
            },
            scrollToFocus: function(a, b, c) {
                var d = null,
                e = null;
                return "undefined" != typeof b && null !== b && (d = a.getRow(b)),
                "undefined" != typeof c && null !== c && (e = a.getColumn(c.name ? c.name: c.field)),
                a.api.core.scrollToIfNecessary(d, e).then(function() {
                    var b = {
                        row: d,
                        col: e
                    };
                    null !== d && null !== e && a.cellNav.broadcastCellNav(b)
                })
            },
            getLeftWidth: function(a, b) {
                var c = 0;
                if (!b) return c;
                var d = a.renderContainers.body.visibleColumnCache.indexOf(b);
                a.renderContainers.body.visibleColumnCache.forEach(function(a, b) {
                    d > b && (c += a.drawnWidth)
                });
                var e = 0 === d ? 0 : (d + 1) / a.renderContainers.body.visibleColumnCache.length;
                return c += b.drawnWidth * e
            }
        };
        return h
    }]),
    a.directive("uiGridCellnav", ["gridUtil", "uiGridCellNavService", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn", "$timeout", "$compile",
    function(a, b, c, d, e, f, g) {
        return {
            replace: !0,
            priority: -150,
            require: "^uiGrid",
            scope: !1,
            controller: function() {},
            compile: function() {
                return {
                    pre: function(a, f, g, h) {
                        var i = a,
                        j = h.grid;
                        b.initializeGrid(j),
                        h.cellNav = {},
                        h.cellNav.makeRowCol = function(a) {
                            return a instanceof e || (a = new e(a.row, a.col)),
                            a
                        },
                        h.cellNav.getActiveCell = function() {
                            var a = f[0].getElementsByClassName("ui-grid-cell-focus");
                            return a.length > 0 ? a[0] : void 0
                        },
                        h.cellNav.broadcastCellNav = j.cellNav.broadcastCellNav = function(a, b, d) {
                            b = !(void 0 === b || !b),
                            a = h.cellNav.makeRowCol(a),
                            h.cellNav.broadcastFocus(a, b, d),
                            i.$broadcast(c.CELL_NAV_EVENT, a, b, d)
                        },
                        h.cellNav.clearFocus = j.cellNav.clearFocus = function() {
                            j.cellNav.focusedCells = [],
                            i.$broadcast(c.CELL_NAV_EVENT)
                        },
                        h.cellNav.broadcastFocus = function(a, b, c) {
                            b = !(void 0 === b || !b),
                            a = h.cellNav.makeRowCol(a);
                            var d = a.row,
                            f = a.col,
                            g = h.grid.api.cellNav.rowColSelectIndex(a);
                            if (null === j.cellNav.lastRowCol || -1 === g) {
                                var i = new e(d, f); (null === j.cellNav.lastRowCol || j.cellNav.lastRowCol.row !== i.row || j.cellNav.lastRowCol.col !== i.col) && (j.api.cellNav.raise.navigate(i, j.cellNav.lastRowCol), j.cellNav.lastRowCol = i),
                                h.grid.options.modifierKeysToMultiSelectCells && b ? j.cellNav.focusedCells.push(a) : j.cellNav.focusedCells = [a]
                            } else j.options.modifierKeysToMultiSelectCells && b && g >= 0 && j.cellNav.focusedCells.splice(g, 1)
                        },
                        h.cellNav.handleKeyDown = function(a) {
                            var e = b.getDirection(a);
                            if (null === e) return null;
                            var f = "body";
                            a.uiGridTargetRenderContainerId && (f = a.uiGridTargetRenderContainerId);
                            var g = h.grid.api.cellNav.getFocusedCell();
                            if (g) {
                                var i = h.grid.renderContainers[f].cellNav.getNextRowCol(e, g.row, g.col),
                                k = h.grid.renderContainers[f].cellNav.getFocusableCols(),
                                l = h.grid.api.cellNav.rowColSelectIndex(i);
                                return e === c.direction.LEFT && i.col === k[k.length - 1] && i.row === g.row && a.keyCode === d.keymap.TAB && a.shiftKey ? (j.cellNav.focusedCells.splice(l, 1), h.cellNav.clearFocus(), !0) : e !== c.direction.RIGHT || i.col !== k[0] || i.row !== g.row || a.keyCode !== d.keymap.TAB || a.shiftKey ? (j.scrollToIfNecessary(i.row, i.col).then(function() {
                                    h.cellNav.broadcastCellNav(i)
                                }), a.stopPropagation(), a.preventDefault(), !1) : (j.cellNav.focusedCells.splice(l, 1), h.cellNav.clearFocus(), !0)
                            }
                        }
                    },
                    post: function(a, b, d, e) {
                        function f() {
                            var d = '<div id="' + h.id + '-aria-speakable" class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" aria-live="assertive" role="region" aria-atomic="true" aria-hidden="false" aria-relevant="additions" >&nbsp;</div>',
                            e = g(d)(a);
                            b.prepend(e),
                            a.$on(c.CELL_NAV_EVENT,
                            function(a, b, c, d) {
                                function f(a) {
                                    a !== e.text() && (e[0].style.clip = "rect(0px,0px,0px,0px)", e[0].innerHTML = "", e[0].style.visibility = "hidden", e[0].style.visibility = "visible", "" !== a && (e[0].style.clip = "auto", e[0].appendChild(document.createTextNode(a + " ")), e[0].style.visibility = "hidden", e[0].style.visibility = "visible"))
                                }
                                if (!d || "focus" !== d.type) {
                                    for (var g = [], i = h.api.cellNav.getCurrentSelection(), j = 0; j < i.length; j++) g.push(i[j].getIntersectionValueFiltered());
                                    var k = g.toString();
                                    f(k)
                                }
                            })
                        }
                        var h = e.grid;
                        f()
                    }
                }
            }
        }
    }]),
    a.directive("uiGridRenderContainer", ["$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "$compile", "uiGridCellNavConstants",
    function(a, b, c, d, e, f, g) {
        return {
            replace: !0,
            priority: -99999,
            require: ["^uiGrid", "uiGridRenderContainer", "?^uiGridCellnav"],
            scope: !1,
            compile: function() {
                return {
                    post: function(b, d, h, i) {
                        var j = i[0],
                        k = i[1],
                        l = i[2];
                        if (j.grid.api.cellNav) {
                            var m = k.containerId,
                            n = j.grid;
                            if (e.decorateRenderContainers(n), "body" === m) {
                                j.grid.options.modifierKeysToMultiSelectCells ? d.attr("aria-multiselectable", !0) : d.attr("aria-multiselectable", !1);
                                var o = f('<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' + n.id + "-aria-speakable " + n.id + '-grid-container" aria-owns="' + n.id + '-grid-container"></div>')(b);
                                d.append(o),
                                o.on("focus",
                                function(a) {
                                    a.uiGridTargetRenderContainerId = m;
                                    var b = j.grid.api.cellNav.getFocusedCell();
                                    null === b && (b = j.grid.renderContainers[m].cellNav.getNextRowCol(g.direction.DOWN, null, null), b.row && b.col && j.cellNav.broadcastCellNav(b))
                                }),
                                l.setAriaActivedescendant = function(a) {
                                    d.attr("aria-activedescendant", a)
                                },
                                l.removeAriaActivedescendant = function(a) {
                                    d.attr("aria-activedescendant") === a && d.attr("aria-activedescendant", "")
                                },
                                j.focus = function() {
                                    c.focus.byElement(o[0])
                                };
                                var p = null;
                                o.on("keydown",
                                function(a) {
                                    a.uiGridTargetRenderContainerId = m;
                                    var b = j.grid.api.cellNav.getFocusedCell(),
                                    c = j.cellNav.handleKeyDown(a);
                                    null === c && (j.grid.api.cellNav.raise.viewPortKeyDown(a, b), p = b)
                                }),
                                o.on("keypress",
                                function(b) {
                                    p && (a(function() {
                                        j.grid.api.cellNav.raise.viewPortKeyPress(b, p)
                                    },
                                    4), p = null)
                                }),
                                b.$on("$destroy",
                                function() {
                                    o.off()
                                })
                            }
                        }
                    }
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["$timeout", "$document", "gridUtil", "uiGridConstants", "uiGridCellNavService", "uiGridCellNavConstants", "$log", "$compile",
    function(a, b, c, d, e, f, g, h) {
        return {
            replace: !0,
            priority: -99999,
            require: ["^uiGrid", "^uiGridRenderContainer", "?^uiGridCellnav"],
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, b, c, d) {},
                    post: function(a, b, c, d) {
                        var e = d[0],
                        f = d[1];
                        if (e.grid.api.cellNav) {
                            var g = f.containerId;
                            if ("body" === g) {
                                var h = e.grid;
                                h.api.core.on.scrollBegin(a,
                                function(a) {
                                    var b = e.grid.api.cellNav.getFocusedCell();
                                    null !== b && f.colContainer.containsColumn(b.col) && e.cellNav.clearFocus()
                                }),
                                h.api.core.on.scrollEnd(a,
                                function(a) {
                                    var b = e.grid.api.cellNav.getFocusedCell();
                                    null !== b && f.colContainer.containsColumn(b.col) && e.cellNav.broadcastCellNav(b)
                                }),
                                h.api.cellNav.on.navigate(a,
                                function() {
                                    e.focus()
                                })
                            }
                        }
                    }
                }
            }
        }
    }]),
    a.directive("uiGridCell", ["$timeout", "$document", "uiGridCellNavService", "gridUtil", "uiGridCellNavConstants", "uiGridConstants", "GridRowColumn",
    function(a, b, c, d, e, f, g) {
        return {
            priority: -150,
            restrict: "A",
            require: ["^uiGrid", "?^uiGridCellnav"],
            scope: !1,
            link: function(a, b, c, d) {
                function f(a) {
                    a.preventDefault()
                }
                function h() {
                    if (!a.focused) {
                        var c = b.find("div");
                        c.addClass("ui-grid-cell-focus"),
                        b.attr("aria-selected", !0),
                        k.setAriaActivedescendant(b.attr("id")),
                        a.focused = !0
                    }
                }
                function i() {
                    if (a.focused) {
                        var c = b.find("div");
                        c.removeClass("ui-grid-cell-focus"),
                        b.attr("aria-selected", !1),
                        k.removeAriaActivedescendant(b.attr("id")),
                        a.focused = !1
                    }
                }
                var j = d[0],
                k = d[1];
                if (j.grid.api.cellNav && a.col.colDef.allowCellFocus) {
                    var l = j.grid;
                    a.focused = !1,
                    b.attr("tabindex", -1),
                    b.find("div").on("click",
                    function(b) {
                        j.cellNav.broadcastCellNav(new g(a.row, a.col), b.ctrlKey || b.metaKey, b),
                        b.stopPropagation(),
                        a.$apply()
                    }),
                    b.on("mousedown", f),
                    j.grid.api.edit && (j.grid.api.edit.on.beginCellEdit(a,
                    function() {
                        b.off("mousedown", f)
                    }), j.grid.api.edit.on.afterCellEdit(a,
                    function() {
                        b.on("mousedown", f)
                    }), j.grid.api.edit.on.cancelCellEdit(a,
                    function() {
                        b.on("mousedown", f)
                    })),
                    b.on("focus",
                    function(b) {
                        j.cellNav.broadcastCellNav(new g(a.row, a.col), !1, b),
                        b.stopPropagation(),
                        a.$apply()
                    }),
                    a.$on(e.CELL_NAV_EVENT,
                    function(b, c, d) {
                        var e = l.cellNav.focusedCells.some(function(b, c) {
                            return b.row === a.row && b.col === a.col
                        });
                        e ? h() : i()
                    }),
                    a.$on("$destroy",
                    function() {
                        b.find("div").off(),
                        b.off()
                    })
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.edit", ["ui.grid"]);
    a.constant("uiGridEditConstants", {
        EDITABLE_CELL_TEMPLATE: /EDITABLE_CELL_TEMPLATE/g,
        EDITABLE_CELL_DIRECTIVE: /editable_cell_directive/g,
        events: {
            BEGIN_CELL_EDIT: "uiGridEventBeginCellEdit",
            END_CELL_EDIT: "uiGridEventEndCellEdit",
            CANCEL_CELL_EDIT: "uiGridEventCancelCellEdit"
        }
    }),
    a.service("uiGridEditService", ["$q", "uiGridConstants", "gridUtil",
    function(a, b, c) {
        var d = {
            initializeGrid: function(a) {
                d.defaultGridOptions(a.options),
                a.registerColumnBuilder(d.editColumnBuilder),
                a.edit = {};
                var b = {
                    events: {
                        edit: {
                            afterCellEdit: function(a, b, c, d) {},
                            beginCellEdit: function(a, b, c) {},
                            cancelCellEdit: function(a, b) {}
                        }
                    },
                    methods: {
                        edit: {}
                    }
                };
                a.api.registerEventsFromObject(b.events)
            },
            defaultGridOptions: function(a) {
                a.cellEditableCondition = void 0 === a.cellEditableCondition ? !0 : a.cellEditableCondition,
                a.enableCellEditOnFocus = void 0 === a.enableCellEditOnFocus ? !1 : a.enableCellEditOnFocus
            },
            editColumnBuilder: function(b, d, e) {
                var f = [];
                return b.enableCellEdit = void 0 === b.enableCellEdit ? void 0 === e.enableCellEdit ? "object" !== b.type: e.enableCellEdit: b.enableCellEdit,
                b.cellEditableCondition = void 0 === b.cellEditableCondition ? e.cellEditableCondition: b.cellEditableCondition,
                b.enableCellEdit && (b.editableCellTemplate = b.editableCellTemplate || e.editableCellTemplate || "ui-grid/cellEditor", f.push(c.getTemplate(b.editableCellTemplate).then(function(a) {
                    d.editableCellTemplate = a
                },
                function(a) {
                    throw new Error("Couldn't fetch/use colDef.editableCellTemplate '" + b.editableCellTemplate + "'")
                }))),
                b.enableCellEditOnFocus = void 0 === b.enableCellEditOnFocus ? e.enableCellEditOnFocus: b.enableCellEditOnFocus,
                a.all(f)
            },
            isStartEditKey: function(a) {
                return a.metaKey || a.keyCode === b.keymap.ESC || a.keyCode === b.keymap.SHIFT || a.keyCode === b.keymap.CTRL || a.keyCode === b.keymap.ALT || a.keyCode === b.keymap.WIN || a.keyCode === b.keymap.CAPSLOCK || a.keyCode === b.keymap.LEFT || a.keyCode === b.keymap.TAB && a.shiftKey || a.keyCode === b.keymap.RIGHT || a.keyCode === b.keymap.TAB || a.keyCode === b.keymap.UP || a.keyCode === b.keymap.ENTER && a.shiftKey || a.keyCode === b.keymap.DOWN || a.keyCode === b.keymap.ENTER ? !1 : !0
            }
        };
        return d
    }]),
    a.directive("uiGridEdit", ["gridUtil", "uiGridEditService",
    function(a, b) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        b.initializeGrid(e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["uiGridEditConstants",
    function(a) {
        return {
            replace: !0,
            priority: -99998,
            require: ["^uiGrid", "^uiGridRenderContainer"],
            scope: !1,
            compile: function() {
                return {
                    post: function(b, c, d, e) {
                        var f = e[0];
                        if (f.grid.api.edit && f.grid.api.cellNav) {
                            var g = e[1].containerId;
                            "body" === g && (b.$on(a.events.CANCEL_CELL_EDIT,
                            function() {
                                f.focus()
                            }), b.$on(a.events.END_CELL_EDIT,
                            function() {
                                f.focus()
                            }))
                        }
                    }
                }
            }
        }
    }]),
    a.directive("uiGridCell", ["$compile", "$injector", "$timeout", "uiGridConstants", "uiGridEditConstants", "gridUtil", "$parse", "uiGridEditService", "$rootScope", "$q",
    function(a, b, c, d, e, f, g, h, i, j) {
        var k = 500;
        if (b.has("uiGridCellNavService")) {
            b.get("uiGridCellNavService")
        }
        return {
            priority: -100,
            restrict: "A",
            scope: !1,
            require: "?^uiGrid",
            link: function(b, l, m, n) {
                function o() {
                    l.on("dblclick", u),
                    l.on("touchstart", p),
                    n && n.grid.api.cellNav && (G = n.grid.api.cellNav.on.viewPortKeyDown(b,
                    function(a, c) {
                        null !== c && (c.row !== b.row || c.col !== b.col || b.col.colDef.enableCellEditOnFocus || s(a))
                    }), F = n.grid.api.cellNav.on.navigate(b,
                    function(a, d) {
                        b.col.colDef.enableCellEditOnFocus && (d && a.row === d.row && a.col === d.col || a.row !== b.row || a.col !== b.col || c(function() {
                            u()
                        }))
                    })),
                    b.beginEditEventsWired = !0
                }
                function p(a) {
                    "undefined" != typeof a.originalEvent && void 0 !== a.originalEvent && (a = a.originalEvent),
                    l.on("touchend", q),
                    C = c(function() {},
                    k),
                    C.then(function() {
                        setTimeout(u, 0),
                        l.off("touchend", q)
                    })
                }
                function q(a) {
                    c.cancel(C),
                    l.off("touchend", q)
                }
                function r() {
                    l.off("dblclick", u),
                    l.off("keydown", s),
                    l.off("touchstart", p),
                    F(),
                    G(),
                    b.beginEditEventsWired = !1
                }
                function s(a) {
                    h.isStartEditKey(a) && u(a)
                }
                function t(a, c) {
                    return ! c.isSaving && (angular.isFunction(a.colDef.cellEditableCondition) ? a.colDef.cellEditableCondition(b) : a.colDef.cellEditableCondition)
                }
                function u(a) {
                    b.grid.api.core.scrollToIfNecessary(b.row, b.col).then(function() {
                        v(a)
                    })
                }
                function v(h) {
                    if (!E && t(b.col, b.row)) {
                        B = g(b.row.getQualifiedColField(b.col)),
                        A = B(b),
                        z = b.col.editableCellTemplate,
                        z = b.col.colDef.editModelField ? z.replace(d.MODEL_COL_FIELD, f.preEval("row.entity." + b.col.colDef.editModelField)) : z.replace(d.MODEL_COL_FIELD, b.row.getQualifiedColField(b.col)),
                        z = z.replace(d.COL_FIELD, "grid.getCellValue(row, col)");
                        var k = b.col.colDef.editDropdownFilter ? "|" + b.col.colDef.editDropdownFilter: "";
                        z = z.replace(d.CUSTOM_FILTERS, k);
                        var m = "text";
                        switch (b.col.colDef.type) {
                        case "boolean":
                            m = "checkbox";
                            break;
                        case "number":
                            m = "number";
                            break;
                        case "date":
                            m = "date"
                        }
                        z = z.replace("INPUT_TYPE", m);
                        var n = b.col.colDef.editDropdownOptionsFunction;
                        if (n) j.when(n(b.row.entity, b.col.colDef)).then(function(a) {
                            b.editDropdownOptionsArray = a
                        });
                        else {
                            var o = b.col.colDef.editDropdownRowEntityOptionsArrayPath;
                            o ? b.editDropdownOptionsArray = y(b.row.entity, o) : b.editDropdownOptionsArray = b.col.colDef.editDropdownOptionsArray
                        }
                        b.editDropdownIdLabel = b.col.colDef.editDropdownIdLabel ? b.col.colDef.editDropdownIdLabel: "id",
                        b.editDropdownValueLabel = b.col.colDef.editDropdownValueLabel ? b.col.colDef.editDropdownValueLabel: "value";
                        var p = function() {
                            E = !0,
                            r();
                            var c = angular.element(z);
                            l.append(c),
                            D = b.$new(),
                            a(c)(D);
                            var d = angular.element(l.children()[0]);
                            d.addClass("ui-grid-cell-contents-hidden")
                        };
                        i.$$phase ? p() : b.$apply(p);
                        var q = b.col.grid.api.core.on.scrollBegin(b,
                        function() {
                            b.grid.disableScrolling || (w(), b.grid.api.edit.raise.afterCellEdit(b.row.entity, b.col.colDef, B(b), A), q(), s(), u())
                        }),
                        s = b.$on(e.events.END_CELL_EDIT,
                        function() {
                            w(),
                            b.grid.api.edit.raise.afterCellEdit(b.row.entity, b.col.colDef, B(b), A),
                            s(),
                            q(),
                            u()
                        }),
                        u = b.$on(e.events.CANCEL_CELL_EDIT,
                        function() {
                            x(),
                            u(),
                            q(),
                            s()
                        });
                        b.$broadcast(e.events.BEGIN_CELL_EDIT, h),
                        c(function() {
                            b.grid.api.edit.raise.beginCellEdit(b.row.entity, b.col.colDef, h)
                        })
                    }
                }
                function w() {
                    if (b.grid.disableScrolling = !1, E) {
                        n && n.grid.api.cellNav && n.focus();
                        var a = angular.element(l.children()[0]);
                        D.$destroy(),
                        angular.element(l.children()[1]).remove(),
                        a.removeClass("ui-grid-cell-contents-hidden"),
                        E = !1,
                        o(),
                        b.grid.api.core.notifyDataChange(d.dataChange.EDIT)
                    }
                }
                function x() {
                    b.grid.disableScrolling = !1,
                    E && (B.assign(b, A), b.$apply(), b.grid.api.edit.raise.cancelCellEdit(b.row.entity, b.col.colDef), w())
                }
                function y(a, b) {
                    b = b.replace(/\[(\w+)\]/g, ".$1"),
                    b = b.replace(/^\./, "");
                    for (var c = b.split("."); c.length;) {
                        var d = c.shift();
                        if (! (d in a)) return;
                        a = a[d]
                    }
                    return a
                }
                var z, A, B, C, D, E = !1;
                if (b.col.colDef.enableCellEdit) {
                    var F = function() {},
                    G = function() {},
                    H = function() {
                        b.col.colDef.enableCellEdit && b.row.enableCellEdit !== !1 ? b.beginEditEventsWired || o() : b.beginEditEventsWired && r()
                    };
                    H();
                    var I = b.$watch("row",
                    function(a, b) {
                        a !== b && H()
                    });
                    b.$on("$destroy", I)
                }
            }
        }
    }]),
    a.directive("uiGridEditor", ["gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout", "uiGridEditService",
    function(a, b, c, d, e) {
        return {
            scope: !0,
            require: ["?^uiGrid", "?^uiGridRenderContainer", "ngModel"],
            compile: function() {
                return {
                    pre: function(a, b, c) {},
                    post: function(a, f, g, h) {
                        var i, j, k;
                        h[0] && (i = h[0]),
                        h[1] && (j = h[1]),
                        h[2] && (k = h[2]),
                        a.$on(c.events.BEGIN_CELL_EDIT,
                        function(b, c) {
                            if (d(function() {
                                if (f[0].focus(), !a.col.colDef.enableCellEditOnFocus && i && i.grid.api.cellNav) try {
                                    f[0].setSelectionRange(f[0].value.length, f[0].value.length)
                                } catch(b) {} else f[0].select()
                            }), i && i.grid.api.cellNav) var g = i.grid.api.cellNav.on.viewPortKeyPress(a,
                            function(a, b) {
                                e.isStartEditKey(a) && (k.$setViewValue(String.fromCharCode("number" == typeof a.which ? a.which: a.keyCode), a), k.$render()),
                                g()
                            });
                            f.on("blur",
                            function(b) {
                                a.stopEdit(b)
                            })
                        }),
                        a.deepEdit = !1,
                        a.stopEdit = function(b) {
                            a.inputForm && !a.inputForm.$valid ? (b.stopPropagation(), a.$emit(c.events.CANCEL_CELL_EDIT)) : a.$emit(c.events.END_CELL_EDIT),
                            a.deepEdit = !1
                        },
                        f.on("click",
                        function(b) {
                            "checkbox" !== f[0].type && (a.deepEdit = !0, d(function() {
                                a.grid.disableScrolling = !0
                            }))
                        }),
                        f.on("keydown",
                        function(d) {
                            switch (d.keyCode) {
                            case b.keymap.ESC:
                                d.stopPropagation(),
                                a.$emit(c.events.CANCEL_CELL_EDIT)
                            }
                            if (!a.deepEdit || d.keyCode !== b.keymap.LEFT && d.keyCode !== b.keymap.RIGHT && d.keyCode !== b.keymap.UP && d.keyCode !== b.keymap.DOWN) if (i && i.grid.api.cellNav) d.uiGridTargetRenderContainerId = j.containerId,
                            null !== i.cellNav.handleKeyDown(d) && a.stopEdit(d);
                            else switch (d.keyCode) {
                            case b.keymap.ENTER:
                            case b.keymap.TAB:
                                d.stopPropagation(),
                                d.preventDefault(),
                                a.stopEdit(d)
                            } else d.stopPropagation();
                            return ! 0
                        })
                    }
                }
            }
        }
    }]),
    a.directive("uiGridEditor", ["$filter",
    function(a) {
        function b(a) {
            if ("undefined" == typeof a || "" === a) return null;
            var b = a.split("-");
            if (3 !== b.length) return null;
            var c = parseInt(b[0], 10),
            d = parseInt(b[1], 10),
            e = parseInt(b[2], 10);
            return 1 > d || 1 > c || 1 > e ? null: new Date(c, d - 1, e)
        }
        return {
            priority: -100,
            require: "?ngModel",
            link: function(c, d, e, f) {
                2 === angular.version.minor && e.type && "date" === e.type && f && (f.$formatters.push(function(b) {
                    return f.$setValidity(null, !b || !isNaN(b.getTime())),
                    a("date")(b, "yyyy-MM-dd")
                }), f.$parsers.push(function(a) {
                    if (a && a.length > 0) {
                        var c = b(a);
                        return f.$setValidity(null, c && !isNaN(c.getTime())),
                        c
                    }
                    return f.$setValidity(null, !0),
                    null
                }))
            }
        }
    }]),
    a.directive("uiGridEditDropdown", ["uiGridConstants", "uiGridEditConstants",
    function(a, b) {
        return {
            require: ["?^uiGrid", "?^uiGridRenderContainer"],
            scope: !0,
            compile: function() {
                return {
                    pre: function(a, b, c) {},
                    post: function(c, d, e, f) {
                        var g = f[0],
                        h = f[1];
                        c.$on(b.events.BEGIN_CELL_EDIT,
                        function() {
                            d[0].focus(),
                            d[0].style.width = d[0].parentElement.offsetWidth - 1 + "px",
                            d.on("blur",
                            function(a) {
                                c.stopEdit(a)
                            })
                        }),
                        c.stopEdit = function(a) {
                            c.$emit(b.events.END_CELL_EDIT)
                        },
                        d.on("keydown",
                        function(d) {
                            switch (d.keyCode) {
                            case a.keymap.ESC:
                                d.stopPropagation(),
                                c.$emit(b.events.CANCEL_CELL_EDIT)
                            }
                            if (g && g.grid.api.cellNav) d.uiGridTargetRenderContainerId = h.containerId,
                            null !== g.cellNav.handleKeyDown(d) && c.stopEdit(d);
                            else switch (d.keyCode) {
                            case a.keymap.ENTER:
                            case a.keymap.TAB:
                                d.stopPropagation(),
                                d.preventDefault(),
                                c.stopEdit(d)
                            }
                            return ! 0
                        })
                    }
                }
            }
        }
    }]),
    a.directive("uiGridEditFileChooser", ["gridUtil", "uiGridConstants", "uiGridEditConstants", "$timeout",
    function(a, b, c, d) {
        return {
            scope: !0,
            require: ["?^uiGrid", "?^uiGridRenderContainer"],
            compile: function() {
                return {
                    pre: function(a, b, c) {},
                    post: function(b, d, e, f) {
                        var g, h;
                        f[0] && (g = f[0]),
                        f[1] && (h = f[1]);
                        var i = (g.grid,
                        function(d) {
                            var e = d.srcElement || d.target;
                            e && e.files && e.files.length > 0 ? ("function" == typeof b.col.colDef.editFileChooserCallback ? b.col.colDef.editFileChooserCallback(b.row, b.col, e.files) : a.logError("You need to set colDef.editFileChooserCallback to use the file chooser"), e.form.reset(), b.$emit(c.events.END_CELL_EDIT)) : b.$emit(c.events.CANCEL_CELL_EDIT)
                        });
                        d[0].addEventListener("change", i, !1),
                        b.$on(c.events.BEGIN_CELL_EDIT,
                        function() {
                            d[0].focus(),
                            d[0].select(),
                            d.on("blur",
                            function(a) {
                                b.$emit(c.events.END_CELL_EDIT)
                            })
                        })
                    }
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.expandable", ["ui.grid"]);
    a.service("uiGridExpandableService", ["gridUtil", "$compile",
    function(a, b) {
        var c = {
            initializeGrid: function(b) {
                b.expandable = {},
                b.expandable.expandedAll = !1,
                b.options.enableExpandable = b.options.enableExpandable !== !1,
                b.options.expandableRowHeight = b.options.expandableRowHeight || 150,
                b.options.expandableRowHeaderWidth = b.options.expandableRowHeaderWidth || 40,
                b.options.enableExpandable && !b.options.expandableRowTemplate && (a.logError("You have not set the expandableRowTemplate, disabling expandable module"), b.options.enableExpandable = !1);
                var d = {
                    events: {
                        expandable: {
                            rowExpandedBeforeStateChanged: function(a, b) {},
                            rowExpandedStateChanged: function(a, b) {}
                        }
                    },
                    methods: {
                        expandable: {
                            toggleRowExpansion: function(a) {
                                var d = b.getRow(a);
                                null !== d && c.toggleRowExpansion(b, d)
                            },
                            expandAllRows: function() {
                                c.expandAllRows(b)
                            },
                            collapseAllRows: function() {
                                c.collapseAllRows(b)
                            },
                            toggleAllRows: function() {
                                c.toggleAllRows(b)
                            }
                        }
                    }
                };
                b.api.registerEventsFromObject(d.events),
                b.api.registerMethodsFromObject(d.methods)
            },
            toggleRowExpansion: function(a, b) {
                a.api.expandable.raise.rowExpandedBeforeStateChanged(b),
                b.isExpanded = !b.isExpanded,
                angular.isUndefined(b.expandedRowHeight) && (b.expandedRowHeight = a.options.expandableRowHeight),
                b.isExpanded ? b.height = b.grid.options.rowHeight + b.expandedRowHeight: (b.height = b.grid.options.rowHeight, a.expandable.expandedAll = !1),
                a.api.expandable.raise.rowExpandedStateChanged(b)
            },
            expandAllRows: function(a, b) {
                a.renderContainers.body.visibleRowCache.forEach(function(b) {
                    b.isExpanded || c.toggleRowExpansion(a, b)
                }),
                a.expandable.expandedAll = !0,
                a.queueGridRefresh()
            },
            collapseAllRows: function(a) {
                a.renderContainers.body.visibleRowCache.forEach(function(b) {
                    b.isExpanded && c.toggleRowExpansion(a, b)
                }),
                a.expandable.expandedAll = !1,
                a.queueGridRefresh()
            },
            toggleAllRows: function(a) {
                a.expandable.expandedAll ? c.collapseAllRows(a) : c.expandAllRows(a)
            }
        };
        return c
    }]),
    a.directive("uiGridExpandable", ["uiGridExpandableService", "$templateCache",
    function(a, b) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(c, d, e, f) {
                        if (f.grid.options.enableExpandableRowHeader !== !1) {
                            var g = {
                                name: "expandableButtons",
                                displayName: "",
                                exporterSuppressExport: !0,
                                enableColumnResizing: !1,
                                enableColumnMenu: !1,
                                width: f.grid.options.expandableRowHeaderWidth || 40
                            };
                            g.cellTemplate = b.get("ui-grid/expandableRowHeader"),
                            g.headerCellTemplate = b.get("ui-grid/expandableTopRowHeader"),
                            f.grid.addRowHeaderColumn(g)
                        }
                        a.initializeGrid(f.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGrid", ["uiGridExpandableService", "$templateCache",
    function(a, b) {
        return {
            replace: !0,
            priority: 599,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, b, c, d) {
                        d.grid.api.core.on.renderingComplete(a,
                        function() {
                            a.row && a.row.grid && a.row.grid.options && a.row.grid.options.enableExpandable && (d.grid.parentRow = a.row)
                        })
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridExpandableRow", ["uiGridExpandableService", "$timeout", "$compile", "uiGridConstants", "gridUtil", "$interval", "$log",
    function(a, b, c, d, e, f, g) {
        return {
            replace: !1,
            priority: 0,
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, b, d, f) {
                        e.getTemplate(a.grid.options.expandableRowTemplate).then(function(d) {
                            if (a.grid.options.expandableRowScope) {
                                var e = a.grid.options.expandableRowScope;
                                for (var f in e) e.hasOwnProperty(f) && (a[f] = e[f])
                            }
                            var g = c(d)(a);
                            b.append(g),
                            a.row.expandedRendered = !0
                        })
                    },
                    post: function(a, b, c, d) {
                        a.$on("$destroy",
                        function() {
                            a.row.expandedRendered = !1
                        })
                    }
                }
            }
        }
    }]),
    a.directive("uiGridRow", ["$compile", "gridUtil", "$templateCache",
    function(a, b, c) {
        return {
            priority: -200,
            scope: !1,
            compile: function(a, b) {
                return {
                    pre: function(a, b, c, d) {
                        a.expandableRow = {},
                        a.expandableRow.shouldRenderExpand = function() {
                            var b = "body" === a.colContainer.name && a.grid.options.enableExpandable !== !1 && a.row.isExpanded && (!a.grid.isScrollingVertically || a.row.expandedRendered);
                            return b
                        },
                        a.expandableRow.shouldRenderFiller = function() {
                            var b = a.row.isExpanded && ("body" !== a.colContainer.name || a.grid.isScrollingVertically && !a.row.expandedRendered);
                            return b
                        }
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["$compile", "gridUtil", "$templateCache",
    function(a, b, c) {
        return {
            priority: -200,
            scope: !1,
            compile: function(a, b) {
                var d = angular.element(a.children().children()[0]),
                e = c.get("ui-grid/expandableScrollFiller"),
                f = c.get("ui-grid/expandableRow");
                return d.append(f),
                d.append(e),
                {
                    pre: function(a, b, c, d) {},
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.exporter", ["ui.grid"]);
    a.constant("uiGridExporterConstants", {
        featureName: "exporter",
        ALL: "all",
        VISIBLE: "visible",
        SELECTED: "selected",
        CSV_CONTENT: "CSV_CONTENT",
        BUTTON_LABEL: "BUTTON_LABEL",
        FILE_NAME: "FILE_NAME"
    }),
    a.service("uiGridExporterService", ["$q", "uiGridExporterConstants", "gridUtil", "$compile", "$interval", "i18nService",
    function(a, b, c, d, e, f) {
        var g = {
            delay: 100,
            initializeGrid: function(a) {
                a.exporter = {},
                this.defaultGridOptions(a.options);
                var b = {
                    events: {
                        exporter: {}
                    },
                    methods: {
                        exporter: {
                            csvExport: function(b, c) {
                                g.csvExport(a, b, c)
                            },
                            pdfExport: function(b, c) {
                                g.pdfExport(a, b, c)
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods),
                a.api.core.addToGridMenu ? g.addToMenu(a) : e(function() {
                    a.api.core.addToGridMenu && g.addToMenu(a)
                },
                this.delay, 1)
            },
            defaultGridOptions: function(a) {
                a.exporterSuppressMenu = a.exporterSuppressMenu === !0,
                a.exporterMenuLabel = a.exporterMenuLabel ? a.exporterMenuLabel: "Export",
                a.exporterSuppressColumns = a.exporterSuppressColumns ? a.exporterSuppressColumns: [],
                a.exporterCsvColumnSeparator = a.exporterCsvColumnSeparator ? a.exporterCsvColumnSeparator: ",",
                a.exporterCsvFilename = a.exporterCsvFilename ? a.exporterCsvFilename: "download.csv",
                a.exporterPdfFilename = a.exporterPdfFilename ? a.exporterPdfFilename: "download.pdf",
                a.exporterOlderExcelCompatibility = a.exporterOlderExcelCompatibility === !0,
                a.exporterPdfDefaultStyle = a.exporterPdfDefaultStyle ? a.exporterPdfDefaultStyle: {
                    fontSize: 11
                },
                a.exporterPdfTableStyle = a.exporterPdfTableStyle ? a.exporterPdfTableStyle: {
                    margin: [0, 5, 0, 15]
                },
                a.exporterPdfTableHeaderStyle = a.exporterPdfTableHeaderStyle ? a.exporterPdfTableHeaderStyle: {
                    bold: !0,
                    fontSize: 12,
                    color: "black"
                },
                a.exporterPdfHeader = a.exporterPdfHeader ? a.exporterPdfHeader: null,
                a.exporterPdfFooter = a.exporterPdfFooter ? a.exporterPdfFooter: null,
                a.exporterPdfOrientation = a.exporterPdfOrientation ? a.exporterPdfOrientation: "landscape",
                a.exporterPdfPageSize = a.exporterPdfPageSize ? a.exporterPdfPageSize: "A4",
                a.exporterPdfMaxGridWidth = a.exporterPdfMaxGridWidth ? a.exporterPdfMaxGridWidth: 720,
                a.exporterMenuAllData = void 0 !== a.exporterMenuAllData ? a.exporterMenuAllData: !0,
                a.exporterMenuVisibleData = void 0 !== a.exporterMenuVisibleData ? a.exporterMenuVisibleData: !0,
                a.exporterMenuSelectedData = void 0 !== a.exporterMenuSelectedData ? a.exporterMenuSelectedData: !0,
                a.exporterMenuCsv = void 0 !== a.exporterMenuCsv ? a.exporterMenuCsv: !0,
                a.exporterMenuPdf = void 0 !== a.exporterMenuPdf ? a.exporterMenuPdf: !0,
                a.exporterPdfCustomFormatter = a.exporterPdfCustomFormatter && "function" == typeof a.exporterPdfCustomFormatter ? a.exporterPdfCustomFormatter: function(a) {
                    return a
                },
                a.exporterHeaderFilterUseName = a.exporterHeaderFilterUseName === !0,
                a.exporterFieldCallback = a.exporterFieldCallback ? a.exporterFieldCallback: function(a, b, c, d) {
                    return d
                },
                a.exporterAllDataFn = a.exporterAllDataFn ? a.exporterAllDataFn: null,
                null == a.exporterAllDataFn && a.exporterAllDataPromise && (a.exporterAllDataFn = a.exporterAllDataPromise)
            },
            addToMenu: function(a) {
                a.api.core.addToGridMenu(a, [{
                    title: f.getSafeText("gridMenu.exporterAllAsCsv"),
                    action: function(a) {
                        this.grid.api.exporter.csvExport(b.ALL, b.ALL)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuAllData
                    },
                    order: 200
                },
                {
                    title: f.getSafeText("gridMenu.exporterVisibleAsCsv"),
                    action: function(a) {
                        this.grid.api.exporter.csvExport(b.VISIBLE, b.VISIBLE)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuVisibleData
                    },
                    order: 201
                },
                {
                    title: f.getSafeText("gridMenu.exporterSelectedAsCsv"),
                    action: function(a) {
                        this.grid.api.exporter.csvExport(b.SELECTED, b.VISIBLE)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuSelectedData && this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0
                    },
                    order: 202
                },
                {
                    title: f.getSafeText("gridMenu.exporterAllAsPdf"),
                    action: function(a) {
                        this.grid.api.exporter.pdfExport(b.ALL, b.ALL)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuAllData
                    },
                    order: 203
                },
                {
                    title: f.getSafeText("gridMenu.exporterVisibleAsPdf"),
                    action: function(a) {
                        this.grid.api.exporter.pdfExport(b.VISIBLE, b.VISIBLE)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuVisibleData
                    },
                    order: 204
                },
                {
                    title: f.getSafeText("gridMenu.exporterSelectedAsPdf"),
                    action: function(a) {
                        this.grid.api.exporter.pdfExport(b.SELECTED, b.VISIBLE)
                    },
                    shown: function() {
                        return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuSelectedData && this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0
                    },
                    order: 205
                }])
            },
            csvExport: function(a, b, c) {
                var d = this;
                this.loadAllDataIfNeeded(a, b, c).then(function() {
                    var e = a.options.showHeader ? d.getColumnHeaders(a, c) : [],
                    f = d.getData(a, b, c),
                    g = d.formatAsCsv(e, f, a.options.exporterCsvColumnSeparator);
                    d.downloadFile(a.options.exporterCsvFilename, g, a.options.exporterOlderExcelCompatibility)
                })
            },
            loadAllDataIfNeeded: function(c, d, e) {
                if (d === b.ALL && c.rows.length !== c.options.totalItems && c.options.exporterAllDataFn) return c.options.exporterAllDataFn().then(function() {
                    c.modifyRows(c.options.data)
                });
                var f = a.defer();
                return f.resolve(),
                f.promise
            },
            getColumnHeaders: function(a, c) {
                var d, e = [];
                if (c === b.ALL) d = a.columns;
                else {
                    var f = a.renderContainers.left ? a.renderContainers.left.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [],
                    g = a.renderContainers.body ? a.renderContainers.body.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [],
                    h = a.renderContainers.right ? a.renderContainers.right.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [];
                    d = f.concat(g, h)
                }
                return d.forEach(function(b, c) {
                    b.colDef.exporterSuppressExport !== !0 && -1 === a.options.exporterSuppressColumns.indexOf(b.name) && e.push({
                        name: b.field,
                        displayName: a.options.exporterHeaderFilter ? a.options.exporterHeaderFilterUseName ? a.options.exporterHeaderFilter(b.name) : a.options.exporterHeaderFilter(b.displayName) : b.displayName,
                        width: b.drawnWidth ? b.drawnWidth: b.width,
                        align: "number" === b.colDef.type ? "right": "left"
                    })
                }),
                e
            },
            getData: function(a, d, e, f) {
                var g, h, i = [];
                switch (d) {
                case b.ALL:
                    g = a.rows;
                    break;
                case b.VISIBLE:
                    g = a.getVisibleRows();
                    break;
                case b.SELECTED:
                    a.api.selection ? g = a.api.selection.getSelectedGridRows() : c.logError("selection feature must be enabled to allow selected rows to be exported")
                }
                if (e === b.ALL) h = a.columns;
                else {
                    var j = a.renderContainers.left ? a.renderContainers.left.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [],
                    k = a.renderContainers.body ? a.renderContainers.body.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [],
                    l = a.renderContainers.right ? a.renderContainers.right.visibleColumnCache.filter(function(a) {
                        return a.visible
                    }) : [];
                    h = j.concat(k, l)
                }
                return g.forEach(function(c, d) {
                    if (c.exporterEnableExporting !== !1) {
                        var g = [];
                        h.forEach(function(d, h) {
                            if ((d.visible || e === b.ALL) && d.colDef.exporterSuppressExport !== !0 && -1 === a.options.exporterSuppressColumns.indexOf(d.name)) {
                                var i = f ? a.getCellDisplayValue(c, d) : a.getCellValue(c, d),
                                j = {
                                    value: a.options.exporterFieldCallback(a, c, d, i)
                                };
                                d.colDef.exporterPdfAlign && (j.alignment = d.colDef.exporterPdfAlign),
                                g.push(j)
                            }
                        }),
                        i.push(g)
                    }
                }),
                i
            },
            formatAsCsv: function(a, b, c) {
                var d = this,
                e = a.map(function(a) {
                    return {
                        value: a.displayName
                    }
                }),
                f = e.length > 0 ? d.formatRowAsCsv(this, c)(e) + "\n": "";
                return f += b.map(this.formatRowAsCsv(this, c)).join("\n")
            },
            formatRowAsCsv: function(a, b) {
                return function(c) {
                    return c.map(a.formatFieldAsCsv).join(b)
                }
            },
            formatFieldAsCsv: function(a) {
                return null == a.value ? "": "number" == typeof a.value ? a.value: "boolean" == typeof a.value ? a.value ? "TRUE": "FALSE": "string" == typeof a.value ? '"' + a.value.replace(/"/g, '""') + '"': JSON.stringify(a.value)
            },
            isIE: function() {
                var a = navigator.userAgent.search(/(?:Edge|MSIE|Trident\/.*; rv:)/),
                b = !1;
                return - 1 !== a && (b = !0),
                b
            },
            downloadFile: function(a, b, c) {
                var d, e, f = document,
                g = f.createElement("a"),
                h = "application/octet-stream;charset=utf-8";
                if (e = this.isIE(), e && 10 > e) {
                    var i = f.createElement("iframe");
                    return document.body.appendChild(i),
                    i.contentWindow.document.open("text/html", "replace"),
                    i.contentWindow.document.write("sep=,\r\n" + b),
                    i.contentWindow.document.close(),
                    i.contentWindow.focus(),
                    i.contentWindow.document.execCommand("SaveAs", !0, a),
                    document.body.removeChild(i),
                    !0
                }
                if (navigator.msSaveBlob) return navigator.msSaveOrOpenBlob(new Blob([c ? "\ufeff": "", b], {
                    type: h
                }), a);
                if ("download" in g) {
                    var j = new Blob([c ? "\ufeff": "", b], {
                        type: h
                    });
                    d = URL.createObjectURL(j),
                    g.setAttribute("download", a)
                } else d = "data:" + h + "," + encodeURIComponent(b),
                g.setAttribute("target", "_blank");
                g.href = d,
                g.setAttribute("style", "display:none;"),
                f.body.appendChild(g),
                setTimeout(function() {
                    if (g.click) g.click();
                    else if (document.createEvent) {
                        var a = document.createEvent("MouseEvents");
                        a.initEvent("click", !0, !0),
                        g.dispatchEvent(a)
                    }
                    f.body.removeChild(g)
                },
                this.delay)
            },
            pdfExport: function(a, b, c) {
                var d = this;
                this.loadAllDataIfNeeded(a, b, c).then(function() {
                    var e = d.getColumnHeaders(a, c),
                    f = d.getData(a, b, c),
                    g = d.prepareAsPdf(a, e, f);
                    d.isIE() || -1 !== navigator.appVersion.indexOf("Edge") ? d.downloadPDF(a.options.exporterPdfFilename, g) : pdfMake.createPdf(g).open()
                })
            },
            downloadPDF: function(a, b) {
                var c, d = document;
                d.createElement("a");
                c = this.isIE();
                var e, f = pdfMake.createPdf(b);
                f.getBuffer(function(b) {
                    if (e = new Blob([b]), navigator.msSaveBlob) return navigator.msSaveBlob(e, a);
                    if (c) {
                        var f = d.createElement("iframe");
                        return document.body.appendChild(f),
                        f.contentWindow.document.open("text/html", "replace"),
                        f.contentWindow.document.write(e),
                        f.contentWindow.document.close(),
                        f.contentWindow.focus(),
                        f.contentWindow.document.execCommand("SaveAs", !0, a),
                        document.body.removeChild(f),
                        !0
                    }
                })
            },
            prepareAsPdf: function(a, b, c) {
                var d = this.calculatePdfHeaderWidths(a, b),
                e = b.map(function(a) {
                    return {
                        text: a.displayName,
                        style: "tableHeader"
                    }
                }),
                f = c.map(this.formatRowAsPdf(this)),
                g = [e].concat(f),
                h = {
                    pageOrientation: a.options.exporterPdfOrientation,
                    pageSize: a.options.exporterPdfPageSize,
                    content: [{
                        style: "tableStyle",
                        table: {
                            headerRows: 1,
                            widths: d,
                            body: g
                        }
                    }],
                    styles: {
                        tableStyle: a.options.exporterPdfTableStyle,
                        tableHeader: a.options.exporterPdfTableHeaderStyle
                    },
                    defaultStyle: a.options.exporterPdfDefaultStyle
                };
                return a.options.exporterPdfLayout && (h.layout = a.options.exporterPdfLayout),
                a.options.exporterPdfHeader && (h.header = a.options.exporterPdfHeader),
                a.options.exporterPdfFooter && (h.footer = a.options.exporterPdfFooter),
                a.options.exporterPdfCustomFormatter && (h = a.options.exporterPdfCustomFormatter(h)),
                h
            },
            calculatePdfHeaderWidths: function(a, b) {
                var c = 0;
                b.forEach(function(a) {
                    "number" == typeof a.width && (c += a.width)
                });
                var d = 0;
                b.forEach(function(a) {
                    if ("*" === a.width && (d += 100), "string" == typeof a.width && a.width.match(/(\d)*%/)) {
                        var b = parseInt(a.width.match(/(\d)*%/)[0]);
                        a.width = c * b / 100,
                        d += a.width
                    }
                });
                var e = c + d;
                return b.map(function(b) {
                    return "*" === b.width ? b.width: b.width * a.options.exporterPdfMaxGridWidth / e
                })
            },
            formatRowAsPdf: function(a) {
                return function(b) {
                    return b.map(a.formatFieldAsPdfString)
                }
            },
            formatFieldAsPdfString: function(a) {
                var b;
                return b = null == a.value ? "": "number" == typeof a.value ? a.value.toString() : "boolean" == typeof a.value ? a.value ? "TRUE": "FALSE": "string" == typeof a.value ? a.value.replace(/"/g, '""') : JSON.stringify(a.value).replace(/^"/, "").replace(/"$/, ""),
                a.alignment && "string" == typeof a.alignment && (b = {
                    text: b,
                    alignment: a.alignment
                }),
                b
            }
        };
        return g
    }]),
    a.directive("uiGridExporter", ["uiGridExporterConstants", "uiGridExporterService", "gridUtil", "$compile",
    function(a, b, c, d) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function(a, c, d, e) {
                b.initializeGrid(e.grid),
                e.grid.exporter.$scope = a
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.grouping", ["ui.grid", "ui.grid.treeBase"]);
    a.constant("uiGridGroupingConstants", {
        featureName: "grouping",
        rowHeaderColName: "treeBaseRowHeaderCol",
        EXPANDED: "expanded",
        COLLAPSED: "collapsed",
        aggregation: {
            COUNT: "count",
            SUM: "sum",
            MAX: "max",
            MIN: "min",
            AVG: "avg"
        }
    }),
    a.service("uiGridGroupingService", ["$q", "uiGridGroupingConstants", "gridUtil", "rowSorter", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "uiGridTreeBaseService",
    function(a, b, c, d, e, f, g, h, i) {
        var j = {
            initializeGrid: function(a, b) {
                i.initializeGrid(a, b),
                a.grouping = {},
                a.grouping.groupHeaderCache = {},
                j.defaultGridOptions(a.options),
                a.registerRowsProcessor(j.groupRows, 400),
                a.registerColumnBuilder(j.groupingColumnBuilder),
                a.registerColumnsProcessor(j.groupingColumnProcessor, 400);
                var c = {
                    events: {
                        grouping: {
                            aggregationChanged: {},
                            groupingChanged: {}
                        }
                    },
                    methods: {
                        grouping: {
                            getGrouping: function(b) {
                                var c = j.getGrouping(a);
                                return c.grouping.forEach(function(a) {
                                    a.colName = a.col.name,
                                    delete a.col
                                }),
                                c.aggregations.forEach(function(a) {
                                    a.colName = a.col.name,
                                    delete a.col
                                }),
                                c.aggregations = c.aggregations.filter(function(a) {
                                    return ! a.aggregation.source || "grouping" !== a.aggregation.source
                                }),
                                b && (c.rowExpandedStates = j.getRowExpandedStates(a.grouping.groupingHeaderCache)),
                                c
                            },
                            setGrouping: function(b) {
                                j.setGrouping(a, b)
                            },
                            groupColumn: function(b) {
                                var c = a.getColumn(b);
                                j.groupColumn(a, c)
                            },
                            ungroupColumn: function(b) {
                                var c = a.getColumn(b);
                                j.ungroupColumn(a, c)
                            },
                            clearGrouping: function() {
                                j.clearGrouping(a)
                            },
                            aggregateColumn: function(b, c, d) {
                                var e = a.getColumn(b);
                                j.aggregateColumn(a, e, c, d)
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods),
                a.api.core.on.sortChanged(b, j.tidyPriorities)
            },
            defaultGridOptions: function(a) {
                a.enableGrouping = a.enableGrouping !== !1,
                a.groupingShowCounts = a.groupingShowCounts !== !1,
                a.groupingNullLabel = "undefined" == typeof a.groupingNullLabel ? "Null": a.groupingNullLabel,
                a.enableGroupHeaderSelection = a.enableGroupHeaderSelection === !0
            },
            groupingColumnBuilder: function(a, d, e) {
                if (a.enableGrouping !== !1) {
                    "undefined" == typeof d.grouping && "undefined" != typeof a.grouping ? (d.grouping = angular.copy(a.grouping), "undefined" != typeof d.grouping.groupPriority && d.grouping.groupPriority > -1 && (d.treeAggregationFn = i.nativeAggregations()[b.aggregation.COUNT].aggregationFn, d.treeAggregationFinalizerFn = j.groupedFinalizerFn)) : "undefined" == typeof d.grouping && (d.grouping = {}),
                    "undefined" != typeof d.grouping && "undefined" != typeof d.grouping.groupPriority && d.grouping.groupPriority >= 0 && (d.suppressRemoveSort = !0);
                    var f = {
                        name: "ui.grid.grouping.group",
                        title: g.get().grouping.group,
                        icon: "ui-grid-icon-indent-right",
                        shown: function() {
                            return "undefined" == typeof this.context.col.grouping || "undefined" == typeof this.context.col.grouping.groupPriority || this.context.col.grouping.groupPriority < 0
                        },
                        action: function() {
                            j.groupColumn(this.context.col.grid, this.context.col)
                        }
                    },
                    h = {
                        name: "ui.grid.grouping.ungroup",
                        title: g.get().grouping.ungroup,
                        icon: "ui-grid-icon-indent-left",
                        shown: function() {
                            return "undefined" != typeof this.context.col.grouping && "undefined" != typeof this.context.col.grouping.groupPriority && this.context.col.grouping.groupPriority >= 0
                        },
                        action: function() {
                            j.ungroupColumn(this.context.col.grid, this.context.col)
                        }
                    },
                    k = {
                        name: "ui.grid.grouping.aggregateRemove",
                        title: g.get().grouping.aggregate_remove,
                        shown: function() {
                            return "undefined" != typeof this.context.col.treeAggregationFn
                        },
                        action: function() {
                            j.aggregateColumn(this.context.col.grid, this.context.col, null)
                        }
                    },
                    l = function(a, b) {
                        b = b || g.get().grouping["aggregate_" + a] || a;
                        var e = {
                            name: "ui.grid.grouping.aggregate" + a,
                            title: b,
                            shown: function() {
                                return "undefined" == typeof this.context.col.treeAggregation || "undefined" == typeof this.context.col.treeAggregation.type || this.context.col.treeAggregation.type !== a
                            },
                            action: function() {
                                j.aggregateColumn(this.context.col.grid, this.context.col, a)
                            }
                        };
                        c.arrayContainsObjectWithProperty(d.menuItems, "name", "ui.grid.grouping.aggregate" + a) || d.menuItems.push(e)
                    };
                    d.colDef.groupingShowGroupingMenu !== !1 && (c.arrayContainsObjectWithProperty(d.menuItems, "name", "ui.grid.grouping.group") || d.menuItems.push(f), c.arrayContainsObjectWithProperty(d.menuItems, "name", "ui.grid.grouping.ungroup") || d.menuItems.push(h)),
                    d.colDef.groupingShowAggregationMenu !== !1 && (angular.forEach(i.nativeAggregations(),
                    function(a, b) {
                        l(b)
                    }), angular.forEach(e.treeCustomAggregations,
                    function(a, b) {
                        l(b, a.menuTitle)
                    }), c.arrayContainsObjectWithProperty(d.menuItems, "name", "ui.grid.grouping.aggregateRemove") || d.menuItems.push(k))
                }
            },
            groupingColumnProcessor: function(a, b) {
                return a = j.moveGroupColumns(this, a, b)
            },
            groupedFinalizerFn: function(a) {
                var b = this;
                "undefined" != typeof a.groupVal ? (a.rendered = a.groupVal, b.grid.options.groupingShowCounts && "date" !== b.colDef.type && (a.rendered += " (" + a.value + ")")) : a.rendered = null
            },
            moveGroupColumns: function(a, b, c) {
                return a.options.moveGroupColumns === !1 ? b: (b.forEach(function(a, b) {
                    a.groupingPosition = b
                }), b.sort(function(a, b) {
                    var c, d;
                    return c = a.isRowHeader ? -1e3: "undefined" == typeof a.grouping || "undefined" == typeof a.grouping.groupPriority || a.grouping.groupPriority < 0 ? null: a.grouping.groupPriority,
                    d = b.isRowHeader ? -1e3: "undefined" == typeof b.grouping || "undefined" == typeof b.grouping.groupPriority || b.grouping.groupPriority < 0 ? null: b.grouping.groupPriority,
                    null !== c && null === d ? -1 : null !== d && null === c ? 1 : null !== c && null !== d ? c - d: a.groupingPosition - b.groupingPosition
                }), b.forEach(function(a, b) {
                    delete a.groupingPosition
                }), b)
            },
            groupColumn: function(a, c) {
                "undefined" == typeof c.grouping && (c.grouping = {});
                var d = j.getGrouping(a);
                c.grouping.groupPriority = d.grouping.length,
                c.sort ? ("undefined" == typeof c.sort.direction || null === c.sort.direction) && (c.sort.direction = h.ASC) : c.sort = {
                    direction: h.ASC
                },
                c.treeAggregation = {
                    type: b.aggregation.COUNT,
                    source: "grouping"
                },
                c.treeAggregationFn = i.nativeAggregations()[b.aggregation.COUNT].aggregationFn,
                c.treeAggregationFinalizerFn = j.groupedFinalizerFn,
                a.api.grouping.raise.groupingChanged(c),
                a.api.core.raise.sortChanged(a, a.getColumnSorting()),
                a.queueGridRefresh()
            },
            ungroupColumn: function(a, b) {
                "undefined" != typeof b.grouping && (delete b.grouping.groupPriority, delete b.treeAggregation, delete b.customTreeAggregationFinalizer, j.tidyPriorities(a), a.api.grouping.raise.groupingChanged(b), a.queueGridRefresh())
            },
            aggregateColumn: function(a, b, c) {
                "undefined" != typeof b.grouping && "undefined" != typeof b.grouping.groupPriority && b.grouping.groupPriority >= 0 && j.ungroupColumn(a, b);
                var d = {};
                "undefined" != typeof a.options.treeCustomAggregations[c] ? d = a.options.treeCustomAggregations[c] : "undefined" != typeof i.nativeAggregations()[c] && (d = i.nativeAggregations()[c]),
                b.treeAggregation = {
                    type: c,
                    label: g.get().aggregation[d.label] || d.label
                },
                b.treeAggregationFn = d.aggregationFn,
                b.treeAggregationFinalizerFn = d.finalizerFn,
                a.api.grouping.raise.aggregationChanged(b),
                a.queueGridRefresh()
            },
            setGrouping: function(a, b) {
                "undefined" != typeof b && (j.clearGrouping(a), b.grouping && b.grouping.length && b.grouping.length > 0 && b.grouping.forEach(function(b) {
                    var c = a.getColumn(b.colName);
                    c && j.groupColumn(a, c)
                }), b.aggregations && b.aggregations.length && b.aggregations.forEach(function(b) {
                    var c = a.getColumn(b.colName);
                    c && j.aggregateColumn(a, c, b.aggregation.type)
                }), b.rowExpandedStates && j.applyRowExpandedStates(a.grouping.groupingHeaderCache, b.rowExpandedStates))
            },
            clearGrouping: function(a) {
                var b = j.getGrouping(a);
                b.grouping.length > 0 && b.grouping.forEach(function(b) {
                    b.col || (b.col = a.getColumn(b.colName)),
                    j.ungroupColumn(a, b.col)
                }),
                b.aggregations.length > 0 && b.aggregations.forEach(function(b) {
                    b.col || (b.col = a.getColumn(b.colName)),
                    j.aggregateColumn(a, b.col, null)
                })
            },
            tidyPriorities: function(a) {
                "undefined" != typeof a && "undefined" == typeof a.grid || "undefined" == typeof this.grid || (a = this.grid);
                var b = [],
                c = [];
                a.columns.forEach(function(a, d) {
                    "undefined" != typeof a.grouping && "undefined" != typeof a.grouping.groupPriority && a.grouping.groupPriority >= 0 ? b.push(a) : "undefined" != typeof a.sort && "undefined" != typeof a.sort.priority && a.sort.priority >= 0 && c.push(a)
                }),
                b.sort(function(a, b) {
                    return a.grouping.groupPriority - b.grouping.groupPriority
                }),
                b.forEach(function(a, b) {
                    a.grouping.groupPriority = b,
                    a.suppressRemoveSort = !0,
                    "undefined" == typeof a.sort && (a.sort = {}),
                    a.sort.priority = b
                });
                var d = b.length;
                c.sort(function(a, b) {
                    return a.sort.priority - b.sort.priority
                }),
                c.forEach(function(a, b) {
                    a.sort.priority = d,
                    a.suppressRemoveSort = a.colDef.suppressRemoveSort,
                    d++
                })
            },
            groupRows: function(a) {
                if (0 === a.length) return a;
                var b = this;
                b.grouping.oldGroupingHeaderCache = b.grouping.groupingHeaderCache || {},
                b.grouping.groupingHeaderCache = {};
                for (var c = j.initialiseProcessingState(b), e = function(e, h) {
                    var i = b.getCellValue(g, e.col);
                    e.initialised && 0 === d.getSortFn(b, e.col, a)(i, e.currentValue) || (j.insertGroupHeader(b, a, f, c, h), f++)
                },
                f = 0; f < a.length; f++) {
                    var g = a[f];
                    g.visible && c.forEach(e)
                }
                return delete b.grouping.oldGroupingHeaderCache,
                a
            },
            initialiseProcessingState: function(a) {
                var b = [],
                c = j.getGrouping(a);
                return c.grouping.forEach(function(a, c) {
                    b.push({
                        fieldName: a.field,
                        col: a.col,
                        initialised: !1,
                        currentValue: null,
                        currentRow: null
                    })
                }),
                b
            },
            getGrouping: function(a) {
                var b = [],
                c = [];
                return a.columns.forEach(function(a, d) {
                    a.grouping && "undefined" != typeof a.grouping.groupPriority && a.grouping.groupPriority >= 0 && b.push({
                        field: a.field,
                        col: a,
                        groupPriority: a.grouping.groupPriority,
                        grouping: a.grouping
                    }),
                    a.treeAggregation && a.treeAggregation.type && c.push({
                        field: a.field,
                        col: a,
                        aggregation: a.treeAggregation
                    })
                }),
                b.sort(function(a, b) {
                    return a.groupPriority - b.groupPriority
                }),
                b.forEach(function(a, b) {
                    a.grouping.groupPriority = b,
                    a.groupPriority = b,
                    delete a.grouping
                }),
                {
                    grouping: b,
                    aggregations: c
                }
            },
            insertGroupHeader: function(a, b, c, d, g) {
                var h = (d[g].fieldName, d[g].col),
                i = a.getCellValue(b[c], h),
                k = i; ("undefined" == typeof i || null === i) && (k = a.options.groupingNullLabel);
                for (var l = function(a) {
                    return angular.isObject(a) ? JSON.stringify(a) : a
                },
                m = a.grouping.oldGroupingHeaderCache, n = 0; g > n; n++) m && m[l(d[n].currentValue)] && (m = m[l(d[n].currentValue)].children);
                var o;
                for (m && m[l(i)] ? (o = m[l(i)].row, o.entity = {}) : (o = new e({},
                null, a), f.rowTemplateAssigner.call(a, o)), o.entity["$$" + d[g].col.uid] = {
                    groupVal: k
                },
                o.treeLevel = g, o.groupHeader = !0, o.internalRow = !0, o.enableCellEdit = !1, o.enableSelection = a.options.enableGroupHeaderSelection, d[g].initialised = !0, d[g].currentValue = i, d[g].currentRow = o, j.finaliseProcessingState(d, g + 1), b.splice(c, 0, o), m = a.grouping.groupingHeaderCache, n = 0; g > n; n++) m = m[l(d[n].currentValue)].children;
                m[l(i)] = {
                    row: o,
                    children: {}
                }
            },
            finaliseProcessingState: function(a, b) {
                for (var c = b; c < a.length; c++) a[c].initialised = !1,
                a[c].currentRow = null,
                a[c].currentValue = null
            },
            getRowExpandedStates: function(a) {
                if ("undefined" == typeof a) return {};
                var b = {};
                return angular.forEach(a,
                function(a, c) {
                    b[c] = {
                        state: a.row.treeNode.state
                    },
                    a.children ? b[c].children = j.getRowExpandedStates(a.children) : b[c].children = {}
                }),
                b
            },
            applyRowExpandedStates: function(a, b) {
                "undefined" != typeof b && angular.forEach(b,
                function(b, c) {
                    a[c] && (a[c].row.treeNode.state = b.state, b.children && a[c].children && j.applyRowExpandedStates(a[c].children, b.children))
                })
            }
        };
        return j
    }]),
    a.directive("uiGridGrouping", ["uiGridGroupingConstants", "uiGridGroupingService", "$templateCache",
    function(a, b, c) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        e.grid.options.enableGrouping !== !1 && b.initializeGrid(e.grid, a)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.importer", ["ui.grid"]);
    a.constant("uiGridImporterConstants", {
        featureName: "importer"
    }),
    a.service("uiGridImporterService", ["$q", "uiGridConstants", "uiGridImporterConstants", "gridUtil", "$compile", "$interval", "i18nService", "$window",
    function(a, b, c, d, e, f, g, h) {
        var i = {
            initializeGrid: function(a, b) {
                b.importer = {
                    $scope: a
                },
                this.defaultGridOptions(b.options);
                var c = {
                    events: {
                        importer: {}
                    },
                    methods: {
                        importer: {
                            importFile: function(a) {
                                i.importThisFile(b, a)
                            }
                        }
                    }
                };
                b.api.registerEventsFromObject(c.events),
                b.api.registerMethodsFromObject(c.methods),
                b.options.enableImporter && b.options.importerShowMenu && (b.api.core.addToGridMenu ? i.addToMenu(b) : f(function() {
                    b.api.core.addToGridMenu && i.addToMenu(b)
                },
                100, 1))
            },
            defaultGridOptions: function(a) {
                a.enableImporter || void 0 === a.enableImporter ? h.hasOwnProperty("File") && h.hasOwnProperty("FileReader") && h.hasOwnProperty("FileList") && h.hasOwnProperty("Blob") ? a.enableImporter = !0 : (d.logError("The File APIs are not fully supported in this browser, grid importer cannot be used."), a.enableImporter = !1) : a.enableImporter = !1,
                a.importerProcessHeaders = a.importerProcessHeaders || i.processHeaders,
                a.importerHeaderFilter = a.importerHeaderFilter ||
                function(a) {
                    return a
                },
                a.importerErrorCallback && "function" == typeof a.importerErrorCallback || delete a.importerErrorCallback,
                a.enableImporter !== !0 || a.importerDataAddCallback || (d.logError("You have not set an importerDataAddCallback, importer is disabled"), a.enableImporter = !1),
                a.importerShowMenu = a.importerShowMenu !== !1,
                a.importerObjectCallback = a.importerObjectCallback ||
                function(a, b) {
                    return b
                }
            },
            addToMenu: function(a) {
                a.api.core.addToGridMenu(a, [{
                    title: g.getSafeText("gridMenu.importerTitle"),
                    order: 150
                },
                {
                    templateUrl: "ui-grid/importerMenuItemContainer",
                    action: function(b) {
                        this.grid.api.importer.importAFile(a)
                    },
                    order: 151
                }])
            },
            importThisFile: function(a, b) {
                if (!b) return void d.logError("No file object provided to importThisFile, should be impossible, aborting");
                var c = new FileReader;
                switch (b.type) {
                case "application/json":
                    c.onload = i.importJsonClosure(a);
                    break;
                default:
                    c.onload = i.importCsvClosure(a)
                }
                c.readAsText(b)
            },
            importJsonClosure: function(a) {
                return function(b) {
                    var c, d = [],
                    e = i.parseJson(a, b);
                    null !== e && (e.forEach(function(b, e) {
                        c = i.newObject(a),
                        angular.extend(c, b),
                        c = a.options.importerObjectCallback(a, c),
                        d.push(c)
                    }), i.addObjects(a, d))
                }
            },
            parseJson: function(a, b) {
                var c;
                try {
                    c = JSON.parse(b.target.result)
                } catch(d) {
                    return void i.alertError(a, "importer.invalidJson", "File could not be processed, is it valid json? Content was: ", b.target.result)
                }
                return Array.isArray(c) ? c: (i.alertError(a, "importer.jsonNotarray", "Import failed, file is not an array, file was: ", b.target.result), [])
            },
            importCsvClosure: function(a) {
                return function(b) {
                    var c = i.parseCsv(b);
                    if (!c || c.length < 1) return void i.alertError(a, "importer.invalidCsv", "File could not be processed, is it valid csv? Content was: ", b.target.result);
                    var d = i.createCsvObjects(a, c);
                    return d && 0 !== d.length ? void i.addObjects(a, d) : void i.alertError(a, "importer.noObjects", "Objects were not able to be derived, content was: ", b.target.result)
                }
            },
            parseCsv: function(a) {
                var b = a.target.result;
                return CSV.parse(b)
            },
            createCsvObjects: function(a, b) {
                var c = a.options.importerProcessHeaders(a, b.shift());
                if (!c || 0 === c.length) return i.alertError(a, "importer.noHeaders", "Column names could not be derived, content was: ", b),
                [];
                var d, e = [];
                return b.forEach(function(b, f) {
                    d = i.newObject(a),
                    null !== b && b.forEach(function(a, b) {
                        null !== c[b] && (d[c[b]] = a)
                    }),
                    d = a.options.importerObjectCallback(a, d),
                    e.push(d)
                }),
                e
            },
            processHeaders: function(a, b) {
                var c = [];
                if (a.options.columnDefs && 0 !== a.options.columnDefs.length) {
                    var d = i.flattenColumnDefs(a, a.options.columnDefs);
                    return b.forEach(function(a, b) {
                        d[a] ? c.push(d[a]) : d[a.toLowerCase()] ? c.push(d[a.toLowerCase()]) : c.push(null)
                    }),
                    c
                }
                return b.forEach(function(a, b) {
                    c.push(a.replace(/[^0-9a-zA-Z\-_]/g, "_"))
                }),
                c
            },
            flattenColumnDefs: function(a, b) {
                var c = {};
                return b.forEach(function(b, d) {
                    b.name && (c[b.name] = b.field || b.name, c[b.name.toLowerCase()] = b.field || b.name),
                    b.field && (c[b.field] = b.field || b.name, c[b.field.toLowerCase()] = b.field || b.name),
                    b.displayName && (c[b.displayName] = b.field || b.name, c[b.displayName.toLowerCase()] = b.field || b.name),
                    b.displayName && a.options.importerHeaderFilter && (c[a.options.importerHeaderFilter(b.displayName)] = b.field || b.name, c[a.options.importerHeaderFilter(b.displayName).toLowerCase()] = b.field || b.name)
                }),
                c
            },
            addObjects: function(a, c, d) {
                if (a.api.rowEdit) {
                    var e = a.registerDataChangeCallback(function() {
                        a.api.rowEdit.setRowsDirty(c),
                        e()
                    },
                    [b.dataChange.ROW]);
                    a.importer.$scope.$on("$destroy", e)
                }
                a.importer.$scope.$apply(a.options.importerDataAddCallback(a, c))
            },
            newObject: function(a) {
                return "undefined" != typeof a.options && "undefined" != typeof a.options.importerNewObject ? new a.options.importerNewObject: {}
            },
            alertError: function(a, b, c, e) {
                a.options.importerErrorCallback ? a.options.importerErrorCallback(a, b, c, e) : (h.alert(g.getSafeText(b)), d.logError(c + e))
            }
        };
        return i
    }]),
    a.directive("uiGridImporter", ["uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile",
    function(a, b, c, d) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function(a, c, d, e) {
                b.initializeGrid(a, e.grid)
            }
        }
    }]),
    a.directive("uiGridImporterMenuItem", ["uiGridImporterConstants", "uiGridImporterService", "gridUtil", "$compile",
    function(a, b, c, d) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            templateUrl: "ui-grid/importerMenuItem",
            link: function(a, d, e, f) {
                var g = function(a) {
                    var c = a.srcElement || a.target;
                    if (c && c.files && 1 === c.files.length) {
                        var d = c.files[0];
                        b.importThisFile(i, d),
                        c.form.reset()
                    }
                },
                h = d[0].querySelectorAll(".ui-grid-importer-file-chooser"),
                i = f.grid;
                1 !== h.length ? c.logError("Found > 1 or < 1 file choosers within the menu item, error, cannot continue") : h[0].addEventListener("change", g, !1)
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.infiniteScroll", ["ui.grid"]);
    a.service("uiGridInfiniteScrollService", ["gridUtil", "$compile", "$timeout", "uiGridConstants", "ScrollEvent", "$q",
    function(a, b, c, d, e, f) {
        var g = {
            initializeGrid: function(a, b) {
                if (g.defaultGridOptions(a.options), a.options.enableInfiniteScroll) {
                    a.infiniteScroll = {
                        dataLoading: !1
                    },
                    g.setScrollDirections(a, a.options.infiniteScrollUp, a.options.infiniteScrollDown),
                    a.api.core.on.scrollEnd(b, g.handleScroll);
                    var c = {
                        events: {
                            infiniteScroll: {
                                needLoadMoreData: function(a, b) {},
                                needLoadMoreDataTop: function(a, b) {}
                            }
                        },
                        methods: {
                            infiniteScroll: {
                                dataLoaded: function(b, c) {
                                    g.setScrollDirections(a, b, c);
                                    var d = g.adjustScroll(a).then(function() {
                                        a.infiniteScroll.dataLoading = !1
                                    });
                                    return d
                                },
                                resetScroll: function(b, c) {
                                    return g.setScrollDirections(a, b, c),
                                    g.adjustInfiniteScrollPosition(a, 0)
                                },
                                saveScrollPercentage: function() {
                                    a.infiniteScroll.prevScrollTop = a.renderContainers.body.prevScrollTop,
                                    a.infiniteScroll.previousVisibleRows = a.getVisibleRowCount()
                                },
                                dataRemovedTop: function(b, c) {
                                    g.dataRemovedTop(a, b, c)
                                },
                                dataRemovedBottom: function(b, c) {
                                    g.dataRemovedBottom(a, b, c)
                                },
                                setScrollDirections: function(b, c) {
                                    g.setScrollDirections(a, b, c)
                                }
                            }
                        }
                    };
                    a.api.registerEventsFromObject(c.events),
                    a.api.registerMethodsFromObject(c.methods)
                }
            },
            defaultGridOptions: function(a) {
                a.enableInfiniteScroll = a.enableInfiniteScroll !== !1,
                a.infiniteScrollRowsFromEnd = a.infiniteScrollRowsFromEnd || 20,
                a.infiniteScrollUp = a.infiniteScrollUp === !0,
                a.infiniteScrollDown = a.infiniteScrollDown !== !1
            },
            setScrollDirections: function(a, b, c) {
                a.infiniteScroll.scrollUp = b === !0,
                a.suppressParentScrollUp = b === !0,
                a.infiniteScroll.scrollDown = c !== !1,
                a.suppressParentScrollDown = c !== !1
            },
            handleScroll: function(a) {
                if (! (a.grid.infiniteScroll && a.grid.infiniteScroll.dataLoading || "ui.grid.adjustInfiniteScrollPosition" === a.source) && a.y) {
                    var b, c = a.grid.options.infiniteScrollRowsFromEnd / a.grid.renderContainers.body.visibleRowCache.length;
                    a.grid.scrollDirection === d.scrollDirection.UP ? (b = a.y.percentage, c >= b && g.loadData(a.grid)) : a.grid.scrollDirection === d.scrollDirection.DOWN && (b = 1 - a.y.percentage, c >= b && g.loadData(a.grid))
                }
            },
            loadData: function(a) {
                a.infiniteScroll.previousVisibleRows = a.renderContainers.body.visibleRowCache.length,
                a.infiniteScroll.direction = a.scrollDirection,
                delete a.infiniteScroll.prevScrollTop,
                a.scrollDirection === d.scrollDirection.UP && a.infiniteScroll.scrollUp ? (a.infiniteScroll.dataLoading = !0, a.api.infiniteScroll.raise.needLoadMoreDataTop()) : a.scrollDirection === d.scrollDirection.DOWN && a.infiniteScroll.scrollDown && (a.infiniteScroll.dataLoading = !0, a.api.infiniteScroll.raise.needLoadMoreData())
            },
            adjustScroll: function(a) {
                var b = f.defer();
                return c(function() {
                    var e, f, h, i, j;
                    e = a.getViewportHeight() + a.headerHeight - a.renderContainers.body.headerHeight - a.scrollbarHeight,
                    f = a.options.rowHeight,
                    void 0 === a.infiniteScroll.direction && g.adjustInfiniteScrollPosition(a, 0),
                    h = a.getVisibleRowCount();
                    var k = f * h;
                    a.infiniteScroll.scrollDown && e > k && a.api.infiniteScroll.raise.needLoadMoreData(),
                    a.infiniteScroll.direction === d.scrollDirection.UP && (i = a.infiniteScroll.prevScrollTop || 0, j = i + (h - a.infiniteScroll.previousVisibleRows) * f, g.adjustInfiniteScrollPosition(a, j), c(function() {
                        b.resolve()
                    })),
                    a.infiniteScroll.direction === d.scrollDirection.DOWN && (j = a.infiniteScroll.prevScrollTop || a.infiniteScroll.previousVisibleRows * f - e, g.adjustInfiniteScrollPosition(a, j), c(function() {
                        b.resolve()
                    }))
                },
                0),
                b.promise
            },
            adjustInfiniteScrollPosition: function(a, b) {
                var c = new e(a, null, null, "ui.grid.adjustInfiniteScrollPosition"),
                d = a.getVisibleRowCount(),
                f = a.getViewportHeight() + a.headerHeight - a.renderContainers.body.headerHeight - a.scrollbarHeight,
                g = a.options.rowHeight,
                h = d * g - f;
                0 === b && a.infiniteScroll.scrollUp ? c.y = {
                    percentage: 1 / h
                }: c.y = {
                    percentage: b / h
                },
                a.scrollContainers("", c)
            },
            dataRemovedTop: function(a, b, c) {
                var d, e, f, h;
                return g.setScrollDirections(a, b, c),
                d = a.renderContainers.body.visibleRowCache.length,
                e = a.infiniteScroll.prevScrollTop,
                h = a.options.rowHeight,
                f = e - (a.infiniteScroll.previousVisibleRows - d) * h,
                g.adjustInfiniteScrollPosition(a, f)
            },
            dataRemovedBottom: function(a, b, c) {
                var d;
                return g.setScrollDirections(a, b, c),
                d = a.infiniteScroll.prevScrollTop,
                g.adjustInfiniteScrollPosition(a, d)
            }
        };
        return g
    }]),
    a.directive("uiGridInfiniteScroll", ["uiGridInfiniteScrollService",
    function(a) {
        return {
            priority: -200,
            scope: !1,
            require: "^uiGrid",
            compile: function(b, c, d) {
                return {
                    pre: function(b, c, d, e) {
                        a.initializeGrid(e.grid, b)
                    },
                    post: function(a, b, c) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.moveColumns", ["ui.grid"]);
    a.service("uiGridMoveColumnService", ["$q", "$timeout", "$log", "ScrollEvent", "uiGridConstants", "gridUtil",
    function(a, b, c, d, e, f) {
        var g = {
            initializeGrid: function(a) {
                var b = this;
                this.registerPublicApi(a),
                this.defaultGridOptions(a.options),
                a.moveColumns = {
                    orderCache: []
                },
                a.registerColumnBuilder(b.movableColumnBuilder),
                a.registerDataChangeCallback(b.verifyColumnOrder, [e.dataChange.COLUMN])
            },
            registerPublicApi: function(a) {
                var b = this,
                c = {
                    events: {
                        colMovable: {
                            columnPositionChanged: function(a, b, c) {}
                        }
                    },
                    methods: {
                        colMovable: {
                            moveColumn: function(c, d) {
                                var e = a.columns;
                                if (!angular.isNumber(c) || !angular.isNumber(d)) return void f.logError("MoveColumn: Please provide valid values for originalPosition and finalPosition");
                                for (var g = 0,
                                h = 0; h < e.length; h++)(angular.isDefined(e[h].colDef.visible) && e[h].colDef.visible === !1 || e[h].isRowHeader === !0) && g++;
                                if (c >= e.length - g || d >= e.length - g) return void f.logError("MoveColumn: Invalid values for originalPosition, finalPosition");
                                var i = function(a) {
                                    for (var b = a,
                                    c = 0; b >= c; c++) angular.isDefined(e[c]) && (angular.isDefined(e[c].colDef.visible) && e[c].colDef.visible === !1 || e[c].isRowHeader === !0) && b++;
                                    return b
                                };
                                b.redrawColumnAtPosition(a, i(c), i(d))
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods)
            },
            defaultGridOptions: function(a) {
                a.enableColumnMoving = a.enableColumnMoving !== !1
            },
            movableColumnBuilder: function(b, c, d) {
                var e = [];
                return b.enableColumnMoving = void 0 === b.enableColumnMoving ? d.enableColumnMoving: b.enableColumnMoving,
                a.all(e)
            },
            updateColumnCache: function(a) {
                a.moveColumns.orderCache = a.getOnlyDataColumns()
            },
            verifyColumnOrder: function(a) {
                var b, c = a.rowHeaderColumns.length;
                angular.forEach(a.moveColumns.orderCache,
                function(d, e) {
                    if (b = a.columns.indexOf(d), -1 !== b && b - c !== e) {
                        var f = a.columns.splice(b, 1)[0];
                        a.columns.splice(e + c, 0, f)
                    }
                })
            },
            redrawColumnAtPosition: function(a, c, d) {
                if (c !== d) {
                    var f = a.columns,
                    h = f[c];
                    if (h.colDef.enableColumnMoving) {
                        if (c > d) for (var i = c; i > d; i--) f[i] = f[i - 1];
                        else if (d > c) for (var j = c; d > j; j++) f[j] = f[j + 1];
                        f[d] = h,
                        g.updateColumnCache(a),
                        a.queueGridRefresh(),
                        b(function() {
                            a.api.core.notifyDataChange(e.dataChange.COLUMN),
                            a.api.colMovable.raise.columnPositionChanged(h.colDef, c, d)
                        })
                    }
                }
            }
        };
        return g
    }]),
    a.directive("uiGridMoveColumns", ["uiGridMoveColumnService",
    function(a) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(b, c, d, e) {
                        a.initializeGrid(e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridHeaderCell", ["$q", "gridUtil", "uiGridMoveColumnService", "$document", "$log", "uiGridConstants", "ScrollEvent",
    function(a, b, c, d, e, f, g) {
        return {
            priority: -10,
            require: "^uiGrid",
            compile: function() {
                return {
                    post: function(a, b, e, f) {
                        if (a.col.colDef.enableColumnMoving) {
                            var h, i, j, k, l, m, n = angular.element(b[0].querySelectorAll(".ui-grid-cell-contents")),
                            o = !1,
                            p = !1,
                            q = function(b) {
                                h = a.grid.element[0].getBoundingClientRect().left,
                                a.grid.hasLeftContainer() && (h += a.grid.renderContainers.left.header[0].getBoundingClientRect().width),
                                i = b.pageX,
                                j = 0,
                                k = h + a.grid.getViewportWidth(),
                                "mousedown" === b.type ? (d.on("mousemove", r), d.on("mouseup", s)) : "touchstart" === b.type && (d.on("touchmove", r), d.on("touchend", s))
                            },
                            r = function(a) {
                                var b = a.pageX - i;
                                0 !== b && (document.onselectstart = function() {
                                    return ! 1
                                },
                                p = !0, o ? o && (w(b), i = a.pageX) : v())
                            },
                            s = function(b) {
                                if (document.onselectstart = null, l && (l.remove(), o = !1), u(), t(), p) {
                                    for (var d = a.grid.columns,
                                    e = 0,
                                    f = 0; f < d.length && d[f].colDef.name !== a.col.colDef.name; f++) e++;
                                    if (0 > j) {
                                        for (var g = 0,
                                        h = e - 1; h >= 0; h--) if ((angular.isUndefined(d[h].colDef.visible) || d[h].colDef.visible === !0) && (g += d[h].drawnWidth || d[h].width || d[h].colDef.width, g > Math.abs(j))) {
                                            c.redrawColumnAtPosition(a.grid, e, h + 1);
                                            break
                                        }
                                        g < Math.abs(j) && c.redrawColumnAtPosition(a.grid, e, 0)
                                    } else if (j > 0) {
                                        for (var i = 0,
                                        k = e + 1; k < d.length; k++) if ((angular.isUndefined(d[k].colDef.visible) || d[k].colDef.visible === !0) && (i += d[k].drawnWidth || d[k].width || d[k].colDef.width, i > j)) {
                                            c.redrawColumnAtPosition(a.grid, e, k - 1);
                                            break
                                        }
                                        j > i && c.redrawColumnAtPosition(a.grid, e, d.length - 1)
                                    }
                                }
                            },
                            t = function() {
                                n.on("touchstart", q),
                                n.on("mousedown", q)
                            },
                            u = function() {
                                n.off("touchstart", q),
                                n.off("mousedown", q),
                                d.off("mousemove", r),
                                d.off("touchmove", r),
                                d.off("mouseup", s),
                                d.off("touchend", s)
                            };
                            t();
                            var v = function() {
                                o = !0,
                                l = b.clone(),
                                b.parent().append(l),
                                l.addClass("movingColumn");
                                var c = {};
                                c.left = b[0].offsetLeft + "px";
                                var d = a.grid.element[0].getBoundingClientRect().right,
                                e = b[0].getBoundingClientRect().right;
                                e > d && (m = a.col.drawnWidth + (d - e), c.width = m + "px"),
                                l.css(c)
                            },
                            w = function(b) {
                                for (var c = a.grid.columns,
                                d = 0,
                                e = 0; e < c.length; e++)(angular.isUndefined(c[e].colDef.visible) || c[e].colDef.visible === !0) && (d += c[e].drawnWidth || c[e].width || c[e].colDef.width);
                                var i, n = l[0].getBoundingClientRect().left - 1,
                                o = l[0].getBoundingClientRect().right;
                                if (i = n - h + b, i = k > i ? i: k, (n >= h || b > 0) && (k >= o || 0 > b)) l.css({
                                    visibility: "visible",
                                    left: l[0].offsetLeft + (k > i ? b: k - n) + "px"
                                });
                                else if (d > Math.ceil(f.grid.gridWidth)) {
                                    b *= 8;
                                    var p = new g(a.col.grid, null, null, "uiGridHeaderCell.moveElement");
                                    p.x = {
                                        pixels: b
                                    },
                                    p.grid.scrollContainers("", p)
                                }
                                for (var q = 0,
                                r = 0; r < c.length; r++) if (angular.isUndefined(c[r].colDef.visible) || c[r].colDef.visible === !0) {
                                    if (c[r].colDef.name === a.col.colDef.name) break;
                                    q += c[r].drawnWidth || c[r].width || c[r].colDef.width
                                }
                                void 0 === a.newScrollLeft ? j += b: j = a.newScrollLeft + i - q,
                                m < a.col.drawnWidth && (m += Math.abs(b), l.css({
                                    width: m + "px"
                                }))
                            }
                        }
                    }
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.pagination", ["ng", "ui.grid"]);
    a.service("uiGridPaginationService", ["gridUtil",
    function(a) {
        var b = {
            initializeGrid: function(a) {
                b.defaultGridOptions(a.options);
                var c = {
                    events: {
                        pagination: {
                            paginationChanged: function(a, b) {}
                        }
                    },
                    methods: {
                        pagination: {
                            getPage: function() {
                                return a.options.enablePagination ? a.options.paginationCurrentPage: null
                            },
                            getTotalPages: function() {
                                return a.options.enablePagination ? 0 === a.options.totalItems ? 1 : Math.ceil(a.options.totalItems / a.options.paginationPageSize) : null
                            },
                            nextPage: function() {
                                a.options.enablePagination && (a.options.totalItems > 0 ? a.options.paginationCurrentPage = Math.min(a.options.paginationCurrentPage + 1, c.methods.pagination.getTotalPages()) : a.options.paginationCurrentPage++)
                            },
                            previousPage: function() {
                                a.options.enablePagination && (a.options.paginationCurrentPage = Math.max(a.options.paginationCurrentPage - 1, 1))
                            },
                            seek: function(b) {
                                if (a.options.enablePagination) {
                                    if (!angular.isNumber(b) || 1 > b) throw "Invalid page number: " + b;
                                    a.options.paginationCurrentPage = Math.min(b, c.methods.pagination.getTotalPages())
                                }
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods);
                var d = function(b) {
                    if (a.options.useExternalPagination || !a.options.enablePagination) return b;
                    var c = parseInt(a.options.paginationPageSize, 10),
                    d = parseInt(a.options.paginationCurrentPage, 10),
                    e = b.filter(function(a) {
                        return a.visible
                    });
                    a.options.totalItems = e.length;
                    var f = (d - 1) * c;
                    return f > e.length && (d = a.options.paginationCurrentPage = 1, f = (d - 1) * c),
                    e.slice(f, f + c)
                };
                a.registerRowsProcessor(d, 900)
            },
            defaultGridOptions: function(b) {
                b.enablePagination = b.enablePagination !== !1,
                b.enablePaginationControls = b.enablePaginationControls !== !1,
                b.useExternalPagination = b.useExternalPagination === !0,
                a.isNullOrUndefined(b.totalItems) && (b.totalItems = 0),
                a.isNullOrUndefined(b.paginationPageSizes) && (b.paginationPageSizes = [250, 500, 1e3]),
                a.isNullOrUndefined(b.paginationPageSize) && (b.paginationPageSizes.length > 0 ? b.paginationPageSize = b.paginationPageSizes[0] : b.paginationPageSize = 0),
                a.isNullOrUndefined(b.paginationCurrentPage) && (b.paginationCurrentPage = 1),
                a.isNullOrUndefined(b.paginationTemplate) && (b.paginationTemplate = "ui-grid/pagination")
            },
            onPaginationChanged: function(a, b, c) {
                a.api.pagination.raise.paginationChanged(b, c),
                a.options.useExternalPagination || a.queueGridRefresh()
            }
        };
        return b
    }]),
    a.directive("uiGridPagination", ["gridUtil", "uiGridPaginationService",
    function(a, b) {
        return {
            priority: -200,
            scope: !1,
            require: "uiGrid",
            link: {
                pre: function(c, d, e, f) {
                    b.initializeGrid(f.grid),
                    a.getTemplate(f.grid.options.paginationTemplate).then(function(a) {
                        var b = angular.element(a);
                        d.append(b),
                        f.innerCompile(b)
                    })
                }
            }
        }
    }]),
    a.directive("uiGridPager", ["uiGridPaginationService", "uiGridConstants", "gridUtil", "i18nService",
    function(a, b, c, d) {
        return {
            priority: -200,
            scope: !0,
            require: "^uiGrid",
            link: function(e, f, g, h) {
                var i = ".ui-grid-pager-control-input";
                e.aria = d.getSafeText("pagination.aria"),
                e.paginationApi = h.grid.api.pagination,
                e.sizesLabel = d.getSafeText("pagination.sizes"),
                e.totalItemsLabel = d.getSafeText("pagination.totalItems"),
                e.paginationOf = d.getSafeText("pagination.of"),
                e.paginationThrough = d.getSafeText("pagination.through");
                var j = h.grid.options;
                h.grid.renderContainers.body.registerViewportAdjuster(function(a) {
                    return a.height = a.height - c.elementHeight(f, "padding"),
                    a
                });
                var k = h.grid.registerDataChangeCallback(function(a) {
                    a.options.useExternalPagination || (a.options.totalItems = a.rows.length)
                },
                [b.dataChange.ROW]);
                e.$on("$destroy", k);
                var l = function() {
                    e.showingLow = (j.paginationCurrentPage - 1) * j.paginationPageSize + 1,
                    e.showingHigh = Math.min(j.paginationCurrentPage * j.paginationPageSize, j.totalItems)
                },
                m = e.$watch("grid.options.totalItems + grid.options.paginationPageSize", l),
                n = e.$watch("grid.options.paginationCurrentPage + grid.options.paginationPageSize",
                function(b, c) {
                    if (b !== c && void 0 !== c) {
                        if (!angular.isNumber(j.paginationCurrentPage) || j.paginationCurrentPage < 1) return void(j.paginationCurrentPage = 1);
                        if (j.totalItems > 0 && j.paginationCurrentPage > e.paginationApi.getTotalPages()) return void(j.paginationCurrentPage = e.paginationApi.getTotalPages());
                        l(),
                        a.onPaginationChanged(e.grid, j.paginationCurrentPage, j.paginationPageSize)
                    }
                });
                e.$on("$destroy",
                function() {
                    m(),
                    n()
                }),
                e.cantPageForward = function() {
                    return j.totalItems > 0 ? j.paginationCurrentPage >= e.paginationApi.getTotalPages() : j.data.length < 1
                },
                e.cantPageToLast = function() {
                    return j.totalItems > 0 ? e.cantPageForward() : !0
                },
                e.cantPageBackward = function() {
                    return j.paginationCurrentPage <= 1
                };
                var o = function(a) {
                    a && c.focus.bySelector(f, i)
                };
                e.pageFirstPageClick = function() {
                    e.paginationApi.seek(1),
                    o(e.cantPageBackward())
                },
                e.pagePreviousPageClick = function() {
                    e.paginationApi.previousPage(),
                    o(e.cantPageBackward())
                },
                e.pageNextPageClick = function() {
                    e.paginationApi.nextPage(),
                    o(e.cantPageForward())
                },
                e.pageLastPageClick = function() {
                    e.paginationApi.seek(e.paginationApi.getTotalPages()),
                    o(e.cantPageToLast())
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.pinning", ["ui.grid"]);
    a.constant("uiGridPinningConstants", {
        container: {
            LEFT: "left",
            RIGHT: "right",
            NONE: ""
        }
    }),
    a.service("uiGridPinningService", ["gridUtil", "GridRenderContainer", "i18nService", "uiGridPinningConstants",
    function(a, b, c, d) {
        var e = {
            initializeGrid: function(a) {
                e.defaultGridOptions(a.options),
                a.registerColumnBuilder(e.pinningColumnBuilder);
                var b = {
                    events: {
                        pinning: {
                            columnPinned: function(a, b) {}
                        }
                    },
                    methods: {
                        pinning: {
                            pinColumn: function(b, c) {
                                e.pinColumn(a, b, c)
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods)
            },
            defaultGridOptions: function(a) {
                a.enablePinning = a.enablePinning !== !1
            },
            pinningColumnBuilder: function(b, f, g) {
                if (b.enablePinning = void 0 === b.enablePinning ? g.enablePinning: b.enablePinning, b.pinnedLeft ? (f.renderContainer = "left", f.grid.createLeftContainer()) : b.pinnedRight && (f.renderContainer = "right", f.grid.createRightContainer()), b.enablePinning) {
                    var h = {
                        name: "ui.grid.pinning.pinLeft",
                        title: c.get().pinning.pinLeft,
                        icon: "ui-grid-icon-left-open",
                        shown: function() {
                            return "undefined" == typeof this.context.col.renderContainer || !this.context.col.renderContainer || "left" !== this.context.col.renderContainer
                        },
                        action: function() {
                            e.pinColumn(this.context.col.grid, this.context.col, d.container.LEFT)
                        }
                    },
                    i = {
                        name: "ui.grid.pinning.pinRight",
                        title: c.get().pinning.pinRight,
                        icon: "ui-grid-icon-right-open",
                        shown: function() {
                            return "undefined" == typeof this.context.col.renderContainer || !this.context.col.renderContainer || "right" !== this.context.col.renderContainer
                        },
                        action: function() {
                            e.pinColumn(this.context.col.grid, this.context.col, d.container.RIGHT)
                        }
                    },
                    j = {
                        name: "ui.grid.pinning.unpin",
                        title: c.get().pinning.unpin,
                        icon: "ui-grid-icon-cancel",
                        shown: function() {
                            return "undefined" != typeof this.context.col.renderContainer && null !== this.context.col.renderContainer && "body" !== this.context.col.renderContainer
                        },
                        action: function() {
                            e.pinColumn(this.context.col.grid, this.context.col, d.container.UNPIN)
                        }
                    };
                    a.arrayContainsObjectWithProperty(f.menuItems, "name", "ui.grid.pinning.pinLeft") || f.menuItems.push(h),
                    a.arrayContainsObjectWithProperty(f.menuItems, "name", "ui.grid.pinning.pinRight") || f.menuItems.push(i),
                    a.arrayContainsObjectWithProperty(f.menuItems, "name", "ui.grid.pinning.unpin") || f.menuItems.push(j)
                }
            },
            pinColumn: function(a, b, c) {
                c === d.container.NONE ? b.renderContainer = null: (b.renderContainer = c, c === d.container.LEFT ? a.createLeftContainer() : c === d.container.RIGHT && a.createRightContainer()),
                a.refresh().then(function() {
                    a.api.pinning.raise.columnPinned(b.colDef, c)
                })
            }
        };
        return e
    }]),
    a.directive("uiGridPinning", ["gridUtil", "uiGridPinningService",
    function(a, b) {
        return {
            require: "uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        b.initializeGrid(e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.resizeColumns", ["ui.grid"]);
    a.service("uiGridResizeColumnsService", ["gridUtil", "$q", "$timeout",
    function(a, b, c) {
        var d = {
            defaultGridOptions: function(a) {
                a.enableColumnResizing = a.enableColumnResizing !== !1,
                a.enableColumnResize === !1 && (a.enableColumnResizing = !1)
            },
            colResizerColumnBuilder: function(a, c, d) {
                var e = [];
                return a.enableColumnResizing = void 0 === a.enableColumnResizing ? d.enableColumnResizing: a.enableColumnResizing,
                a.enableColumnResize === !1 && (a.enableColumnResizing = !1),
                b.all(e)
            },
            registerPublicApi: function(a) {
                var b = {
                    events: {
                        colResizable: {
                            columnSizeChanged: function(a, b) {}
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events)
            },
            fireColumnSizeChanged: function(b, d, e) {
                c(function() {
                    b.api.colResizable ? b.api.colResizable.raise.columnSizeChanged(d, e) : a.logError("The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events.")
                })
            },
            findTargetCol: function(a, b, c) {
                var d = a.getRenderContainer();
                if ("left" === b) {
                    var e = d.visibleColumnCache.indexOf(a);
                    return d.visibleColumnCache[e - 1 * c]
                }
                return a
            }
        };
        return d
    }]),
    a.directive("uiGridResizeColumns", ["gridUtil", "uiGridResizeColumnsService",
    function(a, b) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        b.defaultGridOptions(e.grid.options),
                        e.grid.registerColumnBuilder(b.colResizerColumnBuilder),
                        b.registerPublicApi(e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridHeaderCell", ["gridUtil", "$templateCache", "$compile", "$q", "uiGridResizeColumnsService", "uiGridConstants", "$timeout",
    function(a, b, c, d, e, f, g) {
        return {
            priority: -10,
            require: "^uiGrid",
            compile: function() {
                return {
                    post: function(a, d, h, i) {
                        var j = i.grid;
                        if (j.options.enableColumnResizing) {
                            var k = b.get("ui-grid/columnResizer"),
                            l = 1;
                            j.isRTL() && (a.position = "left", l = -1);
                            var m = function() {
                                for (var b = d[0].getElementsByClassName("ui-grid-column-resizer"), f = 0; f < b.length; f++) angular.element(b[f]).remove();
                                var g = e.findTargetCol(a.col, "left", l),
                                h = a.col.getRenderContainer();
                                if (g && 0 !== h.visibleColumnCache.indexOf(a.col) && g.colDef.enableColumnResizing !== !1) {
                                    var i = angular.element(k).clone();
                                    i.attr("position", "left"),
                                    d.prepend(i),
                                    c(i)(a)
                                }
                                if (a.col.colDef.enableColumnResizing !== !1) {
                                    var j = angular.element(k).clone();
                                    j.attr("position", "right"),
                                    d.append(j),
                                    c(j)(a)
                                }
                            };
                            m();
                            var n = function() {
                                g(m)
                            },
                            o = j.registerDataChangeCallback(n, [f.dataChange.COLUMN]);
                            a.$on("$destroy", o)
                        }
                    }
                }
            }
        }
    }]),
    a.directive("uiGridColumnResizer", ["$document", "gridUtil", "uiGridConstants", "uiGridResizeColumnsService",
    function(a, b, c, d) {
        var e = angular.element('<div class="ui-grid-resize-overlay"></div>'),
        f = {
            priority: 0,
            scope: {
                col: "=",
                position: "@",
                renderIndex: "="
            },
            require: "?^uiGrid",
            link: function(f, g, h, i) {
                function j(a) {
                    i.grid.refreshCanvas(!0).then(function() {
                        i.grid.queueGridRefresh()
                    })
                }
                function k(a, b) {
                    var c = b;
                    return a.minWidth && c < a.minWidth ? c = a.minWidth: a.maxWidth && c > a.maxWidth && (c = a.maxWidth),
                    c
                }
                function l(a, b) {
                    a.originalEvent && (a = a.originalEvent),
                    a.preventDefault(),
                    o = (a.targetTouches ? a.targetTouches[0] : a).clientX - p,
                    0 > o ? o = 0 : o > i.grid.gridWidth && (o = i.grid.gridWidth);
                    var g = d.findTargetCol(f.col, f.position, q);
                    if (g.colDef.enableColumnResizing !== !1) {
                        i.grid.element.hasClass("column-resizing") || i.grid.element.addClass("column-resizing");
                        var h = o - n,
                        j = parseInt(g.drawnWidth + h * q, 10);
                        o += (k(g, j) - j) * q,
                        e.css({
                            left: o + "px"
                        }),
                        i.fireEvent(c.events.ITEM_DRAGGING)
                    }
                }
                function m(a, b) {
                    a.originalEvent && (a = a.originalEvent),
                    a.preventDefault(),
                    i.grid.element.removeClass("column-resizing"),
                    e.remove(),
                    o = (a.changedTouches ? a.changedTouches[0] : a).clientX - p;
                    var c = o - n;
                    if (0 === c) return t(),
                    void s();
                    var g = d.findTargetCol(f.col, f.position, q);
                    if (g.colDef.enableColumnResizing !== !1) {
                        var h = parseInt(g.drawnWidth + c * q, 10);
                        g.width = k(g, h),
                        g.hasCustomWidth = !0,
                        j(c),
                        d.fireColumnSizeChanged(i.grid, g.colDef, c),
                        t(),
                        s()
                    }
                }
                var n = 0,
                o = 0,
                p = 0,
                q = 1;
                i.grid.isRTL() && (f.position = "left", q = -1),
                "left" === f.position ? g.addClass("left") : "right" === f.position && g.addClass("right");
                var r = function(b, c) {
                    b.originalEvent && (b = b.originalEvent),
                    b.stopPropagation(),
                    p = i.grid.element[0].getBoundingClientRect().left,
                    n = (b.targetTouches ? b.targetTouches[0] : b).clientX - p,
                    i.grid.element.append(e),
                    e.css({
                        left: n
                    }),
                    "touchstart" === b.type ? (a.on("touchend", m), a.on("touchmove", l), g.off("mousedown", r)) : (a.on("mouseup", m), a.on("mousemove", l), g.off("touchstart", r))
                },
                s = function() {
                    g.on("mousedown", r),
                    g.on("touchstart", r)
                },
                t = function() {
                    a.off("mouseup", m),
                    a.off("touchend", m),
                    a.off("mousemove", l),
                    a.off("touchmove", l),
                    g.off("mousedown", r),
                    g.off("touchstart", r)
                };
                s();
                var u = function(a, e) {
                    a.stopPropagation();
                    var h = d.findTargetCol(f.col, f.position, q);
                    if (h.colDef.enableColumnResizing !== !1) {
                        var l = 0,
                        m = 0,
                        n = b.closestElm(g, ".ui-grid-render-container"),
                        o = n.querySelectorAll("." + c.COL_CLASS_PREFIX + h.uid + " .ui-grid-cell-contents");
                        Array.prototype.forEach.call(o,
                        function(a) {
                            var c;
                            angular.element(a).parent().hasClass("ui-grid-header-cell") && (c = angular.element(a).parent()[0].querySelectorAll(".ui-grid-column-menu-button")),
                            b.fakeElement(a, {},
                            function(a) {
                                var d = angular.element(a);
                                d.attr("style", "float: left");
                                var e = b.elementWidth(d);
                                if (c) {
                                    var f = b.elementWidth(c);
                                    e += f
                                }
                                e > l && (l = e, m = l - e)
                            })
                        }),
                        h.width = k(h, l),
                        h.hasCustomWidth = !0,
                        j(m),
                        d.fireColumnSizeChanged(i.grid, h.colDef, m)
                    }
                };
                g.on("dblclick", u),
                g.on("$destroy",
                function() {
                    g.off("dblclick", u),
                    t()
                })
            }
        };
        return f
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.rowEdit", ["ui.grid", "ui.grid.edit", "ui.grid.cellNav"]);
    a.constant("uiGridRowEditConstants", {}),
    a.service("uiGridRowEditService", ["$interval", "$q", "uiGridConstants", "uiGridRowEditConstants", "gridUtil",
    function(a, b, c, d, e) {
        var f = {
            initializeGrid: function(a, b) {
                b.rowEdit = {};
                var c = {
                    events: {
                        rowEdit: {
                            saveRow: function(a) {}
                        }
                    },
                    methods: {
                        rowEdit: {
                            setSavePromise: function(a, c) {
                                f.setSavePromise(b, a, c)
                            },
                            getDirtyRows: function() {
                                return b.rowEdit.dirtyRows ? b.rowEdit.dirtyRows: []
                            },
                            getErrorRows: function() {
                                return b.rowEdit.errorRows ? b.rowEdit.errorRows: []
                            },
                            flushDirtyRows: function() {
                                return f.flushDirtyRows(b)
                            },
                            setRowsDirty: function(a) {
                                f.setRowsDirty(b, a)
                            },
                            setRowsClean: function(a) {
                                f.setRowsClean(b, a)
                            }
                        }
                    }
                };
                b.api.registerEventsFromObject(c.events),
                b.api.registerMethodsFromObject(c.methods),
                b.api.core.on.renderingComplete(a,
                function(c) {
                    b.api.edit.on.afterCellEdit(a, f.endEditCell),
                    b.api.edit.on.beginCellEdit(a, f.beginEditCell),
                    b.api.edit.on.cancelCellEdit(a, f.cancelEditCell),
                    b.api.cellNav && b.api.cellNav.on.navigate(a, f.navigate)
                })
            },
            defaultGridOptions: function(a) {},
            saveRow: function(a, b) {
                var c = this;
                return function() {
                    if (b.isSaving = !0, b.rowEditSavePromise) return b.rowEditSavePromise;
                    var d = a.api.rowEdit.raise.saveRow(b.entity);
                    return b.rowEditSavePromise ? b.rowEditSavePromise.then(c.processSuccessPromise(a, b), c.processErrorPromise(a, b)) : e.logError("A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise"),
                    d
                }
            },
            setSavePromise: function(a, b, c) {
                var d = a.getRow(b);
                d.rowEditSavePromise = c
            },
            processSuccessPromise: function(a, b) {
                var c = this;
                return function() {
                    delete b.isSaving,
                    delete b.isDirty,
                    delete b.isError,
                    delete b.rowEditSaveTimer,
                    delete b.rowEditSavePromise,
                    c.removeRow(a.rowEdit.errorRows, b),
                    c.removeRow(a.rowEdit.dirtyRows, b)
                }
            },
            processErrorPromise: function(a, b) {
                return function() {
                    delete b.isSaving,
                    delete b.rowEditSaveTimer,
                    delete b.rowEditSavePromise,
                    b.isError = !0,
                    a.rowEdit.errorRows || (a.rowEdit.errorRows = []),
                    f.isRowPresent(a.rowEdit.errorRows, b) || a.rowEdit.errorRows.push(b)
                }
            },
            removeRow: function(a, b) {
                "undefined" != typeof a && null !== a && a.forEach(function(c, d) {
                    c.uid === b.uid && a.splice(d, 1)
                })
            },
            isRowPresent: function(a, b) {
                var c = !1;
                return a.forEach(function(a, d) {
                    a.uid === b.uid && (c = !0)
                }),
                c
            },
            flushDirtyRows: function(a) {
                var c = [];
                return a.api.rowEdit.getDirtyRows().forEach(function(b) {
                    f.saveRow(a, b)(),
                    c.push(b.rowEditSavePromise)
                }),
                b.all(c)
            },
            endEditCell: function(a, b, c, d) {
                var g = this.grid,
                h = g.getRow(a);
                return h ? void((c !== d || h.isDirty) && (g.rowEdit.dirtyRows || (g.rowEdit.dirtyRows = []), h.isDirty || (h.isDirty = !0, g.rowEdit.dirtyRows.push(h)), delete h.isError, f.considerSetTimer(g, h))) : void e.logError("Unable to find rowEntity in grid data, dirty flag cannot be set")
            },
            beginEditCell: function(a, b) {
                var c = this.grid,
                d = c.getRow(a);
                return d ? void f.cancelTimer(c, d) : void e.logError("Unable to find rowEntity in grid data, timer cannot be cancelled")
            },
            cancelEditCell: function(a, b) {
                var c = this.grid,
                d = c.getRow(a);
                return d ? void f.considerSetTimer(c, d) : void e.logError("Unable to find rowEntity in grid data, timer cannot be set")
            },
            navigate: function(a, b) {
                var c = this.grid;
                a.row.rowEditSaveTimer && f.cancelTimer(c, a.row),
                b && b.row && b.row !== a.row && f.considerSetTimer(c, b.row)
            },
            considerSetTimer: function(b, c) {
                if (f.cancelTimer(b, c), c.isDirty && !c.isSaving && -1 !== b.options.rowEditWaitInterval) {
                    var d = b.options.rowEditWaitInterval ? b.options.rowEditWaitInterval: 2e3;
                    c.rowEditSaveTimer = a(f.saveRow(b, c), d, 1)
                }
            },
            cancelTimer: function(b, c) {
                c.rowEditSaveTimer && !c.isSaving && (a.cancel(c.rowEditSaveTimer), delete c.rowEditSaveTimer)
            },
            setRowsDirty: function(a, b) {
                var c;
                b.forEach(function(b, d) {
                    c = a.getRow(b),
                    c ? (a.rowEdit.dirtyRows || (a.rowEdit.dirtyRows = []), c.isDirty || (c.isDirty = !0, a.rowEdit.dirtyRows.push(c)), delete c.isError, f.considerSetTimer(a, c)) : e.logError("requested row not found in rowEdit.setRowsDirty, row was: " + b)
                })
            },
            setRowsClean: function(a, b) {
                var c;
                b.forEach(function(b, d) {
                    c = a.getRow(b),
                    c ? (delete c.isDirty, f.removeRow(a.rowEdit.dirtyRows, c), f.cancelTimer(a, c), delete c.isError, f.removeRow(a.rowEdit.errorRows, c)) : e.logError("requested row not found in rowEdit.setRowsClean, row was: " + b)
                })
            }
        };
        return f
    }]),
    a.directive("uiGridRowEdit", ["gridUtil", "uiGridRowEditService", "uiGridEditConstants",
    function(a, b, c) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        b.initializeGrid(a, e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["$compile", "uiGridConstants", "gridUtil", "$parse",
    function(a, b, c, d) {
        return {
            priority: -200,
            scope: !1,
            compile: function(a, b) {
                var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
                return e = d ? d.slice(0, -1) + ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}": "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}",
                c.attr("ng-class", e),
                {
                    pre: function(a, b, c, d) {},
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.saveState", ["ui.grid", "ui.grid.selection", "ui.grid.cellNav", "ui.grid.grouping", "ui.grid.pinning", "ui.grid.treeView"]);
    a.constant("uiGridSaveStateConstants", {
        featureName: "saveState"
    }),
    a.service("uiGridSaveStateService", ["$q", "uiGridSaveStateConstants", "gridUtil", "$compile", "$interval", "uiGridConstants",
    function(a, b, c, d, e, f) {
        var g = {
            initializeGrid: function(a) {
                a.saveState = {},
                this.defaultGridOptions(a.options);
                var b = {
                    events: {
                        saveState: {}
                    },
                    methods: {
                        saveState: {
                            save: function() {
                                return g.save(a)
                            },
                            restore: function(b, c) {
                                g.restore(a, b, c)
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods)
            },
            defaultGridOptions: function(a) {
                a.saveWidths = a.saveWidths !== !1,
                a.saveOrder = a.saveOrder !== !1,
                a.saveScroll = a.saveScroll === !0,
                a.saveFocus = a.saveScroll !== !0 && a.saveFocus !== !1,
                a.saveVisible = a.saveVisible !== !1,
                a.saveSort = a.saveSort !== !1,
                a.saveFilter = a.saveFilter !== !1,
                a.saveSelection = a.saveSelection !== !1,
                a.saveGrouping = a.saveGrouping !== !1,
                a.saveGroupingExpandedStates = a.saveGroupingExpandedStates === !0,
                a.savePinning = a.savePinning !== !1,
                a.saveTreeView = a.saveTreeView !== !1
            },
            save: function(a) {
                var b = {};
                return b.columns = g.saveColumns(a),
                b.scrollFocus = g.saveScrollFocus(a),
                b.selection = g.saveSelection(a),
                b.grouping = g.saveGrouping(a),
                b.treeView = g.saveTreeView(a),
                b
            },
            restore: function(a, b, c) {
                c.columns && g.restoreColumns(a, c.columns),
                c.scrollFocus && g.restoreScrollFocus(a, b, c.scrollFocus),
                c.selection && g.restoreSelection(a, c.selection),
                c.grouping && g.restoreGrouping(a, c.grouping),
                c.treeView && g.restoreTreeView(a, c.treeView),
                a.refresh()
            },
            saveColumns: function(a) {
                var b = [];
                return a.getOnlyDataColumns().forEach(function(c) {
                    var d = {};
                    d.name = c.name,
                    a.options.saveVisible && (d.visible = c.visible),
                    a.options.saveWidths && (d.width = c.width),
                    a.options.saveSort && (d.sort = angular.copy(c.sort)),
                    a.options.saveFilter && (d.filters = [], c.filters.forEach(function(a) {
                        var b = {};
                        angular.forEach(a,
                        function(a, c) {
                            "condition" !== c && "$$hashKey" !== c && "placeholder" !== c && (b[c] = a)
                        }),
                        d.filters.push(b)
                    })),
                    a.api.pinning && a.options.savePinning && (d.pinned = c.renderContainer ? c.renderContainer: ""),
                    b.push(d)
                }),
                b
            },
            saveScrollFocus: function(a) {
                if (!a.api.cellNav) return {};
                var b = {};
                if (a.options.saveFocus) {
                    b.focus = !0;
                    var c = a.api.cellNav.getFocusedCell();
                    null !== c && (null !== c.col && (b.colName = c.col.colDef.name), null !== c.row && (b.rowVal = g.getRowVal(a, c.row)))
                }
                return (a.options.saveScroll || a.options.saveFocus && !b.colName && !b.rowVal) && (b.focus = !1, a.renderContainers.body.prevRowScrollIndex && (b.rowVal = g.getRowVal(a, a.renderContainers.body.visibleRowCache[a.renderContainers.body.prevRowScrollIndex])), a.renderContainers.body.prevColScrollIndex && (b.colName = a.renderContainers.body.visibleColumnCache[a.renderContainers.body.prevColScrollIndex].name)),
                b
            },
            saveSelection: function(a) {
                if (!a.api.selection || !a.options.saveSelection) return [];
                var b = a.api.selection.getSelectedGridRows().map(function(b) {
                    return g.getRowVal(a, b)
                });
                return b
            },
            saveGrouping: function(a) {
                return a.api.grouping && a.options.saveGrouping ? a.api.grouping.getGrouping(a.options.saveGroupingExpandedStates) : {}
            },
            saveTreeView: function(a) {
                return a.api.treeView && a.options.saveTreeView ? a.api.treeView.getTreeView() : {}
            },
            getRowVal: function(a, b) {
                if (!b) return null;
                var c = {};
                return a.options.saveRowIdentity ? (c.identity = !0, c.row = a.options.saveRowIdentity(b.entity)) : (c.identity = !1, c.row = a.renderContainers.body.visibleRowCache.indexOf(b)),
                c
            },
            restoreColumns: function(a, b) {
                var c = !1;
                b.forEach(function(b, d) {
                    var e = a.getColumn(b.name);
                    if (e && !a.isRowHeaderColumn(e)) { ! a.options.saveVisible || e.visible === b.visible && e.colDef.visible === b.visible || (e.visible = b.visible, e.colDef.visible = b.visible, a.api.core.raise.columnVisibilityChanged(e)),
                        a.options.saveWidths && (e.width = b.width),
                        !a.options.saveSort || angular.equals(e.sort, b.sort) || void 0 === e.sort && angular.isEmpty(b.sort) || (e.sort = angular.copy(b.sort), c = !0),
                        a.options.saveFilter && !angular.equals(e.filters, b.filters) && (b.filters.forEach(function(a, b) {
                            angular.extend(e.filters[b], a),
                            ("undefined" == typeof a.term || null === a.term) && delete e.filters[b].term
                        }), a.api.core.raise.filterChanged()),
                        a.api.pinning && a.options.savePinning && e.renderContainer !== b.pinned && a.api.pinning.pinColumn(e, b.pinned);
                        var f = a.getOnlyDataColumns().indexOf(e);
                        if ( - 1 !== f && a.options.saveOrder && f !== d) {
                            var g = a.columns.splice(f + a.rowHeaderColumns.length, 1)[0];
                            a.columns.splice(d + a.rowHeaderColumns.length, 0, g)
                        }
                    }
                }),
                c && a.api.core.raise.sortChanged(a, a.getColumnSorting())
            },
            restoreScrollFocus: function(a, b, c) {
                if (a.api.cellNav) {
                    var d, e;
                    if (c.colName) {
                        var f = a.options.columnDefs.filter(function(a) {
                            return a.name === c.colName
                        });
                        f.length > 0 && (d = f[0])
                    }
                    c.rowVal && c.rowVal.row && (e = c.rowVal.identity ? g.findRowByIdentity(a, c.rowVal) : a.renderContainers.body.visibleRowCache[c.rowVal.row]);
                    var h = e && e.entity ? e.entity: null; (d || h) && (c.focus ? a.api.cellNav.scrollToFocus(h, d) : a.scrollTo(h, d))
                }
            },
            restoreSelection: function(a, b) {
                a.api.selection && (a.api.selection.clearSelectedRows(), b.forEach(function(b) {
                    if (b.identity) {
                        var c = g.findRowByIdentity(a, b);
                        c && a.api.selection.selectRow(c.entity)
                    } else a.api.selection.selectRowByVisibleIndex(b.row)
                }))
            },
            restoreGrouping: function(a, b) {
                a.api.grouping && "undefined" != typeof b && null !== b && !angular.equals(b, {}) && a.api.grouping.setGrouping(b)
            },
            restoreTreeView: function(a, b) {
                a.api.treeView && "undefined" != typeof b && null !== b && !angular.equals(b, {}) && a.api.treeView.setTreeView(b)
            },
            findRowByIdentity: function(a, b) {
                if (!a.options.saveRowIdentity) return null;
                var c = a.rows.filter(function(c) {
                    return a.options.saveRowIdentity(c.entity) === b.row ? !0 : !1
                });
                return c.length > 0 ? c[0] : null
            }
        };
        return g
    }]),
    a.directive("uiGridSaveState", ["uiGridSaveStateConstants", "uiGridSaveStateService", "gridUtil", "$compile",
    function(a, b, c, d) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function(a, c, d, e) {
                b.initializeGrid(e.grid)
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.selection", ["ui.grid"]);
    a.constant("uiGridSelectionConstants", {
        featureName: "selection",
        selectionRowHeaderColName: "selectionRowHeaderCol"
    }),
    angular.module("ui.grid").config(["$provide",
    function(a) {
        a.decorator("GridRow", ["$delegate",
        function(a) {
            return a.prototype.setSelected = function(a) {
                this.isSelected = a,
                a ? this.grid.selection.selectedCount++:this.grid.selection.selectedCount--
            },
            a
        }])
    }]),
    a.service("uiGridSelectionService", ["$q", "$templateCache", "uiGridSelectionConstants", "gridUtil",
    function(a, b, c, d) {
        var e = {
            initializeGrid: function(a) {
                a.selection = {},
                a.selection.lastSelectedRow = null,
                a.selection.selectAll = !1,
                a.selection.selectedCount = 0,
                e.defaultGridOptions(a.options);
                var b = {
                    events: {
                        selection: {
                            rowSelectionChanged: function(a, b, c) {},
                            rowSelectionChangedBatch: function(a, b, c) {}
                        }
                    },
                    methods: {
                        selection: {
                            toggleRowSelection: function(b, c) {
                                var d = a.getRow(b);
                                null !== d && e.toggleRowSelection(a, d, c, a.options.multiSelect, a.options.noUnselect)
                            },
                            selectRow: function(b, c) {
                                var d = a.getRow(b);
                                null === d || d.isSelected || e.toggleRowSelection(a, d, c, a.options.multiSelect, a.options.noUnselect)
                            },
                            selectRowByVisibleIndex: function(b, c) {
                                var d = a.renderContainers.body.visibleRowCache[b];
                                null === d || "undefined" == typeof d || d.isSelected || e.toggleRowSelection(a, d, c, a.options.multiSelect, a.options.noUnselect)
                            },
                            unSelectRow: function(b, c) {
                                var d = a.getRow(b);
                                null !== d && d.isSelected && e.toggleRowSelection(a, d, c, a.options.multiSelect, a.options.noUnselect)
                            },
                            selectAllRows: function(b) {
                                if (a.options.multiSelect !== !1) {
                                    var c = [];
                                    a.rows.forEach(function(d) {
                                        d.isSelected || d.enableSelection === !1 || (d.setSelected(!0), e.decideRaiseSelectionEvent(a, d, c, b))
                                    }),
                                    e.decideRaiseSelectionBatchEvent(a, c, b),
                                    a.selection.selectAll = !0
                                }
                            },
                            selectAllVisibleRows: function(b) {
                                if (a.options.multiSelect !== !1) {
                                    var c = [];
                                    a.rows.forEach(function(d) {
                                        d.visible ? d.isSelected || d.enableSelection === !1 || (d.setSelected(!0), e.decideRaiseSelectionEvent(a, d, c, b)) : d.isSelected && (d.setSelected(!1), e.decideRaiseSelectionEvent(a, d, c, b))
                                    }),
                                    e.decideRaiseSelectionBatchEvent(a, c, b),
                                    a.selection.selectAll = !0
                                }
                            },
                            clearSelectedRows: function(b) {
                                e.clearSelectedRows(a, b)
                            },
                            getSelectedRows: function() {
                                return e.getSelectedRows(a).map(function(a) {
                                    return a.entity
                                })
                            },
                            getSelectedGridRows: function() {
                                return e.getSelectedRows(a)
                            },
                            getSelectedCount: function() {
                                return a.selection.selectedCount
                            },
                            setMultiSelect: function(b) {
                                a.options.multiSelect = b
                            },
                            setModifierKeysToMultiSelect: function(b) {
                                a.options.modifierKeysToMultiSelect = b
                            },
                            getSelectAllState: function() {
                                return a.selection.selectAll
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods)
            },
            defaultGridOptions: function(a) {
                a.enableRowSelection = a.enableRowSelection !== !1,
                a.multiSelect = a.multiSelect !== !1,
                a.noUnselect = a.noUnselect === !0,
                a.modifierKeysToMultiSelect = a.modifierKeysToMultiSelect === !0,
                a.enableRowHeaderSelection = a.enableRowHeaderSelection !== !1,
                "undefined" == typeof a.enableFullRowSelection && (a.enableFullRowSelection = !a.enableRowHeaderSelection),
                a.enableSelectAll = a.enableSelectAll !== !1,
                a.enableSelectionBatchEvent = a.enableSelectionBatchEvent !== !1,
                a.selectionRowHeaderWidth = angular.isDefined(a.selectionRowHeaderWidth) ? a.selectionRowHeaderWidth: 30,
                a.enableFooterTotalSelected = a.enableFooterTotalSelected !== !1,
                a.isRowSelectable = angular.isDefined(a.isRowSelectable) ? a.isRowSelectable: angular.noop
            },
            toggleRowSelection: function(a, b, c, d, f) {
                var g = b.isSelected;
                if (b.enableSelection !== !1 || g) {
                    var h;
                    d || g ? !d && g && (h = e.getSelectedRows(a), h.length > 1 && (g = !1, e.clearSelectedRows(a, c))) : e.clearSelectedRows(a, c),
                    g && f || (b.setSelected(!g), b.isSelected === !0 && (a.selection.lastSelectedRow = b), h = e.getSelectedRows(a), a.selection.selectAll = a.rows.length === h.length, a.api.selection.raise.rowSelectionChanged(b, c))
                }
            },
            shiftSelect: function(a, b, c, d) {
                if (d) {
                    var f = e.getSelectedRows(a),
                    g = f.length > 0 ? a.renderContainers.body.visibleRowCache.indexOf(a.selection.lastSelectedRow) : 0,
                    h = a.renderContainers.body.visibleRowCache.indexOf(b);
                    if (g > h) {
                        var i = g;
                        g = h,
                        h = i
                    }
                    for (var j = [], k = g; h >= k; k++) {
                        var l = a.renderContainers.body.visibleRowCache[k];
                        l && (l.isSelected || l.enableSelection === !1 || (l.setSelected(!0), a.selection.lastSelectedRow = l, e.decideRaiseSelectionEvent(a, l, j, c)))
                    }
                    e.decideRaiseSelectionBatchEvent(a, j, c)
                }
            },
            getSelectedRows: function(a) {
                return a.rows.filter(function(a) {
                    return a.isSelected
                })
            },
            clearSelectedRows: function(a, b) {
                var c = [];
                e.getSelectedRows(a).forEach(function(d) {
                    d.isSelected && (d.setSelected(!1), e.decideRaiseSelectionEvent(a, d, c, b))
                }),
                e.decideRaiseSelectionBatchEvent(a, c, b),
                a.selection.selectAll = !1,
                a.selection.selectedCount = 0
            },
            decideRaiseSelectionEvent: function(a, b, c, d) {
                a.options.enableSelectionBatchEvent ? c.push(b) : a.api.selection.raise.rowSelectionChanged(b, d)
            },
            decideRaiseSelectionBatchEvent: function(a, b, c) {
                b.length > 0 && a.api.selection.raise.rowSelectionChangedBatch(b, c)
            }
        };
        return e
    }]),
    a.directive("uiGridSelection", ["uiGridSelectionConstants", "uiGridSelectionService", "$templateCache", "uiGridConstants",
    function(a, b, c, d) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(c, e, f, g) {
                        if (b.initializeGrid(g.grid), g.grid.options.enableRowHeaderSelection) {
                            var h = {
                                name: a.selectionRowHeaderColName,
                                displayName: "",
                                width: g.grid.options.selectionRowHeaderWidth,
                                minWidth: 10,
                                cellTemplate: "ui-grid/selectionRowHeader",
                                headerCellTemplate: "ui-grid/selectionHeaderCell",
                                enableColumnResizing: !1,
                                enableColumnMenu: !1,
                                exporterSuppressExport: !0,
                                allowCellFocus: !0
                            };
                            g.grid.addRowHeaderColumn(h)
                        }
                        var i = !1,
                        j = function(a) {
                            return a.forEach(function(a) {
                                a.enableSelection = g.grid.options.isRowSelectable(a)
                            }),
                            a
                        },
                        k = function() {
                            g.grid.options.isRowSelectable !== angular.noop && i !== !0 && (g.grid.registerRowsProcessor(j, 500), i = !0)
                        };
                        k();
                        var l = g.grid.registerDataChangeCallback(k, [d.dataChange.OPTIONS]);
                        c.$on("$destroy", l)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridSelectionRowHeaderButtons", ["$templateCache", "uiGridSelectionService", "gridUtil",
    function(a, b, c) {
        return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/selectionRowHeaderButtons"),
            scope: !0,
            require: "^uiGrid",
            link: function(a, d, e, f) {
                function g(a, c) {
                    c.stopPropagation(),
                    c.shiftKey ? b.shiftSelect(i, a, c, i.options.multiSelect) : c.ctrlKey || c.metaKey ? b.toggleRowSelection(i, a, c, i.options.multiSelect, i.options.noUnselect) : b.toggleRowSelection(i, a, c, i.options.multiSelect && !i.options.modifierKeysToMultiSelect, i.options.noUnselect)
                }
                function h(a) { (a.ctrlKey || a.shiftKey) && (a.target.onselectstart = function() {
                        return ! 1
                    },
                    window.setTimeout(function() {
                        a.target.onselectstart = null
                    },
                    0))
                }
                var i = f.grid;
                a.selectButtonClick = g,
                "ie" === c.detectBrowser() && d.on("mousedown", h)
            }
        }
    }]),
    a.directive("uiGridSelectionSelectAllButtons", ["$templateCache", "uiGridSelectionService",
    function(a, b) {
        return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/selectionSelectAllButtons"),
            scope: !1,
            link: function(a, c, d, e) {
                var f = a.col.grid;
                a.headerButtonClick = function(a, c) {
                    f.selection.selectAll ? (b.clearSelectedRows(f, c), f.options.noUnselect && f.api.selection.selectRowByVisibleIndex(0, c), f.selection.selectAll = !1) : f.options.multiSelect && (f.api.selection.selectAllVisibleRows(c), f.selection.selectAll = !0)
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService",
    function(a, b, c, d, e, f) {
        return {
            priority: -200,
            scope: !1,
            compile: function(a, b) {
                var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
                return e = d ? d.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}": "{'ui-grid-row-selected': row.isSelected}",
                c.attr("ng-class", e),
                {
                    pre: function(a, b, c, d) {},
                    post: function(a, b, c, d) {}
                }
            }
        }
    }]),
    a.directive("uiGridCell", ["$compile", "uiGridConstants", "uiGridSelectionConstants", "gridUtil", "$parse", "uiGridSelectionService", "$timeout",
    function(a, b, c, d, e, f, g) {
        return {
            priority: -200,
            restrict: "A",
            require: "?^uiGrid",
            scope: !1,
            link: function(a, c, d, e) {
                function h() {
                    a.grid.options.enableRowSelection && a.grid.options.enableFullRowSelection && (c.addClass("ui-grid-disable-selection"), c.on("touchstart", m), c.on("touchend", n), c.on("click", l), a.registered = !0)
                }
                function i() {
                    a.registered && (c.removeClass("ui-grid-disable-selection"), c.off("touchstart", m), c.off("touchend", n), c.off("click", l), a.registered = !1)
                }
                var j = 0,
                k = 300;
                e.grid.api.cellNav && e.grid.api.cellNav.on.viewPortKeyDown(a,
                function(b, c) {
                    null !== c && c.row === a.row && c.col === a.col && 32 === b.keyCode && "selectionRowHeaderCol" === a.col.colDef.name && (f.toggleRowSelection(a.grid, a.row, b, a.grid.options.multiSelect && !a.grid.options.modifierKeysToMultiSelect, a.grid.options.noUnselect), a.$apply())
                });
                var l = function(b) {
                    c.off("touchend", n),
                    b.shiftKey ? f.shiftSelect(a.grid, a.row, b, a.grid.options.multiSelect) : b.ctrlKey || b.metaKey ? f.toggleRowSelection(a.grid, a.row, b, a.grid.options.multiSelect, a.grid.options.noUnselect) : f.toggleRowSelection(a.grid, a.row, b, a.grid.options.multiSelect && !a.grid.options.modifierKeysToMultiSelect, a.grid.options.noUnselect),
                    a.$apply(),
                    g(function() {
                        c.on("touchend", n)
                    },
                    k)
                },
                m = function(a) {
                    j = (new Date).getTime(),
                    c.off("click", l)
                },
                n = function(a) {
                    var b = (new Date).getTime(),
                    d = b - j;
                    k > d && l(a),
                    g(function() {
                        c.on("click", l)
                    },
                    k)
                };
                h();
                var o = a.grid.registerDataChangeCallback(function() {
                    a.grid.options.enableRowSelection && a.grid.options.enableFullRowSelection && !a.registered ? h() : a.grid.options.enableRowSelection && a.grid.options.enableFullRowSelection || !a.registered || i();
                },
                [b.dataChange.OPTIONS]);
                c.on("$destroy", o)
            }
        }
    }]),
    a.directive("uiGridGridFooter", ["$compile", "uiGridConstants", "gridUtil",
    function(a, b, c) {
        return {
            restrict: "EA",
            replace: !0,
            priority: -1e3,
            require: "^uiGrid",
            scope: !0,
            compile: function(b, d) {
                return {
                    pre: function(b, d, e, f) {
                        f.grid.options.showGridFooter && c.getTemplate("ui-grid/gridFooterSelectedItems").then(function(c) {
                            var e = angular.element(c),
                            f = a(e)(b);
                            angular.element(d[0].getElementsByClassName("ui-grid-grid-footer")[0]).append(f)
                        })
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.treeBase", ["ui.grid"]);
    a.constant("uiGridTreeBaseConstants", {
        featureName: "treeBase",
        rowHeaderColName: "treeBaseRowHeaderCol",
        EXPANDED: "expanded",
        COLLAPSED: "collapsed",
        aggregation: {
            COUNT: "count",
            SUM: "sum",
            MAX: "max",
            MIN: "min",
            AVG: "avg"
        }
    }),
    a.service("uiGridTreeBaseService", ["$q", "uiGridTreeBaseConstants", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants", "rowSorter",
    function(a, b, c, d, e, f, g, h) {
        var i = {
            initializeGrid: function(a, b) {
                a.treeBase = {},
                a.treeBase.numberLevels = 0,
                a.treeBase.expandAll = !1,
                a.treeBase.tree = [],
                i.defaultGridOptions(a.options),
                a.registerRowsProcessor(i.treeRows, 410),
                a.registerColumnBuilder(i.treeBaseColumnBuilder),
                i.createRowHeader(a);
                var c = {
                    events: {
                        treeBase: {
                            rowExpanded: {},
                            rowCollapsed: {}
                        }
                    },
                    methods: {
                        treeBase: {
                            expandAllRows: function() {
                                i.expandAllRows(a)
                            },
                            collapseAllRows: function() {
                                i.collapseAllRows(a)
                            },
                            toggleRowTreeState: function(b) {
                                i.toggleRowTreeState(a, b)
                            },
                            expandRow: function(b) {
                                i.expandRow(a, b)
                            },
                            expandRowChildren: function(b) {
                                i.expandRowChildren(a, b)
                            },
                            collapseRow: function(b) {
                                i.collapseRow(a, b)
                            },
                            collapseRowChildren: function(b) {
                                i.collapseRowChildren(a, b)
                            },
                            getTreeExpandedState: function() {
                                return {
                                    expandedState: i.getTreeState(a)
                                }
                            },
                            setTreeState: function(b) {
                                i.setTreeState(a, b)
                            },
                            getRowChildren: function(a) {
                                return a.treeNode.children.map(function(a) {
                                    return a.row
                                })
                            }
                        }
                    }
                };
                a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods)
            },
            defaultGridOptions: function(a) {
                a.treeRowHeaderBaseWidth = a.treeRowHeaderBaseWidth || 30,
                a.treeIndent = a.treeIndent || 10,
                a.showTreeRowHeader = a.showTreeRowHeader !== !1,
                a.showTreeExpandNoChildren = a.showTreeExpandNoChildren !== !1,
                a.treeRowHeaderAlwaysVisible = a.treeRowHeaderAlwaysVisible !== !1,
                a.treeCustomAggregations = a.treeCustomAggregations || {}
            },
            treeBaseColumnBuilder: function(a, b, c) {
                "undefined" != typeof a.customTreeAggregationFn && (b.treeAggregationFn = a.customTreeAggregationFn),
                "undefined" != typeof a.treeAggregationType && (b.treeAggregation = {
                    type: a.treeAggregationType
                },
                "undefined" != typeof c.treeCustomAggregations[a.treeAggregationType] ? (b.treeAggregationFn = c.treeCustomAggregations[a.treeAggregationType].aggregationFn, b.treeAggregationFinalizerFn = c.treeCustomAggregations[a.treeAggregationType].finalizerFn, b.treeAggregation.label = c.treeCustomAggregations[a.treeAggregationType].label) : "undefined" != typeof i.nativeAggregations()[a.treeAggregationType] && (b.treeAggregationFn = i.nativeAggregations()[a.treeAggregationType].aggregationFn, b.treeAggregation.label = i.nativeAggregations()[a.treeAggregationType].label)),
                "undefined" != typeof a.treeAggregationLabel && ("undefined" == typeof b.treeAggregation && (b.treeAggregation = {}), b.treeAggregation.label = a.treeAggregationLabel),
                b.treeAggregationUpdateEntity = a.treeAggregationUpdateEntity !== !1,
                "undefined" == typeof b.customTreeAggregationFinalizerFn && (b.customTreeAggregationFinalizerFn = a.customTreeAggregationFinalizerFn)
            },
            createRowHeader: function(a) {
                var c = {
                    name: b.rowHeaderColName,
                    displayName: "",
                    width: a.options.treeRowHeaderBaseWidth,
                    minWidth: 10,
                    cellTemplate: "ui-grid/treeBaseRowHeader",
                    headerCellTemplate: "ui-grid/treeBaseHeaderCell",
                    enableColumnResizing: !1,
                    enableColumnMenu: !1,
                    exporterSuppressExport: !0,
                    allowCellFocus: !0
                };
                c.visible = a.options.treeRowHeaderAlwaysVisible,
                a.addRowHeaderColumn(c)
            },
            expandAllRows: function(a) {
                a.treeBase.tree.forEach(function(c) {
                    i.setAllNodes(a, c, b.EXPANDED)
                }),
                a.treeBase.expandAll = !0,
                a.queueGridRefresh()
            },
            collapseAllRows: function(a) {
                a.treeBase.tree.forEach(function(c) {
                    i.setAllNodes(a, c, b.COLLAPSED)
                }),
                a.treeBase.expandAll = !1,
                a.queueGridRefresh()
            },
            setAllNodes: function(a, c, d) {
                "undefined" != typeof c.state && c.state !== d && (c.state = d, d === b.EXPANDED ? a.api.treeBase.raise.rowExpanded(c.row) : a.api.treeBase.raise.rowCollapsed(c.row)),
                c.children && c.children.forEach(function(b) {
                    i.setAllNodes(a, b, d)
                })
            },
            toggleRowTreeState: function(a, c) {
                "undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0 || (c.treeNode.state === b.EXPANDED ? i.collapseRow(a, c) : i.expandRow(a, c), a.queueGridRefresh())
            },
            expandRow: function(a, c) {
                "undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0 || c.treeNode.state !== b.EXPANDED && (c.treeNode.state = b.EXPANDED, a.api.treeBase.raise.rowExpanded(c), a.treeBase.expandAll = i.allExpanded(a.treeBase.tree), a.queueGridRefresh())
            },
            expandRowChildren: function(a, c) {
                "undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0 || (i.setAllNodes(a, c.treeNode, b.EXPANDED), a.treeBase.expandAll = i.allExpanded(a.treeBase.tree), a.queueGridRefresh())
            },
            collapseRow: function(a, c) {
                "undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0 || c.treeNode.state !== b.COLLAPSED && (c.treeNode.state = b.COLLAPSED, a.treeBase.expandAll = !1, a.api.treeBase.raise.rowCollapsed(c), a.queueGridRefresh())
            },
            collapseRowChildren: function(a, c) {
                "undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0 || (i.setAllNodes(a, c.treeNode, b.COLLAPSED), a.treeBase.expandAll = !1, a.queueGridRefresh())
            },
            allExpanded: function(a) {
                var b = !0;
                return a.forEach(function(a) {
                    i.allExpandedInternal(a) || (b = !1)
                }),
                b
            },
            allExpandedInternal: function(a) {
                if (a.children && a.children.length > 0) {
                    if (a.state === b.COLLAPSED) return ! 1;
                    var c = !0;
                    return a.children.forEach(function(a) {
                        i.allExpandedInternal(a) || (c = !1)
                    }),
                    c
                }
                return ! 0
            },
            treeRows: function(a) {
                if (0 === a.length) return a;
                var c = this;
                b.EXPANDED;
                return c.treeBase.tree = i.createTree(c, a),
                i.updateRowHeaderWidth(c),
                i.sortTree(c),
                i.fixFilter(c),
                i.renderTree(c.treeBase.tree)
            },
            updateRowHeaderWidth: function(a) {
                var c = a.getColumn(b.rowHeaderColName),
                d = a.options.treeRowHeaderBaseWidth + a.options.treeIndent * Math.max(a.treeBase.numberLevels - 1, 0);
                c && d !== c.width && (c.width = d, a.queueRefresh());
                var e = !0;
                a.options.showTreeRowHeader === !1 && (e = !1),
                a.options.treeRowHeaderAlwaysVisible === !1 && a.treeBase.numberLevels <= 0 && (e = !1),
                c.visible !== e && (c.visible = e, c.colDef.visible = e, a.queueGridRefresh())
            },
            renderTree: function(a) {
                var c = [];
                return a.forEach(function(a) {
                    a.row.visible && c.push(a.row),
                    a.state === b.EXPANDED && a.children && a.children.length > 0 && (c = c.concat(i.renderTree(a.children)))
                }),
                c
            },
            createTree: function(a, c) {
                var d, e = -1,
                f = [];
                a.treeBase.tree = [],
                a.treeBase.numberLevels = 0;
                var g = i.getAggregations(a),
                h = function(c) {
                    if ("undefined" != typeof c.entity.$$treeLevel && c.treeLevel !== c.entity.$$treeLevel && (c.treeLevel = c.entity.$$treeLevel), c.treeLevel <= e) {
                        for (; c.treeLevel <= e;) {
                            var h = f.pop();
                            i.finaliseAggregations(h),
                            e--
                        }
                        d = f.length > 0 ? i.setCurrentState(f) : b.EXPANDED
                    } ("undefined" == typeof c.treeLevel || null === c.treeLevel || c.treeLevel < 0) && c.visible && i.aggregate(a, c, f),
                    i.addOrUseNode(a, c, f, g),
                    "undefined" != typeof c.treeLevel && null !== c.treeLevel && c.treeLevel >= 0 && (f.push(c), e++, d = i.setCurrentState(f)),
                    a.treeBase.numberLevels < c.treeLevel + 1 && (a.treeBase.numberLevels = c.treeLevel + 1)
                };
                for (c.forEach(h); f.length > 0;) {
                    var j = f.pop();
                    i.finaliseAggregations(j)
                }
                return a.treeBase.tree
            },
            addOrUseNode: function(a, c, d, e) {
                var f = [];
                e.forEach(function(a) {
                    f.push(i.buildAggregationObject(a.col))
                });
                var g = {
                    state: b.COLLAPSED,
                    row: c,
                    parentRow: null,
                    aggregations: f,
                    children: []
                };
                c.treeNode && (g.state = c.treeNode.state),
                d.length > 0 && (g.parentRow = d[d.length - 1]),
                c.treeNode = g,
                0 === d.length ? a.treeBase.tree.push(g) : d[d.length - 1].treeNode.children.push(g)
            },
            setCurrentState: function(a) {
                var c = b.EXPANDED;
                return a.forEach(function(a) {
                    a.treeNode.state === b.COLLAPSED && (c = b.COLLAPSED)
                }),
                c
            },
            sortTree: function(a) {
                a.columns.forEach(function(a) {
                    a.sort && a.sort.ignoreSort && delete a.sort.ignoreSort
                }),
                a.treeBase.tree = i.sortInternal(a, a.treeBase.tree)
            },
            sortInternal: function(a, c) {
                var d = c.map(function(a) {
                    return a.row
                });
                d = h.sort(a, d, a.columns);
                var e = d.map(function(a) {
                    return a.treeNode
                });
                return e.forEach(function(c) {
                    c.state === b.EXPANDED && c.children && c.children.length > 0 && (c.children = i.sortInternal(a, c.children))
                }),
                e
            },
            fixFilter: function(a) {
                var b;
                a.treeBase.tree.forEach(function(a) {
                    a.children && a.children.length > 0 && (b = a.row.visible, i.fixFilterInternal(a.children, b))
                })
            },
            fixFilterInternal: function(a, b) {
                return a.forEach(function(a) {
                    a.row.visible && !b && (i.setParentsVisible(a), b = !0),
                    a.children && a.children.length > 0 && i.fixFilterInternal(a.children, b && a.row.visible) && (b = !0)
                }),
                b
            },
            setParentsVisible: function(a) {
                for (; a.parentRow;) a.parentRow.visible = !0,
                a = a.parentRow.treeNode
            },
            buildAggregationObject: function(a) {
                var b = {
                    col: a
                };
                return a.treeAggregation && a.treeAggregation.type && (b.type = a.treeAggregation.type),
                a.treeAggregation && a.treeAggregation.label && (b.label = a.treeAggregation.label),
                b
            },
            getAggregations: function(a) {
                var b = [];
                return a.columns.forEach(function(c) {
                    "undefined" != typeof c.treeAggregationFn && (b.push(i.buildAggregationObject(c)), a.options.showColumnFooter && "undefined" == typeof c.colDef.aggregationType && c.treeAggregation && (c.treeFooterAggregation = i.buildAggregationObject(c), c.aggregationType = i.treeFooterAggregationType))
                }),
                b
            },
            aggregate: function(a, b, c) {
                0 === c.length && b.treeNode && b.treeNode.aggregations && b.treeNode.aggregations.forEach(function(c) {
                    if ("undefined" != typeof c.col.treeFooterAggregation) {
                        var d = a.getCellValue(b, c.col),
                        e = Number(d);
                        c.col.treeAggregationFn(c.col.treeFooterAggregation, d, e, b)
                    }
                }),
                c.forEach(function(c, d) {
                    c.treeNode.aggregations && c.treeNode.aggregations.forEach(function(c) {
                        var e = a.getCellValue(b, c.col),
                        f = Number(e);
                        c.col.treeAggregationFn(c, e, f, b),
                        0 === d && "undefined" != typeof c.col.treeFooterAggregation && c.col.treeAggregationFn(c.col.treeFooterAggregation, e, f, b)
                    })
                })
            },
            nativeAggregations: function() {
                var a = {
                    count: {
                        label: f.get().aggregation.count,
                        menuTitle: f.get().grouping.aggregate_count,
                        aggregationFn: function(a, b, c) {
                            "undefined" == typeof a.value ? a.value = 1 : a.value++
                        }
                    },
                    sum: {
                        label: f.get().aggregation.sum,
                        menuTitle: f.get().grouping.aggregate_sum,
                        aggregationFn: function(a, b, c) {
                            isNaN(c) || ("undefined" == typeof a.value ? a.value = c: a.value += c)
                        }
                    },
                    min: {
                        label: f.get().aggregation.min,
                        menuTitle: f.get().grouping.aggregate_min,
                        aggregationFn: function(a, b, c) {
                            "undefined" == typeof a.value ? a.value = b: "undefined" != typeof b && null !== b && (b < a.value || null === a.value) && (a.value = b)
                        }
                    },
                    max: {
                        label: f.get().aggregation.max,
                        menuTitle: f.get().grouping.aggregate_max,
                        aggregationFn: function(a, b, c) {
                            "undefined" == typeof a.value ? a.value = b: "undefined" != typeof b && null !== b && (b > a.value || null === a.value) && (a.value = b)
                        }
                    },
                    avg: {
                        label: f.get().aggregation.avg,
                        menuTitle: f.get().grouping.aggregate_avg,
                        aggregationFn: function(a, b, c) {
                            "undefined" == typeof a.count ? a.count = 1 : a.count++,
                            isNaN(c) || ("undefined" == typeof a.value || "undefined" == typeof a.sum ? (a.value = c, a.sum = c) : (a.sum += c, a.value = a.sum / a.count))
                        }
                    }
                };
                return a
            },
            finaliseAggregation: function(a, b) {
                b.col.treeAggregationUpdateEntity && "undefined" != typeof a && "undefined" != typeof a.entity["$$" + b.col.uid] && angular.extend(b, a.entity["$$" + b.col.uid]),
                "function" == typeof b.col.treeAggregationFinalizerFn && b.col.treeAggregationFinalizerFn(b),
                "function" == typeof b.col.customTreeAggregationFinalizerFn && b.col.customTreeAggregationFinalizerFn(b),
                "undefined" == typeof b.rendered && (b.rendered = b.label ? b.label + b.value: b.value)
            },
            finaliseAggregations: function(a) {
                "undefined" != typeof a.treeNode.aggregations && a.treeNode.aggregations.forEach(function(b) {
                    if (i.finaliseAggregation(a, b), b.col.treeAggregationUpdateEntity) {
                        var c = {};
                        angular.forEach(b,
                        function(a, d) {
                            b.hasOwnProperty(d) && "col" !== d && (c[d] = a)
                        }),
                        a.entity["$$" + b.col.uid] = c
                    }
                })
            },
            treeFooterAggregationType: function(a, b) {
                return i.finaliseAggregation(void 0, b.treeFooterAggregation),
                "undefined" == typeof b.treeFooterAggregation.value || null === b.treeFooterAggregation.rendered ? "": b.treeFooterAggregation.rendered
            }
        };
        return i
    }]),
    a.directive("uiGridTreeBaseRowHeaderButtons", ["$templateCache", "uiGridTreeBaseService",
    function(a, b) {
        return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/treeBaseRowHeaderButtons"),
            scope: !0,
            require: "^uiGrid",
            link: function(a, c, d, e) {
                var f = e.grid;
                a.treeButtonClick = function(a, c) {
                    console.log(a);
                    console.log(c);
                    b.toggleRowTreeState(f, a, c)
                }
            }
        }
    }]),
    a.directive("uiGridTreeBaseExpandAllButtons", ["$templateCache", "uiGridTreeBaseService",
    function(a, b) {
        return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/treeBaseExpandAllButtons"),
            scope: !1,
            link: function(a, c, d, e) {
                var f = a.col.grid;
                a.headerButtonClick = function(a, c) {
                    f.treeBase.expandAll ? b.collapseAllRows(f, c) : b.expandAllRows(f, c)
                }
            }
        }
    }]),
    a.directive("uiGridViewport", ["$compile", "uiGridConstants", "gridUtil", "$parse",
    function(a, b, c, d) {
        return {
            priority: -200,
            scope: !1,
            compile: function(a, b) {
                var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
                return e = d ? d.slice(0, -1) + ",'ui-grid-tree-header-row': row.treeLevel > -1}": "{'ui-grid-tree-header-row': row.treeLevel > -1}",
                c.attr("ng-class", e),
                {
                    pre: function(a, b, c, d) {},
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.treeView", ["ui.grid", "ui.grid.treeBase"]);
    a.constant("uiGridTreeViewConstants", {
        featureName: "treeView",
        rowHeaderColName: "treeBaseRowHeaderCol",
        EXPANDED: "expanded",
        COLLAPSED: "collapsed",
        aggregation: {
            COUNT: "count",
            SUM: "sum",
            MAX: "max",
            MIN: "min",
            AVG: "avg"
        }
    }),
    a.service("uiGridTreeViewService", ["$q", "uiGridTreeViewConstants", "uiGridTreeBaseConstants", "uiGridTreeBaseService", "gridUtil", "GridRow", "gridClassFactory", "i18nService", "uiGridConstants",
    function(a, b, c, d, e, f, g, h, i) {
        var j = {
            initializeGrid: function(a, b) {
                d.initializeGrid(a, b),
                a.treeView = {},
                a.registerRowsProcessor(j.adjustSorting, 60);
                var c = {
                    events: {
                        treeView: {}
                    },
                    methods: {
                        treeView: {}
                    }
                };
                a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods)
            },
            defaultGridOptions: function(a) {
                a.enableTreeView = a.enableTreeView !== !1
            },
            adjustSorting: function(a) {
                var b = this;
                return b.columns.forEach(function(a) {
                    a.sort && (a.sort.ignoreSort = !0)
                }),
                a
            }
        };
        return j
    }]),
    a.directive("uiGridTreeView", ["uiGridTreeViewConstants", "uiGridTreeViewService", "$templateCache",
    function(a, b, c) {
        return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        e.grid.options.enableTreeView !== !1 && b.initializeGrid(e.grid, a)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
function() {
    "use strict";
    var a = angular.module("ui.grid.validate", ["ui.grid"]);
    a.service("uiGridValidateService", ["$sce", "$q", "$http", "i18nService", "uiGridConstants",
    function(a, b, c, d, e) {
        var f = {
            validatorFactories: {},
            setExternalFactoryFunction: function(a) {
                f.externalFactoryFunction = a
            },
            clearExternalFactory: function() {
                delete f.externalFactoryFunction
            },
            getValidatorFromExternalFactory: function(a, b) {
                return f.externalFactoryFunction(a, b).validatorFactory(b)
            },
            getMessageFromExternalFactory: function(a, b) {
                return f.externalFactoryFunction(a, b).messageFunction(b)
            },
            setValidator: function(a, b, c) {
                f.validatorFactories[a] = {
                    validatorFactory: b,
                    messageFunction: c
                }
            },
            getValidator: function(a, b) {
                if (f.externalFactoryFunction) {
                    var c = f.getValidatorFromExternalFactory(a, b);
                    if (c) return c
                }
                if (!f.validatorFactories[a]) throw "Invalid validator name: " + a;
                return f.validatorFactories[a].validatorFactory(b)
            },
            getMessage: function(a, b) {
                if (f.externalFactoryFunction) {
                    var c = f.getMessageFromExternalFactory(a, b);
                    if (c) return c
                }
                return f.validatorFactories[a].messageFunction(b)
            },
            isInvalid: function(a, b) {
                return a["$$invalid" + b.name]
            },
            setInvalid: function(a, b) {
                a["$$invalid" + b.name] = !0
            },
            setValid: function(a, b) {
                delete a["$$invalid" + b.name]
            },
            setError: function(a, b, c) {
                a["$$errors" + b.name] || (a["$$errors" + b.name] = {}),
                a["$$errors" + b.name][c] = !0
            },
            clearError: function(a, b, c) {
                a["$$errors" + b.name] && c in a["$$errors" + b.name] && delete a["$$errors" + b.name][c]
            },
            getErrorMessages: function(a, b) {
                var c = [];
                return a["$$errors" + b.name] && 0 !== Object.keys(a["$$errors" + b.name]).length ? (Object.keys(a["$$errors" + b.name]).sort().forEach(function(a) {
                    c.push(f.getMessage(a, b.validators[a]))
                }), c) : c
            },
            getFormattedErrors: function(b, c) {
                var e = "",
                g = f.getErrorMessages(b, c);
                return g.length ? (g.forEach(function(a) {
                    e += a + "<br/>"
                }), a.trustAsHtml("<p><b>" + d.getSafeText("validate.error") + "</b></p>" + e)) : void 0
            },
            getTitleFormattedErrors: function(b, c) {
                var e = "\n",
                g = "",
                h = f.getErrorMessages(b, c);
                return h.length ? (h.forEach(function(a) {
                    g += a + e
                }), a.trustAsHtml(d.getSafeText("validate.error") + e + g)) : void 0
            },
            runValidators: function(a, c, d, e, g) {
                if (d !== e) {
                    if ("undefined" == typeof c.name || !c.name) throw new Error("colDef.name is required to perform validation");
                    f.setValid(a, c);
                    var h = function(a, b, c) {
                        return function(h) {
                            h || (f.setInvalid(a, b), f.setError(a, b, c), g && g.api.validate.raise.validationFailed(a, b, d, e))
                        }
                    };
                    for (var i in c.validators) {
                        f.clearError(a, c, i);
                        var j = f.getValidator(i, c.validators[i]);
                        b.when(j(e, d, a, c)).then(h(a, c, i))
                    }
                }
            },
            createDefaultValidators: function() {
                f.setValidator("minLength",
                function(a) {
                    return function(b, c, d, e) {
                        return void 0 === c || null === c || "" === c ? !0 : c.length >= a
                    }
                },
                function(a) {
                    return d.getSafeText("validate.minLength").replace("THRESHOLD", a)
                }),
                f.setValidator("maxLength",
                function(a) {
                    return function(b, c, d, e) {
                        return void 0 === c || null === c || "" === c ? !0 : c.length <= a
                    }
                },
                function(a) {
                    return d.getSafeText("validate.maxLength").replace("THRESHOLD", a)
                }),
                f.setValidator("required",
                function(a) {
                    return function(b, c, d, e) {
                        return a ? !(void 0 === c || null === c || "" === c) : !0
                    }
                },
                function(a) {
                    return d.getSafeText("validate.required")
                })
            },
            initializeGrid: function(a, b) {
                b.validate = {
                    isInvalid: f.isInvalid,
                    getFormattedErrors: f.getFormattedErrors,
                    getTitleFormattedErrors: f.getTitleFormattedErrors,
                    runValidators: f.runValidators
                };
                var c = {
                    events: {
                        validate: {
                            validationFailed: function(a, b, c, d) {}
                        }
                    },
                    methods: {
                        validate: {
                            isInvalid: function(a, c) {
                                return b.validate.isInvalid(a, c)
                            },
                            getErrorMessages: function(a, c) {
                                return b.validate.getErrorMessages(a, c)
                            },
                            getFormattedErrors: function(a, c) {
                                return b.validate.getFormattedErrors(a, c)
                            },
                            getTitleFormattedErrors: function(a, c) {
                                return b.validate.getTitleFormattedErrors(a, c)
                            }
                        }
                    }
                };
                b.api.registerEventsFromObject(c.events),
                b.api.registerMethodsFromObject(c.methods),
                b.edit && b.api.edit.on.afterCellEdit(a,
                function(a, c, d, e) {
                    b.validate.runValidators(a, c, d, e, b)
                }),
                f.createDefaultValidators()
            }
        };
        return f
    }]),
    a.directive("uiGridValidate", ["gridUtil", "uiGridValidateService",
    function(a, b) {
        return {
            priority: 0,
            replace: !0,
            require: "^uiGrid",
            scope: !1,
            compile: function() {
                return {
                    pre: function(a, c, d, e) {
                        b.initializeGrid(a, e.grid)
                    },
                    post: function(a, b, c, d) {}
                }
            }
        }
    }])
} (),
angular.module("ui.grid").run(["$templateCache",
function(a) {
    "use strict";
    a.put("ui-grid/ui-grid-filter", '<div class="ui-grid-filter-container" ng-repeat="colFilter in col.filters" ng-class="{\'ui-grid-filter-cancel-button-hidden\' : colFilter.disableCancelFilterButton === true }"><div ng-if="colFilter.type !== \'select\'"><input type="text" class="ui-grid-filter-input ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || \'\'}}" aria-label="{{colFilter.ariaLabel || aria.defaultFilterLabel}}"><div role="button" class="ui-grid-filter-button" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== \'\'"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div><div ng-if="colFilter.type === \'select\'"><select class="ui-grid-filter-select ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || aria.defaultFilterLabel}}" aria-label="{{colFilter.ariaLabel || \'\'}}" ng-options="option.value as option.label for option in colFilter.selectOptions"><option value=""></option></select><div role="button" class="ui-grid-filter-button-select" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term != null"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div></div>'),
    a.put("ui-grid/ui-grid-footer", '<div class="ui-grid-footer-panel ui-grid-footer-aggregates-row"><!-- tfooter --><div class="ui-grid-footer ui-grid-footer-viewport"><div class="ui-grid-footer-canvas"><div class="ui-grid-footer-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-footer-cell-row"><div ui-grid-footer-cell role="gridcell" ng-repeat="col in colContainer.renderedColumns track by col.uid" col="col" render-index="$index" class="ui-grid-footer-cell ui-grid-clearfix"></div></div></div></div></div></div>'),
    a.put("ui-grid/ui-grid-grid-footer", '<div class="ui-grid-footer-info ui-grid-grid-footer"><span>{{\'search.totalItems\' | t}} {{grid.rows.length}}</span> <span ng-if="grid.renderContainers.body.visibleRowCache.length !== grid.rows.length" class="ngLabel">({{"search.showingItems" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>'),
    a.put("ui-grid/ui-grid-group-panel", '<div class="ui-grid-group-panel"><div ui-t="groupPanel.description" class="description" ng-show="groupings.length == 0"></div><ul ng-show="groupings.length > 0" class="ngGroupList"><li class="ngGroupItem" ng-repeat="group in configGroups"><span class="ngGroupElement"><span class="ngGroupName">{{group.displayName}} <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span></span> <span ng-hide="$last" class="ngGroupArrow"></span></span></li></ul></div>'),
    a.put("ui-grid/ui-grid-header", '<div role="rowgroup" class="ui-grid-header"><!-- theader --><div class="ui-grid-top-panel"><div class="ui-grid-header-viewport"><div class="ui-grid-header-canvas"><div class="ui-grid-header-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-header-cell-row"><div class="ui-grid-header-cell ui-grid-clearfix" ng-repeat="col in colContainer.renderedColumns track by col.uid" ui-grid-header-cell col="col" render-index="$index"></div></div></div></div></div></div></div>'),
    a.put("ui-grid/ui-grid-menu-button", '<div class="ui-grid-menu-button"><div role="button" ui-grid-one-bind-id-grid="\'grid-menu\'" class="ui-grid-icon-container" ng-click="toggleMenu()" aria-haspopup="true"><i class="ui-grid-icon-menu" ui-grid-one-bind-aria-label="i18n.aria.buttonLabel">&nbsp;</i></div><div ui-grid-menu menu-items="menuItems"></div></div>'),
    a.put("ui-grid/ui-grid-no-header", '<div class="ui-grid-top-panel"></div>'),
    a.put("ui-grid/ui-grid-row", "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>"),
    a.put("ui-grid/ui-grid", '<div ui-i18n="en" class="ui-grid"><!-- TODO (c0bra): add "scoped" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n      /* Styles for the grid */\n    }\n\n    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n      height: {{ grid.options.rowHeight }}px;\n    }\n\n    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && \'1\') || \'0\' }}px;\n    }\n\n    {{ grid.verticalScrollbarStyles }}\n    {{ grid.horizontalScrollbarStyles }}\n\n    /*\n    .ui-grid[dir=rtl] .ui-grid-viewport {\n      padding-left: {{ grid.verticalScrollbarWidth }}px;\n    }\n    */\n\n    {{ grid.customStyles }}</style><div class="ui-grid-contents-wrapper"><div ui-grid-menu-button ng-if="grid.options.enableGridMenu"></div><div ng-if="grid.hasLeftContainer()" style="width: 0" ui-grid-pinned-container="\'left\'"></div><div ui-grid-render-container container-id="\'body\'" col-container-name="\'body\'" row-container-name="\'body\'" bind-scroll-horizontal="true" bind-scroll-vertical="true" enable-horizontal-scrollbar="grid.options.enableHorizontalScrollbar" enable-vertical-scrollbar="grid.options.enableVerticalScrollbar"></div><div ng-if="grid.hasRightContainer()" style="width: 0" ui-grid-pinned-container="\'right\'"></div><div ui-grid-grid-footer ng-if="grid.options.showGridFooter"></div><div ui-grid-column-menu ng-if="grid.options.enableColumnMenus"></div><div ng-transclude></div></div></div>'),
    a.put("ui-grid/uiGridCell", '<div class="ui-grid-cell-contents" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>'),
    a.put("ui-grid/uiGridColumnMenu", '<div class="ui-grid-column-menu"><div ui-grid-menu menu-items="menuItems"><!-- <div class="ui-grid-column-menu">\n    <div class="inner" ng-show="menuShown">\n      <ul>\n        <div ng-show="grid.options.enableSorting">\n          <li ng-click="sortColumn($event, asc)" ng-class="{ \'selected\' : col.sort.direction == asc }"><i class="ui-grid-icon-sort-alt-up"></i> Sort Ascending</li>\n          <li ng-click="sortColumn($event, desc)" ng-class="{ \'selected\' : col.sort.direction == desc }"><i class="ui-grid-icon-sort-alt-down"></i> Sort Descending</li>\n          <li ng-show="col.sort.direction" ng-click="unsortColumn()"><i class="ui-grid-icon-cancel"></i> Remove Sort</li>\n        </div>\n      </ul>\n    </div>\n  </div> --></div></div>'),
    a.put("ui-grid/uiGridFooterCell", '<div class="ui-grid-cell-contents" col-index="renderIndex"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>'),
    a.put("ui-grid/uiGridHeaderCell", '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}"><div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" title="TOOLTIP"><span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}"><i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{isSortPriorityVisible() ? i18n.headerCell.priority + \' \' + col.sort.priority : null}}" aria-hidden="true"></i> <sub ui-grid-visible="isSortPriorityVisible()" class="ui-grid-sort-priority-number">{{col.sort.priority}}</sub></span></div><div role="button" tabindex="0" ui-grid-one-bind-id-grid="col.uid + \'-menu-button\'" class="ui-grid-column-menu-button" ng-if="grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false" ng-click="toggleMenu($event)" ng-class="{\'ui-grid-column-menu-button-last-col\': isLastCol}" ui-grid-one-bind-aria-label="i18n.headerCell.aria.columnMenuButtonLabel" aria-haspopup="true"><i class="ui-grid-icon-angle-down" aria-hidden="true">&nbsp;</i></div><div ui-grid-filter></div></div>'),
    a.put("ui-grid/uiGridMenu", '<div class="ui-grid-menu" ng-if="shown"><style ui-grid-style>{{dynamicStyles}}</style><div class="ui-grid-menu-mid" ng-show="shownMid"><div class="ui-grid-menu-inner"><button type="button" ng-focus="focus=true" ng-blur="focus=false" class="ui-grid-menu-close-button" ng-class="{\'ui-grid-sr-only\': (!focus)}"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="i18n.close"></i></button><ul role="menu" class="ui-grid-menu-items"><li ng-repeat="item in menuItems" role="menuitem" ui-grid-menu-item ui-grid-one-bind-id="\'menuitem-\'+$index" action="item.action" name="item.title" active="item.active" icon="item.icon" shown="item.shown" context="item.context" template-url="item.templateUrl" leave-open="item.leaveOpen" screen-reader-only="item.screenReaderOnly"></li></ul></div></div></div>'),
    a.put("ui-grid/uiGridMenuItem", '<button type="button" class="ui-grid-menu-item" ng-click="itemAction($event, title)" ng-show="itemShown()" ng-class="{ \'ui-grid-menu-item-active\': active(), \'ui-grid-sr-only\': (!focus && screenReaderOnly) }" aria-pressed="{{active()}}" tabindex="0" ng-focus="focus=true" ng-blur="focus=false"><i ng-class="icon" aria-hidden="true">&nbsp;</i> {{ name }}</button>'),
    a.put("ui-grid/uiGridRenderContainer", "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>"),
    a.put("ui-grid/uiGridViewport", '<div role="rowgroup" class="ui-grid-viewport" ng-style="colContainer.getViewportStyle()"><!-- tbody 222--><div class="ui-grid-canvas"><div ng-repeat="(rowRenderIndex, row) in rowContainer.renderedRows track by $index" class="ui-grid-row" ng-style="Viewport.rowStyle(rowRenderIndex)"><div role="row" ui-grid-row="row" row-render-index="rowRenderIndex"></div></div></div></div>'),
    a.put("ui-grid/cellEditor", '<div><form name="inputForm"><input type="INPUT_TYPE" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD"></form></div>'),
    a.put("ui-grid/dropdownEditor", '<div><form name="inputForm"><select ng-class="\'colt\' + col.uid" ui-grid-edit-dropdown ng-model="MODEL_COL_FIELD" ng-options="field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray"></select></form></div>'),
    a.put("ui-grid/fileChooserEditor", '<div><form name="inputForm"><input ng-class="\'colt\' + col.uid" ui-grid-edit-file-chooser type="file" id="files" name="files[]" ng-model="MODEL_COL_FIELD"></form></div>'),
    a.put("ui-grid/expandableRow", '<div ui-grid-expandable-row ng-if="expandableRow.shouldRenderExpand()" class="expandableRow" style="float:left; margin-top: 1px; margin-bottom: 1px" ng-style="{width: (grid.renderContainers.body.getCanvasWidth()) + \'px\', height: row.expandedRowHeight + \'px\'}"></div>'),
    a.put("ui-grid/expandableRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !row.isExpanded, \'ui-grid-icon-minus-squared\' : row.isExpanded }" ng-click="grid.api.expandable.toggleRowExpansion(row.entity)"></i></div></div>'),
    a.put("ui-grid/expandableScrollFiller", "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: row.expandedRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( row.expandedRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>"),
    a.put("ui-grid/expandableTopRowHeader", '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !grid.expandable.expandedAll, \'ui-grid-icon-minus-squared\' : grid.expandable.expandedAll }" ng-click="grid.api.expandable.toggleAllRows()"></i></div></div>'),
    a.put("ui-grid/csvLink", '<span class="ui-grid-exporter-csv-link-span"><a href="data:text/csv;charset=UTF-8,CSV_CONTENT" download="FILE_NAME">LINK_LABEL</a></span>'),
    a.put("ui-grid/importerMenuItem", '<li class="ui-grid-menu-item"><form><input class="ui-grid-importer-file-chooser" type="file" id="files" name="files[]"></form></li>'),
    a.put("ui-grid/importerMenuItemContainer", "<div ui-grid-importer-menu-item></div>"),
    a.put("ui-grid/pagination", '<div role="contentinfo" class="ui-grid-pager-panel" ui-grid-pager ng-show="grid.options.enablePaginationControls"><div role="navigation" class="ui-grid-pager-container"><div role="menubar" class="ui-grid-pager-control"><button type="button" role="menuitem" class="ui-grid-pager-first" ui-grid-one-bind-title="aria.pageToFirst" ui-grid-one-bind-aria-label="aria.pageToFirst" ng-click="pageFirstPageClick()" ng-disabled="cantPageBackward()"><div class="first-triangle"><div class="first-bar"></div></div></button> <button type="button" role="menuitem" class="ui-grid-pager-previous" ui-grid-one-bind-title="aria.pageBack" ui-grid-one-bind-aria-label="aria.pageBack" ng-click="pagePreviousPageClick()" ng-disabled="cantPageBackward()"><div class="first-triangle prev-triangle"></div></button> <input type="number" ui-grid-one-bind-title="aria.pageSelected" ui-grid-one-bind-aria-label="aria.pageSelected" class="ui-grid-pager-control-input" ng-model="grid.options.paginationCurrentPage" min="1" max="{{ paginationApi.getTotalPages() }}" required> <span class="ui-grid-pager-max-pages-number" ng-show="paginationApi.getTotalPages() > 0"><abbr ui-grid-one-bind-title="paginationOf">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type="button" role="menuitem" class="ui-grid-pager-next" ui-grid-one-bind-title="aria.pageForward" ui-grid-one-bind-aria-label="aria.pageForward" ng-click="pageNextPageClick()" ng-disabled="cantPageForward()"><div class="last-triangle next-triangle"></div></button> <button type="button" role="menuitem" class="ui-grid-pager-last" ui-grid-one-bind-title="aria.pageToLast" ui-grid-one-bind-aria-label="aria.pageToLast" ng-click="pageLastPageClick()" ng-disabled="cantPageToLast()"><div class="last-triangle"><div class="last-bar"></div></div></button></div><div class="ui-grid-pager-row-count-picker" ng-if="grid.options.paginationPageSizes.length > 1"><select ui-grid-one-bind-aria-labelledby-grid="\'items-per-page-label\'" ng-model="grid.options.paginationPageSize" ng-options="o as o for o in grid.options.paginationPageSizes"></select><span ui-grid-one-bind-id-grid="\'items-per-page-label\'" class="ui-grid-pager-row-count-label">&nbsp;{{sizesLabel}}</span></div><span ng-if="grid.options.paginationPageSizes.length <= 1" class="ui-grid-pager-row-count-label">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class="ui-grid-pager-count-container"><div class="ui-grid-pager-count"><span ng-show="grid.options.totalItems > 0">{{showingLow}} <abbr ui-grid-one-bind-title="paginationThrough">-</abbr> {{showingHigh}} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>'),
    a.put("ui-grid/columnResizer", '<div ui-grid-column-resizer ng-if="grid.options.enableColumnResizing" class="ui-grid-column-resizer" col="col" position="right" render-index="renderIndex" unselectable="on"></div>'),
    a.put("ui-grid/gridFooterSelectedItems", '<span ng-if="grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected">({{"search.selectedItems" | t}} {{grid.selection.selectedCount}})</span>'),
    a.put("ui-grid/selectionHeaderCell", '<div><!-- <div class="ui-grid-vertical-bar">&nbsp;</div> --><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons></div></div>'),
    a.put("ui-grid/selectionRowHeader", '<div class="ui-grid-disable-selection"><div class="ui-grid-cell-contents"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>'),
    a.put("ui-grid/selectionRowHeaderButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-row-selected\': row.isSelected}" ng-click="selectButtonClick(row, $event)">&nbsp;</div>'),
    a.put("ui-grid/selectionSelectAllButtons", '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-all-selected\': grid.selection.selectAll}" ng-click="headerButtonClick($event)"></div>'),
    a.put("ui-grid/treeBaseExpandAllButtons", '<div class="ui-grid-tree-base-row-header-buttons" ng-class="{\'ui-grid-icon-minus-squared\': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, \'ui-grid-icon-plus-squared\': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}" ng-click="headerButtonClick($event)"></div>'),
    a.put("ui-grid/treeBaseHeaderCell", '<div><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-tree-base-expand-all-buttons></ui-grid-tree-base-expand-all-buttons></div></div>'),
    a.put("ui-grid/treeBaseRowHeader", '<div class="ui-grid-cell-contents"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>'),
    a.put("ui-grid/treeBaseRowHeaderButtons", "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>"),
    a.put("ui-grid/cellTitleValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" title="{{grid.validate.getTitleFormattedErrors(row.entity,col.colDef)}}">{{COL_FIELD CUSTOM_FILTERS}}</div>'),
    a.put("ui-grid/cellTooltipValidator", '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" tooltip-html-unsafe="{{grid.validate.getFormattedErrors(row.entity,col.colDef)}}" tooltip-enable="grid.validate.isInvalid(row.entity,col.colDef)" tooltip-append-to-body="true" tooltip-placement="top" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>')
}]);

angular.module('huatek.directives')
.directive('search',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/search.html',
        restrict:'E',
        replace:true
    }
}).directive('reportSearchOne',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/reportSearchOne.html',
        restrict:'E',
        replace:true
    }
}).directive('reportSearchTwo',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/reportSearchTwo.html',
        restrict:'E',
        replace:true
    }
}).directive('reportSearchThree',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/reportSearchThree.html',
        restrict:'E',
        replace:true
    }
}).directive('btn',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/btn.html',
        restrict:'E',
        replace:true
    }
}).directive('page',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/page.html',
        restrict:'E',
        replace:true
    }
}).directive('alert',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/alert.html',
        restrict:'E',
        replace:true
    }
}).directive('footer',function(){
    return {
        templateUrl: 'static/js/directives/custom/pageDirective/footer.html',
        restrict:'E',
        replace:true
    }
}).directive("huatekUploadify", function() {
    return {
        require: '?ngModel',
        restrict: 'A',
        priority: 1000,
        link: function ($scope, element, attrs, ngModel) {
        	console.log(attrs);
            var opts = angular.extend({}, $scope.$eval(attrs.nlUploadify));
            var optsEx =angular.extend({}, $scope.$eval(attrs.huatekUploadify));/*获取扩展参数*/
            var businessId=(optsEx.businessId!=null&&optsEx.businessId!=undefined)?optsEx.businessId:"";/*业务id*/
            var busiType=(optsEx.busiType!=null&&optsEx.busiType!=undefined)?optsEx.busiType:"";/*业务类型id*/
            var param={
                    'fileObjName': opts.fileObjName || 'upfile',
                    'auto': opts.auto!=undefined?opts.auto:true,
                    'swf': opts.swf || 'static/css/theme-default/uploadify.swf',
                    'uploader': opts.uploader || 'upload.do?actionMethod=process',/*图片上传方法*/
                    'buttonText': opts.buttonText || '上传文件',
                    'width': opts.width || 80,
                    'height': opts.height || 25,
                    'formData':{businessId:optsEx.businessId,busiType:busiType},
                    'onUploadSuccess': function (file, d, response) {
                    	if (ngModel) {
                    		var result=eval("[" + d + "]")[0];
                    		var visitUrl=result.visitUrl;/*获取访问地址*/
                    		var viewDivId=optsEx.viewDivId;/*获取显示图片的div*/
                    		var extFileName=result.extFileName;/*获取扩展名*/
                    		var fileId=result.fileId;/*返回文件的id  */
                    		if('true'==result.ifSuccess){
                          		if(visitUrl!=null&&visitUrl!=undefined&&viewDivId!=null&&viewDivId!=undefined&&("img"==extFileName||"png"==extFileName) )
                        		{
                        			var img="<span style='margin:2px;float:left'><img src='"+visitUrl+"'/></span>";
                        			var html=$("#"+viewDivId).html();
                        			$("#"+viewDivId).html(img+html);/*添加图片*/
                        		}
                    		}

                    		
  
                        }
                    }};
            element.uploadify(param);
        }
    };
}).directive('fileModel', ['$parse', function ($parse) {

    return {

        restrict: 'A',

        link: function(scope, element, attrs) {

            var model = $parse(attrs.fileModel);

            var modelSetter = model.assign;

            

            element.bind('change', function(){

                scope.$apply(function(){

                    modelSetter(scope, element[0].files[0]);

                });

            });

        }

    };

}]);

/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2013 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @website http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
* @version 4.1.7 (2013-04-21)
*******************************************************************************/
(function (window, undefined) {
	if (window.KindEditor) {
		return;
	}
if (!window.console) {
	window.console = {};
}
if (!console.log) {
	console.log = function () {};
}
var _VERSION = '4.1.7 (2013-04-21)',
	_ua = navigator.userAgent.toLowerCase(),
	_IE = _ua.indexOf('msie') > -1 && _ua.indexOf('opera') == -1,
	_GECKO = _ua.indexOf('gecko') > -1 && _ua.indexOf('khtml') == -1,
	_WEBKIT = _ua.indexOf('applewebkit') > -1,
	_OPERA = _ua.indexOf('opera') > -1,
	_MOBILE = _ua.indexOf('mobile') > -1,
	_IOS = /ipad|iphone|ipod/.test(_ua),
	_QUIRKS = document.compatMode != 'CSS1Compat',
	_matches = /(?:msie|firefox|webkit|opera)[\/:\s](\d+)/.exec(_ua),
	_V = _matches ? _matches[1] : '0',
	_TIME = new Date().getTime();
function _isArray(val) {
	if (!val) {
		return false;
	}
	return Object.prototype.toString.call(val) === '[object Array]';
}
function _isFunction(val) {
	if (!val) {
		return false;
	}
	return Object.prototype.toString.call(val) === '[object Function]';
}
function _inArray(val, arr) {
	for (var i = 0, len = arr.length; i < len; i++) {
		if (val === arr[i]) {
			return i;
		}
	}
	return -1;
}
function _each(obj, fn) {
	if (_isArray(obj)) {
		for (var i = 0, len = obj.length; i < len; i++) {
			if (fn.call(obj[i], i, obj[i]) === false) {
				break;
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn.call(obj[key], key, obj[key]) === false) {
					break;
				}
			}
		}
	}
}
function _trim(str) {
	return str.replace(/(?:^[ \t\n\r]+)|(?:[ \t\n\r]+$)/g, '');
}
function _inString(val, str, delimiter) {
	delimiter = delimiter === undefined ? ',' : delimiter;
	return (delimiter + str + delimiter).indexOf(delimiter + val + delimiter) >= 0;
}
function _addUnit(val, unit) {
	unit = unit || 'px';
	return val && /^\d+$/.test(val) ? val + unit : val;
}
function _removeUnit(val) {
	var match;
	return val && (match = /(\d+)/.exec(val)) ? parseInt(match[1], 10) : 0;
}
function _escape(val) {
	return val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
function _unescape(val) {
	return val.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&amp;/g, '&');
}
function _toCamel(str) {
	var arr = str.split('-');
	str = '';
	_each(arr, function(key, val) {
		str += (key > 0) ? val.charAt(0).toUpperCase() + val.substr(1) : val;
	});
	return str;
}
function _toHex(val) {
	function hex(d) {
		var s = parseInt(d, 10).toString(16).toUpperCase();
		return s.length > 1 ? s : '0' + s;
	}
	return val.replace(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/ig,
		function($0, $1, $2, $3) {
			return '#' + hex($1) + hex($2) + hex($3);
		}
	);
}
function _toMap(val, delimiter) {
	delimiter = delimiter === undefined ? ',' : delimiter;
	var map = {}, arr = _isArray(val) ? val : val.split(delimiter), match;
	_each(arr, function(key, val) {
		if ((match = /^(\d+)\.\.(\d+)$/.exec(val))) {
			for (var i = parseInt(match[1], 10); i <= parseInt(match[2], 10); i++) {
				map[i.toString()] = true;
			}
		} else {
			map[val] = true;
		}
	});
	return map;
}
function _toArray(obj, offset) {
	return Array.prototype.slice.call(obj, offset || 0);
}
function _undef(val, defaultVal) {
	return val === undefined ? defaultVal : val;
}
function _invalidUrl(url) {
	return !url || /[<>"]/.test(url);
}
function _addParam(url, param) {
	return url.indexOf('?') >= 0 ? url + '&' + param : url + '?' + param;
}
function _extend(child, parent, proto) {
	if (!proto) {
		proto = parent;
		parent = null;
	}
	var childProto;
	if (parent) {
		var fn = function () {};
		fn.prototype = parent.prototype;
		childProto = new fn();
		_each(proto, function(key, val) {
			childProto[key] = val;
		});
	} else {
		childProto = proto;
	}
	childProto.constructor = child;
	child.prototype = childProto;
	child.parent = parent ? parent.prototype : null;
}
function _json(text) {
	var match;
	if ((match = /\{[\s\S]*\}|\[[\s\S]*\]/.exec(text))) {
		text = match[0];
	}
	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
	cx.lastIndex = 0;
	if (cx.test(text)) {
		text = text.replace(cx, function (a) {
			return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
		});
	}
	if (/^[\],:{}\s]*$/.
	test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
	replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
	replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
		return eval('(' + text + ')');
	}
	throw 'JSON parse error';
}
var _round = Math.round;
var K = {
	DEBUG : false,
	VERSION : _VERSION,
	IE : _IE,
	GECKO : _GECKO,
	WEBKIT : _WEBKIT,
	OPERA : _OPERA,
	V : _V,
	TIME : _TIME,
	each : _each,
	isArray : _isArray,
	isFunction : _isFunction,
	inArray : _inArray,
	inString : _inString,
	trim : _trim,
	addUnit : _addUnit,
	removeUnit : _removeUnit,
	escape : _escape,
	unescape : _unescape,
	toCamel : _toCamel,
	toHex : _toHex,
	toMap : _toMap,
	toArray : _toArray,
	undef : _undef,
	invalidUrl : _invalidUrl,
	addParam : _addParam,
	extend : _extend,
	json : _json
};
var _INLINE_TAG_MAP = _toMap('a,abbr,acronym,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,img,input,ins,kbd,label,map,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'),
	_BLOCK_TAG_MAP = _toMap('address,applet,blockquote,body,center,dd,dir,div,dl,dt,fieldset,form,frameset,h1,h2,h3,h4,h5,h6,head,hr,html,iframe,ins,isindex,li,map,menu,meta,noframes,noscript,object,ol,p,pre,script,style,table,tbody,td,tfoot,th,thead,title,tr,ul'),
	_SINGLE_TAG_MAP = _toMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed'),
	_STYLE_TAG_MAP = _toMap('b,basefont,big,del,em,font,i,s,small,span,strike,strong,sub,sup,u'),
	_CONTROL_TAG_MAP = _toMap('img,table,input,textarea,button'),
	_PRE_TAG_MAP = _toMap('pre,style,script'),
	_NOSPLIT_TAG_MAP = _toMap('html,head,body,td,tr,table,ol,ul,li'),
	_AUTOCLOSE_TAG_MAP = _toMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr'),
	_FILL_ATTR_MAP = _toMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected'),
	_VALUE_TAG_MAP = _toMap('input,button,textarea,select');
function _getBasePath() {
	var els = document.getElementsByTagName('script'), src;
	for (var i = 0, len = els.length; i < len; i++) {
		src = els[i].src || '';
		if (/kindeditor[\w\-\.]*\.js/.test(src)) {
			return src.substring(0, src.lastIndexOf('/') + 1);
		}
	}
	return '';
}
K.basePath = _getBasePath();
K.options = {
	designMode : true,
	fullscreenMode : false,
	filterMode : true,
	wellFormatMode : true,
	shadowMode : true,
	loadStyleMode : true,
	basePath : K.basePath,
	themesPath : K.basePath + 'themes/',
	langPath : K.basePath + 'lang/',
	pluginsPath : K.basePath + '/',
	themeType : 'default',
	langType : 'zh_CN',
	urlType : '',
	newlineTag : 'p',
	resizeType : 2,
	syncType : 'form',
	pasteType : 2,
	dialogAlignType : 'page',
	useContextmenu : true,
	fullscreenShortcut : false,
	bodyClass : 'ke-content',
	indentChar : '\t',
	cssPath : '',
	cssData : '',
	minWidth : 650,
	minHeight : 100,
	minChangeSize : 50,
	zIndex : 811213,
	items : [
		'source', '|', 'undo', 'redo', '|', 'preview', 'print', 'template', 'code', 'cut', 'copy', 'paste',
		'plainpaste', 'wordpaste', '|', 'justifyleft', 'justifycenter', 'justifyright',
		'justifyfull', 'insertorderedlist', 'insertunorderedlist', 'indent', 'outdent', 'subscript',
		'superscript', 'clearhtml', 'quickformat', 'selectall', '|', 'fullscreen', '/',
		'formatblock', 'fontname', 'fontsize', '|', 'forecolor', 'hilitecolor', 'bold',
		'italic', 'underline', 'strikethrough', 'lineheight', 'removeformat', '|', 'image', 'multiimage',
		'flash', 'media', 'insertfile', 'table', 'hr', 'emoticons', 'baidumap', 'pagebreak',
		'anchor', 'link', 'unlink', '|', 'about'
	],
	noDisableItems : ['source', 'fullscreen'],
	colorTable : [
		['#E53333', '#E56600', '#FF9900', '#64451D', '#DFC5A4', '#FFE500'],
		['#009900', '#006600', '#99BB00', '#B8D100', '#60D978', '#00D5FF'],
		['#337FE5', '#003399', '#4C33E5', '#9933E5', '#CC33E5', '#EE33EE'],
		['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333', '#000000']
	],
	fontSizeTable : ['9px', '10px', '12px', '14px', '16px', '18px', '24px', '32px'],
	htmlTags : {
		font : ['id', 'class', 'color', 'size', 'face', '.background-color'],
		span : [
			'id', 'class', '.color', '.background-color', '.font-size', '.font-family', '.background',
			'.font-weight', '.font-style', '.text-decoration', '.vertical-align', '.line-height'
		],
		div : [
			'id', 'class', 'align', '.border', '.margin', '.padding', '.text-align', '.color',
			'.background-color', '.font-size', '.font-family', '.font-weight', '.background',
			'.font-style', '.text-decoration', '.vertical-align', '.margin-left'
		],
		table: [
			'id', 'class', 'border', 'cellspacing', 'cellpadding', 'width', 'height', 'align', 'bordercolor',
			'.padding', '.margin', '.border', 'bgcolor', '.text-align', '.color', '.background-color',
			'.font-size', '.font-family', '.font-weight', '.font-style', '.text-decoration', '.background',
			'.width', '.height', '.border-collapse'
		],
		'td,th': [
			'id', 'class', 'align', 'valign', 'width', 'height', 'colspan', 'rowspan', 'bgcolor',
			'.text-align', '.color', '.background-color', '.font-size', '.font-family', '.font-weight',
			'.font-style', '.text-decoration', '.vertical-align', '.background', '.border'
		],
		a : ['id', 'class', 'href', 'target', 'name'],
		embed : ['id', 'class', 'src', 'width', 'height', 'type', 'loop', 'autostart', 'quality', '.width', '.height', 'align', 'allowscriptaccess'],
		img : ['id', 'class', 'src', 'width', 'height', 'border', 'alt', 'title', 'align', '.width', '.height', '.border'],
		'p,ol,ul,li,blockquote,h1,h2,h3,h4,h5,h6' : [
			'id', 'class', 'align', '.text-align', '.color', '.background-color', '.font-size', '.font-family', '.background',
			'.font-weight', '.font-style', '.text-decoration', '.vertical-align', '.text-indent', '.margin-left'
		],
		pre : ['id', 'class'],
		hr : ['id', 'class', '.page-break-after'],
		'br,tbody,tr,strong,b,sub,sup,em,i,u,strike,s,del' : ['id', 'class'],
		iframe : ['id', 'class', 'src', 'frameborder', 'width', 'height', '.width', '.height']
	},
	layout : '<div class="container"><div class="toolbar"></div><div class="edit"></div><div class="statusbar"></div></div>'
};
var _useCapture = false;
var _INPUT_KEY_MAP = _toMap('8,9,13,32,46,48..57,59,61,65..90,106,109..111,188,190..192,219..222');
var _CURSORMOVE_KEY_MAP = _toMap('33..40');
var _CHANGE_KEY_MAP = {};
_each(_INPUT_KEY_MAP, function(key, val) {
	_CHANGE_KEY_MAP[key] = val;
});
_each(_CURSORMOVE_KEY_MAP, function(key, val) {
	_CHANGE_KEY_MAP[key] = val;
});
function _bindEvent(el, type, fn) {
	if (el.addEventListener){
		el.addEventListener(type, fn, _useCapture);
	} else if (el.attachEvent){
		el.attachEvent('on' + type, fn);
	}
}
function _unbindEvent(el, type, fn) {
	if (el.removeEventListener){
		el.removeEventListener(type, fn, _useCapture);
	} else if (el.detachEvent){
		el.detachEvent('on' + type, fn);
	}
}
var _EVENT_PROPS = ('altKey,attrChange,attrName,bubbles,button,cancelable,charCode,clientX,clientY,ctrlKey,currentTarget,' +
	'data,detail,eventPhase,fromElement,handler,keyCode,metaKey,newValue,offsetX,offsetY,originalTarget,pageX,' +
	'pageY,prevValue,relatedNode,relatedTarget,screenX,screenY,shiftKey,srcElement,target,toElement,view,wheelDelta,which').split(',');
function KEvent(el, event) {
	this.init(el, event);
}
_extend(KEvent, {
	init : function(el, event) {
		var self = this, doc = el.ownerDocument || el.document || el;
		self.event = event;
		_each(_EVENT_PROPS, function(key, val) {
			self[val] = event[val];
		});
		if (!self.target) {
			self.target = self.srcElement || doc;
		}
		if (self.target.nodeType === 3) {
			self.target = self.target.parentNode;
		}
		if (!self.relatedTarget && self.fromElement) {
			self.relatedTarget = self.fromElement === self.target ? self.toElement : self.fromElement;
		}
		if (self.pageX == null && self.clientX != null) {
			var d = doc.documentElement, body = doc.body;
			self.pageX = self.clientX + (d && d.scrollLeft || body && body.scrollLeft || 0) - (d && d.clientLeft || body && body.clientLeft || 0);
			self.pageY = self.clientY + (d && d.scrollTop  || body && body.scrollTop  || 0) - (d && d.clientTop  || body && body.clientTop  || 0);
		}
		if (!self.which && ((self.charCode || self.charCode === 0) ? self.charCode : self.keyCode)) {
			self.which = self.charCode || self.keyCode;
		}
		if (!self.metaKey && self.ctrlKey) {
			self.metaKey = self.ctrlKey;
		}
		if (!self.which && self.button !== undefined) {
			self.which = (self.button & 1 ? 1 : (self.button & 2 ? 3 : (self.button & 4 ? 2 : 0)));
		}
		switch (self.which) {
		case 186 :
			self.which = 59;
			break;
		case 187 :
		case 107 :
		case 43 :
			self.which = 61;
			break;
		case 189 :
		case 45 :
			self.which = 109;
			break;
		case 42 :
			self.which = 106;
			break;
		case 47 :
			self.which = 111;
			break;
		case 78 :
			self.which = 110;
			break;
		}
		if (self.which >= 96 && self.which <= 105) {
			self.which -= 48;
		}
	},
	preventDefault : function() {
		var ev = this.event;
		if (ev.preventDefault) {
			ev.preventDefault();
		}
		ev.returnValue = false;
	},
	stopPropagation : function() {
		var ev = this.event;
		if (ev.stopPropagation) {
			ev.stopPropagation();
		}
		ev.cancelBubble = true;
	},
	stop : function() {
		this.preventDefault();
		this.stopPropagation();
	}
});
var _eventExpendo = 'kindeditor_' + _TIME, _eventId = 0, _eventData = {};
function _getId(el) {
	return el[_eventExpendo] || null;
}
function _setId(el) {
	el[_eventExpendo] = ++_eventId;
	return _eventId;
}
function _removeId(el) {
	try {
		delete el[_eventExpendo];
	} catch(e) {
		if (el.removeAttribute) {
			el.removeAttribute(_eventExpendo);
		}
	}
}
function _bind(el, type, fn) {
	if (type.indexOf(',') >= 0) {
		_each(type.split(','), function() {
			_bind(el, this, fn);
		});
		return;
	}
	var id = _getId(el);
	if (!id) {
		id = _setId(el);
	}
	if (_eventData[id] === undefined) {
		_eventData[id] = {};
	}
	var events = _eventData[id][type];
	if (events && events.length > 0) {
		_unbindEvent(el, type, events[0]);
	} else {
		_eventData[id][type] = [];
		_eventData[id].el = el;
	}
	events = _eventData[id][type];
	if (events.length === 0) {
		events[0] = function(e) {
			var kevent = e ? new KEvent(el, e) : undefined;
			_each(events, function(i, event) {
				if (i > 0 && event) {
					event.call(el, kevent);
				}
			});
		};
	}
	if (_inArray(fn, events) < 0) {
		events.push(fn);
	}
	_bindEvent(el, type, events[0]);
}
function _unbind(el, type, fn) {
	if (type && type.indexOf(',') >= 0) {
		_each(type.split(','), function() {
			_unbind(el, this, fn);
		});
		return;
	}
	var id = _getId(el);
	if (!id) {
		return;
	}
	if (type === undefined) {
		if (id in _eventData) {
			_each(_eventData[id], function(key, events) {
				if (key != 'el' && events.length > 0) {
					_unbindEvent(el, key, events[0]);
				}
			});
			delete _eventData[id];
			_removeId(el);
		}
		return;
	}
	if (!_eventData[id]) {
		return;
	}
	var events = _eventData[id][type];
	if (events && events.length > 0) {
		if (fn === undefined) {
			_unbindEvent(el, type, events[0]);
			delete _eventData[id][type];
		} else {
			_each(events, function(i, event) {
				if (i > 0 && event === fn) {
					events.splice(i, 1);
				}
			});
			if (events.length == 1) {
				_unbindEvent(el, type, events[0]);
				delete _eventData[id][type];
			}
		}
		var count = 0;
		_each(_eventData[id], function() {
			count++;
		});
		if (count < 2) {
			delete _eventData[id];
			_removeId(el);
		}
	}
}
function _fire(el, type) {
	if (type.indexOf(',') >= 0) {
		_each(type.split(','), function() {
			_fire(el, this);
		});
		return;
	}
	var id = _getId(el);
	if (!id) {
		return;
	}
	var events = _eventData[id][type];
	if (_eventData[id] && events && events.length > 0) {
		events[0]();
	}
}
function _ctrl(el, key, fn) {
	var self = this;
	key = /^\d{2,}$/.test(key) ? key : key.toUpperCase().charCodeAt(0);
	_bind(el, 'keydown', function(e) {
		if (e.ctrlKey && e.which == key && !e.shiftKey && !e.altKey) {
			fn.call(el);
			e.stop();
		}
	});
}
function _ready(fn) {
	var loaded = false;
	function readyFunc() {
		if (!loaded) {
			loaded = true;
			fn(KindEditor);
		}
	}
	function ieReadyFunc() {
		if (!loaded) {
			try {
				document.documentElement.doScroll('left');
			} catch(e) {
				setTimeout(ieReadyFunc, 100);
				return;
			}
			readyFunc();
		}
	}
	function ieReadyStateFunc() {
		if (document.readyState === 'complete') {
			readyFunc();
		}
	}
	if (document.addEventListener) {
		_bind(document, 'DOMContentLoaded', readyFunc);
	} else if (document.attachEvent) {
		_bind(document, 'readystatechange', ieReadyStateFunc);
		var toplevel = false;
		try {
			toplevel = window.frameElement == null;
		} catch(e) {}
		if (document.documentElement.doScroll && toplevel) {
			ieReadyFunc();
		}
	}
	_bind(window, 'load', readyFunc);
}
if (_IE) {
	window.attachEvent('onunload', function() {
		_each(_eventData, function(key, events) {
			if (events.el) {
				_unbind(events.el);
			}
		});
	});
}
K.ctrl = _ctrl;
K.ready = _ready;
function _getCssList(css) {
	var list = {},
		reg = /\s*([\w\-]+)\s*:([^;]*)(;|$)/g,
		match;
	while ((match = reg.exec(css))) {
		var key = _trim(match[1].toLowerCase()),
			val = _trim(_toHex(match[2]));
		list[key] = val;
	}
	return list;
}
function _getAttrList(tag) {
	var list = {},
		reg = /\s+(?:([\w\-:]+)|(?:([\w\-:]+)=([^\s"'<>]+))|(?:([\w\-:"]+)="([^"]*)")|(?:([\w\-:"]+)='([^']*)'))(?=(?:\s|\/|>)+)/g,
		match;
	while ((match = reg.exec(tag))) {
		var key = (match[1] || match[2] || match[4] || match[6]).toLowerCase(),
			val = (match[2] ? match[3] : (match[4] ? match[5] : match[7])) || '';
		list[key] = val;
	}
	return list;
}
function _addClassToTag(tag, className) {
	if (/\s+class\s*=/.test(tag)) {
		tag = tag.replace(/(\s+class=["']?)([^"']*)(["']?[\s>])/, function($0, $1, $2, $3) {
			if ((' ' + $2 + ' ').indexOf(' ' + className + ' ') < 0) {
				return $2 === '' ? $1 + className + $3 : $1 + $2 + ' ' + className + $3;
			} else {
				return $0;
			}
		});
	} else {
		tag = tag.substr(0, tag.length - 1) + ' class="' + className + '">';
	}
	return tag;
}
function _formatCss(css) {
	var str = '';
	_each(_getCssList(css), function(key, val) {
		str += key + ':' + val + ';';
	});
	return str;
}
function _formatUrl(url, mode, host, pathname) {
	mode = _undef(mode, '').toLowerCase();
	if (url.substr(0, 5) != 'data:') {
		url = url.replace(/([^:])\/\//g, '$1/');
	}
	if (_inArray(mode, ['absolute', 'relative', 'domain']) < 0) {
		return url;
	}
	host = host || location.protocol + '//' + location.host;
	if (pathname === undefined) {
		var m = location.pathname.match(/^(\/.*)\//);
		pathname = m ? m[1] : '';
	}
	var match;
	if ((match = /^(\w+:\/\/[^\/]*)/.exec(url))) {
		if (match[1] !== host) {
			return url;
		}
	} else if (/^\w+:/.test(url)) {
		return url;
	}
	function getRealPath(path) {
		var parts = path.split('/'), paths = [];
		for (var i = 0, len = parts.length; i < len; i++) {
			var part = parts[i];
			if (part == '..') {
				if (paths.length > 0) {
					paths.pop();
				}
			} else if (part !== '' && part != '.') {
				paths.push(part);
			}
		}
		return '/' + paths.join('/');
	}
	if (/^\//.test(url)) {
		url = host + getRealPath(url.substr(1));
	} else if (!/^\w+:\/\//.test(url)) {
		url = host + getRealPath(pathname + '/' + url);
	}
	function getRelativePath(path, depth) {
		if (url.substr(0, path.length) === path) {
			var arr = [];
			for (var i = 0; i < depth; i++) {
				arr.push('..');
			}
			var prefix = '.';
			if (arr.length > 0) {
				prefix += '/' + arr.join('/');
			}
			if (pathname == '/') {
				prefix += '/';
			}
			return prefix + url.substr(path.length);
		} else {
			if ((match = /^(.*)\//.exec(path))) {
				return getRelativePath(match[1], ++depth);
			}
		}
	}
	if (mode === 'relative') {
		url = getRelativePath(host + pathname, 0).substr(2);
	} else if (mode === 'absolute') {
		if (url.substr(0, host.length) === host) {
			url = url.substr(host.length);
		}
	}
	return url;
}
function _formatHtml(html, htmlTags, urlType, wellFormatted, indentChar) {
	urlType = urlType || '';
	wellFormatted = _undef(wellFormatted, false);
	indentChar = _undef(indentChar, '\t');
	var fontSizeList = 'xx-small,x-small,small,medium,large,x-large,xx-large'.split(',');
	html = html.replace(/(<(?:pre|pre\s[^>]*)>)([\s\S]*?)(<\/pre>)/ig, function($0, $1, $2, $3) {
		return $1 + $2.replace(/<(?:br|br\s[^>]*)>/ig, '\n') + $3;
	});
	html = html.replace(/<(?:br|br\s[^>]*)\s*\/?>\s*<\/p>/ig, '</p>');
	html = html.replace(/(<(?:p|p\s[^>]*)>)\s*(<\/p>)/ig, '$1<br />$2');
	html = html.replace(/\u200B/g, '');
	html = html.replace(/\u00A9/g, '&copy;');
	var htmlTagMap = {};
	if (htmlTags) {
		_each(htmlTags, function(key, val) {
			var arr = key.split(',');
			for (var i = 0, len = arr.length; i < len; i++) {
				htmlTagMap[arr[i]] = _toMap(val);
			}
		});
		if (!htmlTagMap.script) {
			html = html.replace(/(<(?:script|script\s[^>]*)>)([\s\S]*?)(<\/script>)/ig, '');
		}
		if (!htmlTagMap.style) {
			html = html.replace(/(<(?:style|style\s[^>]*)>)([\s\S]*?)(<\/style>)/ig, '');
		}
	}
	var re = /([ \t\n\r]*)<(\/)?([\w\-:]+)((?:\s+|(?:\s+[\w\-:]+)|(?:\s+[\w\-:]+=[^\s"'<>]+)|(?:\s+[\w\-:"]+="[^"]*")|(?:\s+[\w\-:"]+='[^']*'))*)(\/)?>([ \t\n\r]*)/g;
	var tagStack = [];
	html = html.replace(re, function($0, $1, $2, $3, $4, $5, $6) {
		var full = $0,
			startNewline = $1 || '',
			startSlash = $2 || '',
			tagName = $3.toLowerCase(),
			attr = $4 || '',
			endSlash = $5 ? ' ' + $5 : '',
			endNewline = $6 || '';
		if (htmlTags && !htmlTagMap[tagName]) {
			return '';
		}
		if (endSlash === '' && _SINGLE_TAG_MAP[tagName]) {
			endSlash = ' /';
		}
		if (_INLINE_TAG_MAP[tagName]) {
			if (startNewline) {
				startNewline = ' ';
			}
			if (endNewline) {
				endNewline = ' ';
			}
		}
		if (_PRE_TAG_MAP[tagName]) {
			if (startSlash) {
				endNewline = '\n';
			} else {
				startNewline = '\n';
			}
		}
		if (wellFormatted && tagName == 'br') {
			endNewline = '\n';
		}
		if (_BLOCK_TAG_MAP[tagName] && !_PRE_TAG_MAP[tagName]) {
			if (wellFormatted) {
				if (startSlash && tagStack.length > 0 && tagStack[tagStack.length - 1] === tagName) {
					tagStack.pop();
				} else {
					tagStack.push(tagName);
				}
				startNewline = '\n';
				endNewline = '\n';
				for (var i = 0, len = startSlash ? tagStack.length : tagStack.length - 1; i < len; i++) {
					startNewline += indentChar;
					if (!startSlash) {
						endNewline += indentChar;
					}
				}
				if (endSlash) {
					tagStack.pop();
				} else if (!startSlash) {
					endNewline += indentChar;
				}
			} else {
				startNewline = endNewline = '';
			}
		}
		if (attr !== '') {
			var attrMap = _getAttrList(full);
			if (tagName === 'font') {
				var fontStyleMap = {}, fontStyle = '';
				_each(attrMap, function(key, val) {
					if (key === 'color') {
						fontStyleMap.color = val;
						delete attrMap[key];
					}
					if (key === 'size') {
						fontStyleMap['font-size'] = fontSizeList[parseInt(val, 10) - 1] || '';
						delete attrMap[key];
					}
					if (key === 'face') {
						fontStyleMap['font-family'] = val;
						delete attrMap[key];
					}
					if (key === 'style') {
						fontStyle = val;
					}
				});
				if (fontStyle && !/;$/.test(fontStyle)) {
					fontStyle += ';';
				}
				_each(fontStyleMap, function(key, val) {
					if (val === '') {
						return;
					}
					if (/\s/.test(val)) {
						val = "'" + val + "'";
					}
					fontStyle += key + ':' + val + ';';
				});
				attrMap.style = fontStyle;
			}
			_each(attrMap, function(key, val) {
				if (_FILL_ATTR_MAP[key]) {
					attrMap[key] = key;
				}
				if (_inArray(key, ['src', 'href']) >= 0) {
					attrMap[key] = _formatUrl(val, urlType);
				}
				if (htmlTags && key !== 'style' && !htmlTagMap[tagName]['*'] && !htmlTagMap[tagName][key] ||
					tagName === 'body' && key === 'contenteditable' ||
					/^kindeditor_\d+$/.test(key)) {
					delete attrMap[key];
				}
				if (key === 'style' && val !== '') {
					var styleMap = _getCssList(val);
					_each(styleMap, function(k, v) {
						if (htmlTags && !htmlTagMap[tagName].style && !htmlTagMap[tagName]['.' + k]) {
							delete styleMap[k];
						}
					});
					var style = '';
					_each(styleMap, function(k, v) {
						style += k + ':' + v + ';';
					});
					attrMap.style = style;
				}
			});
			attr = '';
			_each(attrMap, function(key, val) {
				if (key === 'style' && val === '') {
					return;
				}
				val = val.replace(/"/g, '&quot;');
				attr += ' ' + key + '="' + val + '"';
			});
		}
		if (tagName === 'font') {
			tagName = 'span';
		}
		return startNewline + '<' + startSlash + tagName + attr + endSlash + '>' + endNewline;
	});
	html = html.replace(/(<(?:pre|pre\s[^>]*)>)([\s\S]*?)(<\/pre>)/ig, function($0, $1, $2, $3) {
		return $1 + $2.replace(/\n/g, '<span id="__kindeditor_pre_newline__">\n') + $3;
	});
	html = html.replace(/\n\s*\n/g, '\n');
	html = html.replace(/<span id="__kindeditor_pre_newline__">\n/g, '\n');
	return _trim(html);
}
function _clearMsWord(html, htmlTags) {
	html = html.replace(/<meta[\s\S]*?>/ig, '')
		.replace(/<![\s\S]*?>/ig, '')
		.replace(/<style[^>]*>[\s\S]*?<\/style>/ig, '')
		.replace(/<script[^>]*>[\s\S]*?<\/script>/ig, '')
		.replace(/<w:[^>]+>[\s\S]*?<\/w:[^>]+>/ig, '')
		.replace(/<o:[^>]+>[\s\S]*?<\/o:[^>]+>/ig, '')
		.replace(/<xml>[\s\S]*?<\/xml>/ig, '')
		.replace(/<(?:table|td)[^>]*>/ig, function(full) {
			return full.replace(/border-bottom:([#\w\s]+)/ig, 'border:$1');
		});
	return _formatHtml(html, htmlTags);
}
function _mediaType(src) {
	if (/\.(rm|rmvb)(\?|$)/i.test(src)) {
		return 'audio/x-pn-realaudio-plugin';
	}
	if (/\.(swf|flv)(\?|$)/i.test(src)) {
		return 'application/x-shockwave-flash';
	}
	return 'video/x-ms-asf-plugin';
}
function _mediaClass(type) {
	if (/realaudio/i.test(type)) {
		return 'ke-rm';
	}
	if (/flash/i.test(type)) {
		return 'ke-flash';
	}
	return 'ke-media';
}
function _mediaAttrs(srcTag) {
	return _getAttrList(unescape(srcTag));
}
function _mediaEmbed(attrs) {
	var html = '<embed ';
	_each(attrs, function(key, val) {
		html += key + '="' + val + '" ';
	});
	html += '/>';
	return html;
}
function _mediaImg(blankPath, attrs) {
	var width = attrs.width,
		height = attrs.height,
		type = attrs.type || _mediaType(attrs.src),
		srcTag = _mediaEmbed(attrs),
		style = '';
	if (width > 0) {
		style += 'width:' + width + 'px;';
	}
	if (height > 0) {
		style += 'height:' + height + 'px;';
	}
	var html = '<img class="' + _mediaClass(type) + '" src="' + blankPath + '" ';
	if (style !== '') {
		html += 'style="' + style + '" ';
	}
	html += 'data-ke-tag="' + escape(srcTag) + '" alt="" />';
	return html;
}
function _tmpl(str, data) {
	var fn = new Function("obj",
		"var p=[],print=function(){p.push.apply(p,arguments);};" +
		"with(obj){p.push('" +
		str.replace(/[\r\t\n]/g, " ")
			.split("<%").join("\t")
			.replace(/((^|%>)[^\t]*)'/g, "$1\r")
			.replace(/\t=(.*?)%>/g, "',$1,'")
			.split("\t").join("');")
			.split("%>").join("p.push('")
			.split("\r").join("\\'") + "');}return p.join('');");
	return data ? fn(data) : fn;
}
K.formatUrl = _formatUrl;
K.formatHtml = _formatHtml;
K.getCssList = _getCssList;
K.getAttrList = _getAttrList;
K.mediaType = _mediaType;
K.mediaAttrs = _mediaAttrs;
K.mediaEmbed = _mediaEmbed;
K.mediaImg = _mediaImg;
K.clearMsWord = _clearMsWord;
K.tmpl = _tmpl;
function _contains(nodeA, nodeB) {
	if (nodeA.nodeType == 9 && nodeB.nodeType != 9) {
		return true;
	}
	while ((nodeB = nodeB.parentNode)) {
		if (nodeB == nodeA) {
			return true;
		}
	}
	return false;
}
var _getSetAttrDiv = document.createElement('div');
_getSetAttrDiv.setAttribute('className', 't');
var _GET_SET_ATTRIBUTE = _getSetAttrDiv.className !== 't';
function _getAttr(el, key) {
	key = key.toLowerCase();
	var val = null;
	if (!_GET_SET_ATTRIBUTE && el.nodeName.toLowerCase() != 'script') {
		var div = el.ownerDocument.createElement('div');
		div.appendChild(el.cloneNode(false));
		var list = _getAttrList(_unescape(div.innerHTML));
		if (key in list) {
			val = list[key];
		}
	} else {
		try {
			val = el.getAttribute(key, 2);
		} catch(e) {
			val = el.getAttribute(key, 1);
		}
	}
	if (key === 'style' && val !== null) {
		val = _formatCss(val);
	}
	return val;
}
function _queryAll(expr, root) {
	var exprList = expr.split(',');
	if (exprList.length > 1) {
		var mergedResults = [];
		_each(exprList, function() {
			_each(_queryAll(this, root), function() {
				if (_inArray(this, mergedResults) < 0) {
					mergedResults.push(this);
				}
			});
		});
		return mergedResults;
	}
	root = root || document;
	function escape(str) {
		if (typeof str != 'string') {
			return str;
		}
		return str.replace(/([^\w\-])/g, '\\$1');
	}
	function stripslashes(str) {
		return str.replace(/\\/g, '');
	}
	function cmpTag(tagA, tagB) {
		return tagA === '*' || tagA.toLowerCase() === escape(tagB.toLowerCase());
	}
	function byId(id, tag, root) {
		var arr = [],
			doc = root.ownerDocument || root,
			el = doc.getElementById(stripslashes(id));
		if (el) {
			if (cmpTag(tag, el.nodeName) && _contains(root, el)) {
				arr.push(el);
			}
		}
		return arr;
	}
	function byClass(className, tag, root) {
		var doc = root.ownerDocument || root, arr = [], els, i, len, el;
		if (root.getElementsByClassName) {
			els = root.getElementsByClassName(stripslashes(className));
			for (i = 0, len = els.length; i < len; i++) {
				el = els[i];
				if (cmpTag(tag, el.nodeName)) {
					arr.push(el);
				}
			}
		} else if (doc.querySelectorAll) {
			els = doc.querySelectorAll((root.nodeName !== '#document' ? root.nodeName + ' ' : '') + tag + '.' + className);
			for (i = 0, len = els.length; i < len; i++) {
				el = els[i];
				if (_contains(root, el)) {
					arr.push(el);
				}
			}
		} else {
			els = root.getElementsByTagName(tag);
			className = ' ' + className + ' ';
			for (i = 0, len = els.length; i < len; i++) {
				el = els[i];
				if (el.nodeType == 1) {
					var cls = el.className;
					if (cls && (' ' + cls + ' ').indexOf(className) > -1) {
						arr.push(el);
					}
				}
			}
		}
		return arr;
	}
	function byName(name, tag, root) {
		var arr = [], doc = root.ownerDocument || root,
			els = doc.getElementsByName(stripslashes(name)), el;
		for (var i = 0, len = els.length; i < len; i++) {
			el = els[i];
			if (cmpTag(tag, el.nodeName) && _contains(root, el)) {
				if (el.getAttributeNode('name')) {
					arr.push(el);
				}
			}
		}
		return arr;
	}
	function byAttr(key, val, tag, root) {
		var arr = [], els = root.getElementsByTagName(tag), el;
		for (var i = 0, len = els.length; i < len; i++) {
			el = els[i];
			if (el.nodeType == 1) {
				if (val === null) {
					if (_getAttr(el, key) !== null) {
						arr.push(el);
					}
				} else {
					if (val === escape(_getAttr(el, key))) {
						arr.push(el);
					}
				}
			}
		}
		return arr;
	}
	function select(expr, root) {
		var arr = [], matches;
		matches = /^((?:\\.|[^.#\s\[<>])+)/.exec(expr);
		var tag = matches ? matches[1] : '*';
		if ((matches = /#((?:[\w\-]|\\.)+)$/.exec(expr))) {
			arr = byId(matches[1], tag, root);
		} else if ((matches = /\.((?:[\w\-]|\\.)+)$/.exec(expr))) {
			arr = byClass(matches[1], tag, root);
		} else if ((matches = /\[((?:[\w\-]|\\.)+)\]/.exec(expr))) {
			arr = byAttr(matches[1].toLowerCase(), null, tag, root);
		} else if ((matches = /\[((?:[\w\-]|\\.)+)\s*=\s*['"]?((?:\\.|[^'"]+)+)['"]?\]/.exec(expr))) {
			var key = matches[1].toLowerCase(), val = matches[2];
			if (key === 'id') {
				arr = byId(val, tag, root);
			} else if (key === 'class') {
				arr = byClass(val, tag, root);
			} else if (key === 'name') {
				arr = byName(val, tag, root);
			} else {
				arr = byAttr(key, val, tag, root);
			}
		} else {
			var els = root.getElementsByTagName(tag), el;
			for (var i = 0, len = els.length; i < len; i++) {
				el = els[i];
				if (el.nodeType == 1) {
					arr.push(el);
				}
			}
		}
		return arr;
	}
	var parts = [], arr, re = /((?:\\.|[^\s>])+|[\s>])/g;
	while ((arr = re.exec(expr))) {
		if (arr[1] !== ' ') {
			parts.push(arr[1]);
		}
	}
	var results = [];
	if (parts.length == 1) {
		return select(parts[0], root);
	}
	var isChild = false, part, els, subResults, val, v, i, j, k, length, len, l;
	for (i = 0, lenth = parts.length; i < lenth; i++) {
		part = parts[i];
		if (part === '>') {
			isChild = true;
			continue;
		}
		if (i > 0) {
			els = [];
			for (j = 0, len = results.length; j < len; j++) {
				val = results[j];
				subResults = select(part, val);
				for (k = 0, l = subResults.length; k < l; k++) {
					v = subResults[k];
					if (isChild) {
						if (val === v.parentNode) {
							els.push(v);
						}
					} else {
						els.push(v);
					}
				}
			}
			results = els;
		} else {
			results = select(part, root);
		}
		if (results.length === 0) {
			return [];
		}
	}
	return results;
}
function _query(expr, root) {
	var arr = _queryAll(expr, root);
	return arr.length > 0 ? arr[0] : null;
}
K.query = _query;
K.queryAll = _queryAll;
function _get(val) {
	return K(val)[0];
}
function _getDoc(node) {
	if (!node) {
		return document;
	}
	return node.ownerDocument || node.document || node;
}
function _getWin(node) {
	if (!node) {
		return window;
	}
	var doc = _getDoc(node);
	return doc.parentWindow || doc.defaultView;
}
function _setHtml(el, html) {
	if (el.nodeType != 1) {
		return;
	}
	var doc = _getDoc(el);
	try {
		el.innerHTML = '<img id="__kindeditor_temp_tag__" width="0" height="0" style="display:none;" />' + html;
		var temp = doc.getElementById('__kindeditor_temp_tag__');
		temp.parentNode.removeChild(temp);
	} catch(e) {
		K(el).empty();
		K('@' + html, doc).each(function() {
			el.appendChild(this);
		});
	}
}
function _hasClass(el, cls) {
	return _inString(cls, el.className, ' ');
}
function _setAttr(el, key, val) {
	if (_IE && _V < 8 && key.toLowerCase() == 'class') {
		key = 'className';
	}
	el.setAttribute(key, '' + val);
}
function _removeAttr(el, key) {
	if (_IE && _V < 8 && key.toLowerCase() == 'class') {
		key = 'className';
	}
	_setAttr(el, key, '');
	el.removeAttribute(key);
}
function _getNodeName(node) {
	if (!node || !node.nodeName) {
		return '';
	}
	return node.nodeName.toLowerCase();
}
function _computedCss(el, key) {
	var self = this, win = _getWin(el), camelKey = _toCamel(key), val = '';
	if (win.getComputedStyle) {
		var style = win.getComputedStyle(el, null);
		val = style[camelKey] || style.getPropertyValue(key) || el.style[camelKey];
	} else if (el.currentStyle) {
		val = el.currentStyle[camelKey] || el.style[camelKey];
	}
	return val;
}
function _hasVal(node) {
	return !!_VALUE_TAG_MAP[_getNodeName(node)];
}
function _docElement(doc) {
	doc = doc || document;
	return _QUIRKS ? doc.body : doc.documentElement;
}
function _docHeight(doc) {
	var el = _docElement(doc);
	return Math.max(el.scrollHeight, el.clientHeight);
}
function _docWidth(doc) {
	var el = _docElement(doc);
	return Math.max(el.scrollWidth, el.clientWidth);
}
function _getScrollPos(doc) {
	doc = doc || document;
	var x, y;
	if (_IE || _OPERA) {
		x = _docElement(doc).scrollLeft;
		y = _docElement(doc).scrollTop;
	} else {
		x = _getWin(doc).scrollX;
		y = _getWin(doc).scrollY;
	}
	return {x : x, y : y};
}
function KNode(node) {
	this.init(node);
}
_extend(KNode, {
	init : function(node) {
		var self = this;
		node = _isArray(node) ? node : [node];
		var length = 0;
		for (var i = 0, len = node.length; i < len; i++) {
			if (node[i]) {
				self[i] = node[i].constructor === KNode ? node[i][0] : node[i];
				length++;
			}
		}
		self.length = length;
		self.doc = _getDoc(self[0]);
		self.name = _getNodeName(self[0]);
		self.type = self.length > 0 ? self[0].nodeType : null;
		self.win = _getWin(self[0]);
	},
	each : function(fn) {
		var self = this;
		for (var i = 0; i < self.length; i++) {
			if (fn.call(self[i], i, self[i]) === false) {
				return self;
			}
		}
		return self;
	},
	bind : function(type, fn) {
		this.each(function() {
			_bind(this, type, fn);
		});
		return this;
	},
	unbind : function(type, fn) {
		this.each(function() {
			_unbind(this, type, fn);
		});
		return this;
	},
	fire : function(type) {
		if (this.length < 1) {
			return this;
		}
		_fire(this[0], type);
		return this;
	},
	hasAttr : function(key) {
		if (this.length < 1) {
			return false;
		}
		return !!_getAttr(this[0], key);
	},
	attr : function(key, val) {
		var self = this;
		if (key === undefined) {
			return _getAttrList(self.outer());
		}
		if (typeof key === 'object') {
			_each(key, function(k, v) {
				self.attr(k, v);
			});
			return self;
		}
		if (val === undefined) {
			val = self.length < 1 ? null : _getAttr(self[0], key);
			return val === null ? '' : val;
		}
		self.each(function() {
			_setAttr(this, key, val);
		});
		return self;
	},
	removeAttr : function(key) {
		this.each(function() {
			_removeAttr(this, key);
		});
		return this;
	},
	get : function(i) {
		if (this.length < 1) {
			return null;
		}
		return this[i || 0];
	},
	eq : function(i) {
		if (this.length < 1) {
			return null;
		}
		return this[i] ? new KNode(this[i]) : null;
	},
	hasClass : function(cls) {
		if (this.length < 1) {
			return false;
		}
		return _hasClass(this[0], cls);
	},
	addClass : function(cls) {
		this.each(function() {
			if (!_hasClass(this, cls)) {
				this.className = _trim(this.className + ' ' + cls);
			}
		});
		return this;
	},
	removeClass : function(cls) {
		this.each(function() {
			if (_hasClass(this, cls)) {
				this.className = _trim(this.className.replace(new RegExp('(^|\\s)' + cls + '(\\s|$)'), ' '));
			}
		});
		return this;
	},
	html : function(val) {
		var self = this;
		if (val === undefined) {
			if (self.length < 1 || self.type != 1) {
				return '';
			}
			return _formatHtml(self[0].innerHTML);
		}
		self.each(function() {
			_setHtml(this, val);
		});
		return self;
	},
	text : function() {
		var self = this;
		if (self.length < 1) {
			return '';
		}
		return _IE ? self[0].innerText : self[0].textContent;
	},
	hasVal : function() {
		if (this.length < 1) {
			return false;
		}
		return _hasVal(this[0]);
	},
	val : function(val) {
		var self = this;
		if (val === undefined) {
			if (self.length < 1) {
				return '';
			}
			return self.hasVal() ? self[0].value : self.attr('value');
		} else {
			self.each(function() {
				if (_hasVal(this)) {
					this.value = val;
				} else {
					_setAttr(this, 'value' , val);
				}
			});
			return self;
		}
	},
	css : function(key, val) {
		var self = this;
		if (key === undefined) {
			return _getCssList(self.attr('style'));
		}
		if (typeof key === 'object') {
			_each(key, function(k, v) {
				self.css(k, v);
			});
			return self;
		}
		if (val === undefined) {
			if (self.length < 1) {
				return '';
			}
			return self[0].style[_toCamel(key)] || _computedCss(self[0], key) || '';
		}
		self.each(function() {
			this.style[_toCamel(key)] = val;
		});
		return self;
	},
	width : function(val) {
		var self = this;
		if (val === undefined) {
			if (self.length < 1) {
				return 0;
			}
			return self[0].offsetWidth;
		}
		return self.css('width', _addUnit(val));
	},
	height : function(val) {
		var self = this;
		if (val === undefined) {
			if (self.length < 1) {
				return 0;
			}
			return self[0].offsetHeight;
		}
		return self.css('height', _addUnit(val));
	},
	opacity : function(val) {
		this.each(function() {
			if (this.style.opacity === undefined) {
				this.style.filter = val == 1 ? '' : 'alpha(opacity=' + (val * 100) + ')';
			} else {
				this.style.opacity = val == 1 ? '' : val;
			}
		});
		return this;
	},
	data : function(key, val) {
		var self = this;
		key = 'kindeditor_data_' + key;
		if (val === undefined) {
			if (self.length < 1) {
				return null;
			}
			return self[0][key];
		}
		this.each(function() {
			this[key] = val;
		});
		return self;
	},
	pos : function() {
		var self = this, node = self[0], x = 0, y = 0;
		if (node) {
			if (node.getBoundingClientRect) {
				var box = node.getBoundingClientRect(),
					pos = _getScrollPos(self.doc);
				x = box.left + pos.x;
				y = box.top + pos.y;
			} else {
				while (node) {
					x += node.offsetLeft;
					y += node.offsetTop;
					node = node.offsetParent;
				}
			}
		}
		return {x : _round(x), y : _round(y)};
	},
	clone : function(bool) {
		if (this.length < 1) {
			return new KNode([]);
		}
		return new KNode(this[0].cloneNode(bool));
	},
	append : function(expr) {
		this.each(function() {
			if (this.appendChild) {
				this.appendChild(_get(expr));
			}
		});
		return this;
	},
	appendTo : function(expr) {
		this.each(function() {
			_get(expr).appendChild(this);
		});
		return this;
	},
	before : function(expr) {
		this.each(function() {
			this.parentNode.insertBefore(_get(expr), this);
		});
		return this;
	},
	after : function(expr) {
		this.each(function() {
			if (this.nextSibling) {
				this.parentNode.insertBefore(_get(expr), this.nextSibling);
			} else {
				this.parentNode.appendChild(_get(expr));
			}
		});
		return this;
	},
	replaceWith : function(expr) {
		var nodes = [];
		this.each(function(i, node) {
			_unbind(node);
			var newNode = _get(expr);
			node.parentNode.replaceChild(newNode, node);
			nodes.push(newNode);
		});
		return K(nodes);
	},
	empty : function() {
		var self = this;
		self.each(function(i, node) {
			var child = node.firstChild;
			while (child) {
				if (!node.parentNode) {
					return;
				}
				var next = child.nextSibling;
				child.parentNode.removeChild(child);
				child = next;
			}
		});
		return self;
	},
	remove : function(keepChilds) {
		var self = this;
		self.each(function(i, node) {
			if (!node.parentNode) {
				return;
			}
			_unbind(node);
			if (keepChilds) {
				var child = node.firstChild;
				while (child) {
					var next = child.nextSibling;
					node.parentNode.insertBefore(child, node);
					child = next;
				}
			}
			node.parentNode.removeChild(node);
			delete self[i];
		});
		self.length = 0;
		return self;
	},
	show : function(val) {
		var self = this;
		if (val === undefined) {
			val = self._originDisplay || '';
		}
		if (self.css('display') != 'none') {
			return self;
		}
		return self.css('display', val);
	},
	hide : function() {
		var self = this;
		if (self.length < 1) {
			return self;
		}
		self._originDisplay = self[0].style.display;
		return self.css('display', 'none');
	},
	outer : function() {
		var self = this;
		if (self.length < 1) {
			return '';
		}
		var div = self.doc.createElement('div'), html;
		div.appendChild(self[0].cloneNode(true));
		html = _formatHtml(div.innerHTML);
		div = null;
		return html;
	},
	isSingle : function() {
		return !!_SINGLE_TAG_MAP[this.name];
	},
	isInline : function() {
		return !!_INLINE_TAG_MAP[this.name];
	},
	isBlock : function() {
		return !!_BLOCK_TAG_MAP[this.name];
	},
	isStyle : function() {
		return !!_STYLE_TAG_MAP[this.name];
	},
	isControl : function() {
		return !!_CONTROL_TAG_MAP[this.name];
	},
	contains : function(otherNode) {
		if (this.length < 1) {
			return false;
		}
		return _contains(this[0], _get(otherNode));
	},
	parent : function() {
		if (this.length < 1) {
			return null;
		}
		var node = this[0].parentNode;
		return node ? new KNode(node) : null;
	},
	children : function() {
		if (this.length < 1) {
			return new KNode([]);
		}
		var list = [], child = this[0].firstChild;
		while (child) {
			if (child.nodeType != 3 || _trim(child.nodeValue) !== '') {
				list.push(child);
			}
			child = child.nextSibling;
		}
		return new KNode(list);
	},
	first : function() {
		var list = this.children();
		return list.length > 0 ? list.eq(0) : null;
	},
	last : function() {
		var list = this.children();
		return list.length > 0 ? list.eq(list.length - 1) : null;
	},
	index : function() {
		if (this.length < 1) {
			return -1;
		}
		var i = -1, sibling = this[0];
		while (sibling) {
			i++;
			sibling = sibling.previousSibling;
		}
		return i;
	},
	prev : function() {
		if (this.length < 1) {
			return null;
		}
		var node = this[0].previousSibling;
		return node ? new KNode(node) : null;
	},
	next : function() {
		if (this.length < 1) {
			return null;
		}
		var node = this[0].nextSibling;
		return node ? new KNode(node) : null;
	},
	scan : function(fn, order) {
		if (this.length < 1) {
			return;
		}
		order = (order === undefined) ? true : order;
		function walk(node) {
			var n = order ? node.firstChild : node.lastChild;
			while (n) {
				var next = order ? n.nextSibling : n.previousSibling;
				if (fn(n) === false) {
					return false;
				}
				if (walk(n) === false) {
					return false;
				}
				n = next;
			}
		}
		walk(this[0]);
		return this;
	}
});
_each(('blur,focus,focusin,focusout,load,resize,scroll,unload,click,dblclick,' +
	'mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,' +
	'change,select,submit,keydown,keypress,keyup,error,contextmenu').split(','), function(i, type) {
	KNode.prototype[type] = function(fn) {
		return fn ? this.bind(type, fn) : this.fire(type);
	};
});
var _K = K;
K = function(expr, root) {
	if (expr === undefined || expr === null) {
		return;
	}
	function newNode(node) {
		if (!node[0]) {
			node = [];
		}
		return new KNode(node);
	}
	if (typeof expr === 'string') {
		if (root) {
			root = _get(root);
		}
		var length = expr.length;
		if (expr.charAt(0) === '@') {
			expr = expr.substr(1);
		}
		if (expr.length !== length || /<.+>/.test(expr)) {
			var doc = root ? root.ownerDocument || root : document,
				div = doc.createElement('div'), list = [];
			div.innerHTML = '<img id="__kindeditor_temp_tag__" width="0" height="0" style="display:none;" />' + expr;
			for (var i = 0, len = div.childNodes.length; i < len; i++) {
				var child = div.childNodes[i];
				if (child.id == '__kindeditor_temp_tag__') {
					continue;
				}
				list.push(child);
			}
			return newNode(list);
		}
		return newNode(_queryAll(expr, root));
	}
	if (expr && expr.constructor === KNode) {
		return expr;
	}
	if (expr.toArray) {
		expr = expr.toArray();
	}
	if (_isArray(expr)) {
		return newNode(expr);
	}
	return newNode(_toArray(arguments));
};
_each(_K, function(key, val) {
	K[key] = val;
});
K.NodeClass = KNode;
window.KindEditor = K;
var _START_TO_START = 0,
	_START_TO_END = 1,
	_END_TO_END = 2,
	_END_TO_START = 3,
	_BOOKMARK_ID = 0;
function _updateCollapsed(range) {
	range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
	return range;
}
function _copyAndDelete(range, isCopy, isDelete) {
	var doc = range.doc, nodeList = [];
	function splitTextNode(node, startOffset, endOffset) {
		var length = node.nodeValue.length, centerNode;
		if (isCopy) {
			var cloneNode = node.cloneNode(true);
			if (startOffset > 0) {
				centerNode = cloneNode.splitText(startOffset);
			} else {
				centerNode = cloneNode;
			}
			if (endOffset < length) {
				centerNode.splitText(endOffset - startOffset);
			}
		}
		if (isDelete) {
			var center = node;
			if (startOffset > 0) {
				center = node.splitText(startOffset);
				range.setStart(node, startOffset);
			}
			if (endOffset < length) {
				var right = center.splitText(endOffset - startOffset);
				range.setEnd(right, 0);
			}
			nodeList.push(center);
		}
		return centerNode;
	}
	function removeNodes() {
		if (isDelete) {
			range.up().collapse(true);
		}
		for (var i = 0, len = nodeList.length; i < len; i++) {
			var node = nodeList[i];
			if (node.parentNode) {
				node.parentNode.removeChild(node);
			}
		}
	}
	var copyRange = range.cloneRange().down();
	var start = -1, incStart = -1, incEnd = -1, end = -1,
		ancestor = range.commonAncestor(), frag = doc.createDocumentFragment();
	if (ancestor.nodeType == 3) {
		var textNode = splitTextNode(ancestor, range.startOffset, range.endOffset);
		if (isCopy) {
			frag.appendChild(textNode);
		}
		removeNodes();
		return isCopy ? frag : range;
	}
	function extractNodes(parent, frag) {
		var node = parent.firstChild, nextNode;
		while (node) {
			var testRange = new KRange(doc).selectNode(node);
			start = testRange.compareBoundaryPoints(_START_TO_END, range);
			if (start >= 0 && incStart <= 0) {
				incStart = testRange.compareBoundaryPoints(_START_TO_START, range);
			}
			if (incStart >= 0 && incEnd <= 0) {
				incEnd = testRange.compareBoundaryPoints(_END_TO_END, range);
			}
			if (incEnd >= 0 && end <= 0) {
				end = testRange.compareBoundaryPoints(_END_TO_START, range);
			}
			if (end >= 0) {
				return false;
			}
			nextNode = node.nextSibling;
			if (start > 0) {
				if (node.nodeType == 1) {
					if (incStart >= 0 && incEnd <= 0) {
						if (isCopy) {
							frag.appendChild(node.cloneNode(true));
						}
						if (isDelete) {
							nodeList.push(node);
						}
					} else {
						var childFlag;
						if (isCopy) {
							childFlag = node.cloneNode(false);
							frag.appendChild(childFlag);
						}
						if (extractNodes(node, childFlag) === false) {
							return false;
						}
					}
				} else if (node.nodeType == 3) {
					var textNode;
					if (node == copyRange.startContainer) {
						textNode = splitTextNode(node, copyRange.startOffset, node.nodeValue.length);
					} else if (node == copyRange.endContainer) {
						textNode = splitTextNode(node, 0, copyRange.endOffset);
					} else {
						textNode = splitTextNode(node, 0, node.nodeValue.length);
					}
					if (isCopy) {
						try {
							frag.appendChild(textNode);
						} catch(e) {}
					}
				}
			}
			node = nextNode;
		}
	}
	extractNodes(ancestor, frag);
	if (isDelete) {
		range.up().collapse(true);
	}
	for (var i = 0, len = nodeList.length; i < len; i++) {
		var node = nodeList[i];
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}
	return isCopy ? frag : range;
}
function _moveToElementText(range, el) {
	var node = el;
	while (node) {
		var knode = K(node);
		if (knode.name == 'marquee' || knode.name == 'select') {
			return;
		}
		node = node.parentNode;
	}
	try {
		range.moveToElementText(el);
	} catch(e) {}
}
function _getStartEnd(rng, isStart) {
	var doc = rng.parentElement().ownerDocument,
		pointRange = rng.duplicate();
	pointRange.collapse(isStart);
	var parent = pointRange.parentElement(),
		nodes = parent.childNodes;
	if (nodes.length === 0) {
		return {node: parent.parentNode, offset: K(parent).index()};
	}
	var startNode = doc, startPos = 0, cmp = -1;
	var testRange = rng.duplicate();
	_moveToElementText(testRange, parent);
	for (var i = 0, len = nodes.length; i < len; i++) {
		var node = nodes[i];
		cmp = testRange.compareEndPoints('StartToStart', pointRange);
		if (cmp === 0) {
			return {node: node.parentNode, offset: i};
		}
		if (node.nodeType == 1) {
			var nodeRange = rng.duplicate(), dummy, knode = K(node), newNode = node;
			if (knode.isControl()) {
				dummy = doc.createElement('span');
				knode.after(dummy);
				newNode = dummy;
				startPos += knode.text().replace(/\r\n|\n|\r/g, '').length;
			}
			_moveToElementText(nodeRange, newNode);
			testRange.setEndPoint('StartToEnd', nodeRange);
			if (cmp > 0) {
				startPos += nodeRange.text.replace(/\r\n|\n|\r/g, '').length;
			} else {
				startPos = 0;
			}
			if (dummy) {
				K(dummy).remove();
			}
		} else if (node.nodeType == 3) {
			testRange.moveStart('character', node.nodeValue.length);
			startPos += node.nodeValue.length;
		}
		if (cmp < 0) {
			startNode = node;
		}
	}
	if (cmp < 0 && startNode.nodeType == 1) {
		return {node: parent, offset: K(parent.lastChild).index() + 1};
	}
	if (cmp > 0) {
		while (startNode.nextSibling && startNode.nodeType == 1) {
			startNode = startNode.nextSibling;
		}
	}
	testRange = rng.duplicate();
	_moveToElementText(testRange, parent);
	testRange.setEndPoint('StartToEnd', pointRange);
	startPos -= testRange.text.replace(/\r\n|\n|\r/g, '').length;
	if (cmp > 0 && startNode.nodeType == 3) {
		var prevNode = startNode.previousSibling;
		while (prevNode && prevNode.nodeType == 3) {
			startPos -= prevNode.nodeValue.length;
			prevNode = prevNode.previousSibling;
		}
	}
	return {node: startNode, offset: startPos};
}
function _getEndRange(node, offset) {
	var doc = node.ownerDocument || node,
		range = doc.body.createTextRange();
	if (doc == node) {
		range.collapse(true);
		return range;
	}
	if (node.nodeType == 1 && node.childNodes.length > 0) {
		var children = node.childNodes, isStart, child;
		if (offset === 0) {
			child = children[0];
			isStart = true;
		} else {
			child = children[offset - 1];
			isStart = false;
		}
		if (!child) {
			return range;
		}
		if (K(child).name === 'head') {
			if (offset === 1) {
				isStart = true;
			}
			if (offset === 2) {
				isStart = false;
			}
			range.collapse(isStart);
			return range;
		}
		if (child.nodeType == 1) {
			var kchild = K(child), span;
			if (kchild.isControl()) {
				span = doc.createElement('span');
				if (isStart) {
					kchild.before(span);
				} else {
					kchild.after(span);
				}
				child = span;
			}
			_moveToElementText(range, child);
			range.collapse(isStart);
			if (span) {
				K(span).remove();
			}
			return range;
		}
		node = child;
		offset = isStart ? 0 : child.nodeValue.length;
	}
	var dummy = doc.createElement('span');
	K(node).before(dummy);
	_moveToElementText(range, dummy);
	range.moveStart('character', offset);
	K(dummy).remove();
	return range;
}
function _toRange(rng) {
	var doc, range;
	function tr2td(start) {
		if (K(start.node).name == 'tr') {
			start.node = start.node.cells[start.offset];
			start.offset = 0;
		}
	}
	if (_IE) {
		if (rng.item) {
			doc = _getDoc(rng.item(0));
			range = new KRange(doc);
			range.selectNode(rng.item(0));
			return range;
		}
		doc = rng.parentElement().ownerDocument;
		var start = _getStartEnd(rng, true),
			end = _getStartEnd(rng, false);
		tr2td(start);
		tr2td(end);
		range = new KRange(doc);
		range.setStart(start.node, start.offset);
		range.setEnd(end.node, end.offset);
		return range;
	}
	var startContainer = rng.startContainer;
	doc = startContainer.ownerDocument || startContainer;
	range = new KRange(doc);
	range.setStart(startContainer, rng.startOffset);
	range.setEnd(rng.endContainer, rng.endOffset);
	return range;
}
function KRange(doc) {
	this.init(doc);
}
_extend(KRange, {
	init : function(doc) {
		var self = this;
		self.startContainer = doc;
		self.startOffset = 0;
		self.endContainer = doc;
		self.endOffset = 0;
		self.collapsed = true;
		self.doc = doc;
	},
	commonAncestor : function() {
		function getParents(node) {
			var parents = [];
			while (node) {
				parents.push(node);
				node = node.parentNode;
			}
			return parents;
		}
		var parentsA = getParents(this.startContainer),
			parentsB = getParents(this.endContainer),
			i = 0, lenA = parentsA.length, lenB = parentsB.length, parentA, parentB;
		while (++i) {
			parentA = parentsA[lenA - i];
			parentB = parentsB[lenB - i];
			if (!parentA || !parentB || parentA !== parentB) {
				break;
			}
		}
		return parentsA[lenA - i + 1];
	},
	setStart : function(node, offset) {
		var self = this, doc = self.doc;
		self.startContainer = node;
		self.startOffset = offset;
		if (self.endContainer === doc) {
			self.endContainer = node;
			self.endOffset = offset;
		}
		return _updateCollapsed(this);
	},
	setEnd : function(node, offset) {
		var self = this, doc = self.doc;
		self.endContainer = node;
		self.endOffset = offset;
		if (self.startContainer === doc) {
			self.startContainer = node;
			self.startOffset = offset;
		}
		return _updateCollapsed(this);
	},
	setStartBefore : function(node) {
		return this.setStart(node.parentNode || this.doc, K(node).index());
	},
	setStartAfter : function(node) {
		return this.setStart(node.parentNode || this.doc, K(node).index() + 1);
	},
	setEndBefore : function(node) {
		return this.setEnd(node.parentNode || this.doc, K(node).index());
	},
	setEndAfter : function(node) {
		return this.setEnd(node.parentNode || this.doc, K(node).index() + 1);
	},
	selectNode : function(node) {
		return this.setStartBefore(node).setEndAfter(node);
	},
	selectNodeContents : function(node) {
		var knode = K(node);
		if (knode.type == 3 || knode.isSingle()) {
			return this.selectNode(node);
		}
		var children = knode.children();
		if (children.length > 0) {
			return this.setStartBefore(children[0]).setEndAfter(children[children.length - 1]);
		}
		return this.setStart(node, 0).setEnd(node, 0);
	},
	collapse : function(toStart) {
		if (toStart) {
			return this.setEnd(this.startContainer, this.startOffset);
		}
		return this.setStart(this.endContainer, this.endOffset);
	},
	compareBoundaryPoints : function(how, range) {
		var rangeA = this.get(), rangeB = range.get();
		if (_IE) {
			var arr = {};
			arr[_START_TO_START] = 'StartToStart';
			arr[_START_TO_END] = 'EndToStart';
			arr[_END_TO_END] = 'EndToEnd';
			arr[_END_TO_START] = 'StartToEnd';
			var cmp = rangeA.compareEndPoints(arr[how], rangeB);
			if (cmp !== 0) {
				return cmp;
			}
			var nodeA, nodeB, nodeC, posA, posB;
			if (how === _START_TO_START || how === _END_TO_START) {
				nodeA = this.startContainer;
				posA = this.startOffset;
			}
			if (how === _START_TO_END || how === _END_TO_END) {
				nodeA = this.endContainer;
				posA = this.endOffset;
			}
			if (how === _START_TO_START || how === _START_TO_END) {
				nodeB = range.startContainer;
				posB = range.startOffset;
			}
			if (how === _END_TO_END || how === _END_TO_START) {
				nodeB = range.endContainer;
				posB = range.endOffset;
			}
			if (nodeA === nodeB) {
				var diff = posA - posB;
				return diff > 0 ? 1 : (diff < 0 ? -1 : 0);
			}
			nodeC = nodeB;
			while (nodeC && nodeC.parentNode !== nodeA) {
				nodeC = nodeC.parentNode;
			}
			if (nodeC) {
				return K(nodeC).index() >= posA ? -1 : 1;
			}
			nodeC = nodeA;
			while (nodeC && nodeC.parentNode !== nodeB) {
				nodeC = nodeC.parentNode;
			}
			if (nodeC) {
				return K(nodeC).index() >= posB ? 1 : -1;
			}
			nodeC = K(nodeB).next();
			if (nodeC && nodeC.contains(nodeA)) {
				return 1;
			}
			nodeC = K(nodeA).next();
			if (nodeC && nodeC.contains(nodeB)) {
				return -1;
			}
		} else {
			return rangeA.compareBoundaryPoints(how, rangeB);
		}
	},
	cloneRange : function() {
		return new KRange(this.doc).setStart(this.startContainer, this.startOffset).setEnd(this.endContainer, this.endOffset);
	},
	toString : function() {
		var rng = this.get(), str = _IE ? rng.text : rng.toString();
		return str.replace(/\r\n|\n|\r/g, '');
	},
	cloneContents : function() {
		return _copyAndDelete(this, true, false);
	},
	deleteContents : function() {
		return _copyAndDelete(this, false, true);
	},
	extractContents : function() {
		return _copyAndDelete(this, true, true);
	},
	insertNode : function(node) {
		var self = this,
			sc = self.startContainer, so = self.startOffset,
			ec = self.endContainer, eo = self.endOffset,
			firstChild, lastChild, c, nodeCount = 1;
		if (node.nodeName.toLowerCase() === '#document-fragment') {
			firstChild = node.firstChild;
			lastChild = node.lastChild;
			nodeCount = node.childNodes.length;
		}
		if (sc.nodeType == 1) {
			c = sc.childNodes[so];
			if (c) {
				sc.insertBefore(node, c);
				if (sc === ec) {
					eo += nodeCount;
				}
			} else {
				sc.appendChild(node);
			}
		} else if (sc.nodeType == 3) {
			if (so === 0) {
				sc.parentNode.insertBefore(node, sc);
				if (sc.parentNode === ec) {
					eo += nodeCount;
				}
			} else if (so >= sc.nodeValue.length) {
				if (sc.nextSibling) {
					sc.parentNode.insertBefore(node, sc.nextSibling);
				} else {
					sc.parentNode.appendChild(node);
				}
			} else {
				if (so > 0) {
					c = sc.splitText(so);
				} else {
					c = sc;
				}
				sc.parentNode.insertBefore(node, c);
				if (sc === ec) {
					ec = c;
					eo -= so;
				}
			}
		}
		if (firstChild) {
			self.setStartBefore(firstChild).setEndAfter(lastChild);
		} else {
			self.selectNode(node);
		}
		if (self.compareBoundaryPoints(_END_TO_END, self.cloneRange().setEnd(ec, eo)) >= 1) {
			return self;
		}
		return self.setEnd(ec, eo);
	},
	surroundContents : function(node) {
		node.appendChild(this.extractContents());
		return this.insertNode(node).selectNode(node);
	},
	isControl : function() {
		var self = this,
			sc = self.startContainer, so = self.startOffset,
			ec = self.endContainer, eo = self.endOffset, rng;
		return sc.nodeType == 1 && sc === ec && so + 1 === eo && K(sc.childNodes[so]).isControl();
	},
	get : function(hasControlRange) {
		var self = this, doc = self.doc, node, rng;
		if (!_IE) {
			rng = doc.createRange();
			try {
				rng.setStart(self.startContainer, self.startOffset);
				rng.setEnd(self.endContainer, self.endOffset);
			} catch (e) {}
			return rng;
		}
		if (hasControlRange && self.isControl()) {
			rng = doc.body.createControlRange();
			rng.addElement(self.startContainer.childNodes[self.startOffset]);
			return rng;
		}
		var range = self.cloneRange().down();
		rng = doc.body.createTextRange();
		rng.setEndPoint('StartToStart', _getEndRange(range.startContainer, range.startOffset));
		rng.setEndPoint('EndToStart', _getEndRange(range.endContainer, range.endOffset));
		return rng;
	},
	html : function() {
		return K(this.cloneContents()).outer();
	},
	down : function() {
		var self = this;
		function downPos(node, pos, isStart) {
			if (node.nodeType != 1) {
				return;
			}
			var children = K(node).children();
			if (children.length === 0) {
				return;
			}
			var left, right, child, offset;
			if (pos > 0) {
				left = children.eq(pos - 1);
			}
			if (pos < children.length) {
				right = children.eq(pos);
			}
			if (left && left.type == 3) {
				child = left[0];
				offset = child.nodeValue.length;
			}
			if (right && right.type == 3) {
				child = right[0];
				offset = 0;
			}
			if (!child) {
				return;
			}
			if (isStart) {
				self.setStart(child, offset);
			} else {
				self.setEnd(child, offset);
			}
		}
		downPos(self.startContainer, self.startOffset, true);
		downPos(self.endContainer, self.endOffset, false);
		return self;
	},
	up : function() {
		var self = this;
		function upPos(node, pos, isStart) {
			if (node.nodeType != 3) {
				return;
			}
			if (pos === 0) {
				if (isStart) {
					self.setStartBefore(node);
				} else {
					self.setEndBefore(node);
				}
			} else if (pos == node.nodeValue.length) {
				if (isStart) {
					self.setStartAfter(node);
				} else {
					self.setEndAfter(node);
				}
			}
		}
		upPos(self.startContainer, self.startOffset, true);
		upPos(self.endContainer, self.endOffset, false);
		return self;
	},
	enlarge : function(toBlock) {
		var self = this;
		self.up();
		function enlargePos(node, pos, isStart) {
			var knode = K(node), parent;
			if (knode.type == 3 || _NOSPLIT_TAG_MAP[knode.name] || !toBlock && knode.isBlock()) {
				return;
			}
			if (pos === 0) {
				while (!knode.prev()) {
					parent = knode.parent();
					if (!parent || _NOSPLIT_TAG_MAP[parent.name] || !toBlock && parent.isBlock()) {
						break;
					}
					knode = parent;
				}
				if (isStart) {
					self.setStartBefore(knode[0]);
				} else {
					self.setEndBefore(knode[0]);
				}
			} else if (pos == knode.children().length) {
				while (!knode.next()) {
					parent = knode.parent();
					if (!parent || _NOSPLIT_TAG_MAP[parent.name] || !toBlock && parent.isBlock()) {
						break;
					}
					knode = parent;
				}
				if (isStart) {
					self.setStartAfter(knode[0]);
				} else {
					self.setEndAfter(knode[0]);
				}
			}
		}
		enlargePos(self.startContainer, self.startOffset, true);
		enlargePos(self.endContainer, self.endOffset, false);
		return self;
	},
	shrink : function() {
		var self = this, child, collapsed = self.collapsed;
		while (self.startContainer.nodeType == 1 && (child = self.startContainer.childNodes[self.startOffset]) && child.nodeType == 1 && !K(child).isSingle()) {
			self.setStart(child, 0);
		}
		if (collapsed) {
			return self.collapse(collapsed);
		}
		while (self.endContainer.nodeType == 1 && self.endOffset > 0 && (child = self.endContainer.childNodes[self.endOffset - 1]) && child.nodeType == 1 && !K(child).isSingle()) {
			self.setEnd(child, child.childNodes.length);
		}
		return self;
	},
	createBookmark : function(serialize) {
		var self = this, doc = self.doc, endNode,
			startNode = K('<span style="display:none;"></span>', doc)[0];
		startNode.id = '__kindeditor_bookmark_start_' + (_BOOKMARK_ID++) + '__';
		if (!self.collapsed) {
			endNode = startNode.cloneNode(true);
			endNode.id = '__kindeditor_bookmark_end_' + (_BOOKMARK_ID++) + '__';
		}
		if (endNode) {
			self.cloneRange().collapse(false).insertNode(endNode).setEndBefore(endNode);
		}
		self.insertNode(startNode).setStartAfter(startNode);
		return {
			start : serialize ? '#' + startNode.id : startNode,
			end : endNode ? (serialize ? '#' + endNode.id : endNode) : null
		};
	},
	moveToBookmark : function(bookmark) {
		var self = this, doc = self.doc,
			start = K(bookmark.start, doc), end = bookmark.end ? K(bookmark.end, doc) : null;
		if (!start || start.length < 1) {
			return self;
		}
		self.setStartBefore(start[0]);
		start.remove();
		if (end && end.length > 0) {
			self.setEndBefore(end[0]);
			end.remove();
		} else {
			self.collapse(true);
		}
		return self;
	},
	dump : function() {
		console.log('--------------------');
		console.log(this.startContainer.nodeType == 3 ? this.startContainer.nodeValue : this.startContainer, this.startOffset);
		console.log(this.endContainer.nodeType == 3 ? this.endContainer.nodeValue : this.endContainer, this.endOffset);
	}
});
function _range(mixed) {
	if (!mixed.nodeName) {
		return mixed.constructor === KRange ? mixed : _toRange(mixed);
	}
	return new KRange(mixed);
}
K.RangeClass = KRange;
K.range = _range;
K.START_TO_START = _START_TO_START;
K.START_TO_END = _START_TO_END;
K.END_TO_END = _END_TO_END;
K.END_TO_START = _END_TO_START;
function _nativeCommand(doc, key, val) {
	try {
		doc.execCommand(key, false, val);
	} catch(e) {}
}
function _nativeCommandValue(doc, key) {
	var val = '';
	try {
		val = doc.queryCommandValue(key);
	} catch (e) {}
	if (typeof val !== 'string') {
		val = '';
	}
	return val;
}
function _getSel(doc) {
	var win = _getWin(doc);
	return doc.selection || win.getSelection();
}
function _getRng(doc) {
	var sel = _getSel(doc), rng;
	try {
		if (sel.rangeCount > 0) {
			rng = sel.getRangeAt(0);
		} else {
			rng = sel.createRange();
		}
	} catch(e) {}
	if (_IE && (!rng || (!rng.item && rng.parentElement().ownerDocument !== doc))) {
		return null;
	}
	return rng;
}
function _singleKeyMap(map) {
	var newMap = {}, arr, v;
	_each(map, function(key, val) {
		arr = key.split(',');
		for (var i = 0, len = arr.length; i < len; i++) {
			v = arr[i];
			newMap[v] = val;
		}
	});
	return newMap;
}
function _hasAttrOrCss(knode, map) {
	return _hasAttrOrCssByKey(knode, map, '*') || _hasAttrOrCssByKey(knode, map);
}
function _hasAttrOrCssByKey(knode, map, mapKey) {
	mapKey = mapKey || knode.name;
	if (knode.type !== 1) {
		return false;
	}
	var newMap = _singleKeyMap(map);
	if (!newMap[mapKey]) {
		return false;
	}
	var arr = newMap[mapKey].split(',');
	for (var i = 0, len = arr.length; i < len; i++) {
		var key = arr[i];
		if (key === '*') {
			return true;
		}
		var match = /^(\.?)([^=]+)(?:=([^=]*))?$/.exec(key);
		var method = match[1] ? 'css' : 'attr';
		key = match[2];
		var val = match[3] || '';
		if (val === '' && knode[method](key) !== '') {
			return true;
		}
		if (val !== '' && knode[method](key) === val) {
			return true;
		}
	}
	return false;
}
function _removeAttrOrCss(knode, map) {
	if (knode.type != 1) {
		return;
	}
	_removeAttrOrCssByKey(knode, map, '*');
	_removeAttrOrCssByKey(knode, map);
}
function _removeAttrOrCssByKey(knode, map, mapKey) {
	mapKey = mapKey || knode.name;
	if (knode.type !== 1) {
		return;
	}
	var newMap = _singleKeyMap(map);
	if (!newMap[mapKey]) {
		return;
	}
	var arr = newMap[mapKey].split(','), allFlag = false;
	for (var i = 0, len = arr.length; i < len; i++) {
		var key = arr[i];
		if (key === '*') {
			allFlag = true;
			break;
		}
		var match = /^(\.?)([^=]+)(?:=([^=]*))?$/.exec(key);
		key = match[2];
		if (match[1]) {
			key = _toCamel(key);
			if (knode[0].style[key]) {
				knode[0].style[key] = '';
			}
		} else {
			knode.removeAttr(key);
		}
	}
	if (allFlag) {
		knode.remove(true);
	}
}
function _getInnerNode(knode) {
	var inner = knode;
	while (inner.first()) {
		inner = inner.first();
	}
	return inner;
}
function _isEmptyNode(knode) {
	if (knode.type != 1 || knode.isSingle()) {
		return false;
	}
	return knode.html().replace(/<[^>]+>/g, '') === '';
}
function _mergeWrapper(a, b) {
	a = a.clone(true);
	var lastA = _getInnerNode(a), childA = a, merged = false;
	while (b) {
		while (childA) {
			if (childA.name === b.name) {
				_mergeAttrs(childA, b.attr(), b.css());
				merged = true;
			}
			childA = childA.first();
		}
		if (!merged) {
			lastA.append(b.clone(false));
		}
		merged = false;
		b = b.first();
	}
	return a;
}
function _wrapNode(knode, wrapper) {
	wrapper = wrapper.clone(true);
	if (knode.type == 3) {
		_getInnerNode(wrapper).append(knode.clone(false));
		knode.replaceWith(wrapper);
		return wrapper;
	}
	var nodeWrapper = knode, child;
	while ((child = knode.first()) && child.children().length == 1) {
		knode = child;
	}
	child = knode.first();
	var frag = knode.doc.createDocumentFragment();
	while (child) {
		frag.appendChild(child[0]);
		child = child.next();
	}
	wrapper = _mergeWrapper(nodeWrapper, wrapper);
	if (frag.firstChild) {
		_getInnerNode(wrapper).append(frag);
	}
	nodeWrapper.replaceWith(wrapper);
	return wrapper;
}
function _mergeAttrs(knode, attrs, styles) {
	_each(attrs, function(key, val) {
		if (key !== 'style') {
			knode.attr(key, val);
		}
	});
	_each(styles, function(key, val) {
		knode.css(key, val);
	});
}
function _inPreElement(knode) {
	while (knode && knode.name != 'body') {
		if (_PRE_TAG_MAP[knode.name] || knode.name == 'div' && knode.hasClass('ke-script')) {
			return true;
		}
		knode = knode.parent();
	}
	return false;
}
function KCmd(range) {
	this.init(range);
}
_extend(KCmd, {
	init : function(range) {
		var self = this, doc = range.doc;
		self.doc = doc;
		self.win = _getWin(doc);
		self.sel = _getSel(doc);
		self.range = range;
	},
	selection : function(forceReset) {
		var self = this, doc = self.doc, rng = _getRng(doc);
		self.sel = _getSel(doc);
		if (rng) {
			self.range = _range(rng);
			if (K(self.range.startContainer).name == 'html') {
				self.range.selectNodeContents(doc.body).collapse(false);
			}
			return self;
		}
		if (forceReset) {
			self.range.selectNodeContents(doc.body).collapse(false);
		}
		return self;
	},
	select : function(hasDummy) {
		hasDummy = _undef(hasDummy, true);
		var self = this, sel = self.sel, range = self.range.cloneRange().shrink(),
			sc = range.startContainer, so = range.startOffset,
			ec = range.endContainer, eo = range.endOffset,
			doc = _getDoc(sc), win = self.win, rng, hasU200b = false;
		if (hasDummy && sc.nodeType == 1 && range.collapsed) {
			if (_IE) {
				var dummy = K('<span>&nbsp;</span>', doc);
				range.insertNode(dummy[0]);
				rng = doc.body.createTextRange();
				try {
					rng.moveToElementText(dummy[0]);
				} catch(ex) {}
				rng.collapse(false);
				rng.select();
				dummy.remove();
				win.focus();
				return self;
			}
			if (_WEBKIT) {
				var children = sc.childNodes;
				if (K(sc).isInline() || so > 0 && K(children[so - 1]).isInline() || children[so] && K(children[so]).isInline()) {
					range.insertNode(doc.createTextNode('\u200B'));
					hasU200b = true;
				}
			}
		}
		if (_IE) {
			try {
				rng = range.get(true);
				rng.select();
			} catch(e) {}
		} else {
			if (hasU200b) {
				range.collapse(false);
			}
			rng = range.get(true);
			sel.removeAllRanges();
			sel.addRange(rng);
			if (doc !== document) {
				var pos = K(rng.endContainer).pos();
				win.scrollTo(pos.x, pos.y);
			}
		}
		win.focus();
		return self;
	},
	wrap : function(val) {
		var self = this, doc = self.doc, range = self.range, wrapper;
		wrapper = K(val, doc);
		if (range.collapsed) {
			range.shrink();
			range.insertNode(wrapper[0]).selectNodeContents(wrapper[0]);
			return self;
		}
		if (wrapper.isBlock()) {
			var copyWrapper = wrapper.clone(true), child = copyWrapper;
			while (child.first()) {
				child = child.first();
			}
			child.append(range.extractContents());
			range.insertNode(copyWrapper[0]).selectNode(copyWrapper[0]);
			return self;
		}
		range.enlarge();
		var bookmark = range.createBookmark(), ancestor = range.commonAncestor(), isStart = false;
		K(ancestor).scan(function(node) {
			if (!isStart && node == bookmark.start) {
				isStart = true;
				return;
			}
			if (isStart) {
				if (node == bookmark.end) {
					return false;
				}
				var knode = K(node);
				if (_inPreElement(knode)) {
					return;
				}
				if (knode.type == 3 && _trim(node.nodeValue).length > 0) {
					var parent;
					while ((parent = knode.parent()) && parent.isStyle() && parent.children().length == 1) {
						knode = parent;
					}
					_wrapNode(knode, wrapper);
				}
			}
		});
		range.moveToBookmark(bookmark);
		return self;
	},
	split : function(isStart, map) {
		var range = this.range, doc = range.doc;
		var tempRange = range.cloneRange().collapse(isStart);
		var node = tempRange.startContainer, pos = tempRange.startOffset,
			parent = node.nodeType == 3 ? node.parentNode : node,
			needSplit = false, knode;
		while (parent && parent.parentNode) {
			knode = K(parent);
			if (map) {
				if (!knode.isStyle()) {
					break;
				}
				if (!_hasAttrOrCss(knode, map)) {
					break;
				}
			} else {
				if (_NOSPLIT_TAG_MAP[knode.name]) {
					break;
				}
			}
			needSplit = true;
			parent = parent.parentNode;
		}
		if (needSplit) {
			var dummy = doc.createElement('span');
			range.cloneRange().collapse(!isStart).insertNode(dummy);
			if (isStart) {
				tempRange.setStartBefore(parent.firstChild).setEnd(node, pos);
			} else {
				tempRange.setStart(node, pos).setEndAfter(parent.lastChild);
			}
			var frag = tempRange.extractContents(),
				first = frag.firstChild, last = frag.lastChild;
			if (isStart) {
				tempRange.insertNode(frag);
				range.setStartAfter(last).setEndBefore(dummy);
			} else {
				parent.appendChild(frag);
				range.setStartBefore(dummy).setEndBefore(first);
			}
			var dummyParent = dummy.parentNode;
			if (dummyParent == range.endContainer) {
				var prev = K(dummy).prev(), next = K(dummy).next();
				if (prev && next && prev.type == 3 && next.type == 3) {
					range.setEnd(prev[0], prev[0].nodeValue.length);
				} else if (!isStart) {
					range.setEnd(range.endContainer, range.endOffset - 1);
				}
			}
			dummyParent.removeChild(dummy);
		}
		return this;
	},
	remove : function(map) {
		var self = this, doc = self.doc, range = self.range;
		range.enlarge();
		if (range.startOffset === 0) {
			var ksc = K(range.startContainer), parent;
			while ((parent = ksc.parent()) && parent.isStyle() && parent.children().length == 1) {
				ksc = parent;
			}
			range.setStart(ksc[0], 0);
			ksc = K(range.startContainer);
			if (ksc.isBlock()) {
				_removeAttrOrCss(ksc, map);
			}
			var kscp = ksc.parent();
			if (kscp && kscp.isBlock()) {
				_removeAttrOrCss(kscp, map);
			}
		}
		var sc, so;
		if (range.collapsed) {
			self.split(true, map);
			sc = range.startContainer;
			so = range.startOffset;
			if (so > 0) {
				var sb = K(sc.childNodes[so - 1]);
				if (sb && _isEmptyNode(sb)) {
					sb.remove();
					range.setStart(sc, so - 1);
				}
			}
			var sa = K(sc.childNodes[so]);
			if (sa && _isEmptyNode(sa)) {
				sa.remove();
			}
			if (_isEmptyNode(sc)) {
				range.startBefore(sc);
				sc.remove();
			}
			range.collapse(true);
			return self;
		}
		self.split(true, map);
		self.split(false, map);
		var startDummy = doc.createElement('span'), endDummy = doc.createElement('span');
		range.cloneRange().collapse(false).insertNode(endDummy);
		range.cloneRange().collapse(true).insertNode(startDummy);
		var nodeList = [], cmpStart = false;
		K(range.commonAncestor()).scan(function(node) {
			if (!cmpStart && node == startDummy) {
				cmpStart = true;
				return;
			}
			if (node == endDummy) {
				return false;
			}
			if (cmpStart) {
				nodeList.push(node);
			}
		});
		K(startDummy).remove();
		K(endDummy).remove();
		sc = range.startContainer;
		so = range.startOffset;
		var ec = range.endContainer, eo = range.endOffset;
		if (so > 0) {
			var startBefore = K(sc.childNodes[so - 1]);
			if (startBefore && _isEmptyNode(startBefore)) {
				startBefore.remove();
				range.setStart(sc, so - 1);
				if (sc == ec) {
					range.setEnd(ec, eo - 1);
				}
			}
			var startAfter = K(sc.childNodes[so]);
			if (startAfter && _isEmptyNode(startAfter)) {
				startAfter.remove();
				if (sc == ec) {
					range.setEnd(ec, eo - 1);
				}
			}
		}
		var endAfter = K(ec.childNodes[range.endOffset]);
		if (endAfter && _isEmptyNode(endAfter)) {
			endAfter.remove();
		}
		var bookmark = range.createBookmark(true);
		_each(nodeList, function(i, node) {
			_removeAttrOrCss(K(node), map);
		});
		range.moveToBookmark(bookmark);
		return self;
	},
	commonNode : function(map) {
		var range = this.range;
		var ec = range.endContainer, eo = range.endOffset,
			node = (ec.nodeType == 3 || eo === 0) ? ec : ec.childNodes[eo - 1];
		function find(node) {
			var child = node, parent = node;
			while (parent) {
				if (_hasAttrOrCss(K(parent), map)) {
					return K(parent);
				}
				parent = parent.parentNode;
			}
			while (child && (child = child.lastChild)) {
				if (_hasAttrOrCss(K(child), map)) {
					return K(child);
				}
			}
			return null;
		}
		var cNode = find(node);
		if (cNode) {
			return cNode;
		}
		if (node.nodeType == 1 || (ec.nodeType == 3 && eo === 0)) {
			var prev = K(node).prev();
			if (prev) {
				return find(prev);
			}
		}
		return null;
	},
	commonAncestor : function(tagName) {
		var range = this.range,
			sc = range.startContainer, so = range.startOffset,
			ec = range.endContainer, eo = range.endOffset,
			startNode = (sc.nodeType == 3 || so === 0) ? sc : sc.childNodes[so - 1],
			endNode = (ec.nodeType == 3 || eo === 0) ? ec : ec.childNodes[eo - 1];
		function find(node) {
			while (node) {
				if (node.nodeType == 1) {
					if (node.tagName.toLowerCase() === tagName) {
						return node;
					}
				}
				node = node.parentNode;
			}
			return null;
		}
		var start = find(startNode), end = find(endNode);
		if (start && end && start === end) {
			return K(start);
		}
		return null;
	},
	state : function(key) {
		var self = this, doc = self.doc, bool = false;
		try {
			bool = doc.queryCommandState(key);
		} catch (e) {}
		return bool;
	},
	val : function(key) {
		var self = this, doc = self.doc, range = self.range;
		function lc(val) {
			return val.toLowerCase();
		}
		key = lc(key);
		var val = '', knode;
		if (key === 'fontfamily' || key === 'fontname') {
			val = _nativeCommandValue(doc, 'fontname');
			val = val.replace(/['"]/g, '');
			return lc(val);
		}
		if (key === 'formatblock') {
			val = _nativeCommandValue(doc, key);
			if (val === '') {
				knode = self.commonNode({'h1,h2,h3,h4,h5,h6,p,div,pre,address' : '*'});
				if (knode) {
					val = knode.name;
				}
			}
			if (val === 'Normal') {
				val = 'p';
			}
			return lc(val);
		}
		if (key === 'fontsize') {
			knode = self.commonNode({'*' : '.font-size'});
			if (knode) {
				val = knode.css('font-size');
			}
			return lc(val);
		}
		if (key === 'forecolor') {
			knode = self.commonNode({'*' : '.color'});
			if (knode) {
				val = knode.css('color');
			}
			val = _toHex(val);
			if (val === '') {
				val = 'default';
			}
			return lc(val);
		}
		if (key === 'hilitecolor') {
			knode = self.commonNode({'*' : '.background-color'});
			if (knode) {
				val = knode.css('background-color');
			}
			val = _toHex(val);
			if (val === '') {
				val = 'default';
			}
			return lc(val);
		}
		return val;
	},
	toggle : function(wrapper, map) {
		var self = this;
		if (self.commonNode(map)) {
			self.remove(map);
		} else {
			self.wrap(wrapper);
		}
		return self.select();
	},
	bold : function() {
		return this.toggle('<strong></strong>', {
			span : '.font-weight=bold',
			strong : '*',
			b : '*'
		});
	},
	italic : function() {
		return this.toggle('<em></em>', {
			span : '.font-style=italic',
			em : '*',
			i : '*'
		});
	},
	underline : function() {
		return this.toggle('<u></u>', {
			span : '.text-decoration=underline',
			u : '*'
		});
	},
	strikethrough : function() {
		return this.toggle('<s></s>', {
			span : '.text-decoration=line-through',
			s : '*'
		});
	},
	forecolor : function(val) {
		return this.toggle('<span style="color:' + val + ';"></span>', {
			span : '.color=' + val,
			font : 'color'
		});
	},
	hilitecolor : function(val) {
		return this.toggle('<span style="background-color:' + val + ';"></span>', {
			span : '.background-color=' + val
		});
	},
	fontsize : function(val) {
		return this.toggle('<span style="font-size:' + val + ';"></span>', {
			span : '.font-size=' + val,
			font : 'size'
		});
	},
	fontname : function(val) {
		return this.fontfamily(val);
	},
	fontfamily : function(val) {
		return this.toggle('<span style="font-family:' + val + ';"></span>', {
			span : '.font-family=' + val,
			font : 'face'
		});
	},
	removeformat : function() {
		var map = {
			'*' : '.font-weight,.font-style,.text-decoration,.color,.background-color,.font-size,.font-family,.text-indent'
		},
		tags = _STYLE_TAG_MAP;
		_each(tags, function(key, val) {
			map[key] = '*';
		});
		this.remove(map);
		return this.select();
	},
	inserthtml : function(val, quickMode) {
		var self = this, range = self.range;
		if (val === '') {
			return self;
		}
		function pasteHtml(range, val) {
			val = '<img id="__kindeditor_temp_tag__" width="0" height="0" style="display:none;" />' + val;
			var rng = range.get();
			if (rng.item) {
				rng.item(0).outerHTML = val;
			} else {
				rng.pasteHTML(val);
			}
			var temp = range.doc.getElementById('__kindeditor_temp_tag__');
			temp.parentNode.removeChild(temp);
			var newRange = _toRange(rng);
			range.setEnd(newRange.endContainer, newRange.endOffset);
			range.collapse(false);
			self.select(false);
		}
		function insertHtml(range, val) {
			var doc = range.doc,
				frag = doc.createDocumentFragment();
			K('@' + val, doc).each(function() {
				frag.appendChild(this);
			});
			range.deleteContents();
			range.insertNode(frag);
			range.collapse(false);
			self.select(false);
		}
		if (_IE && quickMode) {
			try {
				pasteHtml(range, val);
			} catch(e) {
				insertHtml(range, val);
			}
			return self;
		}
		insertHtml(range, val);
		return self;
	},
	hr : function() {
		return this.inserthtml('<hr />');
	},
	print : function() {
		this.win.print();
		return this;
	},
	insertimage : function(url, title, width, height, border, align) {
		title = _undef(title, '');
		border = _undef(border, 0);
		var html = '<img src="' + _escape(url) + '" data-ke-src="' + _escape(url) + '" ';
		if (width) {
			html += 'width="' + _escape(width) + '" ';
		}
		if (height) {
			html += 'height="' + _escape(height) + '" ';
		}
		if (title) {
			html += 'title="' + _escape(title) + '" ';
		}
		if (align) {
			html += 'align="' + _escape(align) + '" ';
		}
		html += 'alt="' + _escape(title) + '" ';
		html += '/>';
		return this.inserthtml(html);
	},
	createlink : function(url, type) {
		var self = this, doc = self.doc, range = self.range;
		self.select();
		var a = self.commonNode({ a : '*' });
		if (a && !range.isControl()) {
			range.selectNode(a.get());
			self.select();
		}
		var html = '<a href="' + _escape(url) + '" data-ke-src="' + _escape(url) + '" ';
		if (type) {
			html += ' target="' + _escape(type) + '"';
		}
		if (range.collapsed) {
			html += '>' + _escape(url) + '</a>';
			return self.inserthtml(html);
		}
		if (range.isControl()) {
			var node = K(range.startContainer.childNodes[range.startOffset]);
			html += '></a>';
			node.after(K(html, doc));
			node.next().append(node);
			range.selectNode(node[0]);
			return self.select();
		}
		_nativeCommand(doc, 'createlink', '__kindeditor_temp_url__');
		K('a[href="__kindeditor_temp_url__"]', doc).each(function() {
			K(this).attr('href', url).attr('data-ke-src', url);
			if (type) {
				K(this).attr('target', type);
			} else {
				K(this).removeAttr('target');
			}
		});
		return self;
	},
	unlink : function() {
		var self = this, doc = self.doc, range = self.range;
		self.select();
		if (range.collapsed) {
			var a = self.commonNode({ a : '*' });
			if (a) {
				range.selectNode(a.get());
				self.select();
			}
			_nativeCommand(doc, 'unlink', null);
			if (_WEBKIT && K(range.startContainer).name === 'img') {
				var parent = K(range.startContainer).parent();
				if (parent.name === 'a') {
					parent.remove(true);
				}
			}
		} else {
			_nativeCommand(doc, 'unlink', null);
		}
		return self;
	}
});
_each(('formatblock,selectall,justifyleft,justifycenter,justifyright,justifyfull,insertorderedlist,' +
	'insertunorderedlist,indent,outdent,subscript,superscript').split(','), function(i, name) {
	KCmd.prototype[name] = function(val) {
		var self = this;
		self.select();
		_nativeCommand(self.doc, name, val);
		if (!_IE || _inArray(name, 'formatblock,selectall,insertorderedlist,insertunorderedlist'.split(',')) >= 0) {
			self.selection();
		}
		return self;
	};
});
_each('cut,copy,paste'.split(','), function(i, name) {
	KCmd.prototype[name] = function() {
		var self = this;
		if (!self.doc.queryCommandSupported(name)) {
			throw 'not supported';
		}
		self.select();
		_nativeCommand(self.doc, name, null);
		return self;
	};
});
function _cmd(mixed) {
	if (mixed.nodeName) {
		var doc = _getDoc(mixed);
		mixed = _range(doc).selectNodeContents(doc.body).collapse(false);
	}
	return new KCmd(mixed);
}
K.CmdClass = KCmd;
K.cmd = _cmd;
function _drag(options) {
	var moveEl = options.moveEl,
		moveFn = options.moveFn,
		clickEl = options.clickEl || moveEl,
		beforeDrag = options.beforeDrag,
		iframeFix = options.iframeFix === undefined ? true : options.iframeFix;
	var docs = [document];
	if (iframeFix) {
		K('iframe').each(function() {
			var src = _formatUrl(this.src || '', 'absolute');
			if (/^https?:\/\//.test(src)) {
				return;
			}
			var doc;
			try {
				doc = _iframeDoc(this);
			} catch(e) {}
			if (doc) {
				var pos = K(this).pos();
				K(doc).data('pos-x', pos.x);
				K(doc).data('pos-y', pos.y);
				docs.push(doc);
			}
		});
	}
	clickEl.mousedown(function(e) {
		e.stopPropagation();
		var self = clickEl.get(),
			x = _removeUnit(moveEl.css('left')),
			y = _removeUnit(moveEl.css('top')),
			width = moveEl.width(),
			height = moveEl.height(),
			pageX = e.pageX,
			pageY = e.pageY;
		if (beforeDrag) {
			beforeDrag();
		}
		function moveListener(e) {
			e.preventDefault();
			var kdoc = K(_getDoc(e.target));
			var diffX = _round((kdoc.data('pos-x') || 0) + e.pageX - pageX);
			var diffY = _round((kdoc.data('pos-y') || 0) + e.pageY - pageY);
			moveFn.call(clickEl, x, y, width, height, diffX, diffY);
		}
		function selectListener(e) {
			e.preventDefault();
		}
		function upListener(e) {
			e.preventDefault();
			K(docs).unbind('mousemove', moveListener)
				.unbind('mouseup', upListener)
				.unbind('selectstart', selectListener);
			if (self.releaseCapture) {
				self.releaseCapture();
			}
		}
		K(docs).mousemove(moveListener)
			.mouseup(upListener)
			.bind('selectstart', selectListener);
		if (self.setCapture) {
			self.setCapture();
		}
	});
}
function KWidget(options) {
	this.init(options);
}
_extend(KWidget, {
	init : function(options) {
		var self = this;
		self.name = options.name || '';
		self.doc = options.doc || document;
		self.win = _getWin(self.doc);
		self.x = _addUnit(options.x);
		self.y = _addUnit(options.y);
		self.z = options.z;
		self.width = _addUnit(options.width);
		self.height = _addUnit(options.height);
		self.div = K('<div style="display:block;"></div>');
		self.options = options;
		self._alignEl = options.alignEl;
		if (self.width) {
			self.div.css('width', self.width);
		}
		if (self.height) {
			self.div.css('height', self.height);
		}
		if (self.z) {
			self.div.css({
				position : 'absolute',
				left : self.x,
				top : self.y,
				'z-index' : self.z
			});
		}
		if (self.z && (self.x === undefined || self.y === undefined)) {
			self.autoPos(self.width, self.height);
		}
		if (options.cls) {
			self.div.addClass(options.cls);
		}
		if (options.shadowMode) {
			self.div.addClass('ke-shadow');
		}
		if (options.css) {
			self.div.css(options.css);
		}
		if (options.src) {
			K(options.src).replaceWith(self.div);
		} else {
			K(self.doc.body).append(self.div);
		}
		if (options.html) {
			self.div.html(options.html);
		}
		if (options.autoScroll) {
			if (_IE && _V < 7 || _QUIRKS) {
				var scrollPos = _getScrollPos();
				K(self.win).bind('scroll', function(e) {
					var pos = _getScrollPos(),
						diffX = pos.x - scrollPos.x,
						diffY = pos.y - scrollPos.y;
					self.pos(_removeUnit(self.x) + diffX, _removeUnit(self.y) + diffY, false);
				});
			} else {
				self.div.css('position', 'fixed');
			}
		}
	},
	pos : function(x, y, updateProp) {
		var self = this;
		updateProp = _undef(updateProp, true);
		if (x !== null) {
			x = x < 0 ? 0 : _addUnit(x);
			self.div.css('left', x);
			if (updateProp) {
				self.x = x;
			}
		}
		if (y !== null) {
			y = y < 0 ? 0 : _addUnit(y);
			self.div.css('top', y);
			if (updateProp) {
				self.y = y;
			}
		}
		return self;
	},
	autoPos : function(width, height) {
		var self = this,
			w = _removeUnit(width) || 0,
			h = _removeUnit(height) || 0,
			scrollPos = _getScrollPos();
		if (self._alignEl) {
			var knode = K(self._alignEl),
				pos = knode.pos(),
				diffX = _round(knode[0].clientWidth / 2 - w / 2),
				diffY = _round(knode[0].clientHeight / 2 - h / 2);
			x = diffX < 0 ? pos.x : pos.x + diffX;
			y = diffY < 0 ? pos.y : pos.y + diffY;
		} else {
			var docEl = _docElement(self.doc);
			x = _round(scrollPos.x + (docEl.clientWidth - w) / 2);
			y = _round(scrollPos.y + (docEl.clientHeight - h) / 2);
		}
		if (!(_IE && _V < 7 || _QUIRKS)) {
			x -= scrollPos.x;
			y -= scrollPos.y;
		}
		return self.pos(x, y);
	},
	remove : function() {
		var self = this;
		if (_IE && _V < 7 || _QUIRKS) {
			K(self.win).unbind('scroll');
		}
		self.div.remove();
		_each(self, function(i) {
			self[i] = null;
		});
		return this;
	},
	show : function() {
		this.div.show();
		return this;
	},
	hide : function() {
		this.div.hide();
		return this;
	},
	draggable : function(options) {
		var self = this;
		options = options || {};
		options.moveEl = self.div;
		options.moveFn = function(x, y, width, height, diffX, diffY) {
			if ((x = x + diffX) < 0) {
				x = 0;
			}
			if ((y = y + diffY) < 0) {
				y = 0;
			}
			self.pos(x, y);
		};
		_drag(options);
		return self;
	}
});
function _widget(options) {
	return new KWidget(options);
}
K.WidgetClass = KWidget;
K.widget = _widget;
function _iframeDoc(iframe) {
	iframe = _get(iframe);
	return iframe.contentDocument || iframe.contentWindow.document;
}
var html, _direction = '';
if ((html = document.getElementsByTagName('html'))) {
	_direction = html[0].dir;
}
function _getInitHtml(themesPath, bodyClass, cssPath, cssData) {
	var arr = [
		(_direction === '' ? '<html>' : '<html dir="' + _direction + '">'),
		'<head><meta charset="utf-8" /><title></title>',
		'<style>',
		'html {margin:0;padding:0;}',
		'body {margin:0;padding:5px;}',
		'body, td {font:12px/1.5 "sans serif",tahoma,verdana,helvetica;}',
		'body, p, div {word-wrap: break-word;}',
		'p {margin:5px 0;}',
		'table {border-collapse:collapse;}',
		'img {border:0;}',
		'noscript {display:none;}',
		'table.ke-zeroborder td {border:1px dotted #AAA;}',
		'img.ke-flash {',
		'	border:1px solid #AAA;',
		'	background-image:url(' + themesPath + 'common/flash.gif);',
		'	background-position:center center;',
		'	background-repeat:no-repeat;',
		'	width:100px;',
		'	height:100px;',
		'}',
		'img.ke-rm {',
		'	border:1px solid #AAA;',
		'	background-image:url(' + themesPath + 'common/rm.gif);',
		'	background-position:center center;',
		'	background-repeat:no-repeat;',
		'	width:100px;',
		'	height:100px;',
		'}',
		'img.ke-media {',
		'	border:1px solid #AAA;',
		'	background-image:url(' + themesPath + 'common/media.gif);',
		'	background-position:center center;',
		'	background-repeat:no-repeat;',
		'	width:100px;',
		'	height:100px;',
		'}',
		'img.ke-anchor {',
		'	border:1px dashed #666;',
		'	width:16px;',
		'	height:16px;',
		'}',
		'.ke-script, .ke-noscript, .ke-display-none {',
		'	display:none;',
		'	font-size:0;',
		'	width:0;',
		'	height:0;',
		'}',
		'.ke-pagebreak {',
		'	border:1px dotted #AAA;',
		'	font-size:0;',
		'	height:2px;',
		'}',
		'</style>'
	];
	if (!_isArray(cssPath)) {
		cssPath = [cssPath];
	}
	_each(cssPath, function(i, path) {
		if (path) {
			arr.push('<link href="' + path + '" rel="stylesheet" />');
		}
	});
	if (cssData) {
		arr.push('<style>' + cssData + '</style>');
	}
	arr.push('</head><body ' + (bodyClass ? 'class="' + bodyClass + '"' : '') + '></body></html>');
	return arr.join('\n');
}
function _elementVal(knode, val) {
	if (knode.hasVal()) {
		if (val === undefined) {
			var html = knode.val();
			html = html.replace(/(<(?:p|p\s[^>]*)>) *(<\/p>)/ig, '');
			return html;
		}
		return knode.val(val);
	}
	return knode.html(val);
}
function KEdit(options) {
	this.init(options);
}
_extend(KEdit, KWidget, {
	init : function(options) {
		var self = this;
		KEdit.parent.init.call(self, options);
		self.srcElement = K(options.srcElement);
		self.div.addClass('ke-edit');
		self.designMode = _undef(options.designMode, true);
		self.beforeGetHtml = options.beforeGetHtml;
		self.beforeSetHtml = options.beforeSetHtml;
		self.afterSetHtml = options.afterSetHtml;
		var themesPath = _undef(options.themesPath, ''),
			bodyClass = options.bodyClass,
			cssPath = options.cssPath,
			cssData = options.cssData,
			isDocumentDomain = location.host.replace(/:\d+/, '') !== document.domain,
			srcScript = ('document.open();' +
				(isDocumentDomain ? 'document.domain="' + document.domain + '";' : '') +
				'document.close();'),
			iframeSrc = _IE ? ' src="javascript:void(function(){' + encodeURIComponent(srcScript) + '}())"' : '';
		self.iframe = K('<iframe class="ke-edit-iframe" hidefocus="true" frameborder="0"' + iframeSrc + '></iframe>').css('width', '100%');
		self.textarea = K('<textarea class="ke-edit-textarea" hidefocus="true"></textarea>').css('width', '100%');
		if (self.width) {
			self.setWidth(self.width);
		}
		if (self.height) {
			self.setHeight(self.height);
		}
		if (self.designMode) {
			self.textarea.hide();
		} else {
			self.iframe.hide();
		}
		function ready() {
			var doc = _iframeDoc(self.iframe);
			doc.open();
			if (isDocumentDomain) {
				doc.domain = document.domain;
			}
			doc.write(_getInitHtml(themesPath, bodyClass, cssPath, cssData));
			doc.close();
			self.win = self.iframe[0].contentWindow;
			self.doc = doc;
			var cmd = _cmd(doc);
			self.afterChange(function(e) {
				cmd.selection();
			});
			if (_WEBKIT) {
				K(doc).click(function(e) {
					if (K(e.target).name === 'img') {
						cmd.selection(true);
						cmd.range.selectNode(e.target);
						cmd.select();
					}
				});
			}
			if (_IE) {
				self._mousedownHandler = function() {
					var newRange = cmd.range.cloneRange();
					newRange.shrink();
					if (newRange.isControl()) {
						self.blur();
					}
				};
				K(document).mousedown(self._mousedownHandler);
				K(doc).keydown(function(e) {
					if (e.which == 8) {
						cmd.selection();
						var rng = cmd.range;
						if (rng.isControl()) {
							rng.collapse(true);
							K(rng.startContainer.childNodes[rng.startOffset]).remove();
							e.preventDefault();
						}
					}
				});
			}
			self.cmd = cmd;
			self.html(_elementVal(self.srcElement));
			if (_IE) {
				doc.body.disabled = true;
				doc.body.contentEditable = true;
				doc.body.removeAttribute('disabled');
			} else {
				doc.designMode = 'on';
			}
			if (options.afterCreate) {
				options.afterCreate.call(self);
			}
		}
		if (isDocumentDomain) {
			self.iframe.bind('load', function(e) {
				self.iframe.unbind('load');
				if (_IE) {
					ready();
				} else {
					setTimeout(ready, 0);
				}
			});
		}
		self.div.append(self.iframe);
		self.div.append(self.textarea);
		self.srcElement.hide();
		!isDocumentDomain && ready();
	},
	setWidth : function(val) {
		this.div.css('width', _addUnit(val));
		return this;
	},
	setHeight : function(val) {
		var self = this;
		val = _addUnit(val);
		self.div.css('height', val);
		self.iframe.css('height', val);
		if ((_IE && _V < 8) || _QUIRKS) {
			val = _addUnit(_removeUnit(val) - 2);
		}
		self.textarea.css('height', val);
		return self;
	},
	remove : function() {
		var self = this, doc = self.doc;
		K(doc.body).unbind();
		K(doc).unbind();
		K(self.win).unbind();
		if (self._mousedownHandler) {
			K(document).unbind('mousedown', self._mousedownHandler);
		}
		_elementVal(self.srcElement, self.html());
		self.srcElement.show();
		doc.write('');
		self.iframe.unbind();
		self.textarea.unbind();
		KEdit.parent.remove.call(self);
	},
	html : function(val, isFull) {
		var self = this, doc = self.doc;
		if (self.designMode) {
			var body = doc.body;
			if (val === undefined) {
				if (isFull) {
					val = '<!doctype html><html>' + body.parentNode.innerHTML + '</html>';
				} else {
					val = body.innerHTML;
				}
				if (self.beforeGetHtml) {
					val = self.beforeGetHtml(val);
				}
				if (_GECKO && val == '<br />') {
					val = '';
				}
				return val;
			}
			if (self.beforeSetHtml) {
				val = self.beforeSetHtml(val);
			}
			if (_IE && _V >= 9) {
				val = val.replace(/(<.*?checked=")checked(".*>)/ig, '$1$2');
			}
			K(body).html(val);
			if (self.afterSetHtml) {
				self.afterSetHtml();
			}
			return self;
		}
		if (val === undefined) {
			return self.textarea.val();
		}
		self.textarea.val(val);
		return self;
	},
	design : function(bool) {
		var self = this, val;
		if (bool === undefined ? !self.designMode : bool) {
			if (!self.designMode) {
				val = self.html();
				self.designMode = true;
				self.html(val);
				self.textarea.hide();
				self.iframe.show();
			}
		} else {
			if (self.designMode) {
				val = self.html();
				self.designMode = false;
				self.html(val);
				self.iframe.hide();
				self.textarea.show();
			}
		}
		return self.focus();
	},
	focus : function() {
		var self = this;
		self.designMode ? self.win.focus() : self.textarea[0].focus();
		return self;
	},
	blur : function() {
		var self = this;
		if (_IE) {
			var input = K('<input type="text" style="float:left;width:0;height:0;padding:0;margin:0;border:0;" value="" />', self.div);
			self.div.append(input);
			input[0].focus();
			input.remove();
		} else {
			self.designMode ? self.win.blur() : self.textarea[0].blur();
		}
		return self;
	},
	afterChange : function(fn) {
		var self = this, doc = self.doc, body = doc.body;
		K(doc).keyup(function(e) {
			if (!e.ctrlKey && !e.altKey && _CHANGE_KEY_MAP[e.which]) {
				fn(e);
			}
		});
		K(doc).mouseup(fn).contextmenu(fn);
		K(self.win).blur(fn);
		function timeoutHandler(e) {
			setTimeout(function() {
				fn(e);
			}, 1);
		}
		K(body).bind('paste', timeoutHandler);
		K(body).bind('cut', timeoutHandler);
		return self;
	}
});
function _edit(options) {
	return new KEdit(options);
}
K.EditClass = KEdit;
K.edit = _edit;
K.iframeDoc = _iframeDoc;
function _selectToolbar(name, fn) {
	var self = this,
		knode = self.get(name);
	if (knode) {
		if (knode.hasClass('ke-disabled')) {
			return;
		}
		fn(knode);
	}
}
function KToolbar(options) {
	this.init(options);
}
_extend(KToolbar, KWidget, {
	init : function(options) {
		var self = this;
		KToolbar.parent.init.call(self, options);
		self.disableMode = _undef(options.disableMode, false);
		self.noDisableItemMap = _toMap(_undef(options.noDisableItems, []));
		self._itemMap = {};
		self.div.addClass('ke-toolbar').bind('contextmenu,mousedown,mousemove', function(e) {
			e.preventDefault();
		}).attr('unselectable', 'on');
		function find(target) {
			var knode = K(target);
			if (knode.hasClass('ke-outline')) {
				return knode;
			}
			if (knode.hasClass('ke-toolbar-icon')) {
				return knode.parent();
			}
		}
		function hover(e, method) {
			var knode = find(e.target);
			if (knode) {
				if (knode.hasClass('ke-disabled')) {
					return;
				}
				if (knode.hasClass('ke-selected')) {
					return;
				}
				knode[method]('ke-on');
			}
		}
		self.div.mouseover(function(e) {
			hover(e, 'addClass');
		})
		.mouseout(function(e) {
			hover(e, 'removeClass');
		})
		.click(function(e) {
			var knode = find(e.target);
			if (knode) {
				if (knode.hasClass('ke-disabled')) {
					return;
				}
				self.options.click.call(this, e, knode.attr('data-name'));
			}
		});
	},
	get : function(name) {
		if (this._itemMap[name]) {
			return this._itemMap[name];
		}
		return (this._itemMap[name] = K('span.ke-icon-' + name, this.div).parent());
	},
	select : function(name) {
		_selectToolbar.call(this, name, function(knode) {
			knode.addClass('ke-selected');
		});
		return self;
	},
	unselect : function(name) {
		_selectToolbar.call(this, name, function(knode) {
			knode.removeClass('ke-selected').removeClass('ke-on');
		});
		return self;
	},
	enable : function(name) {
		var self = this,
			knode = name.get ? name : self.get(name);
		if (knode) {
			knode.removeClass('ke-disabled');
			knode.opacity(1);
		}
		return self;
	},
	disable : function(name) {
		var self = this,
			knode = name.get ? name : self.get(name);
		if (knode) {
			knode.removeClass('ke-selected').addClass('ke-disabled');
			knode.opacity(0.5);
		}
		return self;
	},
	disableAll : function(bool, noDisableItems) {
		var self = this, map = self.noDisableItemMap, item;
		if (noDisableItems) {
			map = _toMap(noDisableItems);
		}
		if (bool === undefined ? !self.disableMode : bool) {
			K('span.ke-outline', self.div).each(function() {
				var knode = K(this),
					name = knode[0].getAttribute('data-name', 2);
				if (!map[name]) {
					self.disable(knode);
				}
			});
			self.disableMode = true;
		} else {
			K('span.ke-outline', self.div).each(function() {
				var knode = K(this),
					name = knode[0].getAttribute('data-name', 2);
				if (!map[name]) {
					self.enable(knode);
				}
			});
			self.disableMode = false;
		}
		return self;
	}
});
function _toolbar(options) {
	return new KToolbar(options);
}
K.ToolbarClass = KToolbar;
K.toolbar = _toolbar;
function KMenu(options) {
	this.init(options);
}
_extend(KMenu, KWidget, {
	init : function(options) {
		var self = this;
		options.z = options.z || 811213;
		KMenu.parent.init.call(self, options);
		self.centerLineMode = _undef(options.centerLineMode, true);
		self.div.addClass('ke-menu').bind('click,mousedown', function(e){
			e.stopPropagation();
		}).attr('unselectable', 'on');
	},
	addItem : function(item) {
		var self = this;
		if (item.title === '-') {
			self.div.append(K('<div class="ke-menu-separator"></div>'));
			return;
		}
		var itemDiv = K('<div class="ke-menu-item" unselectable="on"></div>'),
			leftDiv = K('<div class="ke-inline-block ke-menu-item-left"></div>'),
			rightDiv = K('<div class="ke-inline-block ke-menu-item-right"></div>'),
			height = _addUnit(item.height),
			iconClass = _undef(item.iconClass, '');
		self.div.append(itemDiv);
		if (height) {
			itemDiv.css('height', height);
			rightDiv.css('line-height', height);
		}
		var centerDiv;
		if (self.centerLineMode) {
			centerDiv = K('<div class="ke-inline-block ke-menu-item-center"></div>');
			if (height) {
				centerDiv.css('height', height);
			}
		}
		itemDiv.mouseover(function(e) {
			K(this).addClass('ke-menu-item-on');
			if (centerDiv) {
				centerDiv.addClass('ke-menu-item-center-on');
			}
		})
		.mouseout(function(e) {
			K(this).removeClass('ke-menu-item-on');
			if (centerDiv) {
				centerDiv.removeClass('ke-menu-item-center-on');
			}
		})
		.click(function(e) {
			item.click.call(K(this));
			e.stopPropagation();
		})
		.append(leftDiv);
		if (centerDiv) {
			itemDiv.append(centerDiv);
		}
		itemDiv.append(rightDiv);
		if (item.checked) {
			iconClass = 'ke-icon-checked';
		}
		if (iconClass !== '') {
			leftDiv.html('<span class="ke-inline-block ke-toolbar-icon ke-toolbar-icon-url ' + iconClass + '"></span>');
		}
		rightDiv.html(item.title);
		return self;
	},
	remove : function() {
		var self = this;
		if (self.options.beforeRemove) {
			self.options.beforeRemove.call(self);
		}
		K('.ke-menu-item', self.div[0]).unbind();
		KMenu.parent.remove.call(self);
		return self;
	}
});
function _menu(options) {
	return new KMenu(options);
}
K.MenuClass = KMenu;
K.menu = _menu;
function KColorPicker(options) {
	this.init(options);
}
_extend(KColorPicker, KWidget, {
	init : function(options) {
		var self = this;
		options.z = options.z || 811213;
		KColorPicker.parent.init.call(self, options);
		var colors = options.colors || [
			['#E53333', '#E56600', '#FF9900', '#64451D', '#DFC5A4', '#FFE500'],
			['#009900', '#006600', '#99BB00', '#B8D100', '#60D978', '#00D5FF'],
			['#337FE5', '#003399', '#4C33E5', '#9933E5', '#CC33E5', '#EE33EE'],
			['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333', '#000000']
		];
		self.selectedColor = (options.selectedColor || '').toLowerCase();
		self._cells = [];
		self.div.addClass('ke-colorpicker').bind('click,mousedown', function(e){
			e.stopPropagation();
		}).attr('unselectable', 'on');
		var table = self.doc.createElement('table');
		self.div.append(table);
		table.className = 'ke-colorpicker-table';
		table.cellPadding = 0;
		table.cellSpacing = 0;
		table.border = 0;
		var row = table.insertRow(0), cell = row.insertCell(0);
		cell.colSpan = colors[0].length;
		self._addAttr(cell, '', 'ke-colorpicker-cell-top');
		for (var i = 0; i < colors.length; i++) {
			row = table.insertRow(i + 1);
			for (var j = 0; j < colors[i].length; j++) {
				cell = row.insertCell(j);
				self._addAttr(cell, colors[i][j], 'ke-colorpicker-cell');
			}
		}
	},
	_addAttr : function(cell, color, cls) {
		var self = this;
		cell = K(cell).addClass(cls);
		if (self.selectedColor === color.toLowerCase()) {
			cell.addClass('ke-colorpicker-cell-selected');
		}
		cell.attr('title', color || self.options.noColor);
		cell.mouseover(function(e) {
			K(this).addClass('ke-colorpicker-cell-on');
		});
		cell.mouseout(function(e) {
			K(this).removeClass('ke-colorpicker-cell-on');
		});
		cell.click(function(e) {
			e.stop();
			self.options.click.call(K(this), color);
		});
		if (color) {
			cell.append(K('<div class="ke-colorpicker-cell-color" unselectable="on"></div>').css('background-color', color));
		} else {
			cell.html(self.options.noColor);
		}
		K(cell).attr('unselectable', 'on');
		self._cells.push(cell);
	},
	remove : function() {
		var self = this;
		_each(self._cells, function() {
			this.unbind();
		});
		KColorPicker.parent.remove.call(self);
		return self;
	}
});
function _colorpicker(options) {
	return new KColorPicker(options);
}
K.ColorPickerClass = KColorPicker;
K.colorpicker = _colorpicker;
function KUploadButton(options) {
	this.init(options);
}
_extend(KUploadButton, {
	init : function(options) {
		var self = this,
			button = K(options.button),
			fieldName = options.fieldName || 'file',
			url = options.url || '',
			title = button.val(),
			extraParams = options.extraParams || {},
			cls = button[0].className || '',
			target = options.target || 'kindeditor_upload_iframe_' + new Date().getTime();
		options.afterError = options.afterError || function(str) {
			alert(str);
		};
		var hiddenElements = [];
		for(var k in extraParams){
			hiddenElements.push('<input type="hidden" name="' + k + '" value="' + extraParams[k] + '" />');
		}
		var html = [
			'<div class="ke-inline-block ' + cls + '">',
			(options.target ? '' : '<iframe name="' + target + '" style="display:none;"></iframe>'),
			(options.form ? '<div class="ke-upload-area">' : '<form class="ke-upload-area ke-form" method="post" enctype="multipart/form-data" target="' + target + '" action="' + url + '">'),
			'<span class="ke-button-common">',
			hiddenElements.join(''),
			'<input type="button" class="ke-button-common ke-button" value="' + title + '" />',
			'</span>',
			'<input type="file" class="ke-upload-file" name="' + fieldName + '" tabindex="-1" />',
			(options.form ? '</div>' : '</form>'),
			'</div>'].join('');
		var div = K(html, button.doc);
		button.hide();
		button.before(div);
		self.div = div;
		self.button = button;
		self.iframe = options.target ? K('iframe[name="' + target + '"]') : K('iframe', div);
		self.form = options.form ? K(options.form) : K('form', div);
		var width = options.width || K('.ke-button-common', div).width();
		self.fileBox = K('.ke-upload-file', div).width(width);
		self.options = options;
	},
	submit : function() {
		var self = this,
			iframe = self.iframe;
		iframe.bind('load', function() {
			iframe.unbind();
			var tempForm = document.createElement('form');
			self.fileBox.before(tempForm);
			K(tempForm).append(self.fileBox);
			tempForm.reset();
			K(tempForm).remove(true);
			var doc = K.iframeDoc(iframe),
				pre = doc.getElementsByTagName('pre')[0],
				str = '', data;
			if (pre) {
				str = pre.innerHTML;
			} else {
				str = doc.body.innerHTML;
			}
			str = _unescape(str);
			iframe[0].src = 'javascript:false';
			try {
				data = K.json(str);
			} catch (e) {
				self.options.afterError.call(self, '<!doctype html><html>' + doc.body.parentNode.innerHTML + '</html>');
			}
			if (data) {
				self.options.afterUpload.call(self, data);
			}
		});
		self.form[0].submit();
		return self;
	},
	remove : function() {
		var self = this;
		if (self.fileBox) {
			self.fileBox.unbind();
		}
		self.iframe.remove();
		self.div.remove();
		self.button.show();
		return self;
	}
});
function _uploadbutton(options) {
	return new KUploadButton(options);
}
K.UploadButtonClass = KUploadButton;
K.uploadbutton = _uploadbutton;
function _createButton(arg) {
	arg = arg || {};
	var name = arg.name || '',
		span = K('<span class="ke-button-common ke-button-outer" title="' + name + '"></span>'),
		btn = K('<input class="ke-button-common ke-button" type="button" value="' + name + '" />');
	if (arg.click) {
		btn.click(arg.click);
	}
	span.append(btn);
	return span;
}
function KDialog(options) {
	this.init(options);
}
_extend(KDialog, KWidget, {
	init : function(options) {
		var self = this;
		var shadowMode = _undef(options.shadowMode, true);
		options.z = options.z || 811213;
		options.shadowMode = false;
		options.autoScroll = _undef(options.autoScroll, true);
		KDialog.parent.init.call(self, options);
		var title = options.title,
			body = K(options.body, self.doc),
			previewBtn = options.previewBtn,
			yesBtn = options.yesBtn,
			noBtn = options.noBtn,
			closeBtn = options.closeBtn,
			showMask = _undef(options.showMask, true);
		self.div.addClass('ke-dialog').bind('click,mousedown', function(e){
			e.stopPropagation();
		});
		var contentDiv = K('<div class="ke-dialog-content"></div>').appendTo(self.div);
		if (_IE && _V < 7) {
			self.iframeMask = K('<iframe src="about:blank" class="ke-dialog-shadow"></iframe>').appendTo(self.div);
		} else if (shadowMode) {
			K('<div class="ke-dialog-shadow"></div>').appendTo(self.div);
		}
		var headerDiv = K('<div class="ke-dialog-header"></div>');
		contentDiv.append(headerDiv);
		headerDiv.html(title);
		self.closeIcon = K('<span class="ke-dialog-icon-close" title="' + closeBtn.name + '"></span>').click(closeBtn.click);
		headerDiv.append(self.closeIcon);
		self.draggable({
			clickEl : headerDiv,
			beforeDrag : options.beforeDrag
		});
		var bodyDiv = K('<div class="ke-dialog-body"></div>');
		contentDiv.append(bodyDiv);
		bodyDiv.append(body);
		var footerDiv = K('<div class="ke-dialog-footer"></div>');
		if (previewBtn || yesBtn || noBtn) {
			contentDiv.append(footerDiv);
		}
		_each([
			{ btn : previewBtn, name : 'preview' },
			{ btn : yesBtn, name : 'yes' },
			{ btn : noBtn, name : 'no' }
		], function() {
			if (this.btn) {
				var button = _createButton(this.btn);
				button.addClass('ke-dialog-' + this.name);
				footerDiv.append(button);
			}
		});
		if (self.height) {
			bodyDiv.height(_removeUnit(self.height) - headerDiv.height() - footerDiv.height());
		}
		self.div.width(self.div.width());
		self.div.height(self.div.height());
		self.mask = null;
		if (showMask) {
			var docEl = _docElement(self.doc),
				docWidth = Math.max(docEl.scrollWidth, docEl.clientWidth),
				docHeight = Math.max(docEl.scrollHeight, docEl.clientHeight);
			self.mask = _widget({
				x : 0,
				y : 0,
				z : self.z - 1,
				cls : 'ke-dialog-mask',
				width : docWidth,
				height : docHeight
			});
		}
		self.autoPos(self.div.width(), self.div.height());
		self.footerDiv = footerDiv;
		self.bodyDiv = bodyDiv;
		self.headerDiv = headerDiv;
		self.isLoading = false;
	},
	setMaskIndex : function(z) {
		var self = this;
		self.mask.div.css('z-index', z);
	},
	showLoading : function(msg) {
		msg = _undef(msg, '');
		var self = this, body = self.bodyDiv;
		self.loading = K('<div class="ke-dialog-loading"><div class="ke-inline-block ke-dialog-loading-content" style="margin-top:' + Math.round(body.height() / 3) + 'px;">' + msg + '</div></div>')
			.width(body.width()).height(body.height())
			.css('top', self.headerDiv.height() + 'px');
		body.css('visibility', 'hidden').after(self.loading);
		self.isLoading = true;
		return self;
	},
	hideLoading : function() {
		this.loading && this.loading.remove();
		this.bodyDiv.css('visibility', 'visible');
		this.isLoading = false;
		return this;
	},
	remove : function() {
		var self = this;
		if (self.options.beforeRemove) {
			self.options.beforeRemove.call(self);
		}
		self.mask && self.mask.remove();
		self.iframeMask && self.iframeMask.remove();
		self.closeIcon.unbind();
		K('input', self.div).unbind();
		K('button', self.div).unbind();
		self.footerDiv.unbind();
		self.bodyDiv.unbind();
		self.headerDiv.unbind();
		K('iframe', self.div).each(function() {
			K(this).remove();
		});
		KDialog.parent.remove.call(self);
		return self;
	}
});
function _dialog(options) {
	return new KDialog(options);
}
K.DialogClass = KDialog;
K.dialog = _dialog;
function _tabs(options) {
	var self = _widget(options),
		remove = self.remove,
		afterSelect = options.afterSelect,
		div = self.div,
		liList = [];
	div.addClass('ke-tabs')
		.bind('contextmenu,mousedown,mousemove', function(e) {
			e.preventDefault();
		});
	var ul = K('<ul class="ke-tabs-ul ke-clearfix"></ul>');
	div.append(ul);
	self.add = function(tab) {
		var li = K('<li class="ke-tabs-li">' + tab.title + '</li>');
		li.data('tab', tab);
		liList.push(li);
		ul.append(li);
	};
	self.selectedIndex = 0;
	self.select = function(index) {
		self.selectedIndex = index;
		_each(liList, function(i, li) {
			li.unbind();
			if (i === index) {
				li.addClass('ke-tabs-li-selected');
				K(li.data('tab').panel).show('');
			} else {
				li.removeClass('ke-tabs-li-selected').removeClass('ke-tabs-li-on')
				.mouseover(function() {
					K(this).addClass('ke-tabs-li-on');
				})
				.mouseout(function() {
					K(this).removeClass('ke-tabs-li-on');
				})
				.click(function() {
					self.select(i);
				});
				K(li.data('tab').panel).hide();
			}
		});
		if (afterSelect) {
			afterSelect.call(self, index);
		}
	};
	self.remove = function() {
		_each(liList, function() {
			this.remove();
		});
		ul.remove();
		remove.call(self);
	};
	return self;
}
K.tabs = _tabs;
function _loadScript(url, fn) {
	var head = document.getElementsByTagName('head')[0] || (_QUIRKS ? document.body : document.documentElement),
		script = document.createElement('script');
	head.appendChild(script);
	script.src = url;
	script.charset = 'utf-8';
	script.onload = script.onreadystatechange = function() {
		if (!this.readyState || this.readyState === 'loaded') {
			if (fn) {
				fn();
			}
			script.onload = script.onreadystatechange = null;
			head.removeChild(script);
		}
	};
}
function _chopQuery(url) {
	var index = url.indexOf('?');
	return index > 0 ? url.substr(0, index) : url;
}
function _loadStyle(url) {
	var head = document.getElementsByTagName('head')[0] || (_QUIRKS ? document.body : document.documentElement),
		link = document.createElement('link'),
		absoluteUrl = _chopQuery(_formatUrl(url, 'absolute'));
	var links = K('link[rel="stylesheet"]', head);
	for (var i = 0, len = links.length; i < len; i++) {
		if (_chopQuery(_formatUrl(links[i].href, 'absolute')) === absoluteUrl) {
			return;
		}
	}
	head.appendChild(link);
	link.href = url;
	link.rel = 'stylesheet';
}
function _ajax(url, fn, method, param, dataType) {
	method = method || 'GET';
	dataType = dataType || 'json';
	var xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
	xhr.open(method, url, true);
	xhr.onreadystatechange = function () {
		if (xhr.readyState == 4 && xhr.status == 200) {
			if (fn) {
				var data = _trim(xhr.responseText);
				if (dataType == 'json') {
					data = _json(data);
				}
				fn(data);
			}
		}
	};
	if (method == 'POST') {
		var params = [];
		_each(param, function(key, val) {
			params.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
		});
		try {
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		} catch (e) {}
		xhr.send(params.join('&'));
	} else {
		xhr.send(null);
	}
}
K.loadScript = _loadScript;
K.loadStyle = _loadStyle;
K.ajax = _ajax;
var _plugins = {};
function _plugin(name, fn) {
	if (name === undefined) {
		return _plugins;
	}
	if (!fn) {
		return _plugins[name];
	}
	_plugins[name] = fn;
}
var _language = {};
function _parseLangKey(key) {
	var match, ns = 'core';
	if ((match = /^(\w+)\.(\w+)$/.exec(key))) {
		ns = match[1];
		key = match[2];
	}
	return { ns : ns, key : key };
}
function _lang(mixed, langType) {
	langType = langType === undefined ? K.options.langType : langType;
	if (typeof mixed === 'string') {
		if (!_language[langType]) {
			return 'no language';
		}
		var pos = mixed.length - 1;
		if (mixed.substr(pos) === '.') {
			return _language[langType][mixed.substr(0, pos)];
		}
		var obj = _parseLangKey(mixed);
		return _language[langType][obj.ns][obj.key];
	}
	_each(mixed, function(key, val) {
		var obj = _parseLangKey(key);
		if (!_language[langType]) {
			_language[langType] = {};
		}
		if (!_language[langType][obj.ns]) {
			_language[langType][obj.ns] = {};
		}
		_language[langType][obj.ns][obj.key] = val;
	});
}
function _getImageFromRange(range, fn) {
	if (range.collapsed) {
		return;
	}
	range = range.cloneRange().up();
	var sc = range.startContainer, so = range.startOffset;
	if (!_WEBKIT && !range.isControl()) {
		return;
	}
	var img = K(sc.childNodes[so]);
	if (!img || img.name != 'img') {
		return;
	}
	if (fn(img)) {
		return img;
	}
}
function _bindContextmenuEvent() {
	var self = this, doc = self.edit.doc;
	K(doc).contextmenu(function(e) {
		if (self.menu) {
			self.hideMenu();
		}
		if (!self.useContextmenu) {
			e.preventDefault();
			return;
		}
		if (self._contextmenus.length === 0) {
			return;
		}
		var maxWidth = 0, items = [];
		_each(self._contextmenus, function() {
			if (this.title == '-') {
				items.push(this);
				return;
			}
			if (this.cond && this.cond()) {
				items.push(this);
				if (this.width && this.width > maxWidth) {
					maxWidth = this.width;
				}
			}
		});
		while (items.length > 0 && items[0].title == '-') {
			items.shift();
		}
		while (items.length > 0 && items[items.length - 1].title == '-') {
			items.pop();
		}
		var prevItem = null;
		_each(items, function(i) {
			if (this.title == '-' && prevItem.title == '-') {
				delete items[i];
			}
			prevItem = this;
		});
		if (items.length > 0) {
			e.preventDefault();
			var pos = K(self.edit.iframe).pos(),
				menu = _menu({
					x : pos.x + e.clientX,
					y : pos.y + e.clientY,
					width : maxWidth,
					css : { visibility: 'hidden' },
					shadowMode : self.shadowMode
				});
			_each(items, function() {
				if (this.title) {
					menu.addItem(this);
				}
			});
			var docEl = _docElement(menu.doc),
				menuHeight = menu.div.height();
			if (e.clientY + menuHeight >= docEl.clientHeight - 100) {
				menu.pos(menu.x, _removeUnit(menu.y) - menuHeight);
			}
			menu.div.css('visibility', 'visible');
			self.menu = menu;
		}
	});
}
function _bindNewlineEvent() {
	var self = this, doc = self.edit.doc, newlineTag = self.newlineTag;
	if (_IE && newlineTag !== 'br') {
		return;
	}
	if (_GECKO && _V < 3 && newlineTag !== 'p') {
		return;
	}
	if (_OPERA && _V < 9) {
		return;
	}
	var brSkipTagMap = _toMap('h1,h2,h3,h4,h5,h6,pre,li'),
		pSkipTagMap = _toMap('p,h1,h2,h3,h4,h5,h6,pre,li,blockquote');
	function getAncestorTagName(range) {
		var ancestor = K(range.commonAncestor());
		while (ancestor) {
			if (ancestor.type == 1 && !ancestor.isStyle()) {
				break;
			}
			ancestor = ancestor.parent();
		}
		return ancestor.name;
	}
	K(doc).keydown(function(e) {
		if (e.which != 13 || e.shiftKey || e.ctrlKey || e.altKey) {
			return;
		}
		self.cmd.selection();
		var tagName = getAncestorTagName(self.cmd.range);
		if (tagName == 'marquee' || tagName == 'select') {
			return;
		}
		if (newlineTag === 'br' && !brSkipTagMap[tagName]) {
			e.preventDefault();
			self.insertHtml('<br />' + (_IE && _V < 9 ? '' : '\u200B'));
			return;
		}
		if (!pSkipTagMap[tagName]) {
			_nativeCommand(doc, 'formatblock', '<p>');
		}
	});
	K(doc).keyup(function(e) {
		if (e.which != 13 || e.shiftKey || e.ctrlKey || e.altKey) {
			return;
		}
		if (newlineTag == 'br') {
			return;
		}
		if (_GECKO) {
			var root = self.cmd.commonAncestor('p');
			var a = self.cmd.commonAncestor('a');
			if (a && a.text() == '') {
				a.remove(true);
				self.cmd.range.selectNodeContents(root[0]).collapse(true);
				self.cmd.select();
			}
			return;
		}
		self.cmd.selection();
		var tagName = getAncestorTagName(self.cmd.range);
		if (tagName == 'marquee' || tagName == 'select') {
			return;
		}
		if (!pSkipTagMap[tagName]) {
			_nativeCommand(doc, 'formatblock', '<p>');
		}
		var div = self.cmd.commonAncestor('div');
		if (div) {
			var p = K('<p></p>'),
				child = div[0].firstChild;
			while (child) {
				var next = child.nextSibling;
				p.append(child);
				child = next;
			}
			div.before(p);
			div.remove();
			self.cmd.range.selectNodeContents(p[0]);
			self.cmd.select();
		}
	});
}
function _bindTabEvent() {
	var self = this, doc = self.edit.doc;
	K(doc).keydown(function(e) {
		if (e.which == 9) {
			e.preventDefault();
			if (self.afterTab) {
				self.afterTab.call(self, e);
				return;
			}
			var cmd = self.cmd, range = cmd.range;
			range.shrink();
			if (range.collapsed && range.startContainer.nodeType == 1) {
				range.insertNode(K('@&nbsp;', doc)[0]);
				cmd.select();
			}
			self.insertHtml('&nbsp;&nbsp;&nbsp;&nbsp;');
		}
	});
}
function _bindFocusEvent() {
	var self = this;
	K(self.edit.textarea[0], self.edit.win).focus(function(e) {
		if (self.afterFocus) {
			self.afterFocus.call(self, e);
		}
	}).blur(function(e) {
		if (self.afterBlur) {
			self.afterBlur.call(self, e);
		}
	});
}
function _removeBookmarkTag(html) {
	return _trim(html.replace(/<span [^>]*id="?__kindeditor_bookmark_\w+_\d+__"?[^>]*><\/span>/ig, ''));
}
function _removeTempTag(html) {
	return html.replace(/<div[^>]+class="?__kindeditor_paste__"?[^>]*>[\s\S]*?<\/div>/ig, '');
}
function _addBookmarkToStack(stack, bookmark) {
	if (stack.length === 0) {
		stack.push(bookmark);
		return;
	}
	var prev = stack[stack.length - 1];
	if (_removeBookmarkTag(bookmark.html) !== _removeBookmarkTag(prev.html)) {
		stack.push(bookmark);
	}
}
function _undoToRedo(fromStack, toStack) {
	var self = this, edit = self.edit,
		body = edit.doc.body,
		range, bookmark;
	if (fromStack.length === 0) {
		return self;
	}
	if (edit.designMode) {
		range = self.cmd.range;
		bookmark = range.createBookmark(true);
		bookmark.html = body.innerHTML;
	} else {
		bookmark = {
			html : body.innerHTML
		};
	}
	_addBookmarkToStack(toStack, bookmark);
	var prev = fromStack.pop();
	if (_removeBookmarkTag(bookmark.html) === _removeBookmarkTag(prev.html) && fromStack.length > 0) {
		prev = fromStack.pop();
	}
	if (edit.designMode) {
		edit.html(prev.html);
		if (prev.start) {
			range.moveToBookmark(prev);
			self.select();
		}
	} else {
		K(body).html(_removeBookmarkTag(prev.html));
	}
	return self;
}
function KEditor(options) {
	var self = this;
	self.options = {};
	function setOption(key, val) {
		if (KEditor.prototype[key] === undefined) {
			self[key] = val;
		}
		self.options[key] = val;
	}
	_each(options, function(key, val) {
		setOption(key, options[key]);
	});
	_each(K.options, function(key, val) {
		if (self[key] === undefined) {
			setOption(key, val);
		}
	});
	var se = K(self.srcElement || '<textarea/>');
	if (!self.width) {
		self.width = se[0].style.width || se.width();
	}
	if (!self.height) {
		self.height = se[0].style.height || se.height();
	}
	setOption('width', _undef(self.width, self.minWidth));
	setOption('height', _undef(self.height, self.minHeight));
	setOption('width', _addUnit(self.width));
	setOption('height', _addUnit(self.height));
	if (_MOBILE && (!_IOS || _V < 534)) {
		self.designMode = false;
	}
	self.srcElement = se;
	self.initContent = '';
	self.plugin = {};
	self.isCreated = false;
	self.isLoading = false;
	self._handlers = {};
	self._contextmenus = [];
	self._undoStack = [];
	self._redoStack = [];
	self._calledPlugins = {};
	self._firstAddBookmark = true;
	self.menu = self.contextmenu = null;
	self.dialogs = [];
}
KEditor.prototype = {
	lang : function(mixed) {
		return _lang(mixed, this.langType);
	},
	loadPlugin : function(name, fn) {
		var self = this;
		if (_plugins[name]) {
			if (self._calledPlugins[name]) {
				if (fn) {
					fn.call(self);
				}
				return self;
			}
			_plugins[name].call(self, KindEditor);
			if (fn) {
				fn.call(self);
			}
			self._calledPlugins[name] = true;
			return self;
		}
		if (self.isLoading) {
			return self;
		}
		self.isLoading = true;
		_loadScript(self.pluginsPath + name + '/' + name + '.js?ver=' + encodeURIComponent(K.DEBUG ? _TIME : _VERSION), function() {
			self.isLoading = false;
			if (_plugins[name]) {
				self.loadPlugin(name, fn);
			}
		});
		return self;
	},
	handler : function(key, fn) {
		var self = this;
		if (!self._handlers[key]) {
			self._handlers[key] = [];
		}
		if (_isFunction(fn)) {
			self._handlers[key].push(fn);
			return self;
		}
		_each(self._handlers[key], function() {
			fn = this.call(self, fn);
		});
		return fn;
	},
	clickToolbar : function(name, fn) {
		var self = this, key = 'clickToolbar' + name;
		if (fn === undefined) {
			if (self._handlers[key]) {
				return self.handler(key);
			}
			self.loadPlugin(name, function() {
				self.handler(key);
			});
			return self;
		}
		return self.handler(key, fn);
	},
	updateState : function() {
		var self = this;
		_each(('justifyleft,justifycenter,justifyright,justifyfull,insertorderedlist,insertunorderedlist,' +
			'subscript,superscript,bold,italic,underline,strikethrough').split(','), function(i, name) {
			self.cmd.state(name) ? self.toolbar.select(name) : self.toolbar.unselect(name);
		});
		return self;
	},
	addContextmenu : function(item) {
		this._contextmenus.push(item);
		return this;
	},
	afterCreate : function(fn) {
		return this.handler('afterCreate', fn);
	},
	beforeRemove : function(fn) {
		return this.handler('beforeRemove', fn);
	},
	beforeGetHtml : function(fn) {
		return this.handler('beforeGetHtml', fn);
	},
	beforeSetHtml : function(fn) {
		return this.handler('beforeSetHtml', fn);
	},
	afterSetHtml : function(fn) {
		return this.handler('afterSetHtml', fn);
	},
	create : function() {
		var self = this, fullscreenMode = self.fullscreenMode;
		if (self.isCreated) {
			return self;
		}
		if (self.srcElement.data('kindeditor')) {
			return self;
		}
		self.srcElement.data('kindeditor', 'true');
		if (fullscreenMode) {
			_docElement().style.overflow = 'hidden';
		} else {
			_docElement().style.overflow = '';
		}
		var width = fullscreenMode ? _docElement().clientWidth + 'px' : self.width,
			height = fullscreenMode ? _docElement().clientHeight + 'px' : self.height;
		if ((_IE && _V < 8) || _QUIRKS) {
			height = _addUnit(_removeUnit(height) + 2);
		}
		var container = self.container = K(self.layout);
		if (fullscreenMode) {
			K(document.body).append(container);
		} else {
			self.srcElement.before(container);
		}
		var toolbarDiv = K('.toolbar', container),
			editDiv = K('.edit', container),
			statusbar = self.statusbar = K('.statusbar', container);
		container.removeClass('container')
			.addClass('ke-container ke-container-' + self.themeType).css('width', width);
		if (fullscreenMode) {
			container.css({
				position : 'absolute',
				left : 0,
				top : 0,
				'z-index' : 811211
			});
			if (!_GECKO) {
				self._scrollPos = _getScrollPos();
			}
			window.scrollTo(0, 0);
			K(document.body).css({
				'height' : '1px',
				'overflow' : 'hidden'
			});
			K(document.body.parentNode).css('overflow', 'hidden');
			self._fullscreenExecuted = true;
		} else {
			if (self._fullscreenExecuted) {
				K(document.body).css({
					'height' : '',
					'overflow' : ''
				});
				K(document.body.parentNode).css('overflow', '');
			}
			if (self._scrollPos) {
				window.scrollTo(self._scrollPos.x, self._scrollPos.y);
			}
		}
		var htmlList = [];
		K.each(self.items, function(i, name) {
			if (name == '|') {
				htmlList.push('<span class="ke-inline-block ke-separator"></span>');
			} else if (name == '/') {
				htmlList.push('<div class="ke-hr"></div>');
			} else {
				htmlList.push('<span class="ke-outline" data-name="' + name + '" title="' + self.lang(name) + '" unselectable="on">');
				htmlList.push('<span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-' + name + '" unselectable="on"></span></span>');
			}
		});
		var toolbar = self.toolbar = _toolbar({
			src : toolbarDiv,
			html : htmlList.join(''),
			noDisableItems : self.noDisableItems,
			click : function(e, name) {
				e.stop();
				if (self.menu) {
					var menuName = self.menu.name;
					self.hideMenu();
					if (menuName === name) {
						return;
					}
				}
				self.clickToolbar(name);
			}
		});
		var editHeight = _removeUnit(height) - toolbar.div.height();
		var edit = self.edit = _edit({
			height : editHeight > 0 && _removeUnit(height) > self.minHeight ? editHeight : self.minHeight,
			src : editDiv,
			srcElement : self.srcElement,
			designMode : self.designMode,
			themesPath : self.themesPath,
			bodyClass : self.bodyClass,
			cssPath : self.cssPath,
			cssData : self.cssData,
			beforeGetHtml : function(html) {
				html = self.beforeGetHtml(html);
				return _formatHtml(html, self.filterMode ? self.htmlTags : null, self.urlType, self.wellFormatMode, self.indentChar);
			},
			beforeSetHtml : function(html) {
				html = _formatHtml(html, self.filterMode ? self.htmlTags : null, '', false);
				return self.beforeSetHtml(html);
			},
			afterSetHtml : function() {
				self.edit = edit = this;
				self.afterSetHtml();
			},
			afterCreate : function() {
				self.edit = edit = this;
				self.cmd = edit.cmd;
				self._docMousedownFn = function(e) {
					if (self.menu) {
						self.hideMenu();
					}
				};
				K(edit.doc, document).mousedown(self._docMousedownFn);
				_bindContextmenuEvent.call(self);
				_bindNewlineEvent.call(self);
				_bindTabEvent.call(self);
				_bindFocusEvent.call(self);
				edit.afterChange(function(e) {
					if (!edit.designMode) {
						return;
					}
					self.updateState();
					self.addBookmark();
					if (self.options.afterChange) {
						self.options.afterChange.call(self);
					}
				});
				edit.textarea.keyup(function(e) {
					if (!e.ctrlKey && !e.altKey && _INPUT_KEY_MAP[e.which]) {
						if (self.options.afterChange) {
							self.options.afterChange.call(self);
						}
					}
				});
				if (self.readonlyMode) {
					self.readonly();
				}
				self.isCreated = true;
				if (self.initContent === '') {
					self.initContent = self.html();
				}
				self.afterCreate();
				if (self.options.afterCreate) {
					self.options.afterCreate.call(self);
				}
			}
		});
		statusbar.removeClass('statusbar').addClass('ke-statusbar')
			.append('<span class="ke-inline-block ke-statusbar-center-icon"></span>')
			.append('<span class="ke-inline-block ke-statusbar-right-icon"></span>');
		if (self._fullscreenResizeHandler) {
			K(window).unbind('resize', self._fullscreenResizeHandler);
			self._fullscreenResizeHandler = null;
		}
		function initResize() {
			if (statusbar.height() === 0) {
				setTimeout(initResize, 100);
				return;
			}
			self.resize(width, height, false);
		}
		initResize();
		if (fullscreenMode) {
			self._fullscreenResizeHandler = function(e) {
				if (self.isCreated) {
					self.resize(_docElement().clientWidth, _docElement().clientHeight, false);
				}
			};
			K(window).bind('resize', self._fullscreenResizeHandler);
			toolbar.select('fullscreen');
			statusbar.first().css('visibility', 'hidden');
			statusbar.last().css('visibility', 'hidden');
		} else {
			if (_GECKO) {
				K(window).bind('scroll', function(e) {
					self._scrollPos = _getScrollPos();
				});
			}
			if (self.resizeType > 0) {
				_drag({
					moveEl : container,
					clickEl : statusbar,
					moveFn : function(x, y, width, height, diffX, diffY) {
						height += diffY;
						self.resize(null, height);
					}
				});
			} else {
				statusbar.first().css('visibility', 'hidden');
			}
			if (self.resizeType === 2) {
				_drag({
					moveEl : container,
					clickEl : statusbar.last(),
					moveFn : function(x, y, width, height, diffX, diffY) {
						width += diffX;
						height += diffY;
						self.resize(width, height);
					}
				});
			} else {
				statusbar.last().css('visibility', 'hidden');
			}
		}
		return self;
	},
	remove : function() {
		var self = this;
		if (!self.isCreated) {
			return self;
		}
		self.beforeRemove();
		self.srcElement.data('kindeditor', '');
		if (self.menu) {
			self.hideMenu();
		}
		_each(self.dialogs, function() {
			self.hideDialog();
		});
		K(document).unbind('mousedown', self._docMousedownFn);
		self.toolbar.remove();
		self.edit.remove();
		self.statusbar.last().unbind();
		self.statusbar.unbind();
		self.container.remove();
		self.container = self.toolbar = self.edit = self.menu = null;
		self.dialogs = [];
		self.isCreated = false;
		return self;
	},
	resize : function(width, height, updateProp) {
		var self = this;
		updateProp = _undef(updateProp, true);
		if (width) {
			if (!/%/.test(width)) {
				width = _removeUnit(width);
				width = width < self.minWidth ? self.minWidth : width;
			}
			self.container.css('width', _addUnit(width));
			if (updateProp) {
				self.width = _addUnit(width);
			}
		}
		if (height) {
			height = _removeUnit(height);
			editHeight = _removeUnit(height) - self.toolbar.div.height() - self.statusbar.height();
			editHeight = editHeight < self.minHeight ? self.minHeight : editHeight;
			self.edit.setHeight(editHeight);
			if (updateProp) {
				self.height = _addUnit(height);
			}
		}
		return self;
	},
	select : function() {
		this.isCreated && this.cmd.select();
		return this;
	},
	html : function(val) {
		var self = this;
		if (val === undefined) {
			return self.isCreated ? self.edit.html() : _elementVal(self.srcElement);
		}
		self.isCreated ? self.edit.html(val) : _elementVal(self.srcElement, val);
		if (self.isCreated) {
			self.cmd.selection();
		}
		return self;
	},
	fullHtml : function() {
		return this.isCreated ? this.edit.html(undefined, true) : '';
	},
	text : function(val) {
		var self = this;
		if (val === undefined) {
			return _trim(self.html().replace(/<(?!img|embed).*?>/ig, '').replace(/&nbsp;/ig, ' '));
		} else {
			return self.html(_escape(val));
		}
	},
	isEmpty : function() {
		return _trim(this.text().replace(/\r\n|\n|\r/, '')) === '';
	},
	isDirty : function() {
		return _trim(this.initContent.replace(/\r\n|\n|\r|t/g, '')) !== _trim(this.html().replace(/\r\n|\n|\r|t/g, ''));
	},
	selectedHtml : function() {
		return this.isCreated ? this.cmd.range.html() : '';
	},
	count : function(mode) {
		var self = this;
		mode = (mode || 'html').toLowerCase();
		if (mode === 'html') {
			return _removeBookmarkTag(_removeTempTag(self.html())).length;
		}
		if (mode === 'text') {
			return self.text().replace(/<(?:img|embed).*?>/ig, 'K').replace(/\r\n|\n|\r/g, '').length;
		}
		return 0;
	},
	exec : function(key) {
		key = key.toLowerCase();
		var self = this, cmd = self.cmd,
			changeFlag = _inArray(key, 'selectall,copy,paste,print'.split(',')) < 0;
		if (changeFlag) {
			self.addBookmark(false);
		}
		cmd[key].apply(cmd, _toArray(arguments, 1));
		if (changeFlag) {
			self.updateState();
			self.addBookmark(false);
			if (self.options.afterChange) {
				self.options.afterChange.call(self);
			}
		}
		return self;
	},
	insertHtml : function(val, quickMode) {
		if (!this.isCreated) {
			return this;
		}
		val = this.beforeSetHtml(val);
		this.exec('inserthtml', val, quickMode);
		return this;
	},
	appendHtml : function(val) {
		this.html(this.html() + val);
		if (this.isCreated) {
			var cmd = this.cmd;
			cmd.range.selectNodeContents(cmd.doc.body).collapse(false);
			cmd.select();
		}
		return this;
	},
	sync : function() {
		_elementVal(this.srcElement, this.html());
		return this;
	},
	focus : function() {
		this.isCreated ? this.edit.focus() : this.srcElement[0].focus();
		return this;
	},
	blur : function() {
		this.isCreated ? this.edit.blur() : this.srcElement[0].blur();
		return this;
	},
	addBookmark : function(checkSize) {
		checkSize = _undef(checkSize, true);
		var self = this, edit = self.edit,
			body = edit.doc.body,
			html = _removeTempTag(body.innerHTML), bookmark;
		if (checkSize && self._undoStack.length > 0) {
			var prev = self._undoStack[self._undoStack.length - 1];
			if (Math.abs(html.length - _removeBookmarkTag(prev.html).length) < self.minChangeSize) {
				return self;
			}
		}
		if (edit.designMode && !self._firstAddBookmark) {
			var range = self.cmd.range;
			bookmark = range.createBookmark(true);
			bookmark.html = _removeTempTag(body.innerHTML);
			range.moveToBookmark(bookmark);
		} else {
			bookmark = {
				html : html
			};
		}
		self._firstAddBookmark = false;
		_addBookmarkToStack(self._undoStack, bookmark);
		return self;
	},
	undo : function() {
		return _undoToRedo.call(this, this._undoStack, this._redoStack);
	},
	redo : function() {
		return _undoToRedo.call(this, this._redoStack, this._undoStack);
	},
	fullscreen : function(bool) {
		this.fullscreenMode = (bool === undefined ? !this.fullscreenMode : bool);
		return this.remove().create();
	},
	readonly : function(isReadonly) {
		isReadonly = _undef(isReadonly, true);
		var self = this, edit = self.edit, doc = edit.doc;
		if (self.designMode) {
			self.toolbar.disableAll(isReadonly, []);
		} else {
			_each(self.noDisableItems, function() {
				self.toolbar[isReadonly ? 'disable' : 'enable'](this);
			});
		}
		if (_IE) {
			doc.body.contentEditable = !isReadonly;
		} else {
			doc.designMode = isReadonly ? 'off' : 'on';
		}
		edit.textarea[0].disabled = isReadonly;
	},
	createMenu : function(options) {
		var self = this,
			name = options.name,
			knode = self.toolbar.get(name),
			pos = knode.pos();
		options.x = pos.x;
		options.y = pos.y + knode.height();
		options.z = self.options.zIndex;
		options.shadowMode = _undef(options.shadowMode, self.shadowMode);
		if (options.selectedColor !== undefined) {
			options.cls = 'ke-colorpicker-' + self.themeType;
			options.noColor = self.lang('noColor');
			self.menu = _colorpicker(options);
		} else {
			options.cls = 'ke-menu-' + self.themeType;
			options.centerLineMode = false;
			self.menu = _menu(options);
		}
		return self.menu;
	},
	hideMenu : function() {
		this.menu.remove();
		this.menu = null;
		return this;
	},
	hideContextmenu : function() {
		this.contextmenu.remove();
		this.contextmenu = null;
		return this;
	},
	createDialog : function(options) {
		var self = this, name = options.name;
		options.z = self.options.zIndex;
		options.shadowMode = _undef(options.shadowMode, self.shadowMode);
		options.closeBtn = _undef(options.closeBtn, {
			name : self.lang('close'),
			click : function(e) {
				self.hideDialog();
				if (_IE && self.cmd) {
					self.cmd.select();
				}
			}
		});
		options.noBtn = _undef(options.noBtn, {
			name : self.lang(options.yesBtn ? 'no' : 'close'),
			click : function(e) {
				self.hideDialog();
				if (_IE && self.cmd) {
					self.cmd.select();
				}
			}
		});
		if (self.dialogAlignType != 'page') {
			options.alignEl = self.container;
		}
		options.cls = 'ke-dialog-' + self.themeType;
		if (self.dialogs.length > 0) {
			var firstDialog = self.dialogs[0],
				parentDialog = self.dialogs[self.dialogs.length - 1];
			firstDialog.setMaskIndex(parentDialog.z + 2);
			options.z = parentDialog.z + 3;
			options.showMask = false;
		}
		var dialog = _dialog(options);
		self.dialogs.push(dialog);
		return dialog;
	},
	hideDialog : function() {
		var self = this;
		if (self.dialogs.length > 0) {
			self.dialogs.pop().remove();
		}
		if (self.dialogs.length > 0) {
			var firstDialog = self.dialogs[0],
				parentDialog = self.dialogs[self.dialogs.length - 1];
			firstDialog.setMaskIndex(parentDialog.z - 1);
		}
		return self;
	},
	errorDialog : function(html) {
		var self = this;
		var dialog = self.createDialog({
			width : 750,
			title : self.lang('uploadError'),
			body : '<div style="padding:10px 20px;"><iframe frameborder="0" style="width:708px;height:400px;"></iframe></div>'
		});
		var iframe = K('iframe', dialog.div), doc = K.iframeDoc(iframe);
		doc.open();
		doc.write(html);
		doc.close();
		K(doc.body).css('background-color', '#FFF');
		iframe[0].contentWindow.focus();
		return self;
	}
};
function _editor(options) {
	return new KEditor(options);
}
var _instances = [];
function _create(expr, options) {
	options = options || {};
	options.basePath = _undef(options.basePath, K.basePath);
	options.themesPath = _undef(options.themesPath, options.basePath + 'themes/');
	options.langPath = _undef(options.langPath, options.basePath + 'lang/');
	options.pluginsPath = _undef(options.pluginsPath, options.basePath + 'plugins/');
	if (_undef(options.loadStyleMode, K.options.loadStyleMode)) {
		var themeType = _undef(options.themeType, K.options.themeType);
		/*_loadStyle(options.themesPath + themeType + '/' + themeType + '.css');*/
		_loadStyle('static/kindEditor/themes/default/default.css');
	}
	function create(editor) {
		_each(_plugins, function(name, fn) {
			fn.call(editor, KindEditor);
		});
		return editor.create();
	}
	var knode = K(expr);
	if (!knode || knode.length === 0) {
		return;
	}
	if (knode.length > 1) {
		knode.each(function() {
			_create(this, options);
		});
		return _instances[0];
	}
	options.srcElement = knode[0];
	var editor = new KEditor(options);
	_instances.push(editor);
	if (_language[editor.langType]) {
		return create(editor);
	}
	_loadScript(editor.langPath + editor.langType + '.js?ver=' + encodeURIComponent(K.DEBUG ? _TIME : _VERSION), function() {
		create(editor);
	});
	return editor;
}
function _eachEditor(expr, fn) {
	K(expr).each(function(i, el) {
		K.each(_instances, function(j, editor) {
			if (editor && editor.srcElement[0] == el) {
				fn.call(editor, j, editor);
				return false;
			}
		});
	});
}
K.remove = function(expr) {
	_eachEditor(expr, function(i) {
		this.remove();
		_instances.splice(i, 1);
	});
};
K.sync = function(expr) {
	_eachEditor(expr, function() {
		this.sync();
	});
};
if (_IE && _V < 7) {
	_nativeCommand(document, 'BackgroundImageCache', true);
}
K.EditorClass = KEditor;
K.editor = _editor;
K.create = _create;
K.instances = _instances;
K.plugin = _plugin;
K.lang = _lang;
_plugin('core', function(K) {
	var self = this,
		shortcutKeys = {
			undo : 'Z', redo : 'Y', bold : 'B', italic : 'I', underline : 'U', print : 'P', selectall : 'A'
		};
	self.afterSetHtml(function() {
		if (self.options.afterChange) {
			self.options.afterChange.call(self);
		}
	});
	self.afterCreate(function() {
		if (self.syncType != 'form') {
			return;
		}
		var el = K(self.srcElement), hasForm = false;
		while ((el = el.parent())) {
			if (el.name == 'form') {
				hasForm = true;
				break;
			}
		}
		if (hasForm) {
			el.bind('submit', function(e) {
				self.sync();
				K(window).bind('unload', function() {
					self.edit.textarea.remove();
				});
			});
			var resetBtn = K('[type="reset"]', el);
			resetBtn.click(function() {
				self.html(self.initContent);
				self.cmd.selection();
			});
			self.beforeRemove(function() {
				el.unbind();
				resetBtn.unbind();
			});
		}
	});
	self.clickToolbar('source', function() {
		if (self.edit.designMode) {
			self.toolbar.disableAll(true);
			self.edit.design(false);
			self.toolbar.select('source');
		} else {
			self.toolbar.disableAll(false);
			self.edit.design(true);
			self.toolbar.unselect('source');
			self.cmd.selection();
		}
		self.designMode = self.edit.designMode;
	});
	self.afterCreate(function() {
		if (!self.designMode) {
			self.toolbar.disableAll(true).select('source');
		}
	});
	self.clickToolbar('fullscreen', function() {
		self.fullscreen();
	});
	if (self.fullscreenShortcut) {
		var loaded = false;
		self.afterCreate(function() {
			K(self.edit.doc, self.edit.textarea).keyup(function(e) {
				if (e.which == 27) {
					setTimeout(function() {
						self.fullscreen();
					}, 0);
				}
			});
			if (loaded) {
				if (_IE && !self.designMode) {
					return;
				}
				self.focus();
			}
			if (!loaded) {
				loaded = true;
			}
		});
	}
	_each('undo,redo'.split(','), function(i, name) {
		if (shortcutKeys[name]) {
			self.afterCreate(function() {
				_ctrl(this.edit.doc, shortcutKeys[name], function() {
					self.clickToolbar(name);
				});
			});
		}
		self.clickToolbar(name, function() {
			self[name]();
		});
	});
	self.clickToolbar('formatblock', function() {
		var blocks = self.lang('formatblock.formatBlock'),
			heights = {
				h1 : 28,
				h2 : 24,
				h3 : 18,
				H4 : 14,
				p : 12
			},
			curVal = self.cmd.val('formatblock'),
			menu = self.createMenu({
				name : 'formatblock',
				width : self.langType == 'en' ? 200 : 150
			});
		_each(blocks, function(key, val) {
			var style = 'font-size:' + heights[key] + 'px;';
			if (key.charAt(0) === 'h') {
				style += 'font-weight:bold;';
			}
			menu.addItem({
				title : '<span style="' + style + '" unselectable="on">' + val + '</span>',
				height : heights[key] + 12,
				checked : (curVal === key || curVal === val),
				click : function() {
					self.select().exec('formatblock', '<' + key + '>').hideMenu();
				}
			});
		});
	});
	self.clickToolbar('fontname', function() {
		var curVal = self.cmd.val('fontname'),
			menu = self.createMenu({
				name : 'fontname',
				width : 150
			});
		_each(self.lang('fontname.fontName'), function(key, val) {
			menu.addItem({
				title : '<span style="font-family: ' + key + ';" unselectable="on">' + val + '</span>',
				checked : (curVal === key.toLowerCase() || curVal === val.toLowerCase()),
				click : function() {
					self.exec('fontname', key).hideMenu();
				}
			});
		});
	});
	self.clickToolbar('fontsize', function() {
		var curVal = self.cmd.val('fontsize'),
			menu = self.createMenu({
				name : 'fontsize',
				width : 150
			});
		_each(self.fontSizeTable, function(i, val) {
			menu.addItem({
				title : '<span style="font-size:' + val + ';" unselectable="on">' + val + '</span>',
				height : _removeUnit(val) + 12,
				checked : curVal === val,
				click : function() {
					self.exec('fontsize', val).hideMenu();
				}
			});
		});
	});
	_each('forecolor,hilitecolor'.split(','), function(i, name) {
		self.clickToolbar(name, function() {
			self.createMenu({
				name : name,
				selectedColor : self.cmd.val(name) || 'default',
				colors : self.colorTable,
				click : function(color) {
					self.exec(name, color).hideMenu();
				}
			});
		});
	});
	_each(('cut,copy,paste').split(','), function(i, name) {
		self.clickToolbar(name, function() {
			self.focus();
			try {
				self.exec(name, null);
			} catch(e) {
				alert(self.lang(name + 'Error'));
			}
		});
	});
	self.clickToolbar('about', function() {
		var html = '<div style="margin:20px;">' +
			'<div>KindEditor ' + _VERSION + '</div>' +
			'<div>Copyright &copy; <a href="http://www.kindsoft.net/" target="_blank">kindsoft.net</a> All rights reserved.</div>' +
			'</div>';
		self.createDialog({
			name : 'about',
			width : 350,
			title : self.lang('about'),
			body : html
		});
	});
	self.plugin.getSelectedLink = function() {
		return self.cmd.commonAncestor('a');
	};
	self.plugin.getSelectedImage = function() {
		return _getImageFromRange(self.edit.cmd.range, function(img) {
			return !/^ke-\w+$/i.test(img[0].className);
		});
	};
	self.plugin.getSelectedFlash = function() {
		return _getImageFromRange(self.edit.cmd.range, function(img) {
			return img[0].className == 'ke-flash';
		});
	};
	self.plugin.getSelectedMedia = function() {
		return _getImageFromRange(self.edit.cmd.range, function(img) {
			return img[0].className == 'ke-media' || img[0].className == 'ke-rm';
		});
	};
	self.plugin.getSelectedAnchor = function() {
		return _getImageFromRange(self.edit.cmd.range, function(img) {
			return img[0].className == 'ke-anchor';
		});
	};
	_each('link,image,flash,media,anchor'.split(','), function(i, name) {
		var uName = name.charAt(0).toUpperCase() + name.substr(1);
		_each('edit,delete'.split(','), function(j, val) {
			self.addContextmenu({
				title : self.lang(val + uName),
				click : function() {
					self.loadPlugin(name, function() {
						self.plugin[name][val]();
						self.hideMenu();
					});
				},
				cond : self.plugin['getSelected' + uName],
				width : 150,
				iconClass : val == 'edit' ? 'ke-icon-' + name : undefined
			});
		});
		self.addContextmenu({ title : '-' });
	});
	self.plugin.getSelectedTable = function() {
		return self.cmd.commonAncestor('table');
	};
	self.plugin.getSelectedRow = function() {
		return self.cmd.commonAncestor('tr');
	};
	self.plugin.getSelectedCell = function() {
		return self.cmd.commonAncestor('td');
	};
	_each(('prop,cellprop,colinsertleft,colinsertright,rowinsertabove,rowinsertbelow,rowmerge,colmerge,' +
	'rowsplit,colsplit,coldelete,rowdelete,insert,delete').split(','), function(i, val) {
		var cond = _inArray(val, ['prop', 'delete']) < 0 ? self.plugin.getSelectedCell : self.plugin.getSelectedTable;
		self.addContextmenu({
			title : self.lang('table' + val),
			click : function() {
				self.loadPlugin('table', function() {
					self.plugin.table[val]();
					self.hideMenu();
				});
			},
			cond : cond,
			width : 170,
			iconClass : 'ke-icon-table' + val
		});
	});
	self.addContextmenu({ title : '-' });
	_each(('selectall,justifyleft,justifycenter,justifyright,justifyfull,insertorderedlist,' +
		'insertunorderedlist,indent,outdent,subscript,superscript,hr,print,' +
		'bold,italic,underline,strikethrough,removeformat,unlink').split(','), function(i, name) {
		if (shortcutKeys[name]) {
			self.afterCreate(function() {
				_ctrl(this.edit.doc, shortcutKeys[name], function() {
					self.cmd.selection();
					self.clickToolbar(name);
				});
			});
		}
		self.clickToolbar(name, function() {
			self.focus().exec(name, null);
		});
	});
	self.afterCreate(function() {
		var doc = self.edit.doc, cmd, bookmark, div,
			cls = '__kindeditor_paste__', pasting = false;
		function movePastedData() {
			cmd.range.moveToBookmark(bookmark);
			cmd.select();
			if (_WEBKIT) {
				K('div.' + cls, div).each(function() {
					K(this).after('<br />').remove(true);
				});
				K('span.Apple-style-span', div).remove(true);
				K('span.Apple-tab-span', div).remove(true);
				K('span[style]', div).each(function() {
					if (K(this).css('white-space') == 'nowrap') {
						K(this).remove(true);
					}
				});
				K('meta', div).remove();
			}
			var html = div[0].innerHTML;
			div.remove();
			if (html === '') {
				return;
			}
			if (_WEBKIT) {
				html = html.replace(/(<br>)\1/ig, '$1');
			}
			if (self.pasteType === 2) {
				html = html.replace(/(<(?:p|p\s[^>]*)>) *(<\/p>)/ig, '');
				if (/schemas-microsoft-com|worddocument|mso-\w+/i.test(html)) {
					html = _clearMsWord(html, self.filterMode ? self.htmlTags : K.options.htmlTags);
				} else {
					html = _formatHtml(html, self.filterMode ? self.htmlTags : null);
					html = self.beforeSetHtml(html);
				}
			}
			if (self.pasteType === 1) {
				html = html.replace(/&nbsp;/ig, ' ');
				html = html.replace(/\n\s*\n/g, '\n');
				html = html.replace(/<br[^>]*>/ig, '\n');
				html = html.replace(/<\/p><p[^>]*>/ig, '\n');
				html = html.replace(/<[^>]+>/g, '');
				html = html.replace(/ {2}/g, ' &nbsp;');
				if (self.newlineTag == 'p') {
					if (/\n/.test(html)) {
						html = html.replace(/^/, '<p>').replace(/$/, '<br /></p>').replace(/\n/g, '<br /></p><p>');
					}
				} else {
					html = html.replace(/\n/g, '<br />$&');
				}
			}
			self.insertHtml(html, true);
		}
		K(doc.body).bind('paste', function(e){
			if (self.pasteType === 0) {
				e.stop();
				return;
			}
			if (pasting) {
				return;
			}
			pasting = true;
			K('div.' + cls, doc).remove();
			cmd = self.cmd.selection();
			bookmark = cmd.range.createBookmark();
			div = K('<div class="' + cls + '"></div>', doc).css({
				position : 'absolute',
				width : '1px',
				height : '1px',
				overflow : 'hidden',
				left : '-1981px',
				top : K(bookmark.start).pos().y + 'px',
				'white-space' : 'nowrap'
			});
			K(doc.body).append(div);
			if (_IE) {
				var rng = cmd.range.get(true);
				rng.moveToElementText(div[0]);
				rng.select();
				rng.execCommand('paste');
				e.preventDefault();
			} else {
				cmd.range.selectNodeContents(div[0]);
				cmd.select();
			}
			setTimeout(function() {
				movePastedData();
				pasting = false;
			}, 0);
		});
	});
	self.beforeGetHtml(function(html) {
		if (_IE && _V <= 8) {
			html = html.replace(/<div\s+[^>]*data-ke-input-tag="([^"]*)"[^>]*>([\s\S]*?)<\/div>/ig, function(full, tag) {
				return unescape(tag);
			});
			html = html.replace(/(<input)((?:\s+[^>]*)?>)/ig, function($0, $1, $2) {
				if (!/\s+type="[^"]+"/i.test($0)) {
					return $1 + ' type="text"' + $2;
				}
				return $0;
			});
		}
		return html.replace(/(<(?:noscript|noscript\s[^>]*)>)([\s\S]*?)(<\/noscript>)/ig, function($0, $1, $2, $3) {
			return $1 + _unescape($2).replace(/\s+/g, ' ') + $3;
		})
		.replace(/<img[^>]*class="?ke-(flash|rm|media)"?[^>]*>/ig, function(full) {
			var imgAttrs = _getAttrList(full),
				styles = _getCssList(imgAttrs.style || ''),
				attrs = _mediaAttrs(imgAttrs['data-ke-tag']);
			attrs.width = _undef(imgAttrs.width, _removeUnit(_undef(styles.width, '')));
			attrs.height = _undef(imgAttrs.height, _removeUnit(_undef(styles.height, '')));
			return _mediaEmbed(attrs);
		})
		.replace(/<img[^>]*class="?ke-anchor"?[^>]*>/ig, function(full) {
			var imgAttrs = _getAttrList(full);
			return '<a name="' + unescape(imgAttrs['data-ke-name']) + '"></a>';
		})
		.replace(/<div\s+[^>]*data-ke-script-attr="([^"]*)"[^>]*>([\s\S]*?)<\/div>/ig, function(full, attr, code) {
			return '<script' + unescape(attr) + '>' + unescape(code) + '</script>';
		})
		.replace(/<div\s+[^>]*data-ke-noscript-attr="([^"]*)"[^>]*>([\s\S]*?)<\/div>/ig, function(full, attr, code) {
			return '<noscript' + unescape(attr) + '>' + unescape(code) + '</noscript>';
		})
		.replace(/(<[^>]*)data-ke-src="([^"]*)"([^>]*>)/ig, function(full, start, src, end) {
			full = full.replace(/(\s+(?:href|src)=")[^"]*(")/i, function($0, $1, $2) {
				return $1 + _unescape(src) + $2;
			});
			full = full.replace(/\s+data-ke-src="[^"]*"/i, '');
			return full;
		})
		.replace(/(<[^>]+\s)data-ke-(on\w+="[^"]*"[^>]*>)/ig, function(full, start, end) {
			return start + end;
		});
	});
	self.beforeSetHtml(function(html) {
		if (_IE && _V <= 8) {
			html = html.replace(/<input[^>]*>|<(select|button)[^>]*>[\s\S]*?<\/\1>/ig, function(full) {
				var attrs = _getAttrList(full);
				var styles = _getCssList(attrs.style || '');
				if (styles.display == 'none') {
					return '<div class="ke-display-none" data-ke-input-tag="' + escape(full) + '"></div>';
				}
				return full;
			});
		}
		return html.replace(/<embed[^>]*type="([^"]+)"[^>]*>(?:<\/embed>)?/ig, function(full) {
			var attrs = _getAttrList(full);
			attrs.src = _undef(attrs.src, '');
			attrs.width = _undef(attrs.width, 0);
			attrs.height = _undef(attrs.height, 0);
			return _mediaImg(self.themesPath + 'common/blank.gif', attrs);
		})
		.replace(/<a[^>]*name="([^"]+)"[^>]*>(?:<\/a>)?/ig, function(full) {
			var attrs = _getAttrList(full);
			if (attrs.href !== undefined) {
				return full;
			}
			return '<img class="ke-anchor" src="' + self.themesPath + 'common/anchor.gif" data-ke-name="' + escape(attrs.name) + '" />';
		})
		.replace(/<script([^>]*)>([\s\S]*?)<\/script>/ig, function(full, attr, code) {
			return '<div class="ke-script" data-ke-script-attr="' + escape(attr) + '">' + escape(code) + '</div>';
		})
		.replace(/<noscript([^>]*)>([\s\S]*?)<\/noscript>/ig, function(full, attr, code) {
			return '<div class="ke-noscript" data-ke-noscript-attr="' + escape(attr) + '">' + escape(code) + '</div>';
		})
		.replace(/(<[^>]*)(href|src)="([^"]*)"([^>]*>)/ig, function(full, start, key, src, end) {
			if (full.match(/\sdata-ke-src="[^"]*"/i)) {
				return full;
			}
			full = start + key + '="' + src + '"' + ' data-ke-src="' + _escape(src) + '"' + end;
			return full;
		})
		.replace(/(<[^>]+\s)(on\w+="[^"]*"[^>]*>)/ig, function(full, start, end) {
			return start + 'data-ke-' + end;
		})
		.replace(/<table[^>]*\s+border="0"[^>]*>/ig, function(full) {
			if (full.indexOf('ke-zeroborder') >= 0) {
				return full;
			}
			return _addClassToTag(full, 'ke-zeroborder');
		});
	});
});
})(window);
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.lang({
	source : 'HTML代码',
	preview : '预览',
	undo : '后退(Ctrl+Z)',
	redo : '前进(Ctrl+Y)',
	cut : '剪切(Ctrl+X)',
	copy : '复制(Ctrl+C)',
	paste : '粘贴(Ctrl+V)',
	plainpaste : '粘贴为无格式文本',
	wordpaste : '从Word粘贴',
	selectall : '全选(Ctrl+A)',
	justifyleft : '左对齐',
	justifycenter : '居中',
	justifyright : '右对齐',
	justifyfull : '两端对齐',
	insertorderedlist : '编号',
	insertunorderedlist : '项目符号',
	indent : '增加缩进',
	outdent : '减少缩进',
	subscript : '下标',
	superscript : '上标',
	formatblock : '段落',
	fontname : '字体',
	fontsize : '文字大小',
	forecolor : '文字颜色',
	hilitecolor : '文字背景',
	bold : '粗体(Ctrl+B)',
	italic : '斜体(Ctrl+I)',
	underline : '下划线(Ctrl+U)',
	strikethrough : '删除线',
	removeformat : '删除格式',
	image : '图片',
	multiimage : '批量图片上传',
	flash : 'Flash',
	media : '视音频',
	table : '表格',
	tablecell : '单元格',
	hr : '插入横线',
	emoticons : '插入表情',
	link : '超级链接',
	unlink : '取消超级链接',
	fullscreen : '全屏显示',
	about : '关于',
	print : '打印(Ctrl+P)',
	filemanager : '文件空间',
	code : '插入程序代码',
	map : 'Google地图',
	baidumap : '百度地图',
	lineheight : '行距',
	clearhtml : '清理HTML代码',
	pagebreak : '插入分页符',
	quickformat : '一键排版',
	insertfile : '插入文件',
	template : '插入模板',
	anchor : '锚点',
	yes : '确定',
	no : '取消',
	close : '关闭',
	editImage : '图片属性',
	deleteImage : '删除图片',
	editFlash : 'Flash属性',
	deleteFlash : '删除Flash',
	editMedia : '视音频属性',
	deleteMedia : '删除视音频',
	editLink : '超级链接属性',
	deleteLink : '取消超级链接',
	editAnchor : '锚点属性',
	deleteAnchor : '删除锚点',
	tableprop : '表格属性',
	tablecellprop : '单元格属性',
	tableinsert : '插入表格',
	tabledelete : '删除表格',
	tablecolinsertleft : '左侧插入列',
	tablecolinsertright : '右侧插入列',
	tablerowinsertabove : '上方插入行',
	tablerowinsertbelow : '下方插入行',
	tablerowmerge : '向下合并单元格',
	tablecolmerge : '向右合并单元格',
	tablerowsplit : '拆分行',
	tablecolsplit : '拆分列',
	tablecoldelete : '删除列',
	tablerowdelete : '删除行',
	noColor : '无颜色',
	pleaseSelectFile : '请选择文件。',
	invalidImg : "请输入有效的URL地址。\n只允许jpg,gif,bmp,png格式。",
	invalidMedia : "请输入有效的URL地址。\n只允许swf,flv,mp3,wav,wma,wmv,mid,avi,mpg,asf,rm,rmvb格式。",
	invalidWidth : "宽度必须为数字。",
	invalidHeight : "高度必须为数字。",
	invalidBorder : "边框必须为数字。",
	invalidUrl : "请输入有效的URL地址。",
	invalidRows : '行数为必选项，只允许输入大于0的数字。',
	invalidCols : '列数为必选项，只允许输入大于0的数字。',
	invalidPadding : '边距必须为数字。',
	invalidSpacing : '间距必须为数字。',
	invalidJson : '服务器发生故障。',
	uploadSuccess : '上传成功。',
	cutError : '您的浏览器安全设置不允许使用剪切操作，请使用快捷键(Ctrl+X)来完成。',
	copyError : '您的浏览器安全设置不允许使用复制操作，请使用快捷键(Ctrl+C)来完成。',
	pasteError : '您的浏览器安全设置不允许使用粘贴操作，请使用快捷键(Ctrl+V)来完成。',
	ajaxLoading : '加载中，请稍候 ...',
	uploadLoading : '上传中，请稍候 ...',
	uploadError : '上传错误',
	'plainpaste.comment' : '请使用快捷键(Ctrl+V)把内容粘贴到下面的方框里。',
	'wordpaste.comment' : '请使用快捷键(Ctrl+V)把内容粘贴到下面的方框里。',
	'code.pleaseInput' : '请输入程序代码。',
	'link.url' : 'URL',
	'link.linkType' : '打开类型',
	'link.newWindow' : '新窗口',
	'link.selfWindow' : '当前窗口',
	'flash.url' : 'URL',
	'flash.width' : '宽度',
	'flash.height' : '高度',
	'flash.upload' : '上传',
	'flash.viewServer' : '文件空间',
	'media.url' : 'URL',
	'media.width' : '宽度',
	'media.height' : '高度',
	'media.autostart' : '自动播放',
	'media.upload' : '上传',
	'media.viewServer' : '文件空间',
	'image.remoteImage' : '网络图片',
	'image.localImage' : '本地上传',
	'image.remoteUrl' : '图片地址',
	'image.localUrl' : '上传文件',
	'image.size' : '图片大小',
	'image.width' : '宽',
	'image.height' : '高',
	'image.resetSize' : '重置大小',
	'image.align' : '对齐方式',
	'image.defaultAlign' : '默认方式',
	'image.leftAlign' : '左对齐',
	'image.rightAlign' : '右对齐',
	'image.imgTitle' : '图片说明',
	'image.upload' : '浏览...',
	'image.viewServer' : '图片空间',
	'multiimage.uploadDesc' : '允许用户同时上传<%=uploadLimit%>张图片，单张图片容量不超过<%=sizeLimit%>',
	'multiimage.startUpload' : '开始上传',
	'multiimage.clearAll' : '全部清空',
	'multiimage.insertAll' : '全部插入',
	'multiimage.queueLimitExceeded' : '文件数量超过限制。',
	'multiimage.fileExceedsSizeLimit' : '文件大小超过限制。',
	'multiimage.zeroByteFile' : '无法上传空文件。',
	'multiimage.invalidFiletype' : '文件类型不正确。',
	'multiimage.unknownError' : '发生异常，无法上传。',
	'multiimage.pending' : '等待上传',
	'multiimage.uploadError' : '上传失败',
	'filemanager.emptyFolder' : '空文件夹',
	'filemanager.moveup' : '移到上一级文件夹',
	'filemanager.viewType' : '显示方式：',
	'filemanager.viewImage' : '缩略图',
	'filemanager.listImage' : '详细信息',
	'filemanager.orderType' : '排序方式：',
	'filemanager.fileName' : '名称',
	'filemanager.fileSize' : '大小',
	'filemanager.fileType' : '类型',
	'insertfile.url' : 'URL',
	'insertfile.title' : '文件说明',
	'insertfile.upload' : '上传',
	'insertfile.viewServer' : '文件空间',
	'table.cells' : '单元格数',
	'table.rows' : '行数',
	'table.cols' : '列数',
	'table.size' : '大小',
	'table.width' : '宽度',
	'table.height' : '高度',
	'table.percent' : '%',
	'table.px' : 'px',
	'table.space' : '边距间距',
	'table.padding' : '边距',
	'table.spacing' : '间距',
	'table.align' : '对齐方式',
	'table.textAlign' : '水平对齐',
	'table.verticalAlign' : '垂直对齐',
	'table.alignDefault' : '默认',
	'table.alignLeft' : '左对齐',
	'table.alignCenter' : '居中',
	'table.alignRight' : '右对齐',
	'table.alignTop' : '顶部',
	'table.alignMiddle' : '中部',
	'table.alignBottom' : '底部',
	'table.alignBaseline' : '基线',
	'table.border' : '边框',
	'table.borderWidth' : '边框',
	'table.borderColor' : '颜色',
	'table.backgroundColor' : '背景颜色',
	'map.address' : '地址: ',
	'map.search' : '搜索',
	'baidumap.address' : '地址: ',
	'baidumap.search' : '搜索',
	'baidumap.insertDynamicMap' : '插入动态地图',
	'anchor.name' : '锚点名称',
	'formatblock.formatBlock' : {
		h1 : '标题 1',
		h2 : '标题 2',
		h3 : '标题 3',
		h4 : '标题 4',
		p : '正 文'
	},
	'fontname.fontName' : {
		'SimSun' : '宋体',
		'NSimSun' : '新宋体',
		'FangSong_GB2312' : '仿宋_GB2312',
		'KaiTi_GB2312' : '楷体_GB2312',
		'SimHei' : '黑体',
		'Microsoft YaHei' : '微软雅黑',
		'Arial' : 'Arial',
		'Arial Black' : 'Arial Black',
		'Times New Roman' : 'Times New Roman',
		'Courier New' : 'Courier New',
		'Tahoma' : 'Tahoma',
		'Verdana' : 'Verdana'
	},
	'lineheight.lineHeight' : [
		{'1' : '单倍行距'},
		{'1.5' : '1.5倍行距'},
		{'2' : '2倍行距'},
		{'2.5' : '2.5倍行距'},
		{'3' : '3倍行距'}
	],
	'template.selectTemplate' : '可选模板',
	'template.replaceContent' : '替换当前内容',
	'template.fileList' : {
		'1.html' : '图片和文字',
		'2.html' : '表格',
		'3.html' : '项目编号'
	}
}, 'zh_CN');
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('anchor', function(K) {
	var self = this, name = 'anchor', lang = self.lang(name + '.');
	self.plugin.anchor = {
		edit : function() {
			var html = ['<div style="padding:20px;">',
					'<div class="ke-dialog-row">',
					'<label for="keName">' + lang.name + '</label>',
					'<input class="ke-input-text" type="text" id="keName" name="name" value="" style="width:100px;" />',
					'</div>',
					'</div>'].join('');
			var dialog = self.createDialog({
				name : name,
				width : 300,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						self.insertHtml('<a name="' + nameBox.val() + '">').hideDialog().focus();
					}
				}
			});
			var div = dialog.div,
				nameBox = K('input[name="name"]', div);
			var img = self.plugin.getSelectedAnchor();
			if (img) {
				nameBox.val(unescape(img.attr('data-ke-name')));
			}
			nameBox[0].focus();
			nameBox[0].select();
		},
		'delete' : function() {
			self.plugin.getSelectedAnchor().remove();
		}
	};
	self.clickToolbar(name, self.plugin.anchor.edit);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/


KindEditor.plugin('baidumap', function(K) {
	var self = this, name = 'baidumap', lang = self.lang(name + '.');
	var mapWidth = K.undef(self.mapWidth, 558);
	var mapHeight = K.undef(self.mapHeight, 360);
	self.clickToolbar(name, function() {
		var html = ['<div style="padding:10px 20px;">',
			'<div class="ke-header">',
			'<div class="ke-left">',
			lang.address + ' <input id="kindeditor_plugin_map_address" name="address" class="ke-input-text" value="" style="width:200px;" /> ',
			'<span class="ke-button-common ke-button-outer">',
			'<input type="button" name="searchBtn" class="ke-button-common ke-button" value="' + lang.search + '" />',
			'</span>',
			'</div>',
			'<div class="ke-right">',
			'<input type="checkbox" id="keInsertDynamicMap" name="insertDynamicMap" value="1" /> <label for="keInsertDynamicMap">' + lang.insertDynamicMap + '</label>',
			'</div>',
			'<div class="ke-clearfix"></div>',
			'</div>',
			'<div class="ke-map" style="width:' + mapWidth + 'px;height:' + mapHeight + 'px;"></div>',
			'</div>'].join('');
		var dialog = self.createDialog({
			name : name,
			width : mapWidth + 42,
			title : self.lang(name),
			body : html,
			yesBtn : {
				name : self.lang('yes'),
				click : function(e) {
					var map = win.map;
					var centerObj = map.getCenter();
					var center = centerObj.lng + ',' + centerObj.lat;
					var zoom = map.getZoom();
					var url = [checkbox[0].checked ? self.pluginsPath + 'baidumap/index.html' : 'http://api.map.baidu.com/staticimage',
						'?center=' + encodeURIComponent(center),
						'&zoom=' + encodeURIComponent(zoom),
						'&width=' + mapWidth,
						'&height=' + mapHeight,
						'&markers=' + encodeURIComponent(center),
						'&markerStyles=' + encodeURIComponent('l,A')].join('');
					if (checkbox[0].checked) {
						self.insertHtml('<iframe src="' + url + '" frameborder="0" style="width:' + (mapWidth + 2) + 'px;height:' + (mapHeight + 2) + 'px;"></iframe>');
					} else {
						self.exec('insertimage', url);
					}
					self.hideDialog().focus();
				}
			},
			beforeRemove : function() {
				searchBtn.remove();
				if (doc) {
					doc.write('');
				}
				iframe.remove();
			}
		});
		var div = dialog.div,
			addressBox = K('[name="address"]', div),
			searchBtn = K('[name="searchBtn"]', div),
			checkbox = K('[name="insertDynamicMap"]', dialog.div),
			win, doc;
		var iframe = K('<iframe class="ke-textarea" frameborder="0" src="' + self.pluginsPath + 'baidumap/map.html" style="width:' + mapWidth + 'px;height:' + mapHeight + 'px;"></iframe>');
		function ready() {
			win = iframe[0].contentWindow;
			doc = K.iframeDoc(iframe);
		}
		iframe.bind('load', function() {
			iframe.unbind('load');
			if (K.IE) {
				ready();
			} else {
				setTimeout(ready, 0);
			}
		});
		K('.ke-map', div).replaceWith(iframe);
		searchBtn.click(function() {
			win.search(addressBox.val());
		});
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('clearhtml', function(K) {
	var self = this, name = 'clearhtml';
	self.clickToolbar(name, function() {
		self.focus();
		var html = self.html();
		html = html.replace(/(<script[^>]*>)([\s\S]*?)(<\/script>)/ig, '');
		html = html.replace(/(<style[^>]*>)([\s\S]*?)(<\/style>)/ig, '');
		html = K.formatHtml(html, {
			a : ['href', 'target'],
			embed : ['src', 'width', 'height', 'type', 'loop', 'autostart', 'quality', '.width', '.height', 'align', 'allowscriptaccess'],
			img : ['src', 'width', 'height', 'border', 'alt', 'title', '.width', '.height'],
			table : ['border'],
			'td,th' : ['rowspan', 'colspan'],
			'div,hr,br,tbody,tr,p,ol,ul,li,blockquote,h1,h2,h3,h4,h5,h6' : []
		});
		self.html(html);
		self.cmd.selection(true);
		self.addBookmark();
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/


KindEditor.plugin('code', function(K) {
	var self = this, name = 'code';
	self.clickToolbar(name, function() {
		var lang = self.lang(name + '.'),
			html = ['<div style="padding:10px 20px;">',
				'<div class="ke-dialog-row">',
				'<select class="ke-code-type">',
				'<option value="js">JavaScript</option>',
				'<option value="html">HTML</option>',
				'<option value="css">CSS</option>',
				'<option value="php">PHP</option>',
				'<option value="pl">Perl</option>',
				'<option value="py">Python</option>',
				'<option value="rb">Ruby</option>',
				'<option value="java">Java</option>',
				'<option value="vb">ASP/VB</option>',
				'<option value="cpp">C/C++</option>',
				'<option value="cs">C#</option>',
				'<option value="xml">XML</option>',
				'<option value="bsh">Shell</option>',
				'<option value="">Other</option>',
				'</select>',
				'</div>',
				'<textarea class="ke-textarea" style="width:408px;height:260px;"></textarea>',
				'</div>'].join(''),
			dialog = self.createDialog({
				name : name,
				width : 450,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var type = K('.ke-code-type', dialog.div).val(),
							code = textarea.val(),
							cls = type === '' ? '' :  ' lang-' + type,
							html = '<pre class="prettyprint' + cls + '">\n' + K.escape(code) + '</pre> ';
						if (K.trim(code) === '') {
							alert(lang.pleaseInput);
							textarea[0].focus();
							return;
						}
						self.insertHtml(html).hideDialog().focus();
					}
				}
			}),
			textarea = K('textarea', dialog.div);
		textarea[0].focus();
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('emoticons', function(K) {
	var self = this, name = 'emoticons',
		path = (self.emoticonsPath || self.pluginsPath + 'emoticons/images/'),
		allowPreview = self.allowPreviewEmoticons === undefined ? true : self.allowPreviewEmoticons,
		currentPageNum = 1;
	self.clickToolbar(name, function() {
		var rows = 5, cols = 9, total = 135, startNum = 0,
			cells = rows * cols, pages = Math.ceil(total / cells),
			colsHalf = Math.floor(cols / 2),
			wrapperDiv = K('<div class="ke-plugin-emoticons"></div>'),
			elements = [],
			menu = self.createMenu({
				name : name,
				beforeRemove : function() {
					removeEvent();
				}
			});
		menu.div.append(wrapperDiv);
		var previewDiv, previewImg;
		if (allowPreview) {
			previewDiv = K('<div class="ke-preview"></div>').css('right', 0);
			previewImg = K('<img class="ke-preview-img" src="' + path + startNum + '.gif" />');
			wrapperDiv.append(previewDiv);
			previewDiv.append(previewImg);
		}
		function bindCellEvent(cell, j, num) {
			if (previewDiv) {
				cell.mouseover(function() {
					if (j > colsHalf) {
						previewDiv.css('left', 0);
						previewDiv.css('right', '');
					} else {
						previewDiv.css('left', '');
						previewDiv.css('right', 0);
					}
					previewImg.attr('src', path + num + '.gif');
					K(this).addClass('ke-on');
				});
			} else {
				cell.mouseover(function() {
					K(this).addClass('ke-on');
				});
			}
			cell.mouseout(function() {
				K(this).removeClass('ke-on');
			});
			cell.click(function(e) {
				self.insertHtml('<img src="' + path + num + '.gif" border="0" alt="" />').hideMenu().focus();
				e.stop();
			});
		}
		function createEmoticonsTable(pageNum, parentDiv) {
			var table = document.createElement('table');
			parentDiv.append(table);
			if (previewDiv) {
				K(table).mouseover(function() {
					previewDiv.show('block');
				});
				K(table).mouseout(function() {
					previewDiv.hide();
				});
				elements.push(K(table));
			}
			table.className = 'ke-table';
			table.cellPadding = 0;
			table.cellSpacing = 0;
			table.border = 0;
			var num = (pageNum - 1) * cells + startNum;
			for (var i = 0; i < rows; i++) {
				var row = table.insertRow(i);
				for (var j = 0; j < cols; j++) {
					var cell = K(row.insertCell(j));
					cell.addClass('ke-cell');
					bindCellEvent(cell, j, num);
					var span = K('<span class="ke-img"></span>')
						.css('background-position', '-' + (24 * num) + 'px 0px')
						.css('background-image', 'url(' + path + 'static.gif)');
					cell.append(span);
					elements.push(cell);
					num++;
				}
			}
			return table;
		}
		var table = createEmoticonsTable(currentPageNum, wrapperDiv);
		function removeEvent() {
			K.each(elements, function() {
				this.unbind();
			});
		}
		var pageDiv;
		function bindPageEvent(el, pageNum) {
			el.click(function(e) {
				removeEvent();
				table.parentNode.removeChild(table);
				pageDiv.remove();
				table = createEmoticonsTable(pageNum, wrapperDiv);
				createPageTable(pageNum);
				currentPageNum = pageNum;
				e.stop();
			});
		}
		function createPageTable(currentPageNum) {
			pageDiv = K('<div class="ke-page"></div>');
			wrapperDiv.append(pageDiv);
			for (var pageNum = 1; pageNum <= pages; pageNum++) {
				if (currentPageNum !== pageNum) {
					var a = K('<a href="javascript:;">[' + pageNum + ']</a>');
					bindPageEvent(a, pageNum);
					pageDiv.append(a);
					elements.push(a);
				} else {
					pageDiv.append(K('@[' + pageNum + ']'));
				}
				pageDiv.append(K('@&nbsp;'));
			}
		}
		createPageTable(currentPageNum);
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('filemanager', function(K) {
	var self = this, name = 'filemanager',
		fileManagerJson = K.undef(self.fileManagerJson, self.basePath + 'php/file_manager_json.php'),
		imgPath = self.pluginsPath + name + '/images/',
		lang = self.lang(name + '.');
	function makeFileTitle(filename, filesize, datetime) {
		return filename + ' (' + Math.ceil(filesize / 1024) + 'KB, ' + datetime + ')';
	}
	function bindTitle(el, data) {
		if (data.is_dir) {
			el.attr('title', data.filename);
		} else {
			el.attr('title', makeFileTitle(data.filename, data.filesize, data.datetime));
		}
	}
	self.plugin.filemanagerDialog = function(options) {
		var width = K.undef(options.width, 650),
			height = K.undef(options.height, 510),
			dirName = K.undef(options.dirName, ''),
			viewType = K.undef(options.viewType, 'VIEW').toUpperCase(), 
			clickFn = options.clickFn;
		var html = [
			'<div style="padding:10px 20px;">',
			'<div class="ke-plugin-filemanager-header">',
			'<div class="ke-left">',
			'<img class="ke-inline-block" name="moveupImg" src="' + imgPath + 'go-up.gif" width="16" height="16" border="0" alt="" /> ',
			'<a class="ke-inline-block" name="moveupLink" href="javascript:;">' + lang.moveup + '</a>',
			'</div>',
			'<div class="ke-right">',
			lang.viewType + ' <select class="ke-inline-block" name="viewType">',
			'<option value="VIEW">' + lang.viewImage + '</option>',
			'<option value="LIST">' + lang.listImage + '</option>',
			'</select> ',
			lang.orderType + ' <select class="ke-inline-block" name="orderType">',
			'<option value="NAME">' + lang.fileName + '</option>',
			'<option value="SIZE">' + lang.fileSize + '</option>',
			'<option value="TYPE">' + lang.fileType + '</option>',
			'</select>',
			'</div>',
			'<div class="ke-clearfix"></div>',
			'</div>',
			'<div class="ke-plugin-filemanager-body"></div>',
			'</div>'
		].join('');
		var dialog = self.createDialog({
			name : name,
			width : width,
			height : height,
			title : self.lang(name),
			body : html
		}),
		div = dialog.div,
		bodyDiv = K('.ke-plugin-filemanager-body', div),
		moveupImg = K('[name="moveupImg"]', div),
		moveupLink = K('[name="moveupLink"]', div),
		viewServerBtn = K('[name="viewServer"]', div),
		viewTypeBox = K('[name="viewType"]', div),
		orderTypeBox = K('[name="orderType"]', div);
		function reloadPage(path, order, func) {
			var param = 'path=' + path + '&order=' + order + '&dir=' + dirName;
			dialog.showLoading(self.lang('ajaxLoading'));
			K.ajax(K.addParam(fileManagerJson, param + '&' + new Date().getTime()), function(data) {
				dialog.hideLoading();
				func(data);
			});
		}
		var elList = [];
		function bindEvent(el, result, data, createFunc) {
			var fileUrl = K.formatUrl(result.current_url + data.filename, 'absolute'),
				dirPath = encodeURIComponent(result.current_dir_path + data.filename + '/');
			if (data.is_dir) {
				el.click(function(e) {
					reloadPage(dirPath, orderTypeBox.val(), createFunc);
				});
			} else if (data.is_photo) {
				el.click(function(e) {
					clickFn.call(this, fileUrl, data.filename);
				});
			} else {
				el.click(function(e) {
					clickFn.call(this, fileUrl, data.filename);
				});
			}
			elList.push(el);
		}
		function createCommon(result, createFunc) {
			K.each(elList, function() {
				this.unbind();
			});
			moveupLink.unbind();
			viewTypeBox.unbind();
			orderTypeBox.unbind();
			if (result.current_dir_path) {
				moveupLink.click(function(e) {
					reloadPage(result.moveup_dir_path, orderTypeBox.val(), createFunc);
				});
			}
			function changeFunc() {
				if (viewTypeBox.val() == 'VIEW') {
					reloadPage(result.current_dir_path, orderTypeBox.val(), createView);
				} else {
					reloadPage(result.current_dir_path, orderTypeBox.val(), createList);
				}
			}
			viewTypeBox.change(changeFunc);
			orderTypeBox.change(changeFunc);
			bodyDiv.html('');
		}
		function createList(result) {
			createCommon(result, createList);
			var table = document.createElement('table');
			table.className = 'ke-table';
			table.cellPadding = 0;
			table.cellSpacing = 0;
			table.border = 0;
			bodyDiv.append(table);
			var fileList = result.file_list;
			for (var i = 0, len = fileList.length; i < len; i++) {
				var data = fileList[i], row = K(table.insertRow(i));
				row.mouseover(function(e) {
					K(this).addClass('ke-on');
				})
				.mouseout(function(e) {
					K(this).removeClass('ke-on');
				});
				var iconUrl = imgPath + (data.is_dir ? 'folder-16.gif' : 'file-16.gif'),
					img = K('<img src="' + iconUrl + '" width="16" height="16" alt="' + data.filename + '" align="absmiddle" />'),
					cell0 = K(row[0].insertCell(0)).addClass('ke-cell ke-name').append(img).append(document.createTextNode(' ' + data.filename));
				if (!data.is_dir || data.has_file) {
					row.css('cursor', 'pointer');
					cell0.attr('title', data.filename);
					bindEvent(cell0, result, data, createList);
				} else {
					cell0.attr('title', lang.emptyFolder);
				}
				K(row[0].insertCell(1)).addClass('ke-cell ke-size').html(data.is_dir ? '-' : Math.ceil(data.filesize / 1024) + 'KB');
				K(row[0].insertCell(2)).addClass('ke-cell ke-datetime').html(data.datetime);
			}
		}
		function createView(result) {
			createCommon(result, createView);
			var fileList = result.file_list;
			for (var i = 0, len = fileList.length; i < len; i++) {
				var data = fileList[i],
					div = K('<div class="ke-inline-block ke-item"></div>');
				bodyDiv.append(div);
				var photoDiv = K('<div class="ke-inline-block ke-photo"></div>')
					.mouseover(function(e) {
						K(this).addClass('ke-on');
					})
					.mouseout(function(e) {
						K(this).removeClass('ke-on');
					});
				div.append(photoDiv);
				var fileUrl = result.current_url + data.filename,
					iconUrl = data.is_dir ? imgPath + 'folder-64.gif' : (data.is_photo ? fileUrl : imgPath + 'file-64.gif');
				var img = K('<img src="' + iconUrl + '" width="80" height="80" alt="' + data.filename + '" />');
				if (!data.is_dir || data.has_file) {
					photoDiv.css('cursor', 'pointer');
					bindTitle(photoDiv, data);
					bindEvent(photoDiv, result, data, createView);
				} else {
					photoDiv.attr('title', lang.emptyFolder);
				}
				photoDiv.append(img);
				div.append('<div class="ke-name" title="' + data.filename + '">' + data.filename + '</div>');
			}
		}
		viewTypeBox.val(viewType);
		reloadPage('', orderTypeBox.val(), viewType == 'VIEW' ? createView : createList);
		return dialog;
	}

});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('flash', function(K) {
	var self = this, name = 'flash', lang = self.lang(name + '.'),
		allowFlashUpload = K.undef(self.allowFlashUpload, true),
		allowFileManager = K.undef(self.allowFileManager, false),
		formatUploadUrl = K.undef(self.formatUploadUrl, true),
		extraParams = K.undef(self.extraFileUploadParams, {}),
		filePostName = K.undef(self.filePostName, 'imgFile'),
		uploadJson = K.undef(self.uploadJson, self.basePath + 'php/upload_json.php');
	self.plugin.flash = {
		edit : function() {
			var html = [
				'<div style="padding:20px;">',
				'<div class="ke-dialog-row">',
				'<label for="keUrl" style="width:60px;">' + lang.url + '</label>',
				'<input class="ke-input-text" type="text" id="keUrl" name="url" value="" style="width:160px;" /> &nbsp;',
				'<input type="button" class="ke-upload-button" value="' + lang.upload + '" /> &nbsp;',
				'<span class="ke-button-common ke-button-outer">',
				'<input type="button" class="ke-button-common ke-button" name="viewServer" value="' + lang.viewServer + '" />',
				'</span>',
				'</div>',
				'<div class="ke-dialog-row">',
				'<label for="keWidth" style="width:60px;">' + lang.width + '</label>',
				'<input type="text" id="keWidth" class="ke-input-text ke-input-number" name="width" value="550" maxlength="4" /> ',
				'</div>',
				'<div class="ke-dialog-row">',
				'<label for="keHeight" style="width:60px;">' + lang.height + '</label>',
				'<input type="text" id="keHeight" class="ke-input-text ke-input-number" name="height" value="400" maxlength="4" /> ',
				'</div>',
				'</div>'
			].join('');
			var dialog = self.createDialog({
				name : name,
				width : 450,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var url = K.trim(urlBox.val()),
							width = widthBox.val(),
							height = heightBox.val();
						if (url == 'http://' || K.invalidUrl(url)) {
							alert(self.lang('invalidUrl'));
							urlBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(width)) {
							alert(self.lang('invalidWidth'));
							widthBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(height)) {
							alert(self.lang('invalidHeight'));
							heightBox[0].focus();
							return;
						}
						var html = K.mediaImg(self.themesPath + 'common/blank.gif', {
								src : url,
								type : K.mediaType('.swf'),
								width : width,
								height : height,
								quality : 'high'
							});
						self.insertHtml(html).hideDialog().focus();
					}
				}
			}),
			div = dialog.div,
			urlBox = K('[name="url"]', div),
			viewServerBtn = K('[name="viewServer"]', div),
			widthBox = K('[name="width"]', div),
			heightBox = K('[name="height"]', div);
			urlBox.val('http://');

			if (allowFlashUpload) {
				var uploadbutton = K.uploadbutton({
					button : K('.ke-upload-button', div)[0],
					fieldName : filePostName,
					extraParams : extraParams,
					url : K.addParam(uploadJson, 'dir=flash'),
					afterUpload : function(data) {
						dialog.hideLoading();
						if (data.error === 0) {
							var url = data.url;
							if (formatUploadUrl) {
								url = K.formatUrl(url, 'absolute');
							}
							urlBox.val(url);
							if (self.afterUpload) {
								self.afterUpload.call(self, url, data, name);
							}
							alert(self.lang('uploadSuccess'));
						} else {
							alert(data.message);
						}
					},
					afterError : function(html) {
						dialog.hideLoading();
						self.errorDialog(html);
					}
				});
				uploadbutton.fileBox.change(function(e) {
					dialog.showLoading(self.lang('uploadLoading'));
					uploadbutton.submit();
				});
			} else {
				K('.ke-upload-button', div).hide();
			}

			if (allowFileManager) {
				viewServerBtn.click(function(e) {
					self.loadPlugin('filemanager', function() {
						self.plugin.filemanagerDialog({
							viewType : 'LIST',
							dirName : 'flash',
							clickFn : function(url, title) {
								if (self.dialogs.length > 1) {
									K('[name="url"]', div).val(url);
									if (self.afterSelectFile) {
										self.afterSelectFile.call(self, url);
									}
									self.hideDialog();
								}
							}
						});
					});
				});
			} else {
				viewServerBtn.hide();
			}

			var img = self.plugin.getSelectedFlash();
			if (img) {
				var attrs = K.mediaAttrs(img.attr('data-ke-tag'));
				urlBox.val(attrs.src);
				widthBox.val(K.removeUnit(img.css('width')) || attrs.width || 0);
				heightBox.val(K.removeUnit(img.css('height')) || attrs.height || 0);
			}
			urlBox[0].focus();
			urlBox[0].select();
		},
		'delete' : function() {
			self.plugin.getSelectedFlash().remove();
			self.addBookmark();
		}
	};
	self.clickToolbar(name, self.plugin.flash.edit);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('image', function(K) {
	var self = this, name = 'image',
		allowImageUpload = K.undef(self.allowImageUpload, true),
		allowImageRemote = K.undef(self.allowImageRemote, true),
		formatUploadUrl = K.undef(self.formatUploadUrl, true),
		allowFileManager = K.undef(self.allowFileManager, false),
		uploadJson = K.undef(self.uploadJson, self.basePath + 'php/upload_json.php'),
		imageTabIndex = K.undef(self.imageTabIndex, 0),
		imgPath = self.pluginsPath + 'image/images/',
		extraParams = K.undef(self.extraFileUploadParams, {}),
		filePostName = K.undef(self.filePostName, 'imgFile'),
		fillDescAfterUploadImage = K.undef(self.fillDescAfterUploadImage, false),
		lang = self.lang(name + '.');

	self.plugin.imageDialog = function(options) {
		var imageUrl = options.imageUrl,
			imageWidth = K.undef(options.imageWidth, ''),
			imageHeight = K.undef(options.imageHeight, ''),
			imageTitle = K.undef(options.imageTitle, ''),
			imageAlign = K.undef(options.imageAlign, ''),
			showRemote = K.undef(options.showRemote, true),
			showLocal = K.undef(options.showLocal, true),
			tabIndex = K.undef(options.tabIndex, 0),
			clickFn = options.clickFn;
		var target = 'kindeditor_upload_iframe_' + new Date().getTime();
		var hiddenElements = [];
		for(var k in extraParams){
			hiddenElements.push('<input type="hidden" name="' + k + '" value="' + extraParams[k] + '" />');
		}
		var html = [
			'<div style="padding:20px;">',
			
			'<div class="tabs"></div>',
			
			'<div class="tab1" style="display:none;">',
			
			'<div class="ke-dialog-row">',
			'<label for="remoteUrl" style="width:60px;">' + lang.remoteUrl + '</label>',
			'<input type="text" id="remoteUrl" class="ke-input-text" name="url" value="" style="width:200px;" /> &nbsp;',
			'<span class="ke-button-common ke-button-outer">',
			'<input type="button" class="ke-button-common ke-button" name="viewServer" value="' + lang.viewServer + '" />',
			'</span>',
			'</div>',
			
			'<div class="ke-dialog-row">',
			'<label for="remoteWidth" style="width:60px;">' + lang.size + '</label>',
			lang.width + ' <input type="text" id="remoteWidth" class="ke-input-text ke-input-number" name="width" value="" maxlength="4" /> ',
			lang.height + ' <input type="text" class="ke-input-text ke-input-number" name="height" value="" maxlength="4" /> ',
			'<img class="ke-refresh-btn" src="static/kindEditor/image/images/refresh.png" width="16" height="16" alt="" style="cursor:pointer;" title="' + lang.resetSize + '" />',
			'</div>',
			
			'<div class="ke-dialog-row">',
			'<label style="width:60px;">' + lang.align + '</label>',
			'<input type="radio" name="align" class="ke-inline-block" value="" checked="checked" /> <img name="defaultImg" src="static/kindEditor/image/images/align_top.gif" width="23" height="25" alt="" />',
			' <input type="radio" name="align" class="ke-inline-block" value="left" /> <img name="leftImg" src="static/kindEditor/image/images/align_left.gif" width="23" height="25" alt="" />',
			' <input type="radio" name="align" class="ke-inline-block" value="right" /> <img name="rightImg" src="static/kindEditor/image/images/align_right.gif" width="23" height="25" alt="" />',
			'</div>',
			
			'<div class="ke-dialog-row">',
			'<label for="remoteTitle" style="width:60px;">' + lang.imgTitle + '</label>',
			'<input type="text" id="remoteTitle" class="ke-input-text" name="title" value="" style="width:200px;" />',
			'</div>',
			'</div>',
			
			
			'<div class="tab2" style="display:none;">',
			'<iframe name="' + target + '" style="display:none;"></iframe>',
			'<form class="ke-upload-area ke-form" method="post" enctype="multipart/form-data" target="' + target + '" action="' + K.addParam(uploadJson, 'dir=image') + '">',
			
			'<div class="ke-dialog-row">',
			hiddenElements.join(''),
			'<label style="width:60px;">' + lang.localUrl + '</label>',
			'<input type="text" name="localUrl" class="ke-input-text" tabindex="-1" style="width:200px;" readonly="true" /> &nbsp;',
			'<input type="button" class="ke-upload-button" value="' + lang.upload + '" />',
			'</div>',
			'</form>',
			'</div>',
			
			'</div>'
		].join('');
		var dialogWidth = showLocal || allowFileManager ? 450 : 400,
			dialogHeight = showLocal && showRemote ? 300 : 250;
		var dialog = self.createDialog({
			name : name,
			width : dialogWidth,
			height : dialogHeight,
			title : self.lang(name),
			body : html,
			yesBtn : {
				name : self.lang('yes'),
				click : function(e) {
					if (dialog.isLoading) {
						return;
					}
					if (showLocal && showRemote && tabs && tabs.selectedIndex === 1 || !showRemote) {
						if (uploadbutton.fileBox.val() == '') {
							alert(self.lang('pleaseSelectFile'));
							return;
						}
						dialog.showLoading(self.lang('uploadLoading'));
						uploadbutton.submit();
						localUrlBox.val('');
						return;
					}
					var url = K.trim(urlBox.val()),
						width = widthBox.val(),
						height = heightBox.val(),
						title = titleBox.val(),
						align = '';
					alignBox.each(function() {
						if (this.checked) {
							align = this.value;
							return false;
						}
					});
					if (url == 'http://' || K.invalidUrl(url)) {
						alert(self.lang('invalidUrl'));
						urlBox[0].focus();
						return;
					}
					if (!/^\d*$/.test(width)) {
						alert(self.lang('invalidWidth'));
						widthBox[0].focus();
						return;
					}
					if (!/^\d*$/.test(height)) {
						alert(self.lang('invalidHeight'));
						heightBox[0].focus();
						return;
					}
					clickFn.call(self, url, title, width, height, 0, align);
				}
			},
			beforeRemove : function() {
				viewServerBtn.unbind();
				widthBox.unbind();
				heightBox.unbind();
				refreshBtn.unbind();
			}
		}),
		div = dialog.div;

		var urlBox = K('[name="url"]', div),
			localUrlBox = K('[name="localUrl"]', div),
			viewServerBtn = K('[name="viewServer"]', div),
			widthBox = K('.tab1 [name="width"]', div),
			heightBox = K('.tab1 [name="height"]', div),
			refreshBtn = K('.ke-refresh-btn', div),
			titleBox = K('.tab1 [name="title"]', div),
			alignBox = K('.tab1 [name="align"]', div);

		var tabs;
		if (showRemote && showLocal) {
			tabs = K.tabs({
				src : K('.tabs', div),
				afterSelect : function(i) {}
			});
			tabs.add({
				title : lang.remoteImage,
				panel : K('.tab1', div)
			});
			tabs.add({
				title : lang.localImage,
				panel : K('.tab2', div)
			});
			tabs.select(tabIndex);
		} else if (showRemote) {
			K('.tab1', div).show();
		} else if (showLocal) {
			K('.tab2', div).show();
		}

		var uploadbutton = K.uploadbutton({
			button : K('.ke-upload-button', div)[0],
			fieldName : filePostName,
			form : K('.ke-form', div),
			target : target,
			width: 60,
			afterUpload : function(data) {
				dialog.hideLoading();
				if (data.error === 0) {
					var url = data.url;
					if (formatUploadUrl) {
						url = K.formatUrl(url, 'absolute');
					}
					if (self.afterUpload) {
						self.afterUpload.call(self, url, data, name);
					}
					if (!fillDescAfterUploadImage) {
						clickFn.call(self, url, data.title, data.width, data.height, data.border, data.align);
					} else {
						K(".ke-dialog-row #remoteUrl", div).val(url);
						K(".ke-tabs-li", div)[0].click();
						K(".ke-refresh-btn", div).click();
					}
				} else {
					alert(data.message);
				}
			},
			afterError : function(html) {
				dialog.hideLoading();
				self.errorDialog(html);
			}
		});
		uploadbutton.fileBox.change(function(e) {
			localUrlBox.val(uploadbutton.fileBox.val());
		});
		if (allowFileManager) {
			viewServerBtn.click(function(e) {
				self.loadPlugin('filemanager', function() {
					self.plugin.filemanagerDialog({
						viewType : 'VIEW',
						dirName : 'image',
						clickFn : function(url, title) {
							if (self.dialogs.length > 1) {
								K('[name="url"]', div).val(url);
								if (self.afterSelectFile) {
									self.afterSelectFile.call(self, url);
								}
								self.hideDialog();
							}
						}
					});
				});
			});
		} else {
			viewServerBtn.hide();
		}
		var originalWidth = 0, originalHeight = 0;
		function setSize(width, height) {
			widthBox.val(width);
			heightBox.val(height);
			originalWidth = width;
			originalHeight = height;
		}
		refreshBtn.click(function(e) {
			var tempImg = K('<img src="' + urlBox.val() + '" />', document).css({
				position : 'absolute',
				visibility : 'hidden',
				top : 0,
				left : '-1000px'
			});
			tempImg.bind('load', function() {
				setSize(tempImg.width(), tempImg.height());
				tempImg.remove();
			});
			K(document.body).append(tempImg);
		});
		widthBox.change(function(e) {
			if (originalWidth > 0) {
				heightBox.val(Math.round(originalHeight / originalWidth * parseInt(this.value, 10)));
			}
		});
		heightBox.change(function(e) {
			if (originalHeight > 0) {
				widthBox.val(Math.round(originalWidth / originalHeight * parseInt(this.value, 10)));
			}
		});
		urlBox.val(options.imageUrl);
		setSize(options.imageWidth, options.imageHeight);
		titleBox.val(options.imageTitle);
		alignBox.each(function() {
			if (this.value === options.imageAlign) {
				this.checked = true;
				return false;
			}
		});
		if (showRemote && tabIndex === 0) {
			urlBox[0].focus();
			urlBox[0].select();
		}
		return dialog;
	};
	self.plugin.image = {
		edit : function() {
			var img = self.plugin.getSelectedImage();
			self.plugin.imageDialog({
				imageUrl : img ? img.attr('data-ke-src') : 'http://',
				imageWidth : img ? img.width() : '',
				imageHeight : img ? img.height() : '',
				imageTitle : img ? img.attr('title') : '',
				imageAlign : img ? img.attr('align') : '',
				showRemote : allowImageRemote,
				showLocal : allowImageUpload,
				tabIndex: img ? 0 : imageTabIndex,
				clickFn : function(url, title, width, height, border, align) {
					self.exec('insertimage', url, title, width, height, border, align);
					setTimeout(function() {
						self.hideDialog().focus();
					}, 0);
				}
			});
		},
		'delete' : function() {
			var target = self.plugin.getSelectedImage();
			if (target.parent().name == 'a') {
				target = target.parent();
			}
			target.remove();
			self.addBookmark();
		}
	};
	self.clickToolbar(name, self.plugin.image.edit);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('insertfile', function(K) {
	var self = this, name = 'insertfile',
		allowFileUpload = K.undef(self.allowFileUpload, true),
		allowFileManager = K.undef(self.allowFileManager, false),
		formatUploadUrl = K.undef(self.formatUploadUrl, true),
		uploadJson = K.undef(self.uploadJson, self.basePath + 'php/upload_json.php'),
		extraParams = K.undef(self.extraFileUploadParams, {}),
		filePostName = K.undef(self.filePostName, 'imgFile'),
		lang = self.lang(name + '.');
	self.plugin.fileDialog = function(options) {
		var fileUrl = K.undef(options.fileUrl, 'http://'),
			fileTitle = K.undef(options.fileTitle, ''),
			clickFn = options.clickFn;
		var html = [
			'<div style="padding:20px;">',
			'<div class="ke-dialog-row">',
			'<label for="keUrl" style="width:60px;">' + lang.url + '</label>',
			'<input type="text" id="keUrl" name="url" class="ke-input-text" style="width:160px;" /> &nbsp;',
			'<input type="button" class="ke-upload-button" value="' + lang.upload + '" /> &nbsp;',
			'<span class="ke-button-common ke-button-outer">',
			'<input type="button" class="ke-button-common ke-button" name="viewServer" value="' + lang.viewServer + '" />',
			'</span>',
			'</div>',
			'<div class="ke-dialog-row">',
			'<label for="keTitle" style="width:60px;">' + lang.title + '</label>',
			'<input type="text" id="keTitle" class="ke-input-text" name="title" value="" style="width:160px;" /></div>',
			'</div>',
			'</form>',
			'</div>'
			].join('');
		var dialog = self.createDialog({
			name : name,
			width : 450,
			title : self.lang(name),
			body : html,
			yesBtn : {
				name : self.lang('yes'),
				click : function(e) {
					var url = K.trim(urlBox.val()),
						title = titleBox.val();
					if (url == 'http://' || K.invalidUrl(url)) {
						alert(self.lang('invalidUrl'));
						urlBox[0].focus();
						return;
					}
					if (K.trim(title) === '') {
						title = url;
					}
					clickFn.call(self, url, title);
				}
			}
		}),
		div = dialog.div;

		var urlBox = K('[name="url"]', div),
			viewServerBtn = K('[name="viewServer"]', div),
			titleBox = K('[name="title"]', div);

		if (allowFileUpload) {
			var uploadbutton = K.uploadbutton({
				button : K('.ke-upload-button', div)[0],
				fieldName : filePostName,
				url : K.addParam(uploadJson, 'dir=file'),
				extraParams : extraParams,
				afterUpload : function(data) {
					dialog.hideLoading();
					if (data.error === 0) {
						var url = data.url;
						if (formatUploadUrl) {
							url = K.formatUrl(url, 'absolute');
						}
						urlBox.val(url);
						if (self.afterUpload) {
							self.afterUpload.call(self, url, data, name);
						}
						alert(self.lang('uploadSuccess'));
					} else {
						alert(data.message);
					}
				},
				afterError : function(html) {
					dialog.hideLoading();
					self.errorDialog(html);
				}
			});
			uploadbutton.fileBox.change(function(e) {
				dialog.showLoading(self.lang('uploadLoading'));
				uploadbutton.submit();
			});
		} else {
			K('.ke-upload-button', div).hide();
		}
		if (allowFileManager) {
			viewServerBtn.click(function(e) {
				self.loadPlugin('filemanager', function() {
					self.plugin.filemanagerDialog({
						viewType : 'LIST',
						dirName : 'file',
						clickFn : function(url, title) {
							if (self.dialogs.length > 1) {
								K('[name="url"]', div).val(url);
								if (self.afterSelectFile) {
									self.afterSelectFile.call(self, url);
								}
								self.hideDialog();
							}
						}
					});
				});
			});
		} else {
			viewServerBtn.hide();
		}
		urlBox.val(fileUrl);
		titleBox.val(fileTitle);
		urlBox[0].focus();
		urlBox[0].select();
	};
	self.clickToolbar(name, function() {
		self.plugin.fileDialog({
			clickFn : function(url, title) {
				var html = '<a class="ke-insertfile" href="' + url + '" data-ke-src="' + url + '" target="_blank">' + title + '</a>';
				self.insertHtml(html).hideDialog().focus();
			}
		});
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('lineheight', function(K) {
	var self = this, name = 'lineheight', lang = self.lang(name + '.');
	self.clickToolbar(name, function() {
		var curVal = '', commonNode = self.cmd.commonNode({'*' : '.line-height'});
		if (commonNode) {
			curVal = commonNode.css('line-height');
		}
		var menu = self.createMenu({
			name : name,
			width : 150
		});
		K.each(lang.lineHeight, function(i, row) {
			K.each(row, function(key, val) {
				menu.addItem({
					title : val,
					checked : curVal === key,
					click : function() {
						self.cmd.toggle('<span style="line-height:' + key + ';"></span>', {
							span : '.line-height=' + key
						});
						self.updateState();
						self.addBookmark();
						self.hideMenu();
					}
				});
			});
		});
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('link', function(K) {
	var self = this, name = 'link';
	self.plugin.link = {
		edit : function() {
			var lang = self.lang(name + '.'),
				html = '<div style="padding:20px;">' +
					'<div class="ke-dialog-row">' +
					'<label for="keUrl" style="width:60px;">' + lang.url + '</label>' +
					'<input class="ke-input-text" type="text" id="keUrl" name="url" value="" style="width:260px;" /></div>' +
					'<div class="ke-dialog-row"">' +
					'<label for="keType" style="width:60px;">' + lang.linkType + '</label>' +
					'<select id="keType" name="type"></select>' +
					'</div>' +
					'</div>',
				dialog = self.createDialog({
					name : name,
					width : 450,
					title : self.lang(name),
					body : html,
					yesBtn : {
						name : self.lang('yes'),
						click : function(e) {
							var url = K.trim(urlBox.val());
							if (url == 'http://' || K.invalidUrl(url)) {
								alert(self.lang('invalidUrl'));
								urlBox[0].focus();
								return;
							}
							self.exec('createlink', url, typeBox.val()).hideDialog().focus();
						}
					}
				}),
				div = dialog.div,
				urlBox = K('input[name="url"]', div),
				typeBox = K('select[name="type"]', div);
			urlBox.val('http://');
			typeBox[0].options[0] = new Option(lang.newWindow, '_blank');
			typeBox[0].options[1] = new Option(lang.selfWindow, '');
			self.cmd.selection();
			var a = self.plugin.getSelectedLink();
			if (a) {
				self.cmd.range.selectNode(a[0]);
				self.cmd.select();
				urlBox.val(a.attr('data-ke-src'));
				typeBox.val(a.attr('target'));
			}
			urlBox[0].focus();
			urlBox[0].select();
		},
		'delete' : function() {
			self.exec('unlink', null);
		}
	};
	self.clickToolbar(name, self.plugin.link.edit);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/


KindEditor.plugin('map', function(K) {
	var self = this, name = 'map', lang = self.lang(name + '.');
	self.clickToolbar(name, function() {
		var html = ['<div style="padding:10px 20px;">',
			'<div class="ke-dialog-row">',
			lang.address + ' <input id="kindeditor_plugin_map_address" name="address" class="ke-input-text" value="" style="width:200px;" /> ',
			'<span class="ke-button-common ke-button-outer">',
			'<input type="button" name="searchBtn" class="ke-button-common ke-button" value="' + lang.search + '" />',
			'</span>',
			'</div>',
			'<div class="ke-map" style="width:558px;height:360px;"></div>',
			'</div>'].join('');
		var dialog = self.createDialog({
			name : name,
			width : 600,
			title : self.lang(name),
			body : html,
			yesBtn : {
				name : self.lang('yes'),
				click : function(e) {
					var geocoder = win.geocoder,
						map = win.map,
						center = map.getCenter().lat() + ',' + map.getCenter().lng(),
						zoom = map.getZoom(),
						maptype = map.getMapTypeId(),
						url = 'http://maps.googleapis.com/maps/api/staticmap';
						url += '?center=' + encodeURIComponent(center);
						url += '&zoom=' + encodeURIComponent(zoom);
						url += '&size=558x360';
						url += '&maptype=' + encodeURIComponent(maptype);
						url += '&markers=' + encodeURIComponent(center);
						url += '&language=' + self.langType;
						url += '&sensor=false';
					self.exec('insertimage', url).hideDialog().focus();
				}
			},
			beforeRemove : function() {
				searchBtn.remove();
				if (doc) {
					doc.write('');
				}
				iframe.remove();
			}
		});
		var div = dialog.div,
			addressBox = K('[name="address"]', div),
			searchBtn = K('[name="searchBtn"]', div),
			win, doc;
		var iframeHtml = ['<!doctype html><html><head>',
			'<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />',
			'<style>',
			'	html { height: 100% }',
			'	body { height: 100%; margin: 0; padding: 0; background-color: #FFF }',
			'	#map_canvas { height: 100% }',
			'</style>',
			'<script src="http://maps.googleapis.com/maps/api/js?sensor=false&language=' + self.langType + '"></script>',
			'<script>',
			'var map, geocoder;',
			'function initialize() {',
			'	var latlng = new google.maps.LatLng(31.230393, 121.473704);',
			'	var options = {',
			'		zoom: 11,',
			'		center: latlng,',
			'		disableDefaultUI: true,',
			'		panControl: true,',
			'		zoomControl: true,',
			'		mapTypeControl: true,',
			'		scaleControl: true,',
			'		streetViewControl: false,',
			'		overviewMapControl: true,',
			'		mapTypeId: google.maps.MapTypeId.ROADMAP',
			'	};',
			'	map = new google.maps.Map(document.getElementById("map_canvas"), options);',
			'	geocoder = new google.maps.Geocoder();',
			'	geocoder.geocode({latLng: latlng}, function(results, status) {',
			'		if (status == google.maps.GeocoderStatus.OK) {',
			'			if (results[3]) {',
			'				parent.document.getElementById("kindeditor_plugin_map_address").value = results[3].formatted_address;',
			'			}',
			'		}',
			'	});',
			'}',
			'function search(address) {',
			'	if (!map) return;',
			'	geocoder.geocode({address : address}, function(results, status) {',
			'		if (status == google.maps.GeocoderStatus.OK) {',
			'			map.setZoom(11);',
			'			map.setCenter(results[0].geometry.location);',
			'			var marker = new google.maps.Marker({',
			'				map: map,',
			'				position: results[0].geometry.location',
			'			});',
			'		} else {',
			'			alert("Invalid address: " + address);',
			'		}',
			'	});',
			'}',
			'</script>',
			'</head>',
			'<body onload="initialize();">',
			'<div id="map_canvas" style="width:100%; height:100%"></div>',
			'</body></html>'].join('\n');
		
		var iframe = K('<iframe class="ke-textarea" frameborder="0" src="' + self.pluginsPath + 'map/map.html" style="width:558px;height:360px;"></iframe>');
		function ready() {
			win = iframe[0].contentWindow;
			doc = K.iframeDoc(iframe);

		}
		iframe.bind('load', function() {
			iframe.unbind('load');
			if (K.IE) {
				ready();
			} else {
				setTimeout(ready, 0);
			}
		});
		K('.ke-map', div).replaceWith(iframe);
		
		searchBtn.click(function() {
			win.search(addressBox.val());
		});
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('media', function(K) {
	var self = this, name = 'media', lang = self.lang(name + '.'),
		allowMediaUpload = K.undef(self.allowMediaUpload, true),
		allowFileManager = K.undef(self.allowFileManager, false),
		formatUploadUrl = K.undef(self.formatUploadUrl, true),
		extraParams = K.undef(self.extraFileUploadParams, {}),
		filePostName = K.undef(self.filePostName, 'imgFile'),
		uploadJson = K.undef(self.uploadJson, self.basePath + 'php/upload_json.php');
	self.plugin.media = {
		edit : function() {
			var html = [
				'<div style="padding:20px;">',
				'<div class="ke-dialog-row">',
				'<label for="keUrl" style="width:60px;">' + lang.url + '</label>',
				'<input class="ke-input-text" type="text" id="keUrl" name="url" value="" style="width:160px;" /> &nbsp;',
				'<input type="button" class="ke-upload-button" value="' + lang.upload + '" /> &nbsp;',
				'<span class="ke-button-common ke-button-outer">',
				'<input type="button" class="ke-button-common ke-button" name="viewServer" value="' + lang.viewServer + '" />',
				'</span>',
				'</div>',
				'<div class="ke-dialog-row">',
				'<label for="keWidth" style="width:60px;">' + lang.width + '</label>',
				'<input type="text" id="keWidth" class="ke-input-text ke-input-number" name="width" value="550" maxlength="4" />',
				'</div>',
				'<div class="ke-dialog-row">',
				'<label for="keHeight" style="width:60px;">' + lang.height + '</label>',
				'<input type="text" id="keHeight" class="ke-input-text ke-input-number" name="height" value="400" maxlength="4" />',
				'</div>',
				'<div class="ke-dialog-row">',
				'<label for="keAutostart">' + lang.autostart + '</label>',
				'<input type="checkbox" id="keAutostart" name="autostart" value="" /> ',
				'</div>',
				'</div>'
			].join('');
			var dialog = self.createDialog({
				name : name,
				width : 450,
				height : 230,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var url = K.trim(urlBox.val()),
							width = widthBox.val(),
							height = heightBox.val();
						if (url == 'http://' || K.invalidUrl(url)) {
							alert(self.lang('invalidUrl'));
							urlBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(width)) {
							alert(self.lang('invalidWidth'));
							widthBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(height)) {
							alert(self.lang('invalidHeight'));
							heightBox[0].focus();
							return;
						}
						var html = K.mediaImg(self.themesPath + 'common/blank.gif', {
								src : url,
								type : K.mediaType(url),
								width : width,
								height : height,
								autostart : autostartBox[0].checked ? 'true' : 'false',
								loop : 'true'
							});
						self.insertHtml(html).hideDialog().focus();
					}
				}
			}),
			div = dialog.div,
			urlBox = K('[name="url"]', div),
			viewServerBtn = K('[name="viewServer"]', div),
			widthBox = K('[name="width"]', div),
			heightBox = K('[name="height"]', div),
			autostartBox = K('[name="autostart"]', div);
			urlBox.val('http://');

			if (allowMediaUpload) {
				var uploadbutton = K.uploadbutton({
					button : K('.ke-upload-button', div)[0],
					fieldName : filePostName,
					extraParams : extraParams,
					url : K.addParam(uploadJson, 'dir=media'),
					afterUpload : function(data) {
						dialog.hideLoading();
						if (data.error === 0) {
							var url = data.url;
							if (formatUploadUrl) {
								url = K.formatUrl(url, 'absolute');
							}
							urlBox.val(url);
							if (self.afterUpload) {
								self.afterUpload.call(self, url, data, name);
							}
							alert(self.lang('uploadSuccess'));
						} else {
							alert(data.message);
						}
					},
					afterError : function(html) {
						dialog.hideLoading();
						self.errorDialog(html);
					}
				});
				uploadbutton.fileBox.change(function(e) {
					dialog.showLoading(self.lang('uploadLoading'));
					uploadbutton.submit();
				});
			} else {
				K('.ke-upload-button', div).hide();
			}

			if (allowFileManager) {
				viewServerBtn.click(function(e) {
					self.loadPlugin('filemanager', function() {
						self.plugin.filemanagerDialog({
							viewType : 'LIST',
							dirName : 'media',
							clickFn : function(url, title) {
								if (self.dialogs.length > 1) {
									K('[name="url"]', div).val(url);
									if (self.afterSelectFile) {
										self.afterSelectFile.call(self, url);
									}
									self.hideDialog();
								}
							}
						});
					});
				});
			} else {
				viewServerBtn.hide();
			}

			var img = self.plugin.getSelectedMedia();
			if (img) {
				var attrs = K.mediaAttrs(img.attr('data-ke-tag'));
				urlBox.val(attrs.src);
				widthBox.val(K.removeUnit(img.css('width')) || attrs.width || 0);
				heightBox.val(K.removeUnit(img.css('height')) || attrs.height || 0);
				autostartBox[0].checked = (attrs.autostart === 'true');
			}
			urlBox[0].focus();
			urlBox[0].select();
		},
		'delete' : function() {
			self.plugin.getSelectedMedia().remove();
			self.addBookmark();
		}
	};
	self.clickToolbar(name, self.plugin.media.edit);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/


(function(K) {

function KSWFUpload(options) {
	this.init(options);
}
K.extend(KSWFUpload, {
	init : function(options) {
		var self = this;
		options.afterError = options.afterError || function(str) {
			alert(str);
		};
		self.options = options;
		self.progressbars = {};
		self.div = K(options.container).html([
			'<div class="ke-swfupload">',
			'<div class="ke-swfupload-top">',
			'<div class="ke-inline-block ke-swfupload-button">',
			'<input type="button" value="Browse" />',
			'</div>',
			'<div class="ke-inline-block ke-swfupload-desc">' + options.uploadDesc + '</div>',
			'<span class="ke-button-common ke-button-outer ke-swfupload-startupload">',
			'<input type="button" class="ke-button-common ke-button" value="' + options.startButtonValue + '" />',
			'</span>',
			'</div>',
			'<div class="ke-swfupload-body"></div>',
			'</div>'
		].join(''));
		self.bodyDiv = K('.ke-swfupload-body', self.div);

		function showError(itemDiv, msg) {
			K('.ke-status > div', itemDiv).hide();
			K('.ke-message', itemDiv).addClass('ke-error').show().html(K.escape(msg));
		}

		var settings = {
			debug : false,
			upload_url : options.uploadUrl,
			flash_url : options.flashUrl,
			file_post_name : options.filePostName,
			button_placeholder : K('.ke-swfupload-button > input', self.div)[0],
			button_image_url: options.buttonImageUrl,
			button_width: options.buttonWidth,
			button_height: options.buttonHeight,
			button_cursor : SWFUpload.CURSOR.HAND,
			file_types : options.fileTypes,
			file_types_description : options.fileTypesDesc,
			file_upload_limit : options.fileUploadLimit,
			file_size_limit : options.fileSizeLimit,
			post_params : options.postParams,
			file_queued_handler : function(file) {
				file.url = self.options.fileIconUrl;
				self.appendFile(file);
			},
			file_queue_error_handler : function(file, errorCode, message) {
				var errorName = '';
				switch (errorCode) {
					case SWFUpload.QUEUE_ERROR.QUEUE_LIMIT_EXCEEDED:
						errorName = options.queueLimitExceeded;
						break;
					case SWFUpload.QUEUE_ERROR.FILE_EXCEEDS_SIZE_LIMIT:
						errorName = options.fileExceedsSizeLimit;
						break;
					case SWFUpload.QUEUE_ERROR.ZERO_BYTE_FILE:
						errorName = options.zeroByteFile;
						break;
					case SWFUpload.QUEUE_ERROR.INVALID_FILETYPE:
						errorName = options.invalidFiletype;
						break;
					default:
						errorName = options.unknownError;
						break;
				}
				K.DEBUG && alert(errorName);
			},
			upload_start_handler : function(file) {
				var self = this;
				var itemDiv = K('div[data-id="' + file.id + '"]', self.bodyDiv);
				K('.ke-status > div', itemDiv).hide();
				K('.ke-progressbar', itemDiv).show();
			},
			upload_progress_handler : function(file, bytesLoaded, bytesTotal) {
				var percent = Math.round(bytesLoaded * 100 / bytesTotal);
				var progressbar = self.progressbars[file.id];
				progressbar.bar.css('width', Math.round(percent * 80 / 100) + 'px');
				progressbar.percent.html(percent + '%');
			},
			upload_error_handler : function(file, errorCode, message) {
				if (file && file.filestatus == SWFUpload.FILE_STATUS.ERROR) {
					var itemDiv = K('div[data-id="' + file.id + '"]', self.bodyDiv).eq(0);
					showError(itemDiv, self.options.errorMessage);
				}
			},
			upload_success_handler : function(file, serverData) {
				var itemDiv = K('div[data-id="' + file.id + '"]', self.bodyDiv).eq(0);
				var data = {};
				try {
					data = K.json(serverData);
				} catch (e) {
					self.options.afterError.call(this, '<!doctype html><html>' + serverData + '</html>');
				}
				if (data.error !== 0) {
					showError(itemDiv, K.DEBUG ? data.message : self.options.errorMessage);
					return;
				}
				file.url = data.url;
				K('.ke-img', itemDiv).attr('src', file.url).attr('data-status', file.filestatus).data('data', data);
				K('.ke-status > div', itemDiv).hide();
			}
		};
		self.swfu = new SWFUpload(settings);

		K('.ke-swfupload-startupload input', self.div).click(function() {
			self.swfu.startUpload();
		});
	},
	getUrlList : function() {
		var list = [];
		K('.ke-img', self.bodyDiv).each(function() {
			var img = K(this);
			var status = img.attr('data-status');
			if (status == SWFUpload.FILE_STATUS.COMPLETE) {
				list.push(img.data('data'));
			}
		});
		return list;
	},
	removeFile : function(fileId) {
		var self = this;
		self.swfu.cancelUpload(fileId);
		var itemDiv = K('div[data-id="' + fileId + '"]', self.bodyDiv);
		K('.ke-photo', itemDiv).unbind();
		K('.ke-delete', itemDiv).unbind();
		itemDiv.remove();
	},
	removeFiles : function() {
		var self = this;
		K('.ke-item', self.bodyDiv).each(function() {
			self.removeFile(K(this).attr('data-id'));
		});
	},
	appendFile : function(file) {
		var self = this;
		var itemDiv = K('<div class="ke-inline-block ke-item" data-id="' + file.id + '"></div>');
		self.bodyDiv.append(itemDiv);
		var photoDiv = K('<div class="ke-inline-block ke-photo"></div>')
			.mouseover(function(e) {
				K(this).addClass('ke-on');
			})
			.mouseout(function(e) {
				K(this).removeClass('ke-on');
			});
		itemDiv.append(photoDiv);

		var img = K('<img src="' + file.url + '" class="ke-img" data-status="' + file.filestatus + '" width="80" height="80" alt="' + file.name + '" />');
		photoDiv.append(img);
		K('<span class="ke-delete"></span>').appendTo(photoDiv).click(function() {
			self.removeFile(file.id);
		});
		var statusDiv = K('<div class="ke-status"></div>').appendTo(photoDiv);
		K(['<div class="ke-progressbar">',
			'<div class="ke-progressbar-bar"><div class="ke-progressbar-bar-inner"></div></div>',
			'<div class="ke-progressbar-percent">0%</div></div>'].join('')).hide().appendTo(statusDiv);
		K('<div class="ke-message">' + self.options.pendingMessage + '</div>').appendTo(statusDiv);

		itemDiv.append('<div class="ke-name">' + file.name + '</div>');

		self.progressbars[file.id] = {
			bar : K('.ke-progressbar-bar-inner', photoDiv),
			percent : K('.ke-progressbar-percent', photoDiv)
		};
	},
	remove : function() {
		this.removeFiles();
		this.swfu.destroy();
		this.div.html('');
	}
});

K.swfupload = function(element, options) {
	return new KSWFUpload(element, options);
};

})(KindEditor);

KindEditor.plugin('multiimage', function(K) {
	var self = this, name = 'multiimage',
		formatUploadUrl = K.undef(self.formatUploadUrl, true),
		uploadJson = K.undef(self.uploadJson, self.basePath + 'php/upload_json.php'),
		imgPath = self.pluginsPath + 'multiimage/images/',
		imageSizeLimit = K.undef(self.imageSizeLimit, '1MB'),
		imageFileTypes = K.undef(self.imageFileTypes, '*.jpg;*.gif;*.png'),
		imageUploadLimit = K.undef(self.imageUploadLimit, 20),
		filePostName = K.undef(self.filePostName, 'imgFile'),
		lang = self.lang(name + '.');

	self.plugin.multiImageDialog = function(options) {
		var clickFn = options.clickFn,
			uploadDesc = K.tmpl(lang.uploadDesc, {uploadLimit : imageUploadLimit, sizeLimit : imageSizeLimit});
		var html = [
			'<div style="padding:20px;">',
			'<div class="swfupload">',
			'</div>',
			'</div>'
		].join('');
		var dialog = self.createDialog({
			name : name,
			width : 650,
			height : 510,
			title : self.lang(name),
			body : html,
			previewBtn : {
				name : lang.insertAll,
				click : function(e) {
					clickFn.call(self, swfupload.getUrlList());
				}
			},
			yesBtn : {
				name : lang.clearAll,
				click : function(e) {
					swfupload.removeFiles();
				}
			},
			beforeRemove : function() {
				if (!K.IE || K.V <= 8) {
					swfupload.remove();
				}
			}
		}),
		div = dialog.div;

		var swfupload = K.swfupload({
			container : K('.swfupload', div),
			buttonImageUrl : imgPath + (self.langType == 'zh_CN' ? 'select-files-zh_CN.png' : 'select-files-en.png'),
			buttonWidth : self.langType == 'zh_CN' ? 72 : 88,
			buttonHeight : 23,
			fileIconUrl : imgPath + 'image.png',
			uploadDesc : uploadDesc,
			startButtonValue : lang.startUpload,
			uploadUrl : K.addParam(uploadJson, 'dir=image'),
			flashUrl : imgPath + 'swfupload.swf',
			filePostName : filePostName,
			fileTypes : '*.jpg;*.jpeg;*.gif;*.png;*.bmp',
			fileTypesDesc : 'Image Files',
			fileUploadLimit : imageUploadLimit,
			fileSizeLimit : imageSizeLimit,
			postParams :  K.undef(self.extraFileUploadParams, {}),
			queueLimitExceeded : lang.queueLimitExceeded,
			fileExceedsSizeLimit : lang.fileExceedsSizeLimit,
			zeroByteFile : lang.zeroByteFile,
			invalidFiletype : lang.invalidFiletype,
			unknownError : lang.unknownError,
			pendingMessage : lang.pending,
			errorMessage : lang.uploadError,
			afterError : function(html) {
				self.errorDialog(html);
			}
		});

		return dialog;
	};
	self.clickToolbar(name, function() {
		self.plugin.multiImageDialog({
			clickFn : function (urlList) {
				if (urlList.length === 0) {
					return;
				}
				K.each(urlList, function(i, data) {
					if (self.afterUpload) {
						self.afterUpload.call(self, data.url, data, 'multiimage');
					}
					self.exec('insertimage', data.url, data.title, data.width, data.height, data.border, data.align);
				});
				setTimeout(function() {
					self.hideDialog().focus();
				}, 0);
			}
		});
	});
});


/**
 * SWFUpload: http://www.swfupload.org, http://swfupload.googlecode.com
 *
 * mmSWFUpload 1.0: Flash upload dialog - http://profandesign.se/swfupload/,  http://www.vinterwebb.se/
 *
 * SWFUpload is (c) 2006-2007 Lars Huring, Olov Nilz閚 and Mammon Media and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * SWFUpload 2 is (c) 2007-2008 Jake Roberts and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */


/* ******************* */
/* Constructor & Init  */
/* ******************* */

(function() {

if (window.SWFUpload) {
	return;
}

window.SWFUpload = function (settings) {
	this.initSWFUpload(settings);
};

SWFUpload.prototype.initSWFUpload = function (settings) {
	try {
		this.customSettings = {};	
		this.settings = settings;
		this.eventQueue = [];
		this.movieName = "SWFUpload_" + SWFUpload.movieCount++;
		this.movieElement = null;


		SWFUpload.instances[this.movieName] = this;

		this.initSettings();
		this.loadFlash();
		this.displayDebugInfo();
	} catch (ex) {
		delete SWFUpload.instances[this.movieName];
		throw ex;
	}
};

/* *************** */
/* Static Members  */
/* *************** */
SWFUpload.instances = {};
SWFUpload.movieCount = 0;
SWFUpload.version = "2.2.0 2009-03-25";
SWFUpload.QUEUE_ERROR = {
	QUEUE_LIMIT_EXCEEDED	  		: -100,
	FILE_EXCEEDS_SIZE_LIMIT  		: -110,
	ZERO_BYTE_FILE			  		: -120,
	INVALID_FILETYPE		  		: -130
};
SWFUpload.UPLOAD_ERROR = {
	HTTP_ERROR				  		: -200,
	MISSING_UPLOAD_URL	      		: -210,
	IO_ERROR				  		: -220,
	SECURITY_ERROR			  		: -230,
	UPLOAD_LIMIT_EXCEEDED	  		: -240,
	UPLOAD_FAILED			  		: -250,
	SPECIFIED_FILE_ID_NOT_FOUND		: -260,
	FILE_VALIDATION_FAILED	  		: -270,
	FILE_CANCELLED			  		: -280,
	UPLOAD_STOPPED					: -290
};
SWFUpload.FILE_STATUS = {
	QUEUED		 : -1,
	IN_PROGRESS	 : -2,
	ERROR		 : -3,
	COMPLETE	 : -4,
	CANCELLED	 : -5
};
SWFUpload.BUTTON_ACTION = {
	SELECT_FILE  : -100,
	SELECT_FILES : -110,
	START_UPLOAD : -120
};
SWFUpload.CURSOR = {
	ARROW : -1,
	HAND : -2
};
SWFUpload.WINDOW_MODE = {
	WINDOW : "window",
	TRANSPARENT : "transparent",
	OPAQUE : "opaque"
};

SWFUpload.completeURL = function(url) {
	if (typeof(url) !== "string" || url.match(/^https?:\/\//i) || url.match(/^\//)) {
		return url;
	}

	var currentURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");

	var indexSlash = window.location.pathname.lastIndexOf("/");
	if (indexSlash <= 0) {
		path = "/";
	} else {
		path = window.location.pathname.substr(0, indexSlash) + "/";
	}

	return /*currentURL +*/ path + url;

};


/* ******************** */
/* Instance Members  */
/* ******************** */

SWFUpload.prototype.initSettings = function () {
	this.ensureDefault = function (settingName, defaultValue) {
		this.settings[settingName] = (this.settings[settingName] == undefined) ? defaultValue : this.settings[settingName];
	};

	
	this.ensureDefault("upload_url", "");
	this.ensureDefault("preserve_relative_urls", false);
	this.ensureDefault("file_post_name", "Filedata");
	this.ensureDefault("post_params", {});
	this.ensureDefault("use_query_string", false);
	this.ensureDefault("requeue_on_error", false);
	this.ensureDefault("http_success", []);
	this.ensureDefault("assume_success_timeout", 0);

	
	this.ensureDefault("file_types", "*.*");
	this.ensureDefault("file_types_description", "All Files");
	this.ensureDefault("file_size_limit", 0);	
	this.ensureDefault("file_upload_limit", 0);
	this.ensureDefault("file_queue_limit", 0);

	
	this.ensureDefault("flash_url", "swfupload.swf");
	this.ensureDefault("prevent_swf_caching", true);

	
	this.ensureDefault("button_image_url", "");
	this.ensureDefault("button_width", 1);
	this.ensureDefault("button_height", 1);
	this.ensureDefault("button_text", "");
	this.ensureDefault("button_text_style", "color: #000000; font-size: 16pt;");
	this.ensureDefault("button_text_top_padding", 0);
	this.ensureDefault("button_text_left_padding", 0);
	this.ensureDefault("button_action", SWFUpload.BUTTON_ACTION.SELECT_FILES);
	this.ensureDefault("button_disabled", false);
	this.ensureDefault("button_placeholder_id", "");
	this.ensureDefault("button_placeholder", null);
	this.ensureDefault("button_cursor", SWFUpload.CURSOR.ARROW);
	this.ensureDefault("button_window_mode", SWFUpload.WINDOW_MODE.WINDOW);

	
	this.ensureDefault("debug", false);
	this.settings.debug_enabled = this.settings.debug;	

	
	this.settings.return_upload_start_handler = this.returnUploadStart;
	this.ensureDefault("swfupload_loaded_handler", null);
	this.ensureDefault("file_dialog_start_handler", null);
	this.ensureDefault("file_queued_handler", null);
	this.ensureDefault("file_queue_error_handler", null);
	this.ensureDefault("file_dialog_complete_handler", null);

	this.ensureDefault("upload_start_handler", null);
	this.ensureDefault("upload_progress_handler", null);
	this.ensureDefault("upload_error_handler", null);
	this.ensureDefault("upload_success_handler", null);
	this.ensureDefault("upload_complete_handler", null);

	this.ensureDefault("debug_handler", this.debugMessage);

	this.ensureDefault("custom_settings", {});

	
	this.customSettings = this.settings.custom_settings;

	
	if (!!this.settings.prevent_swf_caching) {
		this.settings.flash_url = this.settings.flash_url + (this.settings.flash_url.indexOf("?") < 0 ? "?" : "&") + "preventswfcaching=" + new Date().getTime();
	}

	if (!this.settings.preserve_relative_urls) {
		
		this.settings.upload_url = SWFUpload.completeURL(this.settings.upload_url);
		this.settings.button_image_url = SWFUpload.completeURL(this.settings.button_image_url);
	}

	delete this.ensureDefault;
};


SWFUpload.prototype.loadFlash = function () {
	var targetElement, tempParent;

	
	if (document.getElementById(this.movieName) !== null) {
		throw "ID " + this.movieName + " is already in use. The Flash Object could not be added";
	}

	
	targetElement = document.getElementById(this.settings.button_placeholder_id) || this.settings.button_placeholder;

	if (targetElement == undefined) {
		throw "Could not find the placeholder element: " + this.settings.button_placeholder_id;
	}

	
	tempParent = document.createElement("div");
	tempParent.innerHTML = this.getFlashHTML();	
	targetElement.parentNode.replaceChild(tempParent.firstChild, targetElement);

	
	if (window[this.movieName] == undefined) {
		window[this.movieName] = this.getMovieElement();
	}

};


SWFUpload.prototype.getFlashHTML = function () {
	var classid = '';
	if (KindEditor.IE && KindEditor.V > 8) {
		classid = ' classid = "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"';
	}
	return ['<object id="', this.movieName, '"' + classid + ' type="application/x-shockwave-flash" data="', this.settings.flash_url, '" width="', this.settings.button_width, '" height="', this.settings.button_height, '" class="swfupload">',
				'<param name="wmode" value="', this.settings.button_window_mode, '" />',
				'<param name="movie" value="', this.settings.flash_url, '" />',
				'<param name="quality" value="high" />',
				'<param name="menu" value="false" />',
				'<param name="allowScriptAccess" value="always" />',
				'<param name="flashvars" value="' + this.getFlashVars() + '" />',
				'</object>'].join("");
};

SWFUpload.prototype.getFlashVars = function () {
	var paramString = this.buildParamString();
	var httpSuccessString = this.settings.http_success.join(",");

	return ["movieName=", encodeURIComponent(this.movieName),
			"&amp;uploadURL=", encodeURIComponent(this.settings.upload_url),
			"&amp;useQueryString=", encodeURIComponent(this.settings.use_query_string),
			"&amp;requeueOnError=", encodeURIComponent(this.settings.requeue_on_error),
			"&amp;httpSuccess=", encodeURIComponent(httpSuccessString),
			"&amp;assumeSuccessTimeout=", encodeURIComponent(this.settings.assume_success_timeout),
			"&amp;params=", encodeURIComponent(paramString),
			"&amp;filePostName=", encodeURIComponent(this.settings.file_post_name),
			"&amp;fileTypes=", encodeURIComponent(this.settings.file_types),
			"&amp;fileTypesDescription=", encodeURIComponent(this.settings.file_types_description),
			"&amp;fileSizeLimit=", encodeURIComponent(this.settings.file_size_limit),
			"&amp;fileUploadLimit=", encodeURIComponent(this.settings.file_upload_limit),
			"&amp;fileQueueLimit=", encodeURIComponent(this.settings.file_queue_limit),
			"&amp;debugEnabled=", encodeURIComponent(this.settings.debug_enabled),
			"&amp;buttonImageURL=", encodeURIComponent(this.settings.button_image_url),
			"&amp;buttonWidth=", encodeURIComponent(this.settings.button_width),
			"&amp;buttonHeight=", encodeURIComponent(this.settings.button_height),
			"&amp;buttonText=", encodeURIComponent(this.settings.button_text),
			"&amp;buttonTextTopPadding=", encodeURIComponent(this.settings.button_text_top_padding),
			"&amp;buttonTextLeftPadding=", encodeURIComponent(this.settings.button_text_left_padding),
			"&amp;buttonTextStyle=", encodeURIComponent(this.settings.button_text_style),
			"&amp;buttonAction=", encodeURIComponent(this.settings.button_action),
			"&amp;buttonDisabled=", encodeURIComponent(this.settings.button_disabled),
			"&amp;buttonCursor=", encodeURIComponent(this.settings.button_cursor)
		].join("");
};

SWFUpload.prototype.getMovieElement = function () {
	if (this.movieElement == undefined) {
		this.movieElement = document.getElementById(this.movieName);
	}

	if (this.movieElement === null) {
		throw "Could not find Flash element";
	}

	return this.movieElement;
};

SWFUpload.prototype.buildParamString = function () {
	var postParams = this.settings.post_params;
	var paramStringPairs = [];

	if (typeof(postParams) === "object") {
		for (var name in postParams) {
			if (postParams.hasOwnProperty(name)) {
				paramStringPairs.push(encodeURIComponent(name.toString()) + "=" + encodeURIComponent(postParams[name].toString()));
			}
		}
	}

	return paramStringPairs.join("&amp;");
};

SWFUpload.prototype.destroy = function () {
	try {
		
		this.cancelUpload(null, false);


		
		var movieElement = null;
		movieElement = this.getMovieElement();

		if (movieElement && typeof(movieElement.CallFunction) === "unknown") { 
			
			for (var i in movieElement) {
				try {
					if (typeof(movieElement[i]) === "function") {
						movieElement[i] = null;
					}
				} catch (ex1) {}
			}

			
			try {
				movieElement.parentNode.removeChild(movieElement);
			} catch (ex) {}
		}

		
		window[this.movieName] = null;

		SWFUpload.instances[this.movieName] = null;
		delete SWFUpload.instances[this.movieName];

		this.movieElement = null;
		this.settings = null;
		this.customSettings = null;
		this.eventQueue = null;
		this.movieName = null;


		return true;
	} catch (ex2) {
		return false;
	}
};


SWFUpload.prototype.displayDebugInfo = function () {
	this.debug(
		[
			"---SWFUpload Instance Info---\n",
			"Version: ", SWFUpload.version, "\n",
			"Movie Name: ", this.movieName, "\n",
			"Settings:\n",
			"\t", "upload_url:               ", this.settings.upload_url, "\n",
			"\t", "flash_url:                ", this.settings.flash_url, "\n",
			"\t", "use_query_string:         ", this.settings.use_query_string.toString(), "\n",
			"\t", "requeue_on_error:         ", this.settings.requeue_on_error.toString(), "\n",
			"\t", "http_success:             ", this.settings.http_success.join(", "), "\n",
			"\t", "assume_success_timeout:   ", this.settings.assume_success_timeout, "\n",
			"\t", "file_post_name:           ", this.settings.file_post_name, "\n",
			"\t", "post_params:              ", this.settings.post_params.toString(), "\n",
			"\t", "file_types:               ", this.settings.file_types, "\n",
			"\t", "file_types_description:   ", this.settings.file_types_description, "\n",
			"\t", "file_size_limit:          ", this.settings.file_size_limit, "\n",
			"\t", "file_upload_limit:        ", this.settings.file_upload_limit, "\n",
			"\t", "file_queue_limit:         ", this.settings.file_queue_limit, "\n",
			"\t", "debug:                    ", this.settings.debug.toString(), "\n",

			"\t", "prevent_swf_caching:      ", this.settings.prevent_swf_caching.toString(), "\n",

			"\t", "button_placeholder_id:    ", this.settings.button_placeholder_id.toString(), "\n",
			"\t", "button_placeholder:       ", (this.settings.button_placeholder ? "Set" : "Not Set"), "\n",
			"\t", "button_image_url:         ", this.settings.button_image_url.toString(), "\n",
			"\t", "button_width:             ", this.settings.button_width.toString(), "\n",
			"\t", "button_height:            ", this.settings.button_height.toString(), "\n",
			"\t", "button_text:              ", this.settings.button_text.toString(), "\n",
			"\t", "button_text_style:        ", this.settings.button_text_style.toString(), "\n",
			"\t", "button_text_top_padding:  ", this.settings.button_text_top_padding.toString(), "\n",
			"\t", "button_text_left_padding: ", this.settings.button_text_left_padding.toString(), "\n",
			"\t", "button_action:            ", this.settings.button_action.toString(), "\n",
			"\t", "button_disabled:          ", this.settings.button_disabled.toString(), "\n",

			"\t", "custom_settings:          ", this.settings.custom_settings.toString(), "\n",
			"Event Handlers:\n",
			"\t", "swfupload_loaded_handler assigned:  ", (typeof this.settings.swfupload_loaded_handler === "function").toString(), "\n",
			"\t", "file_dialog_start_handler assigned: ", (typeof this.settings.file_dialog_start_handler === "function").toString(), "\n",
			"\t", "file_queued_handler assigned:       ", (typeof this.settings.file_queued_handler === "function").toString(), "\n",
			"\t", "file_queue_error_handler assigned:  ", (typeof this.settings.file_queue_error_handler === "function").toString(), "\n",
			"\t", "upload_start_handler assigned:      ", (typeof this.settings.upload_start_handler === "function").toString(), "\n",
			"\t", "upload_progress_handler assigned:   ", (typeof this.settings.upload_progress_handler === "function").toString(), "\n",
			"\t", "upload_error_handler assigned:      ", (typeof this.settings.upload_error_handler === "function").toString(), "\n",
			"\t", "upload_success_handler assigned:    ", (typeof this.settings.upload_success_handler === "function").toString(), "\n",
			"\t", "upload_complete_handler assigned:   ", (typeof this.settings.upload_complete_handler === "function").toString(), "\n",
			"\t", "debug_handler assigned:             ", (typeof this.settings.debug_handler === "function").toString(), "\n"
		].join("")
	);
};

/* Note: addSetting and getSetting are no longer used by SWFUpload but are included
	the maintain v2 API compatibility
*/
SWFUpload.prototype.addSetting = function (name, value, default_value) {
    if (value == undefined) {
        return (this.settings[name] = default_value);
    } else {
        return (this.settings[name] = value);
	}
};

SWFUpload.prototype.getSetting = function (name) {
    if (this.settings[name] != undefined) {
        return this.settings[name];
	}

    return "";
};



SWFUpload.prototype.callFlash = function (functionName, argumentArray) {
	argumentArray = argumentArray || [];

	var movieElement = this.getMovieElement();
	var returnValue, returnString;

	
	try {
		returnString = movieElement.CallFunction('<invoke name="' + functionName + '" returntype="javascript">' + __flash__argumentsToXML(argumentArray, 0) + '</invoke>');
		returnValue = eval(returnString);
	} catch (ex) {
		throw "Call to " + functionName + " failed";
	}

	
	if (returnValue != undefined && typeof returnValue.post === "object") {
		returnValue = this.unescapeFilePostParams(returnValue);
	}

	return returnValue;
};

/* *****************************
	-- Flash control methods --
	Your UI should use these
	to operate SWFUpload
   ***************************** */




SWFUpload.prototype.selectFile = function () {
	this.callFlash("SelectFile");
};







SWFUpload.prototype.selectFiles = function () {
	this.callFlash("SelectFiles");
};




SWFUpload.prototype.startUpload = function (fileID) {
	this.callFlash("StartUpload", [fileID]);
};




SWFUpload.prototype.cancelUpload = function (fileID, triggerErrorEvent) {
	if (triggerErrorEvent !== false) {
		triggerErrorEvent = true;
	}
	this.callFlash("CancelUpload", [fileID, triggerErrorEvent]);
};



SWFUpload.prototype.stopUpload = function () {
	this.callFlash("StopUpload");
};

/* ************************
 * Settings methods
 *   These methods change the SWFUpload settings.
 *   SWFUpload settings should not be changed directly on the settings object
 *   since many of the settings need to be passed to Flash in order to take
 *   effect.
 * *********************** */


SWFUpload.prototype.getStats = function () {
	return this.callFlash("GetStats");
};





SWFUpload.prototype.setStats = function (statsObject) {
	this.callFlash("SetStats", [statsObject]);
};



SWFUpload.prototype.getFile = function (fileID) {
	if (typeof(fileID) === "number") {
		return this.callFlash("GetFileByIndex", [fileID]);
	} else {
		return this.callFlash("GetFile", [fileID]);
	}
};




SWFUpload.prototype.addFileParam = function (fileID, name, value) {
	return this.callFlash("AddFileParam", [fileID, name, value]);
};



SWFUpload.prototype.removeFileParam = function (fileID, name) {
	this.callFlash("RemoveFileParam", [fileID, name]);
};


SWFUpload.prototype.setUploadURL = function (url) {
	this.settings.upload_url = url.toString();
	this.callFlash("SetUploadURL", [url]);
};


SWFUpload.prototype.setPostParams = function (paramsObject) {
	this.settings.post_params = paramsObject;
	this.callFlash("SetPostParams", [paramsObject]);
};


SWFUpload.prototype.addPostParam = function (name, value) {
	this.settings.post_params[name] = value;
	this.callFlash("SetPostParams", [this.settings.post_params]);
};


SWFUpload.prototype.removePostParam = function (name) {
	delete this.settings.post_params[name];
	this.callFlash("SetPostParams", [this.settings.post_params]);
};


SWFUpload.prototype.setFileTypes = function (types, description) {
	this.settings.file_types = types;
	this.settings.file_types_description = description;
	this.callFlash("SetFileTypes", [types, description]);
};


SWFUpload.prototype.setFileSizeLimit = function (fileSizeLimit) {
	this.settings.file_size_limit = fileSizeLimit;
	this.callFlash("SetFileSizeLimit", [fileSizeLimit]);
};


SWFUpload.prototype.setFileUploadLimit = function (fileUploadLimit) {
	this.settings.file_upload_limit = fileUploadLimit;
	this.callFlash("SetFileUploadLimit", [fileUploadLimit]);
};


SWFUpload.prototype.setFileQueueLimit = function (fileQueueLimit) {
	this.settings.file_queue_limit = fileQueueLimit;
	this.callFlash("SetFileQueueLimit", [fileQueueLimit]);
};


SWFUpload.prototype.setFilePostName = function (filePostName) {
	this.settings.file_post_name = filePostName;
	this.callFlash("SetFilePostName", [filePostName]);
};


SWFUpload.prototype.setUseQueryString = function (useQueryString) {
	this.settings.use_query_string = useQueryString;
	this.callFlash("SetUseQueryString", [useQueryString]);
};


SWFUpload.prototype.setRequeueOnError = function (requeueOnError) {
	this.settings.requeue_on_error = requeueOnError;
	this.callFlash("SetRequeueOnError", [requeueOnError]);
};


SWFUpload.prototype.setHTTPSuccess = function (http_status_codes) {
	if (typeof http_status_codes === "string") {
		http_status_codes = http_status_codes.replace(" ", "").split(",");
	}

	this.settings.http_success = http_status_codes;
	this.callFlash("SetHTTPSuccess", [http_status_codes]);
};


SWFUpload.prototype.setAssumeSuccessTimeout = function (timeout_seconds) {
	this.settings.assume_success_timeout = timeout_seconds;
	this.callFlash("SetAssumeSuccessTimeout", [timeout_seconds]);
};


SWFUpload.prototype.setDebugEnabled = function (debugEnabled) {
	this.settings.debug_enabled = debugEnabled;
	this.callFlash("SetDebugEnabled", [debugEnabled]);
};


SWFUpload.prototype.setButtonImageURL = function (buttonImageURL) {
	if (buttonImageURL == undefined) {
		buttonImageURL = "";
	}

	this.settings.button_image_url = buttonImageURL;
	this.callFlash("SetButtonImageURL", [buttonImageURL]);
};


SWFUpload.prototype.setButtonDimensions = function (width, height) {
	this.settings.button_width = width;
	this.settings.button_height = height;

	var movie = this.getMovieElement();
	if (movie != undefined) {
		movie.style.width = width + "px";
		movie.style.height = height + "px";
	}

	this.callFlash("SetButtonDimensions", [width, height]);
};

SWFUpload.prototype.setButtonText = function (html) {
	this.settings.button_text = html;
	this.callFlash("SetButtonText", [html]);
};

SWFUpload.prototype.setButtonTextPadding = function (left, top) {
	this.settings.button_text_top_padding = top;
	this.settings.button_text_left_padding = left;
	this.callFlash("SetButtonTextPadding", [left, top]);
};


SWFUpload.prototype.setButtonTextStyle = function (css) {
	this.settings.button_text_style = css;
	this.callFlash("SetButtonTextStyle", [css]);
};

SWFUpload.prototype.setButtonDisabled = function (isDisabled) {
	this.settings.button_disabled = isDisabled;
	this.callFlash("SetButtonDisabled", [isDisabled]);
};

SWFUpload.prototype.setButtonAction = function (buttonAction) {
	this.settings.button_action = buttonAction;
	this.callFlash("SetButtonAction", [buttonAction]);
};


SWFUpload.prototype.setButtonCursor = function (cursor) {
	this.settings.button_cursor = cursor;
	this.callFlash("SetButtonCursor", [cursor]);
};

/* *******************************
	Flash Event Interfaces
	These functions are used by Flash to trigger the various
	events.

	All these functions a Private.

	Because the ExternalInterface library is buggy the event calls
	are added to a queue and the queue then executed by a setTimeout.
	This ensures that events are executed in a determinate order and that
	the ExternalInterface bugs are avoided.
******************************* */

SWFUpload.prototype.queueEvent = function (handlerName, argumentArray) {
	

	if (argumentArray == undefined) {
		argumentArray = [];
	} else if (!(argumentArray instanceof Array)) {
		argumentArray = [argumentArray];
	}

	var self = this;
	if (typeof this.settings[handlerName] === "function") {
		
		this.eventQueue.push(function () {
			this.settings[handlerName].apply(this, argumentArray);
		});

		
		setTimeout(function () {
			self.executeNextEvent();
		}, 0);

	} else if (this.settings[handlerName] !== null) {
		throw "Event handler " + handlerName + " is unknown or is not a function";
	}
};



SWFUpload.prototype.executeNextEvent = function () {
	

	var  f = this.eventQueue ? this.eventQueue.shift() : null;
	if (typeof(f) === "function") {
		f.apply(this);
	}
};




SWFUpload.prototype.unescapeFilePostParams = function (file) {
	var reg = /[$]([0-9a-f]{4})/i;
	var unescapedPost = {};
	var uk;

	if (file != undefined) {
		for (var k in file.post) {
			if (file.post.hasOwnProperty(k)) {
				uk = k;
				var match;
				while ((match = reg.exec(uk)) !== null) {
					uk = uk.replace(match[0], String.fromCharCode(parseInt("0x" + match[1], 16)));
				}
				unescapedPost[uk] = file.post[k];
			}
		}

		file.post = unescapedPost;
	}

	return file;
};


SWFUpload.prototype.testExternalInterface = function () {
	try {
		return this.callFlash("TestExternalInterface");
	} catch (ex) {
		return false;
	}
};



SWFUpload.prototype.flashReady = function () {
	
	var movieElement = this.getMovieElement();

	if (!movieElement) {
		this.debug("Flash called back ready but the flash movie can't be found.");
		return;
	}

	this.cleanUp(movieElement);

	this.queueEvent("swfupload_loaded_handler");
};



SWFUpload.prototype.cleanUp = function (movieElement) {
	
	try {
		if (this.movieElement && typeof(movieElement.CallFunction) === "unknown") { 
			this.debug("Removing Flash functions hooks (this should only run in IE and should prevent memory leaks)");
			for (var key in movieElement) {
				try {
					if (typeof(movieElement[key]) === "function") {
						movieElement[key] = null;
					}
				} catch (ex) {
				}
			}
		}
	} catch (ex1) {

	}

	
	
	window["__flash__removeCallback"] = function (instance, name) {
		try {
			if (instance) {
				instance[name] = null;
			}
		} catch (flashEx) {

		}
	};

};


/* This is a chance to do something before the browse window opens */
SWFUpload.prototype.fileDialogStart = function () {
	this.queueEvent("file_dialog_start_handler");
};


/* Called when a file is successfully added to the queue. */
SWFUpload.prototype.fileQueued = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queued_handler", file);
};


/* Handle errors that occur when an attempt to queue a file fails. */
SWFUpload.prototype.fileQueueError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("file_queue_error_handler", [file, errorCode, message]);
};

/* Called after the file dialog has closed and the selected files have been queued.
	You could call startUpload here if you want the queued files to begin uploading immediately. */
SWFUpload.prototype.fileDialogComplete = function (numFilesSelected, numFilesQueued, numFilesInQueue) {
	this.queueEvent("file_dialog_complete_handler", [numFilesSelected, numFilesQueued, numFilesInQueue]);
};

SWFUpload.prototype.uploadStart = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("return_upload_start_handler", file);
};

SWFUpload.prototype.returnUploadStart = function (file) {
	var returnValue;
	if (typeof this.settings.upload_start_handler === "function") {
		file = this.unescapeFilePostParams(file);
		returnValue = this.settings.upload_start_handler.call(this, file);
	} else if (this.settings.upload_start_handler != undefined) {
		throw "upload_start_handler must be a function";
	}

	if (returnValue === undefined) {
		returnValue = true;
	}

	returnValue = !!returnValue;

	this.callFlash("ReturnUploadStart", [returnValue]);
};



SWFUpload.prototype.uploadProgress = function (file, bytesComplete, bytesTotal) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_progress_handler", [file, bytesComplete, bytesTotal]);
};

SWFUpload.prototype.uploadError = function (file, errorCode, message) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_error_handler", [file, errorCode, message]);
};

SWFUpload.prototype.uploadSuccess = function (file, serverData, responseReceived) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_success_handler", [file, serverData, responseReceived]);
};

SWFUpload.prototype.uploadComplete = function (file) {
	file = this.unescapeFilePostParams(file);
	this.queueEvent("upload_complete_handler", file);
};

/* Called by SWFUpload JavaScript and Flash functions when debug is enabled. By default it writes messages to the
   internal debug console.  You can override this event and have messages written where you want. */
SWFUpload.prototype.debug = function (message) {
	this.queueEvent("debug_handler", message);
};


/* **********************************
	Debug Console
	The debug console is a self contained, in page location
	for debug message to be sent.  The Debug Console adds
	itself to the body if necessary.

	The console is automatically scrolled as messages appear.

	If you are using your own debug handler or when you deploy to production and
	have debug disabled you can remove these functions to reduce the file size
	and complexity.
********************************** */

SWFUpload.prototype.debugMessage = function (message) {
	if (this.settings.debug) {
		var exceptionMessage, exceptionValues = [];

		
		if (typeof message === "object" && typeof message.name === "string" && typeof message.message === "string") {
			for (var key in message) {
				if (message.hasOwnProperty(key)) {
					exceptionValues.push(key + ": " + message[key]);
				}
			}
			exceptionMessage = exceptionValues.join("\n") || "";
			exceptionValues = exceptionMessage.split("\n");
			exceptionMessage = "EXCEPTION: " + exceptionValues.join("\nEXCEPTION: ");
			SWFUpload.Console.writeLine(exceptionMessage);
		} else {
			SWFUpload.Console.writeLine(message);
		}
	}
};

SWFUpload.Console = {};
SWFUpload.Console.writeLine = function (message) {
	var console, documentForm;

	try {
		console = document.getElementById("SWFUpload_Console");

		if (!console) {
			documentForm = document.createElement("form");
			document.getElementsByTagName("body")[0].appendChild(documentForm);

			console = document.createElement("textarea");
			console.id = "SWFUpload_Console";
			console.style.fontFamily = "monospace";
			console.setAttribute("wrap", "off");
			console.wrap = "off";
			console.style.overflow = "auto";
			console.style.width = "700px";
			console.style.height = "350px";
			console.style.margin = "5px";
			documentForm.appendChild(console);
		}

		console.value += message + "\n";

		console.scrollTop = console.scrollHeight - console.clientHeight;
	} catch (ex) {
		alert("Exception: " + ex.name + " Message: " + ex.message);
	}
};

})();

(function() {
/*
	Queue Plug-in

	Features:
		*Adds a cancelQueue() method for cancelling the entire queue.
		*All queued files are uploaded when startUpload() is called.
		*If false is returned from uploadComplete then the queue upload is stopped.
		 If false is not returned (strict comparison) then the queue upload is continued.
		*Adds a QueueComplete event that is fired when all the queued files have finished uploading.
		 Set the event handler with the queue_complete_handler setting.

	*/

if (typeof(SWFUpload) === "function") {
	SWFUpload.queue = {};

	SWFUpload.prototype.initSettings = (function (oldInitSettings) {
		return function () {
			if (typeof(oldInitSettings) === "function") {
				oldInitSettings.call(this);
			}

			this.queueSettings = {};

			this.queueSettings.queue_cancelled_flag = false;
			this.queueSettings.queue_upload_count = 0;

			this.queueSettings.user_upload_complete_handler = this.settings.upload_complete_handler;
			this.queueSettings.user_upload_start_handler = this.settings.upload_start_handler;
			this.settings.upload_complete_handler = SWFUpload.queue.uploadCompleteHandler;
			this.settings.upload_start_handler = SWFUpload.queue.uploadStartHandler;

			this.settings.queue_complete_handler = this.settings.queue_complete_handler || null;
		};
	})(SWFUpload.prototype.initSettings);

	SWFUpload.prototype.startUpload = function (fileID) {
		this.queueSettings.queue_cancelled_flag = false;
		this.callFlash("StartUpload", [fileID]);
	};

	SWFUpload.prototype.cancelQueue = function () {
		this.queueSettings.queue_cancelled_flag = true;
		this.stopUpload();

		var stats = this.getStats();
		while (stats.files_queued > 0) {
			this.cancelUpload();
			stats = this.getStats();
		}
	};

	SWFUpload.queue.uploadStartHandler = function (file) {
		var returnValue;
		if (typeof(this.queueSettings.user_upload_start_handler) === "function") {
			returnValue = this.queueSettings.user_upload_start_handler.call(this, file);
		}

		
		returnValue = (returnValue === false) ? false : true;

		this.queueSettings.queue_cancelled_flag = !returnValue;

		return returnValue;
	};

	SWFUpload.queue.uploadCompleteHandler = function (file) {
		var user_upload_complete_handler = this.queueSettings.user_upload_complete_handler;
		var continueUpload;

		if (file.filestatus === SWFUpload.FILE_STATUS.COMPLETE) {
			this.queueSettings.queue_upload_count++;
		}

		if (typeof(user_upload_complete_handler) === "function") {
			continueUpload = (user_upload_complete_handler.call(this, file) === false) ? false : true;
		} else if (file.filestatus === SWFUpload.FILE_STATUS.QUEUED) {
			
			continueUpload = false;
		} else {
			continueUpload = true;
		}

		if (continueUpload) {
			var stats = this.getStats();
			if (stats.files_queued > 0 && this.queueSettings.queue_cancelled_flag === false) {
				this.startUpload();
			} else if (this.queueSettings.queue_cancelled_flag === false) {
				this.queueEvent("queue_complete_handler", [this.queueSettings.queue_upload_count]);
				this.queueSettings.queue_upload_count = 0;
			} else {
				this.queueSettings.queue_cancelled_flag = false;
				this.queueSettings.queue_upload_count = 0;
			}
		}
	};
}

})();
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http:
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('pagebreak', function(K) {
	var self = this;
	var name = 'pagebreak';
	var pagebreakHtml = K.undef(self.pagebreakHtml, '<hr style="page-break-after: always;" class="ke-pagebreak" />');

	self.clickToolbar(name, function() {
		var cmd = self.cmd, range = cmd.range;
		self.focus();
		range.enlarge(true);
		cmd.split(true);
		var tail = self.newlineTag == 'br' || K.WEBKIT ? '' : '<p id="__kindeditor_tail_tag__"></p>';
		self.insertHtml(pagebreakHtml + tail);
		if (tail !== '') {
			var p = K('#__kindeditor_tail_tag__', self.edit.doc);
			range.selectNodeContents(p[0]);
			p.removeAttr('id');
			cmd.select();
		}
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('plainpaste', function(K) {
	var self = this, name = 'plainpaste';
	self.clickToolbar(name, function() {
		var lang = self.lang(name + '.'),
			html = '<div style="padding:10px 20px;">' +
				'<div style="margin-bottom:10px;">' + lang.comment + '</div>' +
				'<textarea class="ke-textarea" style="width:408px;height:260px;"></textarea>' +
				'</div>',
			dialog = self.createDialog({
				name : name,
				width : 450,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var html = textarea.val();
						html = K.escape(html);
						html = html.replace(/ {2}/g, ' &nbsp;');
						if (self.newlineTag == 'p') {
							html = html.replace(/^/, '<p>').replace(/$/, '</p>').replace(/\n/g, '</p><p>');
						} else {
							html = html.replace(/\n/g, '<br />$&');
						}
						self.insertHtml(html).hideDialog().focus();
					}
				}
			}),
			textarea = K('textarea', dialog.div);
		textarea[0].focus();
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('preview', function(K) {
	var self = this, name = 'preview', undefined;
	self.clickToolbar(name, function() {
		var lang = self.lang(name + '.'),
			html = '<div style="padding:10px 20px;">' +
				'<iframe class="ke-textarea" frameborder="0" style="width:708px;height:400px;"></iframe>' +
				'</div>',
			dialog = self.createDialog({
				name : name,
				width : 750,
				title : self.lang(name),
				body : html
			}),
			iframe = K('iframe', dialog.div),
			doc = K.iframeDoc(iframe);
		doc.open();
		doc.write(self.fullHtml());
		doc.close();
		K(doc.body).css('background-color', '#FFF');
		iframe[0].contentWindow.focus();
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('quickformat', function(K) {
	var self = this, name = 'quickformat',
		blockMap = K.toMap('blockquote,center,div,h1,h2,h3,h4,h5,h6,p');
	function getFirstChild(knode) {
		var child = knode.first();
		while (child && child.first()) {
			child = child.first();
		}
		return child;
	}
	self.clickToolbar(name, function() {
		self.focus();
		var doc = self.edit.doc,
			range = self.cmd.range,
			child = K(doc.body).first(), next,
			nodeList = [], subList = [],
			bookmark = range.createBookmark(true);
		while(child) {
			next = child.next();
			var firstChild = getFirstChild(child);
			if (!firstChild || firstChild.name != 'img') {
				if (blockMap[child.name]) {
					child.html(child.html().replace(/^(\s|&nbsp;|　)+/ig, ''));
					child.css('text-indent', '2em');
				} else {
					subList.push(child);
				}
				if (!next || (blockMap[next.name] || blockMap[child.name] && !blockMap[next.name])) {
					if (subList.length > 0) {
						nodeList.push(subList);
					}
					subList = [];
				}
			}
			child = next;
		}
		K.each(nodeList, function(i, subList) {
			var wrapper = K('<p style="text-indent:2em;"></p>', doc);
			subList[0].before(wrapper);
			K.each(subList, function(i, knode) {
				wrapper.append(knode);
			});
		});
		range.moveToBookmark(bookmark);
		self.addBookmark();
	});
});

/**
--------------------------
abcd<br />
1234<br />

to

<p style="text-indent:2em;">
	abcd<br />
	1234<br />
</p>

--------------------------

&nbsp; abcd<img>1233
<p>1234</p>

to

<p style="text-indent:2em;">abcd<img>1233</p>
<p style="text-indent:2em;">1234</p>

--------------------------
*//*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('table', function(K) {
	var self = this, name = 'table', lang = self.lang(name + '.'), zeroborder = 'ke-zeroborder';
	
	function _setColor(box, color) {
		color = color.toUpperCase();
		box.css('background-color', color);
		box.css('color', color === '#000000' ? '#FFFFFF' : '#000000');
		box.html(color);
	}
	
	var pickerList = [];
	function _initColorPicker(dialogDiv, colorBox) {
		colorBox.bind('click,mousedown', function(e){
			e.stopPropagation();
		});
		function removePicker() {
			K.each(pickerList, function() {
				this.remove();
			});
			pickerList = [];
			K(document).unbind('click,mousedown', removePicker);
			dialogDiv.unbind('click,mousedown', removePicker);
		}
		colorBox.click(function(e) {
			removePicker();
			var box = K(this),
				pos = box.pos();
			var picker = K.colorpicker({
				x : pos.x,
				y : pos.y + box.height(),
				z : 811214,
				selectedColor : K(this).html(),
				colors : self.colorTable,
				noColor : self.lang('noColor'),
				shadowMode : self.shadowMode,
				click : function(color) {
					_setColor(box, color);
					removePicker();
				}
			});
			pickerList.push(picker);
			K(document).bind('click,mousedown', removePicker);
			dialogDiv.bind('click,mousedown', removePicker);
		});
	}
	
	function _getCellIndex(table, row, cell) {
		var rowSpanCount = 0;
		for (var i = 0, len = row.cells.length; i < len; i++) {
			if (row.cells[i] == cell) {
				break;
			}
			rowSpanCount += row.cells[i].rowSpan - 1;
		}
		return cell.cellIndex - rowSpanCount;
	}
	self.plugin.table = {
		
		prop : function(isInsert) {
			var html = [
				'<div style="padding:20px;">',
				
				'<div class="ke-dialog-row">',
				'<label for="keRows" style="width:90px;">' + lang.cells + '</label>',
				lang.rows + ' <input type="text" id="keRows" class="ke-input-text ke-input-number" name="rows" value="" maxlength="4" /> &nbsp; ',
				lang.cols + ' <input type="text" class="ke-input-text ke-input-number" name="cols" value="" maxlength="4" />',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keWidth" style="width:90px;">' + lang.size + '</label>',
				lang.width + ' <input type="text" id="keWidth" class="ke-input-text ke-input-number" name="width" value="" maxlength="4" /> &nbsp; ',
				'<select name="widthType">',
				'<option value="%">' + lang.percent + '</option>',
				'<option value="px">' + lang.px + '</option>',
				'</select> &nbsp; ',
				lang.height + ' <input type="text" class="ke-input-text ke-input-number" name="height" value="" maxlength="4" /> &nbsp; ',
				'<select name="heightType">',
				'<option value="%">' + lang.percent + '</option>',
				'<option value="px">' + lang.px + '</option>',
				'</select>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="kePadding" style="width:90px;">' + lang.space + '</label>',
				lang.padding + ' <input type="text" id="kePadding" class="ke-input-text ke-input-number" name="padding" value="" maxlength="4" /> &nbsp; ',
				lang.spacing + ' <input type="text" class="ke-input-text ke-input-number" name="spacing" value="" maxlength="4" />',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keAlign" style="width:90px;">' + lang.align + '</label>',
				'<select id="keAlign" name="align">',
				'<option value="">' + lang.alignDefault + '</option>',
				'<option value="left">' + lang.alignLeft + '</option>',
				'<option value="center">' + lang.alignCenter + '</option>',
				'<option value="right">' + lang.alignRight + '</option>',
				'</select>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keBorder" style="width:90px;">' + lang.border + '</label>',
				lang.borderWidth + ' <input type="text" id="keBorder" class="ke-input-text ke-input-number" name="border" value="" maxlength="4" /> &nbsp; ',
				lang.borderColor + ' <span class="ke-inline-block ke-input-color"></span>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keBgColor" style="width:90px;">' + lang.backgroundColor + '</label>',
				'<span class="ke-inline-block ke-input-color"></span>',
				'</div>',
				'</div>'
			].join('');
			var dialog = self.createDialog({
				name : name,
				width : 500,
				title : self.lang(name),
				body : html,
				beforeRemove : function() {
					colorBox.unbind();
				},
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var rows = rowsBox.val(),
							cols = colsBox.val(),
							width = widthBox.val(),
							height = heightBox.val(),
							widthType = widthTypeBox.val(),
							heightType = heightTypeBox.val(),
							padding = paddingBox.val(),
							spacing = spacingBox.val(),
							align = alignBox.val(),
							border = borderBox.val(),
							borderColor = K(colorBox[0]).html() || '',
							bgColor = K(colorBox[1]).html() || '';
						if (rows == 0 || !/^\d+$/.test(rows)) {
							alert(self.lang('invalidRows'));
							rowsBox[0].focus();
							return;
						}
						if (cols == 0 || !/^\d+$/.test(cols)) {
							alert(self.lang('invalidRows'));
							colsBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(width)) {
							alert(self.lang('invalidWidth'));
							widthBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(height)) {
							alert(self.lang('invalidHeight'));
							heightBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(padding)) {
							alert(self.lang('invalidPadding'));
							paddingBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(spacing)) {
							alert(self.lang('invalidSpacing'));
							spacingBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(border)) {
							alert(self.lang('invalidBorder'));
							borderBox[0].focus();
							return;
						}
						
						if (table) {
							if (width !== '') {
								table.width(width + widthType);
							} else {
								table.css('width', '');
							}
							if (table[0].width !== undefined) {
								table.removeAttr('width');
							}
							if (height !== '') {
								table.height(height + heightType);
							} else {
								table.css('height', '');
							}
							if (table[0].height !== undefined) {
								table.removeAttr('height');
							}
							table.css('background-color', bgColor);
							if (table[0].bgColor !== undefined) {
								table.removeAttr('bgColor');
							}
							if (padding !== '') {
								table[0].cellPadding = padding;
							} else {
								table.removeAttr('cellPadding');
							}
							if (spacing !== '') {
								table[0].cellSpacing = spacing;
							} else {
								table.removeAttr('cellSpacing');
							}
							if (align !== '') {
								table[0].align = align;
							} else {
								table.removeAttr('align');
							}
							if (border !== '') {
								table.attr('border', border);
							} else {
								table.removeAttr('border');
							}
							if (border === '' || border === '0') {
								table.addClass(zeroborder);
							} else {
								table.removeClass(zeroborder);
							}
							if (borderColor !== '') {
								table.attr('borderColor', borderColor);
							} else {
								table.removeAttr('borderColor');
							}
							self.hideDialog().focus();
							return;
						}
						
						var style = '';
						if (width !== '') {
							style += 'width:' + width + widthType + ';';
						}
						if (height !== '') {
							style += 'height:' + height + heightType + ';';
						}
						if (bgColor !== '') {
							style += 'background-color:' + bgColor + ';';
						}
						var html = '<table';
						if (style !== '') {
							html += ' style="' + style + '"';
						}
						if (padding !== '') {
							html += ' cellpadding="' + padding + '"';
						}
						if (spacing !== '') {
							html += ' cellspacing="' + spacing + '"';
						}
						if (align !== '') {
							html += ' align="' + align + '"';
						}
						if (border !== '') {
							html += ' border="' + border + '"';
						}
						if (border === '' || border === '0') {
							html += ' class="' + zeroborder + '"';
						}
						if (borderColor !== '') {
							html += ' bordercolor="' + borderColor + '"';
						}
						html += '>';
						for (var i = 0; i < rows; i++) {
							html += '<tr>';
							for (var j = 0; j < cols; j++) {
								html += '<td>' + (K.IE ? '&nbsp;' : '<br />') + '</td>';
							}
							html += '</tr>';
						}
						html += '</table>';
						if (!K.IE) {
							html += '<br />';
						}
						self.insertHtml(html);
						self.select().hideDialog().focus();
						self.addBookmark();
					}
				}
			}),
			div = dialog.div,
			rowsBox = K('[name="rows"]', div).val(3),
			colsBox = K('[name="cols"]', div).val(2),
			widthBox = K('[name="width"]', div).val(100),
			heightBox = K('[name="height"]', div),
			widthTypeBox = K('[name="widthType"]', div),
			heightTypeBox = K('[name="heightType"]', div),
			paddingBox = K('[name="padding"]', div).val(2),
			spacingBox = K('[name="spacing"]', div).val(0),
			alignBox = K('[name="align"]', div),
			borderBox = K('[name="border"]', div).val(1),
			colorBox = K('.ke-input-color', div);
			_initColorPicker(div, colorBox.eq(0));
			_initColorPicker(div, colorBox.eq(1));
			_setColor(colorBox.eq(0), '#000000');
			_setColor(colorBox.eq(1), '');
			
			rowsBox[0].focus();
			rowsBox[0].select();
			var table;
			if (isInsert) {
				return;
			}
			
			table = self.plugin.getSelectedTable();
			if (table) {
				rowsBox.val(table[0].rows.length);
				colsBox.val(table[0].rows.length > 0 ? table[0].rows[0].cells.length : 0);
				rowsBox.attr('disabled', true);
				colsBox.attr('disabled', true);
				var match,
					tableWidth = table[0].style.width || table[0].width,
					tableHeight = table[0].style.height || table[0].height;
				if (tableWidth !== undefined && (match = /^(\d+)((?:px|%)*)$/.exec(tableWidth))) {
					widthBox.val(match[1]);
					widthTypeBox.val(match[2]);
				} else {
					widthBox.val('');
				}
				if (tableHeight !== undefined && (match = /^(\d+)((?:px|%)*)$/.exec(tableHeight))) {
					heightBox.val(match[1]);
					heightTypeBox.val(match[2]);
				}
				paddingBox.val(table[0].cellPadding || '');
				spacingBox.val(table[0].cellSpacing || '');
				alignBox.val(table[0].align || '');
				borderBox.val(table[0].border === undefined ? '' : table[0].border);
				_setColor(colorBox.eq(0), K.toHex(table.attr('borderColor') || ''));
				_setColor(colorBox.eq(1), K.toHex(table[0].style.backgroundColor || table[0].bgColor || ''));
				widthBox[0].focus();
				widthBox[0].select();
			}
		},
		
		cellprop : function() {
			var html = [
				'<div style="padding:20px;">',
				
				'<div class="ke-dialog-row">',
				'<label for="keWidth" style="width:90px;">' + lang.size + '</label>',
				lang.width + ' <input type="text" id="keWidth" class="ke-input-text ke-input-number" name="width" value="" maxlength="4" /> &nbsp; ',
				'<select name="widthType">',
				'<option value="%">' + lang.percent + '</option>',
				'<option value="px">' + lang.px + '</option>',
				'</select> &nbsp; ',
				lang.height + ' <input type="text" class="ke-input-text ke-input-number" name="height" value="" maxlength="4" /> &nbsp; ',
				'<select name="heightType">',
				'<option value="%">' + lang.percent + '</option>',
				'<option value="px">' + lang.px + '</option>',
				'</select>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keAlign" style="width:90px;">' + lang.align + '</label>',
				lang.textAlign + ' <select id="keAlign" name="textAlign">',
				'<option value="">' + lang.alignDefault + '</option>',
				'<option value="left">' + lang.alignLeft + '</option>',
				'<option value="center">' + lang.alignCenter + '</option>',
				'<option value="right">' + lang.alignRight + '</option>',
				'</select> ',
				lang.verticalAlign + ' <select name="verticalAlign">',
				'<option value="">' + lang.alignDefault + '</option>',
				'<option value="top">' + lang.alignTop + '</option>',
				'<option value="middle">' + lang.alignMiddle + '</option>',
				'<option value="bottom">' + lang.alignBottom + '</option>',
				'<option value="baseline">' + lang.alignBaseline + '</option>',
				'</select>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keBorder" style="width:90px;">' + lang.border + '</label>',
				lang.borderWidth + ' <input type="text" id="keBorder" class="ke-input-text ke-input-number" name="border" value="" maxlength="4" /> &nbsp; ',
				lang.borderColor + ' <span class="ke-inline-block ke-input-color"></span>',
				'</div>',
				
				'<div class="ke-dialog-row">',
				'<label for="keBgColor" style="width:90px;">' + lang.backgroundColor + '</label>',
				'<span class="ke-inline-block ke-input-color"></span>',
				'</div>',
				'</div>'
			].join('');
			var dialog = self.createDialog({
				name : name,
				width : 500,
				title : self.lang('tablecell'),
				body : html,
				beforeRemove : function() {
					colorBox.unbind();
				},
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var width = widthBox.val(),
							height = heightBox.val(),
							widthType = widthTypeBox.val(),
							heightType = heightTypeBox.val(),
							padding = paddingBox.val(),
							spacing = spacingBox.val(),
							textAlign = textAlignBox.val(),
							verticalAlign = verticalAlignBox.val(),
							border = borderBox.val(),
							borderColor = K(colorBox[0]).html() || '',
							bgColor = K(colorBox[1]).html() || '';
						if (!/^\d*$/.test(width)) {
							alert(self.lang('invalidWidth'));
							widthBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(height)) {
							alert(self.lang('invalidHeight'));
							heightBox[0].focus();
							return;
						}
						if (!/^\d*$/.test(border)) {
							alert(self.lang('invalidBorder'));
							borderBox[0].focus();
							return;
						}
						cell.css({
							width : width !== '' ? (width + widthType) : '',
							height : height !== '' ? (height + heightType) : '',
							'background-color' : bgColor,
							'text-align' : textAlign,
							'vertical-align' : verticalAlign,
							'border-width' : border,
							'border-style' : border !== '' ? 'solid' : '',
							'border-color' : borderColor
						});
						self.hideDialog().focus();
						self.addBookmark();
					}
				}
			}),
			div = dialog.div,
			widthBox = K('[name="width"]', div).val(100),
			heightBox = K('[name="height"]', div),
			widthTypeBox = K('[name="widthType"]', div),
			heightTypeBox = K('[name="heightType"]', div),
			paddingBox = K('[name="padding"]', div).val(2),
			spacingBox = K('[name="spacing"]', div).val(0),
			textAlignBox = K('[name="textAlign"]', div),
			verticalAlignBox = K('[name="verticalAlign"]', div),
			borderBox = K('[name="border"]', div).val(1),
			colorBox = K('.ke-input-color', div);
			_initColorPicker(div, colorBox.eq(0));
			_initColorPicker(div, colorBox.eq(1));
			_setColor(colorBox.eq(0), '#000000');
			_setColor(colorBox.eq(1), '');
			
			widthBox[0].focus();
			widthBox[0].select();
			
			var cell = self.plugin.getSelectedCell();
			var match,
				cellWidth = cell[0].style.width || cell[0].width || '',
				cellHeight = cell[0].style.height || cell[0].height || '';
			if ((match = /^(\d+)((?:px|%)*)$/.exec(cellWidth))) {
				widthBox.val(match[1]);
				widthTypeBox.val(match[2]);
			} else {
				widthBox.val('');
			}
			if ((match = /^(\d+)((?:px|%)*)$/.exec(cellHeight))) {
				heightBox.val(match[1]);
				heightTypeBox.val(match[2]);
			}
			textAlignBox.val(cell[0].style.textAlign || '');
			verticalAlignBox.val(cell[0].style.verticalAlign || '');
			var border = cell[0].style.borderWidth || '';
			if (border) {
				border = parseInt(border);
			}
			borderBox.val(border);
			_setColor(colorBox.eq(0), K.toHex(cell[0].style.borderColor || ''));
			_setColor(colorBox.eq(1), K.toHex(cell[0].style.backgroundColor || ''));
			widthBox[0].focus();
			widthBox[0].select();
		},
		insert : function() {
			this.prop(true);
		},
		'delete' : function() {
			var table = self.plugin.getSelectedTable();
			self.cmd.range.setStartBefore(table[0]).collapse(true);
			self.cmd.select();
			table.remove();
			self.addBookmark();
		},
		colinsert : function(offset) {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				index = cell.cellIndex + offset;
			
			index += table.rows[0].cells.length - row.cells.length;

			for (var i = 0, len = table.rows.length; i < len; i++) {
				var newRow = table.rows[i],
					newCell = newRow.insertCell(index);
				newCell.innerHTML = K.IE ? '' : '<br />';
				
				index = _getCellIndex(table, newRow, newCell);
			}
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		colinsertleft : function() {
			this.colinsert(0);
		},
		colinsertright : function() {
			this.colinsert(1);
		},
		rowinsert : function(offset) {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0];
			var rowIndex = row.rowIndex;
			if (offset === 1) {
				rowIndex = row.rowIndex + (cell.rowSpan - 1) + offset;
			}
			var newRow = table.insertRow(rowIndex);

			for (var i = 0, len = row.cells.length; i < len; i++) {
				
				if (row.cells[i].rowSpan > 1) {
					len -= row.cells[i].rowSpan - 1;
				}
				var newCell = newRow.insertCell(i);
				
				if (offset === 1 && row.cells[i].colSpan > 1) {
					newCell.colSpan = row.cells[i].colSpan;
				}
				newCell.innerHTML = K.IE ? '' : '<br />';
			}
			
			for (var j = rowIndex; j >= 0; j--) {
				var cells = table.rows[j].cells;
				if (cells.length > i) {
					for (var k = cell.cellIndex; k >= 0; k--) {
						if (cells[k].rowSpan > 1) {
							cells[k].rowSpan += 1;
						}
					}
					break;
				}
			}
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		rowinsertabove : function() {
			this.rowinsert(0);
		},
		rowinsertbelow : function() {
			this.rowinsert(1);
		},
		rowmerge : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				rowIndex = row.rowIndex, 
				nextRowIndex = rowIndex + cell.rowSpan, 
				nextRow = table.rows[nextRowIndex]; 
			
			if (table.rows.length <= nextRowIndex) {
				return;
			}
			var cellIndex = cell.cellIndex; 
			if (nextRow.cells.length <= cellIndex) {
				return;
			}
			var nextCell = nextRow.cells[cellIndex]; 
			
			if (cell.colSpan !== nextCell.colSpan) {
				return;
			}
			cell.rowSpan += nextCell.rowSpan;
			nextRow.deleteCell(cellIndex);
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		colmerge : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				rowIndex = row.rowIndex, 
				cellIndex = cell.cellIndex,
				nextCellIndex = cellIndex + 1;
			
			if (row.cells.length <= nextCellIndex) {
				return;
			}
			var nextCell = row.cells[nextCellIndex];
			
			if (cell.rowSpan !== nextCell.rowSpan) {
				return;
			}
			cell.colSpan += nextCell.colSpan;
			row.deleteCell(nextCellIndex);
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		rowsplit : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				rowIndex = row.rowIndex;
			
			if (cell.rowSpan === 1) {
				return;
			}
			var cellIndex = _getCellIndex(table, row, cell);
			for (var i = 1, len = cell.rowSpan; i < len; i++) {
				var newRow = table.rows[rowIndex + i],
					newCell = newRow.insertCell(cellIndex);
				if (cell.colSpan > 1) {
					newCell.colSpan = cell.colSpan;
				}
				newCell.innerHTML = K.IE ? '' : '<br />';
				
				cellIndex = _getCellIndex(table, newRow, newCell);
			}
			K(cell).removeAttr('rowSpan');
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		colsplit : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				cellIndex = cell.cellIndex;
			
			if (cell.colSpan === 1) {
				return;
			}
			for (var i = 1, len = cell.colSpan; i < len; i++) {
				var newCell = row.insertCell(cellIndex + i);
				if (cell.rowSpan > 1) {
					newCell.rowSpan = cell.rowSpan;
				}
				newCell.innerHTML = K.IE ? '' : '<br />';
			}
			K(cell).removeAttr('colSpan');
			self.cmd.range.selectNodeContents(cell).collapse(true);
			self.cmd.select();
			self.addBookmark();
		},
		coldelete : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				index = cell.cellIndex;
			for (var i = 0, len = table.rows.length; i < len; i++) {
				var newRow = table.rows[i],
					newCell = newRow.cells[index];
				if (newCell.colSpan > 1) {
					newCell.colSpan -= 1;
					if (newCell.colSpan === 1) {
						K(newCell).removeAttr('colSpan');
					}
				} else {
					newRow.deleteCell(index);
				}
				
				if (newCell.rowSpan > 1) {
					i += newCell.rowSpan - 1;
				}
			}
			if (row.cells.length === 0) {
				self.cmd.range.setStartBefore(table).collapse(true);
				self.cmd.select();
				K(table).remove();
			} else {
				self.cmd.selection(true);
			}
			self.addBookmark();
		},
		rowdelete : function() {
			var table = self.plugin.getSelectedTable()[0],
				row = self.plugin.getSelectedRow()[0],
				cell = self.plugin.getSelectedCell()[0],
				rowIndex = row.rowIndex;
			
			for (var i = cell.rowSpan - 1; i >= 0; i--) {
				table.deleteRow(rowIndex + i);
			}
			if (table.rows.length === 0) {
				self.cmd.range.setStartBefore(table).collapse(true);
				self.cmd.select();
				K(table).remove();
			} else {
				self.cmd.selection(true);
			}
			self.addBookmark();
		}
	};
	self.clickToolbar(name, self.plugin.table.prop);
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('template', function(K) {
	var self = this, name = 'template', lang = self.lang(name + '.'),
		htmlPath = self.pluginsPath + name + '/html/';
	function getFilePath(fileName) {
		return htmlPath + fileName + '?ver=' + encodeURIComponent(K.DEBUG ? K.TIME : K.VERSION);
	}
	self.clickToolbar(name, function() {
		var lang = self.lang(name + '.'),
			arr = ['<div style="padding:10px 20px;">',
				'<div class="ke-header">',
				
				'<div class="ke-left">',
				lang. selectTemplate + ' <select>'];
			K.each(lang.fileList, function(key, val) {
				arr.push('<option value="' + key + '">' + val + '</option>');
			});
			html = [arr.join(''),
				'</select></div>',
				
				'<div class="ke-right">',
				'<input type="checkbox" id="keReplaceFlag" name="replaceFlag" value="1" /> <label for="keReplaceFlag">' + lang.replaceContent + '</label>',
				'</div>',
				'<div class="ke-clearfix"></div>',
				'</div>',
				'<iframe class="ke-textarea" frameborder="0" style="width:458px;height:260px;background-color:#FFF;"></iframe>',
				'</div>'].join('');
		var dialog = self.createDialog({
			name : name,
			width : 500,
			title : self.lang(name),
			body : html,
			yesBtn : {
				name : self.lang('yes'),
				click : function(e) {
					var doc = K.iframeDoc(iframe);
					self[checkbox[0].checked ? 'html' : 'insertHtml'](doc.body.innerHTML).hideDialog().focus();
				}
			}
		});
		var selectBox = K('select', dialog.div),
			checkbox = K('[name="replaceFlag"]', dialog.div),
			iframe = K('iframe', dialog.div);
		checkbox[0].checked = true;
		iframe.attr('src', getFilePath(selectBox.val()));
		selectBox.change(function() {
			iframe.attr('src', getFilePath(this.value));
		});
	});
});
/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http:
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.plugin('wordpaste', function(K) {
	var self = this, name = 'wordpaste';
	self.clickToolbar(name, function() {
		var lang = self.lang(name + '.'),
			html = '<div style="padding:10px 20px;">' +
				'<div style="margin-bottom:10px;">' + lang.comment + '</div>' +
				'<iframe class="ke-textarea" frameborder="0" style="width:408px;height:260px;"></iframe>' +
				'</div>',
			dialog = self.createDialog({
				name : name,
				width : 450,
				title : self.lang(name),
				body : html,
				yesBtn : {
					name : self.lang('yes'),
					click : function(e) {
						var str = doc.body.innerHTML;
						str = K.clearMsWord(str, self.filterMode ? self.htmlTags : K.options.htmlTags);
						self.insertHtml(str).hideDialog().focus();
					}
				}
			}),
			div = dialog.div,
			iframe = K('iframe', div),
			doc = K.iframeDoc(iframe);
		if (!K.IE) {
			doc.designMode = 'on';
		}
		doc.open();
		doc.write('<!doctype html><html><head><title>WordPaste</title></head>');
		doc.write('<body style="background-color:#FFF;font-size:12px;margin:2px;">');
		if (!K.IE) {
			doc.write('<br />');
		}
		doc.write('</body></html>');
		doc.close();
		if (K.IE) {
			doc.body.contentEditable = 'true';
		}
		iframe[0].contentWindow.focus();
	});
});



(function () {
    'use strict';

    var kindeditor = angular.module('kindeditor', ['oc.lazyLoad']);

    kindeditor.directive('kindEditor', ['$ocLazyLoad',function ($ocLazyLoad) {
    	return{
    		restrict: 'AE',
    		require: '?ngModel',
    		link: function (scope, element, attrs, ctrl) {
    				var _initContent, editor;
    				var fexUE = {
    						initEditor: function () {
    							editor = KindEditor.create(element[0],
    									{
    								width: '100%',
    								height: '400px',
    								resizeType: 1,
    								allowUpload : true, 
    								allowFileManager : true,
    								uploadJson:"api_file/upload.do?actionKindMethod=process",
    								extraFileUploadParams:{ businessId: getUUID() ,systemHeader:'busi'},
    								afterChange: function () {
    									ctrl.$setViewValue(this.html());
    								},
    							   items : [ 'undo', 'redo','preview','wordpaste','|', 'justifyleft', 'justifycenter',
    										'justifyright', 'justifyfull', 'insertorderedlist',
    										'insertunorderedlist', 'indent', 'outdent', '|',
    										'clearhtml', 'quickformat', 'selectall', 'link', 'unlink','|',
    										'formatblock', 'fontname', 'fontsize', '|', 'forecolor',
    										'hilitecolor', 'bold', 'italic', 'underline',
    										'strikethrough', 'lineheight', 'removeformat', '|',
    										'image',  'table', 'hr', 
    										'pagebreak' ],
    									});
    						},
    						setContent: function (content) {
    							if (editor) {
    								editor.html(content);
    							}
    						}
    				}
    				if (!ctrl) {
    					return;
    				}
    				_initContent = ctrl.$viewValue;
    				ctrl.$render = function () {
    					_initContent = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
    					fexUE.setContent(_initContent);
    				};
    				fexUE.initEditor();
    		}
    	};
    }]);

})();






/*******************************************************************************
* KindEditor - WYSIWYG HTML Editor for Internet
* Copyright (C) 2006-2011 kindsoft.net
*
* @author Roddy <luolonghao@gmail.com>
* @site http://www.kindsoft.net/
* @licence http://www.kindsoft.net/license.php
*******************************************************************************/

KindEditor.lang({
	source : 'HTML代码',
	preview : '预览',
	undo : '后退(Ctrl+Z)',
	redo : '前进(Ctrl+Y)',
	cut : '剪切(Ctrl+X)',
	copy : '复制(Ctrl+C)',
	paste : '粘贴(Ctrl+V)',
	plainpaste : '粘贴为无格式文本',
	wordpaste : '从Word粘贴',
	selectall : '全选(Ctrl+A)',
	justifyleft : '左对齐',
	justifycenter : '居中',
	justifyright : '右对齐',
	justifyfull : '两端对齐',
	insertorderedlist : '编号',
	insertunorderedlist : '项目符号',
	indent : '增加缩进',
	outdent : '减少缩进',
	subscript : '下标',
	superscript : '上标',
	formatblock : '段落',
	fontname : '字体',
	fontsize : '文字大小',
	forecolor : '文字颜色',
	hilitecolor : '文字背景',
	bold : '粗体(Ctrl+B)',
	italic : '斜体(Ctrl+I)',
	underline : '下划线(Ctrl+U)',
	strikethrough : '删除线',
	removeformat : '删除格式',
	image : '图片',
	multiimage : '批量图片上传',
	flash : 'Flash',
	media : '视音频',
	table : '表格',
	tablecell : '单元格',
	hr : '插入横线',
	emoticons : '插入表情',
	link : '超级链接',
	unlink : '取消超级链接',
	fullscreen : '全屏显示',
	about : '关于',
	print : '打印(Ctrl+P)',
	filemanager : '文件空间',
	code : '插入程序代码',
	map : 'Google地图',
	baidumap : '百度地图',
	lineheight : '行距',
	clearhtml : '清理HTML代码',
	pagebreak : '插入分页符',
	quickformat : '一键排版',
	insertfile : '插入文件',
	template : '插入模板',
	anchor : '锚点',
	yes : '确定',
	no : '取消',
	close : '关闭',
	editImage : '图片属性',
	deleteImage : '删除图片',
	editFlash : 'Flash属性',
	deleteFlash : '删除Flash',
	editMedia : '视音频属性',
	deleteMedia : '删除视音频',
	editLink : '超级链接属性',
	deleteLink : '取消超级链接',
	editAnchor : '锚点属性',
	deleteAnchor : '删除锚点',
	tableprop : '表格属性',
	tablecellprop : '单元格属性',
	tableinsert : '插入表格',
	tabledelete : '删除表格',
	tablecolinsertleft : '左侧插入列',
	tablecolinsertright : '右侧插入列',
	tablerowinsertabove : '上方插入行',
	tablerowinsertbelow : '下方插入行',
	tablerowmerge : '向下合并单元格',
	tablecolmerge : '向右合并单元格',
	tablerowsplit : '拆分行',
	tablecolsplit : '拆分列',
	tablecoldelete : '删除列',
	tablerowdelete : '删除行',
	noColor : '无颜色',
	pleaseSelectFile : '请选择文件。',
	invalidImg : "请输入有效的URL地址。\n只允许jpg,gif,bmp,png格式。",
	invalidMedia : "请输入有效的URL地址。\n只允许swf,flv,mp3,wav,wma,wmv,mid,avi,mpg,asf,rm,rmvb格式。",
	invalidWidth : "宽度必须为数字。",
	invalidHeight : "高度必须为数字。",
	invalidBorder : "边框必须为数字。",
	invalidUrl : "请输入有效的URL地址。",
	invalidRows : '行数为必选项，只允许输入大于0的数字。',
	invalidCols : '列数为必选项，只允许输入大于0的数字。',
	invalidPadding : '边距必须为数字。',
	invalidSpacing : '间距必须为数字。',
	invalidJson : '服务器发生故障。',
	uploadSuccess : '上传成功。',
	cutError : '您的浏览器安全设置不允许使用剪切操作，请使用快捷键(Ctrl+X)来完成。',
	copyError : '您的浏览器安全设置不允许使用复制操作，请使用快捷键(Ctrl+C)来完成。',
	pasteError : '您的浏览器安全设置不允许使用粘贴操作，请使用快捷键(Ctrl+V)来完成。',
	ajaxLoading : '加载中，请稍候 ...',
	uploadLoading : '上传中，请稍候 ...',
	uploadError : '上传错误',
	'plainpaste.comment' : '请使用快捷键(Ctrl+V)把内容粘贴到下面的方框里。',
	'wordpaste.comment' : '请使用快捷键(Ctrl+V)把内容粘贴到下面的方框里。',
	'code.pleaseInput' : '请输入程序代码。',
	'link.url' : 'URL',
	'link.linkType' : '打开类型',
	'link.newWindow' : '新窗口',
	'link.selfWindow' : '当前窗口',
	'flash.url' : 'URL',
	'flash.width' : '宽度',
	'flash.height' : '高度',
	'flash.upload' : '上传',
	'flash.viewServer' : '文件空间',
	'media.url' : 'URL',
	'media.width' : '宽度',
	'media.height' : '高度',
	'media.autostart' : '自动播放',
	'media.upload' : '上传',
	'media.viewServer' : '文件空间',
	'image.remoteImage' : '网络图片',
	'image.localImage' : '本地上传',
	'image.remoteUrl' : '图片地址',
	'image.localUrl' : '上传文件',
	'image.size' : '图片大小',
	'image.width' : '宽',
	'image.height' : '高',
	'image.resetSize' : '重置大小',
	'image.align' : '对齐方式',
	'image.defaultAlign' : '默认方式',
	'image.leftAlign' : '左对齐',
	'image.rightAlign' : '右对齐',
	'image.imgTitle' : '图片说明',
	'image.upload' : '浏览...',
	'image.viewServer' : '图片空间',
	'multiimage.uploadDesc' : '允许用户同时上传<%=uploadLimit%>张图片，单张图片容量不超过<%=sizeLimit%>',
	'multiimage.startUpload' : '开始上传',
	'multiimage.clearAll' : '全部清空',
	'multiimage.insertAll' : '全部插入',
	'multiimage.queueLimitExceeded' : '文件数量超过限制。',
	'multiimage.fileExceedsSizeLimit' : '文件大小超过限制。',
	'multiimage.zeroByteFile' : '无法上传空文件。',
	'multiimage.invalidFiletype' : '文件类型不正确。',
	'multiimage.unknownError' : '发生异常，无法上传。',
	'multiimage.pending' : '等待上传',
	'multiimage.uploadError' : '上传失败',
	'filemanager.emptyFolder' : '空文件夹',
	'filemanager.moveup' : '移到上一级文件夹',
	'filemanager.viewType' : '显示方式：',
	'filemanager.viewImage' : '缩略图',
	'filemanager.listImage' : '详细信息',
	'filemanager.orderType' : '排序方式：',
	'filemanager.fileName' : '名称',
	'filemanager.fileSize' : '大小',
	'filemanager.fileType' : '类型',
	'insertfile.url' : 'URL',
	'insertfile.title' : '文件说明',
	'insertfile.upload' : '上传',
	'insertfile.viewServer' : '文件空间',
	'table.cells' : '单元格数',
	'table.rows' : '行数',
	'table.cols' : '列数',
	'table.size' : '大小',
	'table.width' : '宽度',
	'table.height' : '高度',
	'table.percent' : '%',
	'table.px' : 'px',
	'table.space' : '边距间距',
	'table.padding' : '边距',
	'table.spacing' : '间距',
	'table.align' : '对齐方式',
	'table.textAlign' : '水平对齐',
	'table.verticalAlign' : '垂直对齐',
	'table.alignDefault' : '默认',
	'table.alignLeft' : '左对齐',
	'table.alignCenter' : '居中',
	'table.alignRight' : '右对齐',
	'table.alignTop' : '顶部',
	'table.alignMiddle' : '中部',
	'table.alignBottom' : '底部',
	'table.alignBaseline' : '基线',
	'table.border' : '边框',
	'table.borderWidth' : '边框',
	'table.borderColor' : '颜色',
	'table.backgroundColor' : '背景颜色',
	'map.address' : '地址: ',
	'map.search' : '搜索',
	'baidumap.address' : '地址: ',
	'baidumap.search' : '搜索',
	'baidumap.insertDynamicMap' : '插入动态地图',
	'anchor.name' : '锚点名称',
	'formatblock.formatBlock' : {
		h1 : '标题 1',
		h2 : '标题 2',
		h3 : '标题 3',
		h4 : '标题 4',
		p : '正 文'
	},
	'fontname.fontName' : {
		'SimSun' : '宋体',
		'NSimSun' : '新宋体',
		'FangSong_GB2312' : '仿宋_GB2312',
		'KaiTi_GB2312' : '楷体_GB2312',
		'SimHei' : '黑体',
		'Microsoft YaHei' : '微软雅黑',
		'Arial' : 'Arial',
		'Arial Black' : 'Arial Black',
		'Times New Roman' : 'Times New Roman',
		'Courier New' : 'Courier New',
		'Tahoma' : 'Tahoma',
		'Verdana' : 'Verdana'
	},
	'lineheight.lineHeight' : [
		{'1' : '单倍行距'},
		{'1.5' : '1.5倍行距'},
		{'2' : '2倍行距'},
		{'2.5' : '2.5倍行距'},
		{'3' : '3倍行距'}
	],
	'template.selectTemplate' : '可选模板',
	'template.replaceContent' : '替换当前内容',
	'template.fileList' : {
		'1.html' : '图片和文字',
		'2.html' : '表格',
		'3.html' : '项目编号'
	}
}, 'zh_CN');

(function(a) { if (typeof define === "function" && define.amd) { define(["jquery"], a) } else { if (typeof exports === "object") { a(require("jquery")) } else { a(jQuery) } } }(function(d, f) { if (!("indexOf" in Array.prototype)) { Array.prototype.indexOf = function(k, j) { if (j === f) { j = 0 } if (j < 0) { j += this.length } if (j < 0) { j = 0 } for (var l = this.length; j < l; j++) { if (j in this && this[j] === k) { return j } } return -1 } }

    function a() { var q, k, p, l, j, n, m, o;
        k = (new Date()).toString();
        p = ((m = k.split("(")[1]) != null ? m.slice(0, -1) : 0) || k.split(" "); if (p instanceof Array) { n = []; for (var l = 0, j = p.length; l < j; l++) { o = p[l]; if ((q = (m = o.match(/\b[A-Z]+\b/)) !== null) ? m[0] : 0) { n.push(q) } } p = n.pop() } return p }

    function h() { return new Date(Date.UTC.apply(Date, arguments)) } var g = function(k, j) { var m = this;
        this.element = d(k);
        this.container = j.container || "body";
        this.language = j.language || this.element.data("date-language") || "en";
        this.language = this.language in e ? this.language : this.language.split("-")[0];
        this.language = this.language in e ? this.language : "en";
        this.isRTL = e[this.language].rtl || false;
        this.formatType = j.formatType || this.element.data("format-type") || "standard";
        this.format = c.parseFormat(j.format || this.element.data("date-format") || e[this.language].format || c.getDefaultFormat(this.formatType, "input"), this.formatType);
        this.isInline = false;
        this.isVisible = false;
        this.isInput = this.element.is("input");
        this.fontAwesome = j.fontAwesome || this.element.data("font-awesome") || false;
        this.bootcssVer = j.bootcssVer || (this.isInput ? (this.element.is(".form-control") ? 3 : 2) : (this.bootcssVer = this.element.is(".input-group") ? 3 : 2));
        this.component = this.element.is(".date") ? (this.bootcssVer === 3 ? this.element.find(".input-group-addon .glyphicon-th, .input-group-addon .glyphicon-time, .input-group-addon .glyphicon-remove, .input-group-addon .glyphicon-calendar, .input-group-addon .fa-calendar, .input-group-addon .fa-clock-o").parent() : this.element.find(".add-on .icon-th, .add-on .icon-time, .add-on .icon-calendar, .add-on .fa-calendar, .add-on .fa-clock-o").parent()) : false;
        this.componentReset = this.element.is(".date") ? (this.bootcssVer === 3 ? this.element.find(".input-group-addon .glyphicon-remove, .input-group-addon .fa-times").parent() : this.element.find(".add-on .icon-remove, .add-on .fa-times").parent()) : false;
        this.hasInput = this.component && this.element.find("input").length; if (this.component && this.component.length === 0) { this.component = false } this.linkField = j.linkField || this.element.data("link-field") || false;
        this.linkFormat = c.parseFormat(j.linkFormat || this.element.data("link-format") || c.getDefaultFormat(this.formatType, "link"), this.formatType);
        this.minuteStep = j.minuteStep || this.element.data("minute-step") || 5;
        this.pickerPosition = j.pickerPosition || this.element.data("picker-position") || "bottom-right";
        this.showMeridian = j.showMeridian || this.element.data("show-meridian") || false;
        this.initialDate = j.initialDate || new Date();
        this.zIndex = j.zIndex || this.element.data("z-index") || f;
        this.title = typeof j.title === "undefined" ? false : j.title;
        this.timezone = j.timezone || a();
        this.icons = { leftArrow: this.fontAwesome ? "fa-arrow-left" : (this.bootcssVer === 3 ? "glyphicon-arrow-left" : "icon-arrow-left"), rightArrow: this.fontAwesome ? "fa-arrow-right" : (this.bootcssVer === 3 ? "glyphicon-arrow-right" : "icon-arrow-right") };
        this.icontype = this.fontAwesome ? "fa" : "glyphicon";
        this._attachEvents();
        this.clickedOutside = function(n) { if (d(n.target).closest(".datetimepicker").length === 0) { m.hide() } };
        this.formatViewType = "datetime"; if ("formatViewType" in j) { this.formatViewType = j.formatViewType } else { if ("formatViewType" in this.element.data()) { this.formatViewType = this.element.data("formatViewType") } } this.minView = 0; if ("minView" in j) { this.minView = j.minView } else { if ("minView" in this.element.data()) { this.minView = this.element.data("min-view") } } this.minView = c.convertViewMode(this.minView);
        this.maxView = c.modes.length - 1; if ("maxView" in j) { this.maxView = j.maxView } else { if ("maxView" in this.element.data()) { this.maxView = this.element.data("max-view") } } this.maxView = c.convertViewMode(this.maxView);
        this.wheelViewModeNavigation = false; if ("wheelViewModeNavigation" in j) { this.wheelViewModeNavigation = j.wheelViewModeNavigation } else { if ("wheelViewModeNavigation" in this.element.data()) { this.wheelViewModeNavigation = this.element.data("view-mode-wheel-navigation") } } this.wheelViewModeNavigationInverseDirection = false; if ("wheelViewModeNavigationInverseDirection" in j) { this.wheelViewModeNavigationInverseDirection = j.wheelViewModeNavigationInverseDirection } else { if ("wheelViewModeNavigationInverseDirection" in this.element.data()) { this.wheelViewModeNavigationInverseDirection = this.element.data("view-mode-wheel-navigation-inverse-dir") } } this.wheelViewModeNavigationDelay = 100; if ("wheelViewModeNavigationDelay" in j) { this.wheelViewModeNavigationDelay = j.wheelViewModeNavigationDelay } else { if ("wheelViewModeNavigationDelay" in this.element.data()) { this.wheelViewModeNavigationDelay = this.element.data("view-mode-wheel-navigation-delay") } } this.startViewMode = 2; if ("startView" in j) { this.startViewMode = j.startView } else { if ("startView" in this.element.data()) { this.startViewMode = this.element.data("start-view") } } this.startViewMode = c.convertViewMode(this.startViewMode);
        this.viewMode = this.startViewMode;
        this.viewSelect = this.minView; if ("viewSelect" in j) { this.viewSelect = j.viewSelect } else { if ("viewSelect" in this.element.data()) { this.viewSelect = this.element.data("view-select") } } this.viewSelect = c.convertViewMode(this.viewSelect);
        this.forceParse = true; if ("forceParse" in j) { this.forceParse = j.forceParse } else { if ("dateForceParse" in this.element.data()) { this.forceParse = this.element.data("date-force-parse") } } var l = this.bootcssVer === 3 ? c.templateV3 : c.template; while (l.indexOf("{iconType}") !== -1) { l = l.replace("{iconType}", this.icontype) } while (l.indexOf("{leftArrow}") !== -1) { l = l.replace("{leftArrow}", this.icons.leftArrow) } while (l.indexOf("{rightArrow}") !== -1) { l = l.replace("{rightArrow}", this.icons.rightArrow) } this.picker = d(l).appendTo(this.isInline ? this.element : this.container).on({ click: d.proxy(this.click, this), mousedown: d.proxy(this.mousedown, this) }); if (this.wheelViewModeNavigation) { if (d.fn.mousewheel) { this.picker.on({ mousewheel: d.proxy(this.mousewheel, this) }) } else { console.log("Mouse Wheel event is not supported. Please include the jQuery Mouse Wheel plugin before enabling this option") } } if (this.isInline) { this.picker.addClass("datetimepicker-inline") } else { this.picker.addClass("datetimepicker-dropdown-" + this.pickerPosition + " dropdown-menu") } if (this.isRTL) { this.picker.addClass("datetimepicker-rtl"); var i = this.bootcssVer === 3 ? ".prev span, .next span" : ".prev i, .next i";
            this.picker.find(i).toggleClass(this.icons.leftArrow + " " + this.icons.rightArrow) } d(document).on("mousedown touchend", this.clickedOutside);
        this.autoclose = false; if ("autoclose" in j) { this.autoclose = j.autoclose } else { if ("dateAutoclose" in this.element.data()) { this.autoclose = this.element.data("date-autoclose") } } this.keyboardNavigation = true; if ("keyboardNavigation" in j) { this.keyboardNavigation = j.keyboardNavigation } else { if ("dateKeyboardNavigation" in this.element.data()) { this.keyboardNavigation = this.element.data("date-keyboard-navigation") } } this.todayBtn = (j.todayBtn || this.element.data("date-today-btn") || false);
        this.clearBtn = (j.clearBtn || this.element.data("date-clear-btn") || false);
        this.todayHighlight = (j.todayHighlight || this.element.data("date-today-highlight") || false);
        this.weekStart = 0; if (typeof j.weekStart !== "undefined") { this.weekStart = j.weekStart } else { if (typeof this.element.data("date-weekstart") !== "undefined") { this.weekStart = this.element.data("date-weekstart") } else { if (typeof e[this.language].weekStart !== "undefined") { this.weekStart = e[this.language].weekStart } } } this.weekStart = this.weekStart % 7;
        this.weekEnd = ((this.weekStart + 6) % 7);
        this.onRenderDay = function(n) { var p = (j.onRenderDay || function() { return [] })(n); if (typeof p === "string") { p = [p] } var o = ["day"]; return o.concat((p ? p : [])) };
        this.onRenderHour = function(n) { var p = (j.onRenderHour || function() { return [] })(n); var o = ["hour"]; if (typeof p === "string") { p = [p] } return o.concat((p ? p : [])) };
        this.onRenderMinute = function(n) { var p = (j.onRenderMinute || function() { return [] })(n); var o = ["minute"]; if (typeof p === "string") { p = [p] } if (n < this.startDate || n > this.endDate) { o.push("disabled") } else { if (Math.floor(this.date.getUTCMinutes() / this.minuteStep) === Math.floor(n.getUTCMinutes() / this.minuteStep)) { o.push("active") } } return o.concat((p ? p : [])) };
        this.onRenderYear = function(o) { var q = (j.onRenderYear || function() { return [] })(o); var p = ["year"]; if (typeof q === "string") { q = [q] } if (this.date.getUTCFullYear() === o.getUTCFullYear()) { p.push("active") } var n = o.getUTCFullYear(); var r = this.endDate.getUTCFullYear(); if (o < this.startDate || n > r) { p.push("disabled") } return p.concat((q ? q : [])) };
        this.onRenderMonth = function(n) { var p = (j.onRenderMonth || function() { return [] })(n); var o = ["month"]; if (typeof p === "string") { p = [p] } return o.concat((p ? p : [])) };
        this.startDate = new Date(-8639968443048000);
        this.endDate = new Date(8639968443048000);
        this.datesDisabled = [];
        this.daysOfWeekDisabled = [];
        this.setStartDate(j.startDate || this.element.data("date-startdate"));
        this.setEndDate(j.endDate || this.element.data("date-enddate"));
        this.setDatesDisabled(j.datesDisabled || this.element.data("date-dates-disabled"));
        this.setDaysOfWeekDisabled(j.daysOfWeekDisabled || this.element.data("date-days-of-week-disabled"));
        this.setMinutesDisabled(j.minutesDisabled || this.element.data("date-minute-disabled"));
        this.setHoursDisabled(j.hoursDisabled || this.element.data("date-hour-disabled"));
        this.fillDow();
        this.fillMonths();
        this.update();
        this.showMode(); if (this.isInline) { this.show() } };
    g.prototype = { constructor: g, _events: [], _attachEvents: function() { this._detachEvents(); if (this.isInput) { this._events = [
                    [this.element, { focus: d.proxy(this.show, this), keyup: d.proxy(this.update, this), keydown: d.proxy(this.keydown, this) }]
                ] } else { if (this.component && this.hasInput) { this._events = [
                        [this.element.find("input"), { focus: d.proxy(this.show, this), keyup: d.proxy(this.update, this), keydown: d.proxy(this.keydown, this) }],
                        [this.component, { click: d.proxy(this.show, this) }]
                    ]; if (this.componentReset) { this._events.push([this.componentReset, { click: d.proxy(this.reset, this) }]) } } else { if (this.element.is("div")) { this.isInline = true } else { this._events = [
                            [this.element, { click: d.proxy(this.show, this) }]
                        ] } } } for (var j = 0, k, l; j < this._events.length; j++) { k = this._events[j][0];
                l = this._events[j][1];
                k.on(l) } }, _detachEvents: function() { for (var j = 0, k, l; j < this._events.length; j++) { k = this._events[j][0];
                l = this._events[j][1];
                k.off(l) } this._events = [] }, show: function(i) { this.picker.show();
            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight(); if (this.forceParse) { this.update() } this.place();
            d(window).on("resize", d.proxy(this.place, this)); if (i) { i.stopPropagation();
                i.preventDefault() } this.isVisible = true;
            this.element.trigger({ type: "show", date: this.date }) }, hide: function() { if (!this.isVisible) { return } if (this.isInline) { return } this.picker.hide();
            d(window).off("resize", this.place);
            this.viewMode = this.startViewMode;
            this.showMode(); if (!this.isInput) { d(document).off("mousedown", this.hide) } if (this.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find("input").val())) { this.setValue() } this.isVisible = false;
            this.element.trigger({ type: "hide", date: this.date }) }, remove: function() { this._detachEvents();
            d(document).off("mousedown", this.clickedOutside);
            this.picker.remove();
            delete this.picker;
            delete this.element.data().datetimepicker }, getDate: function() { var i = this.getUTCDate(); if (i === null) { return null } return new Date(i.getTime() + (i.getTimezoneOffset() * 60000)) }, getUTCDate: function() { return this.date }, getInitialDate: function() { return this.initialDate }, setInitialDate: function(i) { this.initialDate = i }, setDate: function(i) { this.setUTCDate(new Date(i.getTime() - (i.getTimezoneOffset() * 60000))) }, setUTCDate: function(i) { if (i >= this.startDate && i <= this.endDate) { this.date = i;
                this.setValue();
                this.viewDate = this.date;
                this.fill() } else { this.element.trigger({ type: "outOfRange", date: i, startDate: this.startDate, endDate: this.endDate }) } }, setFormat: function(j) { this.format = c.parseFormat(j, this.formatType); var i; if (this.isInput) { i = this.element } else { if (this.component) { i = this.element.find("input") } } if (i && i.val()) { this.setValue() } }, setValue: function() { var i = this.getFormattedDate(); if (!this.isInput) { if (this.component) { this.element.find("input").val(i) } this.element.data("date", i) } else { this.element.val(i) } if (this.linkField) { d("#" + this.linkField).val(this.getFormattedDate(this.linkFormat)) } }, getFormattedDate: function(i) { i = i || this.format; return c.formatDate(this.date, i, this.language, this.formatType, this.timezone) }, setStartDate: function(i) { this.startDate = i || this.startDate; if (this.startDate.valueOf() !== 8639968443048000) { this.startDate = c.parseDate(this.startDate, this.format, this.language, this.formatType, this.timezone) } this.update();
            this.updateNavArrows() }, setEndDate: function(i) { this.endDate = i || this.endDate; if (this.endDate.valueOf() !== 8639968443048000) { this.endDate = c.parseDate(this.endDate, this.format, this.language, this.formatType, this.timezone) } this.update();
            this.updateNavArrows() }, setDatesDisabled: function(j) { this.datesDisabled = j || []; if (!d.isArray(this.datesDisabled)) { this.datesDisabled = this.datesDisabled.split(/,\s*/) } var i = this;
            this.datesDisabled = d.map(this.datesDisabled, function(k) { return c.parseDate(k, i.format, i.language, i.formatType, i.timezone).toDateString() });
            this.update();
            this.updateNavArrows() }, setTitle: function(i, j) { return this.picker.find(i).find("th:eq(1)").text(this.title === false ? j : this.title) }, setDaysOfWeekDisabled: function(i) { this.daysOfWeekDisabled = i || []; if (!d.isArray(this.daysOfWeekDisabled)) { this.daysOfWeekDisabled = this.daysOfWeekDisabled.split(/,\s*/) } this.daysOfWeekDisabled = d.map(this.daysOfWeekDisabled, function(j) { return parseInt(j, 10) });
            this.update();
            this.updateNavArrows() }, setMinutesDisabled: function(i) { this.minutesDisabled = i || []; if (!d.isArray(this.minutesDisabled)) { this.minutesDisabled = this.minutesDisabled.split(/,\s*/) } this.minutesDisabled = d.map(this.minutesDisabled, function(j) { return parseInt(j, 10) });
            this.update();
            this.updateNavArrows() }, setHoursDisabled: function(i) { this.hoursDisabled = i || []; if (!d.isArray(this.hoursDisabled)) { this.hoursDisabled = this.hoursDisabled.split(/,\s*/) } this.hoursDisabled = d.map(this.hoursDisabled, function(j) { return parseInt(j, 10) });
            this.update();
            this.updateNavArrows() }, place: function() { if (this.isInline) { return } if (!this.zIndex) { var j = 0;
                d("div").each(function() { var o = parseInt(d(this).css("zIndex"), 10); if (o > j) { j = o } });
                this.zIndex = j + 10 } var n, m, l, k; if (this.container instanceof d) { k = this.container.offset() } else { k = d(this.container).offset() } if (this.component) { n = this.component.offset();
                l = n.left; if (this.pickerPosition === "bottom-left" || this.pickerPosition === "top-left") { l += this.component.outerWidth() - this.picker.outerWidth() } } else { n = this.element.offset();
                l = n.left; if (this.pickerPosition === "bottom-left" || this.pickerPosition === "top-left") { l += this.element.outerWidth() - this.picker.outerWidth() } } var i = document.body.clientWidth || window.innerWidth; if (l + 220 > i) { l = i - 220 } if (this.pickerPosition === "top-left" || this.pickerPosition === "top-right") { m = n.top - this.picker.outerHeight() } else { m = n.top + this.height } m = m - k.top;
            l = l - k.left;
            this.picker.css({ top: m, left: l, zIndex: this.zIndex }) }, hour_minute: "^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]", update: function() { var i, j = false; if (arguments && arguments.length && (typeof arguments[0] === "string" || arguments[0] instanceof Date)) { i = arguments[0];
                j = true } else { i = (this.isInput ? this.element.val() : this.element.find("input").val()) || this.element.data("date") || this.initialDate; if (typeof i === "string") { i = i.replace(/^\s+|\s+$/g, "") } } if (!i) { i = new Date();
                j = false } if (typeof i === "string") { if (new RegExp(this.hour_minute).test(i) || new RegExp(this.hour_minute + ":[0-5][0-9]").test(i)) { i = this.getDate() } } this.date = c.parseDate(i, this.format, this.language, this.formatType, this.timezone); if (j) { this.setValue() } if (this.date < this.startDate) { this.viewDate = new Date(this.startDate) } else { if (this.date > this.endDate) { this.viewDate = new Date(this.endDate) } else { this.viewDate = new Date(this.date) } } this.fill() }, fillDow: function() { var i = this.weekStart,
                j = "<tr>"; while (i < this.weekStart + 7) { j += '<th class="dow">' + e[this.language].daysMin[(i++) % 7] + "</th>" } j += "</tr>";
            this.picker.find(".datetimepicker-days thead").append(j) }, fillMonths: function() { var l = ""; var m = new Date(this.viewDate); for (var k = 0; k < 12; k++) { m.setUTCMonth(k); var j = this.onRenderMonth(m);
                l += '<span class="' + j.join(" ") + '">' + e[this.language].monthsShort[k] + "</span>" } this.picker.find(".datetimepicker-months td").html(l) }, fill: function() { if (!this.date || !this.viewDate) { return } var E = new Date(this.viewDate),
                t = E.getUTCFullYear(),
                G = E.getUTCMonth(),
                n = E.getUTCDate(),
                A = E.getUTCHours(),
                w = this.startDate.getUTCFullYear(),
                B = this.startDate.getUTCMonth(),
                p = this.endDate.getUTCFullYear(),
                x = this.endDate.getUTCMonth() + 1,
                q = (new h(this.date.getUTCFullYear(), this.date.getUTCMonth(), this.date.getUTCDate())).valueOf(),
                D = new Date();
            this.setTitle(".datetimepicker-days", e[this.language].months[G] + " " + t); if (this.formatViewType === "time") { var k = this.getFormattedDate();
                this.setTitle(".datetimepicker-hours", k);
                this.setTitle(".datetimepicker-minutes", k) } else { this.setTitle(".datetimepicker-hours", n + " " + e[this.language].months[G] + " " + t);
                this.setTitle(".datetimepicker-minutes", n + " " + e[this.language].months[G] + " " + t) } this.picker.find("tfoot th.today").text(e[this.language].today || e.en.today).toggle(this.todayBtn !== false);
            this.picker.find("tfoot th.clear").text(e[this.language].clear || e.en.clear).toggle(this.clearBtn !== false);
            this.updateNavArrows();
            this.fillMonths(); var I = h(t, G - 1, 28, 0, 0, 0, 0),
                z = c.getDaysInMonth(I.getUTCFullYear(), I.getUTCMonth());
            I.setUTCDate(z);
            I.setUTCDate(z - (I.getUTCDay() - this.weekStart + 7) % 7); var j = new Date(I);
            j.setUTCDate(j.getUTCDate() + 42);
            j = j.valueOf(); var r = []; var F; while (I.valueOf() < j) { if (I.getUTCDay() === this.weekStart) { r.push("<tr>") } F = this.onRenderDay(I); if (I.getUTCFullYear() < t || (I.getUTCFullYear() === t && I.getUTCMonth() < G)) { F.push("old") } else { if (I.getUTCFullYear() > t || (I.getUTCFullYear() === t && I.getUTCMonth() > G)) { F.push("new") } } if (this.todayHighlight && I.getUTCFullYear() === D.getFullYear() && I.getUTCMonth() === D.getMonth() && I.getUTCDate() === D.getDate()) { F.push("today") } if (I.valueOf() === q) { F.push("active") } if ((I.valueOf() + 86400000) <= this.startDate || I.valueOf() > this.endDate || d.inArray(I.getUTCDay(), this.daysOfWeekDisabled) !== -1 || d.inArray(I.toDateString(), this.datesDisabled) !== -1) { F.push("disabled") } r.push('<td class="' + F.join(" ") + '">' + I.getUTCDate() + "</td>"); if (I.getUTCDay() === this.weekEnd) { r.push("</tr>") } I.setUTCDate(I.getUTCDate() + 1) } this.picker.find(".datetimepicker-days tbody").empty().append(r.join(""));
            r = []; var u = "",
                C = "",
                s = ""; var l = this.hoursDisabled || [];
            E = new Date(this.viewDate); for (var y = 0; y < 24; y++) { E.setUTCHours(y);
                F = this.onRenderHour(E); if (l.indexOf(y) !== -1) { F.push("disabled") } var v = h(t, G, n, y); if ((v.valueOf() + 3600000) <= this.startDate || v.valueOf() > this.endDate) { F.push("disabled") } else { if (A === y) { F.push("active") } } if (this.showMeridian && e[this.language].meridiem.length === 2) { C = (y < 12 ? e[this.language].meridiem[0] : e[this.language].meridiem[1]); if (C !== s) { if (s !== "") { r.push("</fieldset>") } r.push('<fieldset class="hour"><legend>' + C.toUpperCase() + "</legend>") } s = C;
                    u = (y % 12 ? y % 12 : 12); if (y < 12) { F.push("hour_am") } else { F.push("hour_pm") } r.push('<span class="' + F.join(" ") + '">' + u + "</span>"); if (y === 23) { r.push("</fieldset>") } } else { u = y + ":00";
                    r.push('<span class="' + F.join(" ") + '">' + u + "</span>") } } this.picker.find(".datetimepicker-hours td").html(r.join(""));
            r = [];
            u = "";
            C = "";
            s = ""; var m = this.minutesDisabled || [];
            E = new Date(this.viewDate); for (var y = 0; y < 60; y += this.minuteStep) { if (m.indexOf(y) !== -1) { continue } E.setUTCMinutes(y);
                E.setUTCSeconds(0);
                F = this.onRenderMinute(E); if (this.showMeridian && e[this.language].meridiem.length === 2) { C = (A < 12 ? e[this.language].meridiem[0] : e[this.language].meridiem[1]); if (C !== s) { if (s !== "") { r.push("</fieldset>") } r.push('<fieldset class="minute"><legend>' + C.toUpperCase() + "</legend>") } s = C;
                    u = (A % 12 ? A % 12 : 12);
                    r.push('<span class="' + F.join(" ") + '">' + u + ":" + (y < 10 ? "0" + y : y) + "</span>"); if (y === 59) { r.push("</fieldset>") } } else { u = y + ":00";
                    r.push('<span class="' + F.join(" ") + '">' + A + ":" + (y < 10 ? "0" + y : y) + "</span>") } } this.picker.find(".datetimepicker-minutes td").html(r.join("")); var J = this.date.getUTCFullYear(); var o = this.setTitle(".datetimepicker-months", t).end().find(".month").removeClass("active"); if (J === t) { o.eq(this.date.getUTCMonth()).addClass("active") } if (t < w || t > p) { o.addClass("disabled") } if (t === w) { o.slice(0, B).addClass("disabled") } if (t === p) { o.slice(x).addClass("disabled") } r = "";
            t = parseInt(t / 10, 10) * 10; var H = this.setTitle(".datetimepicker-years", t + "-" + (t + 9)).end().find("td");
            t -= 1;
            E = new Date(this.viewDate); for (var y = -1; y < 11; y++) { E.setUTCFullYear(t);
                F = this.onRenderYear(E); if (y === -1 || y === 10) { F.push(b) } r += '<span class="' + F.join(" ") + '">' + t + "</span>";
                t += 1 } H.html(r);
            this.place() }, updateNavArrows: function() { var m = new Date(this.viewDate),
                k = m.getUTCFullYear(),
                l = m.getUTCMonth(),
                j = m.getUTCDate(),
                i = m.getUTCHours(); switch (this.viewMode) {
                case 0:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth() && j <= this.startDate.getUTCDate() && i <= this.startDate.getUTCHours()) { this.picker.find(".prev").css({ visibility: "hidden" }) } else { this.picker.find(".prev").css({ visibility: "visible" }) } if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth() && j >= this.endDate.getUTCDate() && i >= this.endDate.getUTCHours()) { this.picker.find(".next").css({ visibility: "hidden" }) } else { this.picker.find(".next").css({ visibility: "visible" }) } break;
                case 1:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth() && j <= this.startDate.getUTCDate()) { this.picker.find(".prev").css({ visibility: "hidden" }) } else { this.picker.find(".prev").css({ visibility: "visible" }) } if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth() && j >= this.endDate.getUTCDate()) { this.picker.find(".next").css({ visibility: "hidden" }) } else { this.picker.find(".next").css({ visibility: "visible" }) } break;
                case 2:
                    if (k <= this.startDate.getUTCFullYear() && l <= this.startDate.getUTCMonth()) { this.picker.find(".prev").css({ visibility: "hidden" }) } else { this.picker.find(".prev").css({ visibility: "visible" }) } if (k >= this.endDate.getUTCFullYear() && l >= this.endDate.getUTCMonth()) { this.picker.find(".next").css({ visibility: "hidden" }) } else { this.picker.find(".next").css({ visibility: "visible" }) } break;
                case 3:
                case 4:
                    if (k <= this.startDate.getUTCFullYear()) { this.picker.find(".prev").css({ visibility: "hidden" }) } else { this.picker.find(".prev").css({ visibility: "visible" }) } if (k >= this.endDate.getUTCFullYear()) { this.picker.find(".next").css({ visibility: "hidden" }) } else { this.picker.find(".next").css({ visibility: "visible" }) } break } }, mousewheel: function(j) { j.preventDefault();
            j.stopPropagation(); if (this.wheelPause) { return } this.wheelPause = true; var i = j.originalEvent; var l = i.wheelDelta; var k = l > 0 ? 1 : (l === 0) ? 0 : -1; if (this.wheelViewModeNavigationInverseDirection) { k = -k } this.showMode(k);
            setTimeout(d.proxy(function() { this.wheelPause = false }, this), this.wheelViewModeNavigationDelay) }, click: function(m) { m.stopPropagation();
            m.preventDefault(); var n = d(m.target).closest("span, td, th, legend"); if (n.is("." + this.icontype)) { n = d(n).parent().closest("span, td, th, legend") } if (n.length === 1) { if (n.is(".disabled")) { this.element.trigger({ type: "outOfRange", date: this.viewDate, startDate: this.startDate, endDate: this.endDate }); return } switch (n[0].nodeName.toLowerCase()) {
                    case "th":
                        switch (n[0].className) {
                            case "switch":
                                this.showMode(1); break;
                            case "prev":
                            case "next":
                                var i = c.modes[this.viewMode].navStep * (n[0].className === "prev" ? -1 : 1); switch (this.viewMode) {
                                    case 0:
                                        this.viewDate = this.moveHour(this.viewDate, i); break;
                                    case 1:
                                        this.viewDate = this.moveDate(this.viewDate, i); break;
                                    case 2:
                                        this.viewDate = this.moveMonth(this.viewDate, i); break;
                                    case 3:
                                    case 4:
                                        this.viewDate = this.moveYear(this.viewDate, i); break } this.fill();
                                this.element.trigger({ type: n[0].className + ":" + this.convertViewModeText(this.viewMode), date: this.viewDate, startDate: this.startDate, endDate: this.endDate }); break;
                            case "clear":
                                this.reset(); if (this.autoclose) { this.hide() } break;
                            case "today":
                                var j = new Date();
                                j = h(j.getFullYear(), j.getMonth(), j.getDate(), j.getHours(), j.getMinutes(), j.getSeconds(), 0); if (j < this.startDate) { j = this.startDate } else { if (j > this.endDate) { j = this.endDate } } this.viewMode = this.startViewMode;
                                this.showMode(0);
                                this._setDate(j);
                                this.fill(); if (this.autoclose) { this.hide() } break } break;
                    case "span":
                        if (!n.is(".disabled")) { var p = this.viewDate.getUTCFullYear(),
                                o = this.viewDate.getUTCMonth(),
                                q = this.viewDate.getUTCDate(),
                                r = this.viewDate.getUTCHours(),
                                k = this.viewDate.getUTCMinutes(),
                                s = this.viewDate.getUTCSeconds(); if (n.is(".month")) { this.viewDate.setUTCDate(1);
                                o = n.parent().find("span").index(n);
                                q = this.viewDate.getUTCDate();
                                this.viewDate.setUTCMonth(o);
                                this.element.trigger({ type: "changeMonth", date: this.viewDate }); if (this.viewSelect >= 3) { this._setDate(h(p, o, q, r, k, s, 0)) } } else { if (n.is(".year")) { this.viewDate.setUTCDate(1);
                                    p = parseInt(n.text(), 10) || 0;
                                    this.viewDate.setUTCFullYear(p);
                                    this.element.trigger({ type: "changeYear", date: this.viewDate }); if (this.viewSelect >= 4) { this._setDate(h(p, o, q, r, k, s, 0)) } } else { if (n.is(".hour")) { r = parseInt(n.text(), 10) || 0; if (n.hasClass("hour_am") || n.hasClass("hour_pm")) { if (r === 12 && n.hasClass("hour_am")) { r = 0 } else { if (r !== 12 && n.hasClass("hour_pm")) { r += 12 } } } this.viewDate.setUTCHours(r);
                                        this.element.trigger({ type: "changeHour", date: this.viewDate }); if (this.viewSelect >= 1) { this._setDate(h(p, o, q, r, k, s, 0)) } } else { if (n.is(".minute")) { k = parseInt(n.text().substr(n.text().indexOf(":") + 1), 10) || 0;
                                            this.viewDate.setUTCMinutes(k);
                                            this.element.trigger({ type: "changeMinute", date: this.viewDate }); if (this.viewSelect >= 0) { this._setDate(h(p, o, q, r, k, s, 0)) } } } } } if (this.viewMode !== 0) { var l = this.viewMode;
                                this.showMode(-1);
                                this.fill(); if (l === this.viewMode && this.autoclose) { this.hide() } } else { this.fill(); if (this.autoclose) { this.hide() } } } break;
                    case "td":
                        if (n.is(".day") && !n.is(".disabled")) { var q = parseInt(n.text(), 10) || 1; var p = this.viewDate.getUTCFullYear(),
                                o = this.viewDate.getUTCMonth(),
                                r = this.viewDate.getUTCHours(),
                                k = this.viewDate.getUTCMinutes(),
                                s = this.viewDate.getUTCSeconds(); if (n.is(".old")) { if (o === 0) { o = 11;
                                    p -= 1 } else { o -= 1 } } else { if (n.is(".new")) { if (o === 11) { o = 0;
                                        p += 1 } else { o += 1 } } } this.viewDate.setUTCFullYear(p);
                            this.viewDate.setUTCMonth(o, q);
                            this.element.trigger({ type: "changeDay", date: this.viewDate }); if (this.viewSelect >= 2) { this._setDate(h(p, o, q, r, k, s, 0)) } } var l = this.viewMode;
                        this.showMode(-1);
                        this.fill(); if (l === this.viewMode && this.autoclose) { this.hide() } break } } }, _setDate: function(i, k) { if (!k || k === "date") { this.date = i } if (!k || k === "view") { this.viewDate = i } this.fill();
            this.setValue(); var j; if (this.isInput) { j = this.element } else { if (this.component) { j = this.element.find("input") } } if (j) { j.change() } this.element.trigger({ type: "changeDate", date: this.getDate() }); if (i === null) { this.date = this.viewDate } }, moveMinute: function(j, i) { if (!i) { return j } var k = new Date(j.valueOf());
            k.setUTCMinutes(k.getUTCMinutes() + (i * this.minuteStep)); return k }, moveHour: function(j, i) { if (!i) { return j } var k = new Date(j.valueOf());
            k.setUTCHours(k.getUTCHours() + i); return k }, moveDate: function(j, i) { if (!i) { return j } var k = new Date(j.valueOf());
            k.setUTCDate(k.getUTCDate() + i); return k }, moveMonth: function(j, k) { if (!k) { return j } var n = new Date(j.valueOf()),
                r = n.getUTCDate(),
                o = n.getUTCMonth(),
                m = Math.abs(k),
                q, p;
            k = k > 0 ? 1 : -1; if (m === 1) { p = k === -1 ? function() { return n.getUTCMonth() === o } : function() { return n.getUTCMonth() !== q };
                q = o + k;
                n.setUTCMonth(q); if (q < 0 || q > 11) { q = (q + 12) % 12 } } else { for (var l = 0; l < m; l++) { n = this.moveMonth(n, k) } q = n.getUTCMonth();
                n.setUTCDate(r);
                p = function() { return q !== n.getUTCMonth() } } while (p()) { n.setUTCDate(--r);
                n.setUTCMonth(q) } return n }, moveYear: function(j, i) { return this.moveMonth(j, i * 12) }, dateWithinRange: function(i) { return i >= this.startDate && i <= this.endDate }, keydown: function(o) { if (this.picker.is(":not(:visible)")) { if (o.keyCode === 27) { this.show() } return } var k = false,
                j, i, n; switch (o.keyCode) {
                case 27:
                    this.hide();
                    o.preventDefault(); break;
                case 37:
                case 39:
                    if (!this.keyboardNavigation) { break } j = o.keyCode === 37 ? -1 : 1; var m = this.viewMode; if (o.ctrlKey) { m += 2 } else { if (o.shiftKey) { m += 1 } } if (m === 4) { i = this.moveYear(this.date, j);
                        n = this.moveYear(this.viewDate, j) } else { if (m === 3) { i = this.moveMonth(this.date, j);
                            n = this.moveMonth(this.viewDate, j) } else { if (m === 2) { i = this.moveDate(this.date, j);
                                n = this.moveDate(this.viewDate, j) } else { if (m === 1) { i = this.moveHour(this.date, j);
                                    n = this.moveHour(this.viewDate, j) } else { if (m === 0) { i = this.moveMinute(this.date, j);
                                        n = this.moveMinute(this.viewDate, j) } } } } } if (this.dateWithinRange(i)) { this.date = i;
                        this.viewDate = n;
                        this.setValue();
                        this.update();
                        o.preventDefault();
                        k = true } break;
                case 38:
                case 40:
                    if (!this.keyboardNavigation) { break } j = o.keyCode === 38 ? -1 : 1;
                    m = this.viewMode; if (o.ctrlKey) { m += 2 } else { if (o.shiftKey) { m += 1 } } if (m === 4) { i = this.moveYear(this.date, j);
                        n = this.moveYear(this.viewDate, j) } else { if (m === 3) { i = this.moveMonth(this.date, j);
                            n = this.moveMonth(this.viewDate, j) } else { if (m === 2) { i = this.moveDate(this.date, j * 7);
                                n = this.moveDate(this.viewDate, j * 7) } else { if (m === 1) { if (this.showMeridian) { i = this.moveHour(this.date, j * 6);
                                        n = this.moveHour(this.viewDate, j * 6) } else { i = this.moveHour(this.date, j * 4);
                                        n = this.moveHour(this.viewDate, j * 4) } } else { if (m === 0) { i = this.moveMinute(this.date, j * 4);
                                        n = this.moveMinute(this.viewDate, j * 4) } } } } } if (this.dateWithinRange(i)) { this.date = i;
                        this.viewDate = n;
                        this.setValue();
                        this.update();
                        o.preventDefault();
                        k = true } break;
                case 13:
                    if (this.viewMode !== 0) { var p = this.viewMode;
                        this.showMode(-1);
                        this.fill(); if (p === this.viewMode && this.autoclose) { this.hide() } } else { this.fill(); if (this.autoclose) { this.hide() } } o.preventDefault(); break;
                case 9:
                    this.hide(); break } if (k) { var l; if (this.isInput) { l = this.element } else { if (this.component) { l = this.element.find("input") } } if (l) { l.change() } this.element.trigger({ type: "changeDate", date: this.getDate() }) } }, showMode: function(i) { if (i) { var j = Math.max(0, Math.min(c.modes.length - 1, this.viewMode + i)); if (j >= this.minView && j <= this.maxView) { this.element.trigger({ type: "changeMode", date: this.viewDate, oldViewMode: this.viewMode, newViewMode: j });
                    this.viewMode = j } } this.picker.find(">div").hide().filter(".datetimepicker-" + c.modes[this.viewMode].clsName).css("display", "block");
            this.updateNavArrows() }, reset: function() { this._setDate(null, "date") }, convertViewModeText: function(i) { switch (i) {
                case 4:
                    return "decade";
                case 3:
                    return "year";
                case 2:
                    return "month";
                case 1:
                    return "day";
                case 0:
                    return "hour" } } }; var b = d.fn.datetimepicker;
    d.fn.datetimepicker = function(k) { var i = Array.apply(null, arguments);
        i.shift(); var j;
        this.each(function() { var n = d(this),
                m = n.data("datetimepicker"),
                l = typeof k === "object" && k; if (!m) { n.data("datetimepicker", (m = new g(this, d.extend({}, d.fn.datetimepicker.defaults, l)))) } if (typeof k === "string" && typeof m[k] === "function") { j = m[k].apply(m, i); if (j !== f) { return false } } }); if (j !== f) { return j } else { return this } };
    d.fn.datetimepicker.defaults = {};
    d.fn.datetimepicker.Constructor = g; var e = d.fn.datetimepicker.dates = { en: { days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期日"], daysShort: ["日", "一", "二", "三", "四", "五", "六", "日"], daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], meridiem: ["am", "pm"], suffix: ["st", "nd", "rd", "th"], today: "Today", clear: "Clear" } }; var c = { modes: [{ clsName: "minutes", navFnc: "Hours", navStep: 1 }, { clsName: "hours", navFnc: "Date", navStep: 1 }, { clsName: "days", navFnc: "Month", navStep: 1 }, { clsName: "months", navFnc: "FullYear", navStep: 1 }, { clsName: "years", navFnc: "FullYear", navStep: 10 }], isLeapYear: function(i) { return (((i % 4 === 0) && (i % 100 !== 0)) || (i % 400 === 0)) }, getDaysInMonth: function(i, j) { return [31, (c.isLeapYear(i) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][j] }, getDefaultFormat: function(i, j) { if (i === "standard") { if (j === "input") { return "yyyy-mm-dd hh:ii" } else { return "yyyy-mm-dd hh:ii:ss" } } else { if (i === "php") { if (j === "input") { return "Y-m-d H:i" } else { return "Y-m-d H:i:s" } } else { throw new Error("Invalid format type.") } } }, validParts: function(i) { if (i === "standard") { return /t|hh?|HH?|p|P|z|Z|ii?|ss?|dd?|DD?|mm?|MM?|yy(?:yy)?/g } else { if (i === "php") { return /[dDjlNwzFmMnStyYaABgGhHis]/g } else { throw new Error("Invalid format type.") } } }, nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g, parseFormat: function(l, j) { var i = l.replace(this.validParts(j), "\0").split("\0"),
                k = l.match(this.validParts(j)); if (!i || !i.length || !k || k.length === 0) { throw new Error("Invalid date format.") } return { separators: i, parts: k } }, parseDate: function(A, y, v, j, r) { if (A instanceof Date) { var u = new Date(A.valueOf() - A.getTimezoneOffset() * 60000);
                u.setMilliseconds(0); return u } if (/^\d{4}\-\d{1,2}\-\d{1,2}$/.test(A)) { y = this.parseFormat("yyyy-mm-dd", j) } if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(A)) { y = this.parseFormat("yyyy-mm-dd hh:ii", j) } if (/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(A)) { y = this.parseFormat("yyyy-mm-dd hh:ii:ss", j) } if (/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(A)) { var l = /([-+]\d+)([dmwy])/,
                    q = A.match(/([-+]\d+)([dmwy])/g),
                    t, p;
                A = new Date(); for (var x = 0; x < q.length; x++) { t = l.exec(q[x]);
                    p = parseInt(t[1]); switch (t[2]) {
                        case "d":
                            A.setUTCDate(A.getUTCDate() + p); break;
                        case "m":
                            A = g.prototype.moveMonth.call(g.prototype, A, p); break;
                        case "w":
                            A.setUTCDate(A.getUTCDate() + p * 7); break;
                        case "y":
                            A = g.prototype.moveYear.call(g.prototype, A, p); break } } return h(A.getUTCFullYear(), A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), 0) } var q = A && A.toString().match(this.nonpunctuation) || [],
                A = new Date(0, 0, 0, 0, 0, 0, 0),
                m = {},
                z = ["hh", "h", "ii", "i", "ss", "s", "yyyy", "yy", "M", "MM", "m", "mm", "D", "DD", "d", "dd", "H", "HH", "p", "P", "z", "Z"],
                o = { hh: function(s, i) { return s.setUTCHours(i) }, h: function(s, i) { return s.setUTCHours(i) }, HH: function(s, i) { return s.setUTCHours(i === 12 ? 0 : i) }, H: function(s, i) { return s.setUTCHours(i === 12 ? 0 : i) }, ii: function(s, i) { return s.setUTCMinutes(i) }, i: function(s, i) { return s.setUTCMinutes(i) }, ss: function(s, i) { return s.setUTCSeconds(i) }, s: function(s, i) { return s.setUTCSeconds(i) }, yyyy: function(s, i) { return s.setUTCFullYear(i) }, yy: function(s, i) { return s.setUTCFullYear(2000 + i) }, m: function(s, i) { i -= 1; while (i < 0) { i += 12 } i %= 12;
                        s.setUTCMonth(i); while (s.getUTCMonth() !== i) { if (isNaN(s.getUTCMonth())) { return s } else { s.setUTCDate(s.getUTCDate() - 1) } } return s }, d: function(s, i) { return s.setUTCDate(i) }, p: function(s, i) { return s.setUTCHours(i === 1 ? s.getUTCHours() + 12 : s.getUTCHours()) }, z: function() { return r } },
                B, k, t;
            o.M = o.MM = o.mm = o.m;
            o.dd = o.d;
            o.P = o.p;
            o.Z = o.z;
            A = h(A.getFullYear(), A.getMonth(), A.getDate(), A.getHours(), A.getMinutes(), A.getSeconds()); if (q.length === y.parts.length) { for (var x = 0, w = y.parts.length; x < w; x++) { B = parseInt(q[x], 10);
                    t = y.parts[x]; if (isNaN(B)) { switch (t) {
                            case "MM":
                                k = d(e[v].months).filter(function() { var i = this.slice(0, q[x].length),
                                        s = q[x].slice(0, i.length); return i === s });
                                B = d.inArray(k[0], e[v].months) + 1; break;
                            case "M":
                                k = d(e[v].monthsShort).filter(function() { var i = this.slice(0, q[x].length),
                                        s = q[x].slice(0, i.length); return i.toLowerCase() === s.toLowerCase() });
                                B = d.inArray(k[0], e[v].monthsShort) + 1; break;
                            case "p":
                            case "P":
                                B = d.inArray(q[x].toLowerCase(), e[v].meridiem); break;
                            case "z":
                            case "Z":
                                r; break } } m[t] = B } for (var x = 0, n; x < z.length; x++) { n = z[x]; if (n in m && !isNaN(m[n])) { o[n](A, m[n]) } } } return A }, formatDate: function(l, q, m, p, o) { if (l === null) { return "" } var k; if (p === "standard") { k = { t: l.getTime(), yy: l.getUTCFullYear().toString().substring(2), yyyy: l.getUTCFullYear(), m: l.getUTCMonth() + 1, M: e[m].monthsShort[l.getUTCMonth()], MM: e[m].months[l.getUTCMonth()], d: l.getUTCDate(), D: e[m].daysShort[l.getUTCDay()], DD: e[m].days[l.getUTCDay()], p: (e[m].meridiem.length === 2 ? e[m].meridiem[l.getUTCHours() < 12 ? 0 : 1] : ""), h: l.getUTCHours(), i: l.getUTCMinutes(), s: l.getUTCSeconds(), z: o }; if (e[m].meridiem.length === 2) { k.H = (k.h % 12 === 0 ? 12 : k.h % 12) } else { k.H = k.h } k.HH = (k.H < 10 ? "0" : "") + k.H;
                k.P = k.p.toUpperCase();
                k.Z = k.z;
                k.hh = (k.h < 10 ? "0" : "") + k.h;
                k.ii = (k.i < 10 ? "0" : "") + k.i;
                k.ss = (k.s < 10 ? "0" : "") + k.s;
                k.dd = (k.d < 10 ? "0" : "") + k.d;
                k.mm = (k.m < 10 ? "0" : "") + k.m } else { if (p === "php") { k = { y: l.getUTCFullYear().toString().substring(2), Y: l.getUTCFullYear(), F: e[m].months[l.getUTCMonth()], M: e[m].monthsShort[l.getUTCMonth()], n: l.getUTCMonth() + 1, t: c.getDaysInMonth(l.getUTCFullYear(), l.getUTCMonth()), j: l.getUTCDate(), l: e[m].days[l.getUTCDay()], D: e[m].daysShort[l.getUTCDay()], w: l.getUTCDay(), N: (l.getUTCDay() === 0 ? 7 : l.getUTCDay()), S: (l.getUTCDate() % 10 <= e[m].suffix.length ? e[m].suffix[l.getUTCDate() % 10 - 1] : ""), a: (e[m].meridiem.length === 2 ? e[m].meridiem[l.getUTCHours() < 12 ? 0 : 1] : ""), g: (l.getUTCHours() % 12 === 0 ? 12 : l.getUTCHours() % 12), G: l.getUTCHours(), i: l.getUTCMinutes(), s: l.getUTCSeconds() };
                    k.m = (k.n < 10 ? "0" : "") + k.n;
                    k.d = (k.j < 10 ? "0" : "") + k.j;
                    k.A = k.a.toString().toUpperCase();
                    k.h = (k.g < 10 ? "0" : "") + k.g;
                    k.H = (k.G < 10 ? "0" : "") + k.G;
                    k.i = (k.i < 10 ? "0" : "") + k.i;
                    k.s = (k.s < 10 ? "0" : "") + k.s } else { throw new Error("Invalid format type.") } } var l = [],
                r = d.extend([], q.separators); for (var n = 0, j = q.parts.length; n < j; n++) { if (r.length) { l.push(r.shift()) } l.push(k[q.parts[n]]) } if (r.length) { l.push(r.shift()) } return l.join("") }, convertViewMode: function(i) { switch (i) {
                case 4:
                case "decade":
                    i = 4; break;
                case 3:
                case "year":
                    i = 3; break;
                case 2:
                case "month":
                    i = 2; break;
                case 1:
                case "day":
                    i = 1; break;
                case 0:
                case "hour":
                    i = 0; break } return i }, headTemplate: '<thead><tr><th class="prev"><i class="{iconType} {leftArrow}"/></th><th colspan="5" class="switch"></th><th class="next"><i class="{iconType} {rightArrow}"/></th></tr></thead>', headTemplateV3: '<thead><tr><th class="prev"><span class="{iconType} {leftArrow}"></span> </th><th colspan="5" class="switch"></th><th class="next"><span class="{iconType} {rightArrow}"></span> </th></tr></thead>', contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>', footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>' };
    c.template = '<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-hours"><table class=" table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-days"><table class=" table-condensed">' + c.headTemplate + "<tbody></tbody>" + c.footTemplate + '</table></div><div class="datetimepicker-months"><table class="table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-years"><table class="table-condensed">' + c.headTemplate + c.contTemplate + c.footTemplate + "</table></div></div>";
    c.templateV3 = '<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-hours"><table class=" table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-days"><table class=" table-condensed">' + c.headTemplateV3 + "<tbody></tbody>" + c.footTemplate + '</table></div><div class="datetimepicker-months"><table class="table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + '</table></div><div class="datetimepicker-years"><table class="table-condensed">' + c.headTemplateV3 + c.contTemplate + c.footTemplate + "</table></div></div>";
    d.fn.datetimepicker.DPGlobal = c;
    d.fn.datetimepicker.noConflict = function() { d.fn.datetimepicker = b; return this };
    d(document).on("focus.datetimepicker.data-api click.datetimepicker.data-api", '[data-provide="datetimepicker"]', function(j) { var i = d(this); if (i.data("datetimepicker")) { return } j.preventDefault();
        i.datetimepicker("show") });
    d(function() { d('[data-provide="datetimepicker-inline"]').datetimepicker() }) }));
/*
 * angular-ui-bootstrap
 * http:
 

 * Version: 1.3.3 - 2016-05-22
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.datepicker","ui.bootstrap.position","ui.bootstrap.datepickerPopup","ui.bootstrap.debounce","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/year.html","uib/template/datepickerPopup/popup.html","uib/template/modal/backdrop.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
            expandedExpr = $parse(attrs.expanded),
            collapsingExpr = $parse(attrs.collapsing),
            collapsedExpr = $parse(attrs.collapsed);

        if (!scope.$eval(attrs.uibCollapse)) {
          element.addClass('in')
            .addClass('collapse')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false)
            .css({height: 'auto'});
        }

        function expand() {
          if (element.hasClass('collapse') && element.hasClass('in')) {
            return;
          }

          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);

              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  to: { height: element[0].scrollHeight + 'px' }
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  to: { height: element[0].scrollHeight + 'px' }
                }).then(expandDone);
              }
            });
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css({height: 'auto'});
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
                .css({height: element[0].scrollHeight + 'px'})
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);

              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: {height: '0'}
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: {height: '0'}
                }).then(collapseDone);
              }
            });
        }

        function collapseDone() {
          element.css({height: '0'}); 
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  
  this.groups = [];

  
  
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  
  
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  
  
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };
}])





.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
    }
  };
})



.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         
    
    transclude: true,              
    
    replace: true,                
    
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               
      
      panelClass: '@?',           
      
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass || 'panel-default';
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
    	  console.log("ui-bootstrap-tpls-1.2.4");
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };

      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      scope.headingId = id + '-tab';
      scope.panelId = id + '-panel';
    }
  };
})



.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   
    
    template: '',       
    
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      
      
      
      
      
      
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})





.directive('uibAccordionTransclude', function() {
  return {
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, controller) {
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
          elem.html('');
          elem.append(heading);
        }
      });
    }
  };

  function getHeaderSelectors() {
      return 'uib-accordion-header,' +
          'data-uib-accordion-header,' +
          'x-uib-accordion-header,' +
          'uib\\:accordion-header,' +
          '[uib-accordion-header],' +
          '[data-uib-accordion-header],' +
          '[x-uib-accordion-header]';
  }
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/alert/alert.html';
    },
    transclude: true,
    replace: true,
    scope: {
      type: '@',
      close: '&'
    }
  };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function($parse) {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      var uncheckableExpr = $parse(attrs.uibUncheckable);

      element.find('input').css({display: 'none'});

      
      
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      
      
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });

      if (attrs.uibUncheckable) {
        scope.$watch(uncheckableExpr, function(uncheckable) {
          attrs.$set('uncheckable', uncheckable ? '' : undefined);
        });
      }
    }
  };
}])

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      
      
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      
      
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = $scope.active,
    currentInterval, isPlaying, bufferedTransitions = [];

  var destroyed = false;

  self.addSlide = function(slide, element) {
    slides.push({
      slide: slide,
      element: element
    });
    slides.sort(function(a, b) {
      return +a.slide.index - +b.slide.index;
    });
    
    
    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition = null;
      }

      currentIndex = slide.index;
      $scope.active = slide.index;
      setActive(currentIndex);
      self.select(slides[findSlideIndex(slide)]);
      if (slides.length === 1) {
        $scope.play();
      }
    }
  };

  self.getCurrentIndex = function() {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide.index === currentIndex) {
        return i;
      }
    }
  };

  self.next = $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 && $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'next');
  };

  self.prev = $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() && newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'prev');
  };

  self.removeSlide = function(slide) {
    var index = findSlideIndex(slide);

    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
    if (bufferedIndex !== -1) {
      bufferedTransitions.splice(bufferedIndex, 1);
    }

    
    
    slides.splice(index, 1);
    if (slides.length > 0 && currentIndex === index) {
      if (index >= slides.length) {
        currentIndex = slides.length - 1;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[slides.length - 1]);
      } else {
        currentIndex = index;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
      $scope.active = currentIndex;
    }

    
    
    if (slides.length === 0) {
      currentIndex = null;
      $scope.active = null;
      clearBufferedTransitions();
    }
  };

  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = findSlideIndex(nextSlide.slide);
    
    
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    
    
    if (nextSlide.slide.index !== currentIndex &&
      !$scope.$currentTransition) {
      goNext(nextSlide.slide, nextIndex, direction);
    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
      bufferedTransitions.push(slides[nextIndex]);
    }
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return +slide.slide.index;
  };

  $scope.isActive = function(slide) {
    return $scope.active === slide.slide.index;
  };

  $scope.isPrevDisabled = function() {
    return $scope.active === 0 && $scope.noWrap();
  };

  $scope.isNextDisabled = function() {
    return $scope.active === slides.length - 1 && $scope.noWrap();
  };

  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };

  $scope.$on('$destroy', function() {
    destroyed = true;
    resetTimer();
  });

  $scope.$watch('noTransition', function(noTransition) {
    $animate.enabled($element, !noTransition);
  });

  $scope.$watch('interval', restartTimer);

  $scope.$watchCollection('slides', resetTransition);

  $scope.$watch('active', function(index) {
    if (angular.isNumber(index) && currentIndex !== index) {
      for (var i = 0; i < slides.length; i++) {
        if (slides[i].slide.index === index) {
          index = i;
          break;
        }
      }

      var slide = slides[index];
      if (slide) {
        setActive(index);
        self.select(slides[index]);
        currentIndex = index;
      }
    }
  });

  function clearBufferedTransitions() {
    while (bufferedTransitions.length) {
      bufferedTransitions.shift();
    }
  }

  function getSlideByIndex(index) {
    for (var i = 0, l = slides.length; i < l; ++i) {
      if (slides[i].index === index) {
        return slides[i];
      }
    }
  }

  function setActive(index) {
    for (var i = 0; i < slides.length; i++) {
      slides[i].slide.active = i === index;
    }
  }

  function goNext(slide, index, direction) {
    if (destroyed) {
      return;
    }

    angular.extend(slide, {direction: direction});
    angular.extend(slides[currentIndex].slide || {}, {direction: direction});
    if ($animate.enabled($element) && !$scope.$currentTransition &&
      slides[index].element && self.slides.length > 1) {
      slides[index].element.data(SLIDE_DIRECTION, slide.direction);
      var currentIdx = self.getCurrentIndex();

      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      $animate.on('addClass', slides[index].element, function(element, phase) {
        if (phase === 'close') {
          $scope.$currentTransition = null;
          $animate.off('addClass', element);
          if (bufferedTransitions.length) {
            var nextSlide = bufferedTransitions.pop().slide;
            var nextIndex = nextSlide.index;
            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
            clearBufferedTransitions();

            goNext(nextSlide, nextIndex, nextDirection);
          }
        }
      });
    }

    $scope.active = slide.index;
    currentIndex = slide.index;
    setActive(index);

    
    
    restartTimer();
  }

  function findSlideIndex(slide) {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide === slide) {
        return i;
      }
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function resetTransition(slides) {
    if (!slides.length) {
      $scope.$currentTransition = null;
      clearBufferedTransitions();
    }
  }

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }
}])

.directive('uibCarousel', function() {
  return {
    transclude: true,
    replace: true,
    controller: 'UibCarouselController',
    controllerAs: 'carousel',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/carousel.html';
    },
    scope: {
      active: '=',
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    }
  };
})

.directive('uibSlide', function() {
  return {
    require: '^uibCarousel',
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/slide.html';
    },
    scope: {
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      
      
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });
    }
  };
})

.animation('.item', ['$animateCss',
function($animateCss) {
  var SLIDE_DIRECTION = 'uib-slideDirection';

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function(element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element,
          directionClass + ' ' + direction, done);
        element.addClass(direction);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    }
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
  
  
	
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
    localeId = $locale.id;

    this.parsers = {};
    this.formatters = {};

    formatCodeToRegex = [
      {
        key: 'yyyy',
        regex: '\\d{4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yyyy');
        }
      },
      {
        key: 'yy',
        regex: '\\d{2}',
        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yy');
        }
      },
      {
        key: 'y',
        regex: '\\d{1,4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'y');
        }
      },
      {
        key: 'M!',
        regex: '0?[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) {
          var value = date.getMonth();
          if (/^[0-9]$/.test(value)) {
            return dateFilter(date, 'MM');
          }

          return dateFilter(date, 'M');
        }
      },
      {
        key: 'MMMM',
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMMM'); }
      },
      {
        key: 'MMM',
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMM'); }
      },
      {
        key: 'MM',
        regex: '0[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'MM'); }
      },
      {
        key: 'M',
        regex: '[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'M'); }
      },
      {
        key: 'd!',
        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) {
          var value = date.getDate();
          if (/^[1-9]$/.test(value)) {
            return dateFilter(date, 'dd');
          }

          return dateFilter(date, 'd');
        }
      },
      {
        key: 'dd',
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'dd'); }
      },
      {
        key: 'd',
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'd'); }
      },
      {
        key: 'EEEE',
        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEEE'); }
      },
      {
        key: 'EEE',
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEE'); }
      },
      {
        key: 'HH',
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'HH'); }
      },
      {
        key: 'hh',
        regex: '0[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'hh'); }
      },
      {
        key: 'H',
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'H'); }
      },
      {
        key: 'h',
        regex: '[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'h'); }
      },
      {
        key: 'mm',
        regex: '[0-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'mm'); }
      },
      {
        key: 'm',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'm'); }
      },
      {
        key: 'sss',
        regex: '[0-9][0-9][0-9]',
        apply: function(value) { this.milliseconds = +value; },
        formatter: function(date) { return dateFilter(date, 'sss'); }
      },
      {
        key: 'ss',
        regex: '[0-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 'ss'); }
      },
      {
        key: 's',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 's'); }
      },
      {
        key: 'a',
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }

          if (value === 'PM') {
            this.hours += 12;
          }
        },
        formatter: function(date) { return dateFilter(date, 'a'); }
      },
      {
        key: 'Z',
        regex: '[+-]\\d{4}',
        apply: function(value) {
          var matches = value.match(/([+-])(\d{2})(\d{2})/),
            sign = matches[1],
            hours = matches[2],
            minutes = matches[3];
          this.hours += toInt(sign + hours);
          this.minutes += toInt(sign + minutes);
        },
        formatter: function(date) {
          return dateFilter(date, 'Z');
        }
      },
      {
        key: 'ww',
        regex: '[0-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'ww'); }
      },
      {
        key: 'w',
        regex: '[0-9]|[1-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'w'); }
      },
      {
        key: 'GGGG',
        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
        formatter: function(date) { return dateFilter(date, 'GGGG'); }
      },
      {
        key: 'GGG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GGG'); }
      },
      {
        key: 'GG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GG'); }
      },
      {
        key: 'G',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'G'); }
      }
    ];
  };

  this.init();

  function createParser(format, func) {
    var map = [], regex = format.split('');

    
    
    var quoteIndex = format.indexOf('\'');
    if (quoteIndex > -1) {
      var inLiteral = false;
      format = format.split('');
      for (var i = quoteIndex; i < format.length; i++) {
        if (inLiteral) {
          if (format[i] === '\'') {
            if (i + 1 < format.length && format[i+1] === '\'') { 
            	
              format[i+1] = '$';
              regex[i+1] = '';
            } else { 
            	
              regex[i] = '';
              inLiteral = false;
            }
          }
          format[i] = '$';
        } else {
          if (format[i] === '\'') { 
          	
            format[i] = '$';
            regex[i] = '';
            inLiteral = true;
          }
        }
      }

      format = format.join('');
    }

    angular.forEach(formatCodeToRegex, function(data) {
      var index = format.indexOf(data.key);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; 
        
        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({
          index: index,
          key: data.key,
          apply: data[func],
          matcher: data.regex
        });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.filter = function(date, format) {
    if (!angular.isDate(date) || isNaN(date) || !format) {
      return '';
    }

    format = $locale.DATETIME_FORMATS[format] || format;

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.formatters[format]) {
      this.formatters[format] = createParser(format, 'formatter');
    }

    var parser = this.formatters[format],
      map = parser.map;

    var _format = format;

    return map.reduce(function(str, mapper, i) {
      var match = _format.match(new RegExp('(.*)' + mapper.key));
      if (match && angular.isString(match[1])) {
        str += match[1];
        _format = _format.replace(match[1] + mapper.key, '');
      }

      var endStr = i === map.length - 1 ? _format : '';

      if (mapper.apply) {
        return str + mapper.apply.call(null, date) + endStr;
      }

      return str + endStr;
    }, '');
  };

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format, 'apply');
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i - 1];
        if (mapper.matcher === 'Z') {
          tzOffset = true;
        }

        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
        Date.prototype.setFullYear;
      var timesetter = tzOffset ? Date.prototype.setUTCHours :
        Date.prototype.setHours;

      if (isValid(fields.year, fields.month, fields.date)) {
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
          dt = new Date(baseDate);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours, fields.minutes,
            fields.seconds, fields.milliseconds);
        } else {
          dt = new Date(0);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
            fields.seconds || 0, fields.milliseconds || 0);
        }
      }

      return dt;
    }
  };

  
  
  
  
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }

  function toInt(str) {
    return parseInt(str, 10);
  }

  this.toTimezone = toTimezone;
  this.fromTimezone = fromTimezone;
  this.timezoneToOffset = timezoneToOffset;
  this.addDateMinutes = addDateMinutes;
  this.convertTimezoneToLocal = convertTimezoneToLocal;

  function toTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
  }

  function fromTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
  }

  
  
  
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(/:/g, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }
}]);





angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
         '$animate',
function ($animate) {
  
  
  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
  
  
  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

  var dataPerTracked = {};

  return {
    restrict: 'A',
    compile: function(tElement, tAttrs) {
      var linkedScopes = [];
      var instances = [];
      var expToData = {};
      var lastActivated = null;
      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
      var onExp = onExpMatches[2];
      var expsStr = onExpMatches[1];
      var exps = expsStr.split(',');

      return linkFn;

      function linkFn(scope, element, attrs) {
        linkedScopes.push(scope);
        instances.push({
          scope: scope,
          element: element
        });

        exps.forEach(function(exp, k) {
          addForExp(exp, scope);
        });

        scope.$on('$destroy', removeScope);
      }

      function addForExp(exp, scope) {
        var matches = exp.match(IS_REGEXP);
        var clazz = scope.$eval(matches[1]);
        var compareWithExp = matches[2];
        var data = expToData[exp];
        if (!data) {
          var watchFn = function(compareWithVal) {
            var newActivated = null;
            instances.some(function(instance) {
              var thisVal = instance.scope.$eval(onExp);
              if (thisVal === compareWithVal) {
                newActivated = instance;
                return true;
              }
            });
            if (data.lastActivated !== newActivated) {
              if (data.lastActivated) {
                $animate.removeClass(data.lastActivated.element, clazz);
              }
              if (newActivated) {
                $animate.addClass(newActivated.element, clazz);
              }
              data.lastActivated = newActivated;
            }
          };
          expToData[exp] = data = {
            lastActivated: null,
            scope: scope,
            watchFn: watchFn,
            compareWithExp: compareWithExp,
            watcher: scope.$watch(compareWithExp, watchFn)
          };
        }
        data.watchFn(scope.$eval(compareWithExp));
      }

      function removeScope(e) {
        var removedScope = e.targetScope;
        var index = linkedScopes.indexOf(removedScope);
        linkedScopes.splice(index, 1);
        instances.splice(index, 1);
        if (linkedScopes.length) {
          var newWatchScope = linkedScopes[0];
          angular.forEach(expToData, function(data) {
            if (data.scope === removedScope) {
              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
              data.scope = newWatchScope;
            }
          });
        } else {
          expToData = {};
        }
      }
    }
  };
}]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

.value('$datepickerSuppressError', false)

.value('$datepickerLiteralWarning', true)

.constant('uibDatepickerConfig', {
  datepickerMode: 'day',
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  maxDate: null,
  maxMode: 'year',
  minDate: null,
  minMode: 'day',
  ngModelOptions: {},
  shortcutPropagation: false,
  showWeeks: true,
  yearColumns: 5,
  yearRows: 4
})

.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, 
      
      ngModelOptions = {},
      watchListeners = [],
      optionsUsed = !!$attrs.datepickerOptions;

  if (!$scope.datepickerOptions) {
    $scope.datepickerOptions = {};
  }

  
  
  this.modes = ['day', 'month', 'year'];

  [
    'customClass',
    'dateDisabled',
    'datepickerMode',
    'formatDay',
    'formatDayHeader',
    'formatDayTitle',
    'formatMonth',
    'formatMonthTitle',
    'formatYear',
    'maxDate',
    'maxMode',
    'minDate',
    'minMode',
    'showWeeks',
    'shortcutPropagation',
    'startingDay',
    'yearColumns',
    'yearRows'
  ].forEach(function(key) {
    switch (key) {
      case 'customClass':
      case 'dateDisabled':
        $scope[key] = $scope.datepickerOptions[key] || angular.noop;
        break;
      case 'datepickerMode':
        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
        break;
      case 'formatDay':
      case 'formatDayHeader':
      case 'formatDayTitle':
      case 'formatMonth':
      case 'formatMonthTitle':
      case 'formatYear':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $interpolate($scope.datepickerOptions[key])($scope.$parent) :
          datepickerConfig[key];
        break;
      case 'showWeeks':
      case 'shortcutPropagation':
      case 'yearColumns':
      case 'yearRows':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $scope.datepickerOptions[key] : datepickerConfig[key];
        break;
      case 'startingDay':
        if (angular.isDefined($scope.datepickerOptions.startingDay)) {
          self.startingDay = $scope.datepickerOptions.startingDay;
        } else if (angular.isNumber(datepickerConfig.startingDay)) {
          self.startingDay = datepickerConfig.startingDay;
        } else {
          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
        }

        break;
      case 'maxDate':
      case 'minDate':
        $scope.$watch('datepickerOptions.' + key, function(value) {
          if (value) {
            if (angular.isDate(value)) {
              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
            } else {
              if ($datepickerLiteralWarning) {
                $log.warn('Literal date support has been deprecated, please switch to date object usage');
              }

              self[key] = new Date(dateFilter(value, 'medium'));
            }
          } else {
            self[key] = datepickerConfig[key] ?
              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :
              null;
          }

          self.refreshView();
        });

        break;
      case 'maxMode':
      case 'minMode':
        if ($scope.datepickerOptions[key]) {
          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
            self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
              $scope.datepickerMode = self[key];
              $scope.datepickerOptions.datepickerMode = self[key];
            }
          });
        } else {
          self[key] = $scope[key] = datepickerConfig[key] || null;
        }

        break;
    }
  });

  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if (angular.isDefined($attrs.ngDisabled)) {
    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
      $scope.disabled = disabled;
      self.refreshView();
    }));
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
    if ($scope.datepickerOptions.initDate) {
      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
      $scope.$watch('datepickerOptions.initDate', function(initDate) {
        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
          self.refreshView();
        }
      });
    } else {
      self.activeDate = new Date();
    }

    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
    this.activeDate = !isNaN(date) ?
      dateParser.fromTimezone(date, ngModelOptions.timezone) :
      dateParser.fromTimezone(new Date(), ngModelOptions.timezone);

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      $scope.selectedDt = null;
      this._refreshView();
      if ($scope.activeDt) {
        $scope.activeDateId = $scope.activeDt.uid;
      }

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      date = dateParser.fromTimezone(date, ngModelOptions.timezone);
      ngModelCtrl.$setValidity('dateDisabled', !date ||
        this.element && !this.isDisabled(date));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    model = dateParser.fromTimezone(model, ngModelOptions.timezone);
    var today = new Date();
    today = dateParser.fromTimezone(today, ngModelOptions.timezone);
    var time = this.compare(date, today);
    var dt = {
      date: date,
      label: dateParser.filter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      past: time < 0,
      current: time === 0,
      future: time > 0,
      customClass: this.customClass(date) || null
    };

    if (model && this.compare(date, model) === 0) {
      $scope.selectedDt = dt;
    }

    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
      $scope.activeDt = dt;
    }

    return dt;
  };

  this.isDisabled = function(date) {
    return $scope.disabled ||
      this.minDate && this.compare(date, this.minDate) < 0 ||
      this.maxDate && this.compare(date, this.maxDate) > 0 ||
      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  
  
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

      $scope.$emit('uib:datepicker.mode');
    }

    $scope.$broadcast('uib:datepicker.focus');
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if ($scope.datepickerMode === self.maxMode && direction === 1 ||
      $scope.datepickerMode === self.minMode && direction === -1) {
      return;
    }

    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

    $scope.$emit('uib:datepicker.mode');
  };

  
  
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  
  
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; 
        
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };

  $scope.$on('$destroy', function() {
    
    
    while (watchListeners.length) {
      watchListeners.shift()();
    }
  });

  function setMode(mode) {
    $scope.datepickerMode = mode;
    $scope.datepickerOptions.datepickerMode = mode;
  }
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
    return month === 1 && year % 4 === 0 &&
      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    scope.showWeeks = ctrl.showWeeks;
    ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
    var dates = new Array(n), current = new Date(startDate), i = 0, date;
    while (i < n) {
      date = new Date(current);
      dates[i++] = date;
      current.setDate(current.getDate() + 1);
    }
    return dates;
  };

  this._refreshView = function() {
    var year = this.activeDate.getFullYear(),
      month = this.activeDate.getMonth(),
      firstDayOfMonth = new Date(this.activeDate);

    firstDayOfMonth.setFullYear(year, month, 1);

    var difference = this.startingDay - firstDayOfMonth.getDay(),
      numDisplayedFromPreviousMonth = difference > 0 ?
        7 - difference : - difference,
      firstDate = new Date(firstDayOfMonth);

    if (numDisplayedFromPreviousMonth > 0) {
      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
    }

    
    
    var days = this.getDates(firstDate, 42);
    for (var i = 0; i < 42; i ++) {
      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
        secondary: days[i].getMonth() !== month,
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.labels = new Array(7);
    for (var j = 0; j < 7; j++) {
      scope.labels[j] = {
        abbr: dateFilter(days[j].date, this.formatDayHeader),
        full: dateFilter(days[j].date, 'EEEE')
      };
    }

    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
    scope.rows = this.split(days, 7);

    if (scope.showWeeks) {
      scope.weekNumbers = [];
      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
        scope.weekNumbers.push(
          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
      }
    }
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  function getISO8601WeekNumber(date) {
    var checkDate = new Date(date);
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); 
    
    var time = checkDate.getTime();
    checkDate.setMonth(0); 
    
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getDate();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - 7;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + 7;
    } else if (key === 'pageup' || key === 'pagedown') {
      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setMonth(month, 1);
      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
    } else if (key === 'home') {
      date = 1;
    } else if (key === 'end') {
      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
    }
    this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    ctrl.refreshView();
  };

  this._refreshView = function() {
    var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;

    for (var i = 0; i < 12; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(year, i, 1);
      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
    scope.rows = this.split(months, 3);
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getMonth();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - 3;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + 3;
    } else if (key === 'pageup' || key === 'pagedown') {
      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setFullYear(year);
    } else if (key === 'home') {
      date = 0;
    } else if (key === 'end') {
      date = 11;
    }
    this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var columns, range;
  this.element = $element;

  function getStartingYear(year) {
    return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
    columns = this.yearColumns;
    range = this.yearRows * columns;
    this.step = { years: range };
  };

  this._refreshView = function() {
    var years = new Array(range), date;

    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(start + i, 0, 1);
      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = [years[0].label, years[range - 1].label].join(' - ');
    scope.rows = this.split(years, columns);
    scope.columns = columns;
  };

  this.compare = function(date1, date2) {
    return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getFullYear();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - columns;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + columns;
    } else if (key === 'pageup' || key === 'pagedown') {
      date += (key === 'pageup' ? - 1 : 1) * range;
    } else if (key === 'home') {
      date = getStartingYear(this.activeDate.getFullYear());
    } else if (key === 'end') {
      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
    }
    this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
    },
    scope: {
      datepickerOptions: '=?'
    },
    require: ['uibDatepicker', '^ngModel'],
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('uibDaypicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/day.html';
    },
    require: ['^uibDatepicker', 'uibDaypicker'],
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibMonthpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/month.html';
    },
    require: ['^uibDatepicker', 'uibMonthpicker'],
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibYearpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/year.html';
    },
    require: ['^uibDatepicker', 'uibYearpicker'],
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      var ctrl = ctrls[0];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
});

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods for working with the DOM.
 * It is meant to be used where we need to absolute-position elements in
 * relation to another element (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    /**
     * Used by scrollbarWidth() function to cache scrollbar's width.
     * Do not access this variable directly, use scrollbarWidth() instead.
     */
    var SCROLLBAR_WIDTH;
    /**
     * scrollbar on body and html element in IE and Edge overlay
     * content and should be considered 0 width.
     */
    var BODY_SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    var BODY_REGEX = /(HTML|BODY)/;

    return {

      /**
       * Provides a raw DOM element from a jQuery/jQLite element.
       *
       * @param {element} elem - The element to convert.
       *
       * @returns {element} A HTML element.
       */
      getRawNode: function(elem) {
        return elem.nodeName ? elem : elem[0] || elem;
      },

      /**
       * Provides a parsed number for a style property.  Strips
       * units and casts invalid numbers to 0.
       *
       * @param {string} value - The style value to parse.
       *
       * @returns {number} A valid number.
       */
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },

      /**
       * Provides the closest positioned ancestor.
       *
       * @param {element} element - The element to get the offest parent for.
       *
       * @returns {element} The closest positioned ancestor.
       */
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);

        var offsetParent = elem.offsetParent || $document[0].documentElement;

        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }

        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || $document[0].documentElement;
      },

      /**
       * Provides the scrollbar width, concept from TWBS measureScrollbar()
       * function in https:
       
       * In IE and Edge, scollbar on body and html element overlay and should
       * return a width of 0.
       *
       * @returns {number} The width of the browser scollbar.
       */
      scrollbarWidth: function(isBody) {
        if (isBody) {
          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
            var bodyElem = $document.find('body');
            bodyElem.addClass('uib-position-body-scrollbar-measure');
            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
            bodyElem.removeClass('uib-position-body-scrollbar-measure');
          }
          return BODY_SCROLLBAR_WIDTH;
        }

        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }

        return SCROLLBAR_WIDTH;
      },

      /**
       * Provides the padding required on an element to replace the scrollbar.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**scrollbarWidth**: the width of the scrollbar</li>
       *     <li>**widthOverflow**: whether the the width is overflowing</li>
       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
       *     <li>**heightOverflow**: whether the the height is overflowing</li>
       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
       *   </ul>
       */
      scrollbarPadding: function(elem) {
        elem = this.getRawNode(elem);

        var elemStyle = $window.getComputedStyle(elem);
        var paddingRight = this.parseStyle(elemStyle.paddingRight);
        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
        var scrollParent = this.scrollParent(elem, false, true);
        var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));

        return {
          scrollbarWidth: scrollbarWidth,
          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
          right: paddingRight + scrollbarWidth,
          originalRight: paddingRight,
          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
          bottom: paddingBottom + scrollbarWidth,
          originalBottom: paddingBottom
         };
      },

      /**
       * Checks to see if the element is scrollable.
       *
       * @param {element} elem - The element to check.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       *
       * @returns {boolean} Whether the element is scrollable.
       */
      isScrollable: function(elem, includeHidden) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var elemStyle = $window.getComputedStyle(elem);
        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
      },

      /**
       * Provides the closest scrollable ancestor.
       * A port of the jQuery UI scrollParent method:
       * https:
       
       *
       * @param {element} elem - The element to find the scroll parent of.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       * @param {boolean=} [includeSelf=false] - Should the element being passed be
       * included in the scrollable llokup.
       *
       * @returns {element} A HTML element.
       */
      scrollParent: function(elem, includeHidden, includeSelf) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
          return elem;
        }
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;

        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }

        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== 'static') {
            excludeStatic = false;
          }

          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }

        return scrollParent;
      },

      /**
       * Provides read-only equivalent of jQuery's position function:
       * http:
       
       * ancestor.  Does not account for margins by default like jQuery position.
       *
       * @param {element} elem - The element to caclulate the position on.
       * @param {boolean=} [includeMargins=false] - Should margins be accounted
       * for, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of offset parent</li>
       *     <li>**left**: distance to left edge of offset parent</li>
       *   </ul>
       */
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);

        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {top: 0, left: 0};

        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }

        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http:
       
       * not account for borders, margins, or padding on the body
       * element.
       *
       * @param {element} elem - The element to calculate the offset on.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of viewport</li>
       *     <li>**right**: distance to bottom edge of viewport</li>
       *   </ul>
       */
      offset: function(elem) {
        elem = this.getRawNode(elem);

        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },

      /**
       * Provides offset distance to the closest scrollable ancestor
       * or viewport.  Accounts for border and scrollbar width.
       *
       * Right and bottom dimensions represent the distance to the
       * respective edge of the viewport element.  If the element
       * edge extends beyond the viewport, a negative value will be
       * reported.
       *
       * @param {element} elem - The element to get the viewport offset for.
       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
       * of the first scrollable element, default is false.
       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
       * be accounted for, default is true.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: distance to the top content edge of viewport element</li>
       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
       *     <li>**left**: distance to the left content edge of viewport element</li>
       *     <li>**right**: distance to the right content edge of viewport element</li>
       *   </ul>
       */
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;

        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();

        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }

        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },

      /**
       * Provides an array of placement values parsed from a placement string.
       * Along with the 'auto' indicator, supported placement strings are:
       *   <ul>
       *     <li>top: element on top, horizontally centered on host element.</li>
       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
       *     <li>bottom: element on bottom, horizontally centered on host element.</li>
       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
       *     <li>left: element on left, vertically centered on host element.</li>
       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
       *     <li>right: element on right, vertically centered on host element.</li>
       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
       *   </ul>
       * A placement string with an 'auto' indicator is expected to be
       * space separated from the placement, i.e: 'auto bottom-left'  If
       * the primary and secondary placement values do not match 'top,
       * bottom, left, right' then 'top' will be the primary placement and
       * 'center' will be the secondary placement.  If 'auto' is passed, true
       * will be returned as the 3rd value of the array.
       *
       * @param {string} placement - The placement string to parse.
       *
       * @returns {array} An array with the following values
       * <ul>
       *   <li>**[0]**: The primary placement.</li>
       *   <li>**[1]**: The secondary placement.</li>
       *   <li>**[2]**: If auto is passed: true, else undefined.</li>
       * </ul>
       */
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }

        placement = placement.split('-');

        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }

        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }

        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }

        return placement;
      },

      /**
       * Provides coordinates for an element to be positioned relative to
       * another element.  Passing 'auto' as part of the placement parameter
       * will enable smart placement - where the element fits. i.e:
       * 'auto left-top' will check to see if there is enough space to the left
       * of the hostElem to fit the targetElem, if not place right (same for secondary
       * top placement).  Available space is calculated using the viewportOffset
       * function.
       *
       * @param {element} hostElem - The element to position against.
       * @param {element} targetElem - The element to position.
       * @param {string=} [placement=top] - The placement for the targetElem,
       *   default is 'top'. 'center' is assumed as secondary placement for
       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
       *   <ul>
       *     <li>top</li>
       *     <li>top-right</li>
       *     <li>top-left</li>
       *     <li>bottom</li>
       *     <li>bottom-left</li>
       *     <li>bottom-right</li>
       *     <li>left</li>
       *     <li>left-top</li>
       *     <li>left-bottom</li>
       *     <li>right</li>
       *     <li>right-top</li>
       *     <li>right-bottom</li>
       *   </ul>
       * @param {boolean=} [appendToBody=false] - Should the top and left values returned
       *   be calculated from the body element, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: Value for targetElem top.</li>
       *     <li>**left**: Value for targetElem left.</li>
       *     <li>**placement**: The resolved placement.</li>
       *   </ul>
       */
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);

        
        
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

        placement = this.parsePlacement(placement);

        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {top: 0, left: 0, placement: ''};

        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem, appendToBody);

          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };

          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                         placement[0];

          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                         placement[1];

          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }

        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }

        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }

        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

        return targetElemPos;
      },

      /**
      * Provides a way for positioning tooltip & dropdown
      * arrows when using placement options beyond the standard
      * left, right, top, or bottom.
      *
      * @param {element} elem - The tooltip/dropdown element.
      * @param {string} placement - The placement for the elem.
      */
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);

        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }

        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }

        var arrowCss = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };

        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          
          
          angular.element(arrowElem).css(arrowCss);
          return;
        }

        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }

        arrowCss[placement[1]] = borderRadius;

        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

.value('$datepickerPopupLiteralWarning', true)

.constant('uibDatepickerPopupConfig', {
  altInputFormats: [],
  appendToBody: false,
  clearText: 'Clear',
  closeOnDateSelection: true,
  closeText: 'Done',
  currentText: 'Today',
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  onOpenFocus: true,
  showButtonBar: true,
  placement: 'auto bottom-left'
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [],
    timezone;

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    ngModelOptions = _ngModel_.$options;
    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
      $scope.$parent.$eval($attrs.closeOnDateSelection) :
      datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
      $scope.$parent.$eval($attrs.datepickerAppendToBody) :
      datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
      $attrs.datepickerPopupTemplateUrl :
      datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
    altInputFormats = angular.isDefined($attrs.altInputFormats) ?
      $scope.$parent.$eval($attrs.altInputFormats) :
      datepickerPopupConfig.altInputFormats;

    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
      $scope.$parent.$eval($attrs.showButtonBar) :
      datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[$attrs.type]) {
      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
      isHtml5DateInput = true;
    } else {
      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
        
        
        
        
        
        if (newDateFormat !== dateFormat) {
          dateFormat = newDateFormat;
          ngModel.$modelValue = null;

          if (!dateFormat) {
            throw new Error('uibDatepickerPopup must have a date format specified.');
          }
        }
      });
    }

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
      throw new Error('HTML5 date input types do not support custom formats.');
    }

    
    
    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
    if (ngModelOptions) {
      timezone = ngModelOptions.timezone;
      $scope.ngModelOptions = angular.copy(ngModelOptions);
      $scope.ngModelOptions.timezone = null;
      if ($scope.ngModelOptions.updateOnDefault === true) {
        $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?
          $scope.ngModelOptions.updateOn + ' default' : 'default';
      }

      popupEl.attr('ng-model-options', 'ngModelOptions');
    } else {
      timezone = null;
    }

    popupEl.attr({
      'ng-model': 'date',
      'ng-change': 'dateSelection(date)',
      'template-url': datepickerPopupTemplateUrl
    });

    
    
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (!$scope.datepickerOptions) {
      $scope.datepickerOptions = {};
    }

    if (isHtml5DateInput) {
      if ($attrs.type === 'month') {
        $scope.datepickerOptions.datepickerMode = 'month';
        $scope.datepickerOptions.minMode = 'month';
      }
    }

    datepickerEl.attr('datepicker-options', 'datepickerOptions');

    if (!isHtml5DateInput) {
      
      
      ngModel.$$parserName = 'date';
      ngModel.$validators.date = validator;
      ngModel.$parsers.unshift(parseDate);
      ngModel.$formatters.push(function(value) {
        if (ngModel.$isEmpty(value)) {
          $scope.date = value;
          return value;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }

        $scope.date = dateParser.fromTimezone(value, timezone);

        return dateParser.filter($scope.date, dateFormat);
      });
    } else {
      ngModel.$formatters.push(function(value) {
        $scope.date = dateParser.fromTimezone(value, timezone);
        return value;
      });
    }

    
    
    ngModel.$viewChangeListeners.push(function() {
      $scope.date = parseDateString(ngModel.$viewValue);
    });

    $element.on('keydown', inputKeydownBind);

    $popup = $compile(popupEl)($scope);
    
    
    popupEl.remove();

    if (appendToBody) {
      $document.find('body').append($popup);
    } else {
      $element.after($popup);
    }

    $scope.$on('$destroy', function() {
      if ($scope.isOpen === true) {
        if (!$rootScope.$$phase) {
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
        }
      }

      $popup.remove();
      $element.off('keydown', inputKeydownBind);
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);

      
      
      while (watchListeners.length) {
        watchListeners.shift()();
      }
    });
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  $scope.isDisabled = function(date) {
    if (date === 'today') {
      date = dateParser.fromTimezone(new Date(), timezone);
    }

    var dates = {};
    angular.forEach(['minDate', 'maxDate'], function(key) {
      if (!$scope.datepickerOptions[key]) {
        dates[key] = null;
      } else if (angular.isDate($scope.datepickerOptions[key])) {
        dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);
      } else {
        if ($datepickerPopupLiteralWarning) {
          $log.warn('Literal date support has been deprecated, please switch to date object usage');
        }

        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
      }
    });

    return $scope.datepickerOptions &&
      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
  };

  $scope.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  };

  
  
  $scope.dateSelection = function(dt) {
    if (angular.isDefined(dt)) {
      $scope.date = dt;
    }
    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; 
    
    $element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.keydown = function(evt) {
    if (evt.which === 27) {
      evt.stopPropagation();
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.select = function(date, evt) {
    evt.stopPropagation();

    if (date === 'today') {
      var today = new Date();
      if (angular.isDate($scope.date)) {
        date = new Date($scope.date);
        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
      } else {
        date = new Date(today.setHours(0, 0, 0, 0));
      }
    }
    $scope.dateSelection(date);
  };

  $scope.close = function(evt) {
    evt.stopPropagation();

    $scope.isOpen = false;
    $element[0].focus();
  };

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if ($attrs.ngDisabled) {
    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
      $scope.disabled = disabled;
    }));
  }

  $scope.$watch('isOpen', function(value) {
    if (value) {
      if (!$scope.disabled) {
        $timeout(function() {
          positionPopup();

          if (onOpenFocus) {
            $scope.$broadcast('uib:datepicker.focus');
          }

          $document.on('click', documentClickBind);

          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          if (appendToBody || $position.parsePlacement(placement)[2]) {
            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
            if (scrollParentEl) {
              scrollParentEl.on('scroll', positionPopup);
            }
          } else {
            scrollParentEl = null;
          }

          angular.element($window).on('resize', positionPopup);
        }, 0, false);
      } else {
        $scope.isOpen = false;
      }
    } else {
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDateString(viewValue) {
    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
    if (isNaN(date)) {
      for (var i = 0; i < altInputFormats.length; i++) {
        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
        if (!isNaN(date)) {
          return date;
        }
      }
    }
    return date;
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
      
      
      viewValue = new Date(viewValue);
    }

    if (!viewValue) {
      return null;
    }

    if (angular.isDate(viewValue) && !isNaN(viewValue)) {
      return viewValue;
    }

    if (angular.isString(viewValue)) {
      var date = parseDateString(viewValue);
      if (!isNaN(date)) {
        return dateParser.toTimezone(date, timezone);
      }
    }

    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!$attrs.ngRequired && !value) {
      return true;
    }

    if (angular.isNumber(value)) {
      value = new Date(value);
    }

    if (!value) {
      return true;
    }

    if (angular.isDate(value) && !isNaN(value)) {
      return true;
    }

    if (angular.isString(value)) {
      return !isNaN(parseDateString(viewValue));
    }

    return false;
  }

  function documentClickBind(event) {
    if (!$scope.isOpen && $scope.disabled) {
      return;
    }

    var popup = $popup[0];
    var dpContainsTarget = $element[0].contains(event.target);
    
    
    
    
    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 && $scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
      $element[0].focus();
    } else if (evt.which === 40 && !$scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = true;
      });
    }
  }

  function positionPopup() {
    if ($scope.isOpen) {
      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
      var position = $position.positionElements($element, dpElement, placement, appendToBody);
      dpElement.css({top: position.top + 'px', left: position.left + 'px'});
      if (dpElement.hasClass('uib-position-measure')) {
        dpElement.removeClass('uib-position-measure');
      }
    }
  }

  $scope.$on('uib:datepicker.mode', function() {
    $timeout(positionPopup, 0, false);
  });
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      datepickerOptions: '=?',
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@'
    },
    link: function(scope, element, attrs, ctrls) {
      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
    }
  };
});

angular.module('ui.bootstrap.debounce', [])
/**
 * A helper, internal service that debounces a function
 */
  .factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;

      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }

        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  appendToOpenClass: 'uib-dropdown-open',
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
  var openScope = null;

  this.open = function(dropdownScope, element) {
    if (!openScope) {
      $document.on('click', closeDropdown);
      element.on('keydown', keybindFilter);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function(dropdownScope, element) {
    if (openScope === dropdownScope) {
      openScope = null;
      $document.off('click', closeDropdown);
      element.off('keydown', keybindFilter);
    }
  };

  var closeDropdown = function(evt) {
    
    
    
    
    if (!openScope) { return; }

    if (evt && openScope.getAutoClose() === 'disabled') { return; }

    if (evt && evt.which === 3) { return; }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt && openScope.getAutoClose() === 'outsideClick' &&
      dropdownElement && dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var keybindFilter = function(evt) {
    if (evt.which === 27) {
      evt.stopPropagation();
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), 
    
    templateScope,
    appendToOpenClass = dropdownConfig.appendToOpenClass,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    appendTo = null,
    keynavEnabled = false,
    selectedOption = null,
    body = $document.find('body');

  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    if (angular.isDefined($attrs.dropdownAppendTo)) {
      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
      if (appendToEl) {
        appendTo = angular.element(appendToEl);
      }
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.keyboardNav);

    if (appendToBody && !appendTo) {
      appendTo = body;
    }

    if (appendTo && self.dropdownMenu) {
      appendTo.append(self.dropdownMenu);
      $element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    if (angular.isFunction(setIsOpen)) {
      setIsOpen(scope, scope.isOpen);
    }

    return scope.isOpen;
  };

  
  
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; 
    
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? 
    
      angular.element(self.dropdownMenu).find('a') :
      $element.find('ul').eq(0).find('a');

    switch (keyCode) {
      case 40: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = self.selectedOption === elems.length - 1 ?
            self.selectedOption :
            self.selectedOption + 1;
        }
        break;
      }
      case 38: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    if (appendTo && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
        css,
        rightalign,
        scrollbarWidth;

      css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        scrollbarWidth = $position.scrollbarWidth(true);
        css.right = window.innerWidth - scrollbarWidth -
          (pos.left + $element.prop('offsetWidth')) + 'px';
      }

      
      
      
      
      if (!appendToBody) {
        var appendOffset = $position.offset(appendTo);

        css.top = pos.top - appendOffset.top + 'px';

        if (!rightalign) {
          css.left = pos.left - appendOffset.left + 'px';
        } else {
          css.right = window.innerWidth -
            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
        }
      }

      self.dropdownMenu.css(css);
    }

    var openContainer = appendTo ? appendTo : $element;
    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);

    if (hasOpenClass === !isOpen) {
      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
          toggleInvoker($scope, { open: !!isOpen });
        }
      });
    }

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope, $element);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      uibDropdownService.close(scope, $element);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });
}])

.directive('uibDropdown', function() {
  return {
    controller: 'UibDropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init();
    }
  };
})

.directive('uibDropdownMenu', function() {
  return {
    restrict: 'A',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive('uibDropdownToggle', function() {
  return {
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      
      
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })

/**
 * Pluggable resolve mechanism for the modal resolve resolution
 * Supports UI Router's $resolve service
 */
  .provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;

    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };

    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {
        resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }

          var promises = [];

          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });

          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });

            return resolveObj;
          });
        }
      };
    }];
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
  function($animate, $injector, $modalStack) {
    return {
      replace: true,
      templateUrl: 'uib/template/modal/backdrop.html',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      if (attrs.modalInClass) {
        $animate.addClass(element, attrs.modalInClass);

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if (scope.modalOptions.animation) {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          } else {
            done();
          }
        });
      }
    }
  }])

  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
  function($modalStack, $q, $animateCss, $document) {
    return {
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'uib/template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop &&
            modal.value.backdrop !== 'static' &&
            evt.target === evt.currentTarget) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        
        
        element.on('click', scope.close);

        
        
        
        
        
        
        scope.$isRendered = true;

        
        
        var modalRenderDeferObj = $q.defer();
        
        
        
        
        attrs.$observe('modalRender', function(value) {
          if (value === 'true') {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            animationPromise = $animateCss(element, {
              addClass: attrs.modalInClass
            }).start();

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            });
          }


          $q.when(animationPromise).then(function() {
            
            
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }

            /**
             * If something within the freshly-opened modal already has focus (perhaps via a
             * directive that causes focus). then no need to try and focus anything.
             */
            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              /**
               * Auto-focusing of a freshly-opened modal element causes any child elements
               * with the autofocus attribute to lose focus. This is an issue on touch
               * based devices which will show and then hide the onscreen keyboard.
               * Attempts to refocus the autofocus element via JavaScript will not reopen
               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
               * the modal element if the modal does not contain an autofocus element.
               */
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            }
          });
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', function() {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          element.append(clone);
        });
      }
    };
  })

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;

      
      
      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' +
        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
        'iframe, object, embed, *[tabindex], *[contenteditable=true]';
      var scrollbarPadding;

      function isVisible(element) {
        return !!(element.offsetWidth ||
          element.offsetHeight ||
          element.getClientRects().length);
      }

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }

        
        
        
        
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;

        
        
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
              appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();

        
        
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      
      
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        
        
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        
        
        
        
        
        
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          $animate.leave(domEl).then(function() {
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });

          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.on('keydown', keydownListener);

      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27: {
              if (modal.value.keyboard) {
                evt.preventDefault();
                $rootScope.$apply(function() {
                  $modalStack.dismiss(modal.key, 'escape key press');
                });
              }
              break;
            }
            case 9: {
              var list = $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                  focusChanged = $modalStack.focusLastFocusableElement(list);
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt, list)) {
                  focusChanged = $modalStack.focusFirstFocusableElement(list);
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }

              break;
            }
          }
        }
      }

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        
        
        
        
        previousTopOpenedModal = openedWindows.top();

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();

        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
          if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
          }
        }

        
        
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        appendToElement.addClass(modalBodyClass);
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };

      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabableSelector);
            return elements ?
              Array.prototype.filter.call(elements, function(element) {
                return isVisible(element);
              }) : elements;
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, 
        
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ?
                options.templateUrl() : options.templateUrl);
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            
            
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            
            
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

            
            
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            
            
            
            
            
            
            
            
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {
                var providedScope = modalOptions.scope || $rootScope;

                var modalScope = providedScope.$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });

                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

                
                
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$scope.$resolve = {};
                  ctrlLocals.$uibModalInstance = modalInstance;
                  angular.forEach(tplAndVars[1], function(value, key) {
                    ctrlLocals[key] = value;
                    ctrlLocals.$scope.$resolve[key] = value;
                  });

                  
                  
                  
                  
                  
                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                  if (modalOptions.controllerAs && modalOptions.bindToController) {
                    ctrlInstance = ctrlInstantiate.instance;
                    ctrlInstance.$close = modalScope.$close;
                    ctrlInstance.$dismiss = modalScope.$dismiss;
                    angular.extend(ctrlInstance, {
                      $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope);
                  }

                  ctrlInstance = ctrlInstantiate();

                  if (angular.isFunction(ctrlInstance.$onInit)) {
                    ctrlInstance.$onInit();
                  }
                }

                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  closedDeferred: modalClosedDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass,
                  appendTo: modalOptions.appendTo
                });
                modalOpenedDeferred.resolve(true);

            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])
/**
 * Helper internal service for generating common controller code between the
 * pager and pagination components
 */
.factory('uibPaging', ['$parse', function($parse) {
  return {
    create: function(ctrl, $scope, $attrs) {
      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; 
      
      ctrl._watchers = [];

      ctrl.init = function(ngModelCtrl, config) {
        ctrl.ngModelCtrl = ngModelCtrl;
        ctrl.config = config;

        ngModelCtrl.$render = function() {
          ctrl.render();
        };

        if ($attrs.itemsPerPage) {
          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
            ctrl.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }));
        } else {
          ctrl.itemsPerPage = config.itemsPerPage;
        }

        $scope.$watch('totalItems', function(newTotal, oldTotal) {
          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }
        });
      };

      ctrl.calculateTotalPages = function() {
        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };

      ctrl.render = function() {
        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
      };

      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }

        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ctrl.ngModelCtrl.$setViewValue(page);
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.getText = function(key) {
        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
      };

      $scope.noPrevious = function() {
        return $scope.page === 1;
      };

      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };

      ctrl.updatePage = function() {
        ctrl.setNumPages($scope.$parent, $scope.totalPages); 
        

        if ($scope.page > $scope.totalPages) {
          $scope.selectPage($scope.totalPages);
        } else {
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.$on('$destroy', function() {
        while (ctrl._watchers.length) {
          ctrl._watchers.shift()();
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

  uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
  return {
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    controller: 'UibPagerController',
    controllerAs: 'pager',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pager/pager.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; 
        
      }

      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
    }
  };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
  var ctrl = this;
  
  
  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

  uibPaging.create(this, $scope, $attrs);

  if ($attrs.maxSize) {
    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
      maxSize = parseInt(value, 10);
      ctrl.render();
    }));
  }

  
  
  function makePage(number, text, isActive) {
    return {
      number: number,
      text: text,
      active: isActive
    };
  }

  function getPages(currentPage, totalPages) {
    var pages = [];

    
    
    var startPage = 1, endPage = totalPages;
    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

    
    
    if (isMaxSized) {
      if (rotate) {
        
        
        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
        endPage = startPage + maxSize - 1;

        
        
        if (endPage > totalPages) {
          endPage = totalPages;
          startPage = endPage - maxSize + 1;
        }
      } else {
        
        
        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

        
        
        endPage = Math.min(startPage + maxSize - 1, totalPages);
      }
    }

    
    
    for (var number = startPage; number <= endPage; number++) {
      var page = makePage(number, pageLabel(number), number === currentPage);
      pages.push(page);
    }

    
    
    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
      if (startPage > 1) {
        if (!boundaryLinkNumbers || startPage > 3) { 
        	
        var previousPageSet = makePage(startPage - 1, '...', false);
        pages.unshift(previousPageSet);
      }
        if (boundaryLinkNumbers) {
          if (startPage === 3) { 
          	
            var secondPageLink = makePage(2, '2', false);
            pages.unshift(secondPageLink);
          }
          
          
          var firstPageLink = makePage(1, '1', false);
          pages.unshift(firstPageLink);
        }
      }

      if (endPage < totalPages) {
        if (!boundaryLinkNumbers || endPage < totalPages - 2) { 
        	
        var nextPageSet = makePage(endPage + 1, '...', false);
        pages.push(nextPageSet);
      }
        if (boundaryLinkNumbers) {
          if (endPage === totalPages - 2) { 
          	
            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
            pages.push(secondToLastPageLink);
          }
          
          
          var lastPageLink = makePage(totalPages, totalPages, false);
          pages.push(lastPageLink);
        }
      }
    }
    return pages;
  }

  var originalRender = this.render;
  this.render = function() {
    originalRender();
    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
      $scope.pages = getPages($scope.page, $scope.totalPages);
    }
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  boundaryLinkNumbers: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true,
  forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
  return {
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; 
         
      }

      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  
  
  var defaultOptions = {
    placement: 'top',
    placementClassPrefix: '',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  
  
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'outsideClick': 'outsideClick',
    'focus': 'blur',
    'none': ''
  };

  
  
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     
   
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake_case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
    var openedTooltips = $$stackedMap.createNew();
    $document.on('keypress', keypressListener);

    $rootScope.$on('$destroy', function() {
      $document.off('keypress', keypressListener);
    });

    function keypressListener(e) {
      if (e.which === 27) {
        var last = openedTooltips.top();
        if (last) {
          last.value.close();
          openedTooltips.removeTop();
          last = null;
        }
      }
    }

    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(ttType);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName + '-popup ' +
          'uib-title="' + startSym + 'title' + endSym + '" ' +
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'placement="' + startSym + 'placement' + endSym + '" ' +
          'popup-class="' + startSym + 'popupClass' + endSym + '" ' +
          'animation="animation" ' +
          'is-open="isOpen" ' +
          'origin-scope="origScope" ' +
          'class="uib-position-measure"' +
          '>' +
        '</div>';

      return {
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var showTimeout;
            var hideTimeout;
            var positionTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
            var observers = [];
            var lastPlacement;

            var positionTooltip = function() {
              
              
              if (!tooltip || !tooltip.html()) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });

                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {
                    tooltip.removeClass(lastPlacement.split('-')[0]);
                    tooltip.addClass(ttPosition.placement.split('-')[0]);
                  }

                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                  }

                  
                  
                  
                  
                  
                  
                  if (tooltip.hasClass('uib-position-measure')) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                    tooltip.removeClass('uib-position-measure');
                  } else if (lastPlacement !== ttPosition.placement) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                  }
                  lastPlacement = ttPosition.placement;

                  positionTimeout = null;
                }, 0, false);
              }
            };

            
            
            ttScope.origScope = scope;

            
            
            
            
            ttScope.isOpen = false;
            openedTooltips.add(ttScope, {
              close: hide
            });

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            
            
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              cancelHide();
              prepareTooltip();

              if (ttScope.popupDelay) {
                
                
                
                
                if (!showTimeout) {
                  showTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind() {
              cancelShow();

              if (ttScope.popupCloseDelay) {
                if (!hideTimeout) {
                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                }
              } else {
                hide();
              }
            }

            
            
            function show() {
              cancelShow();
              cancelHide();

              
              
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              
              
              ttScope.$evalAsync(function() {
                ttScope.isOpen = true;
                assignIsOpen(true);
                positionTooltip();
              });
            }

            function cancelShow() {
              if (showTimeout) {
                $timeout.cancel(showTimeout);
                showTimeout = null;
              }

              if (positionTimeout) {
                $timeout.cancel(positionTimeout);
                positionTimeout = null;
              }
            }

            
            
            function hide() {
              if (!ttScope) {
                return;
              }

              
              
              ttScope.$evalAsync(function() {
                if (ttScope) {
                  ttScope.isOpen = false;
                  assignIsOpen(false);
                  
                  
                  
                  
                  
                  
                  
                  
                  if (ttScope.animation) {
                    if (!transitionTimeout) {
                      transitionTimeout = $timeout(removeTooltip, 150, false);
                    }
                  } else {
                    removeTooltip();
                  }
                }
              });
            }

            function cancelHide() {
              if (hideTimeout) {
                $timeout.cancel(hideTimeout);
                hideTimeout = null;
              }

              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }
            }

            function createTooltip() {
              
              
              if (tooltip) {
                return;
              }

              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              prepObservers();
            }

            function removeTooltip() {
              cancelShow();
              cancelHide();
              unregisterObservers();

              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            /**
             * Set the initial scope values. Once
             * the tooltip is created, the observers
             * will be added to keep things in sync.
             */
            function prepareTooltip() {
              ttScope.title = attrs[prefix + 'Title'];
              if (contentParse) {
                ttScope.content = contentParse(scope);
              } else {
                ttScope.content = attrs[ttType];
              }

              ttScope.popupClass = attrs[prefix + 'Class'];
              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
              var placement = $position.parsePlacement(ttScope.placement);
              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
            }

            function assignIsOpen(isOpen) {
              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                isOpenParse.assign(scope, isOpen);
              }
            }

            ttScope.contentExp = function() {
              return ttScope.content;
            };

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe('disabled', function(val) {
              if (val) {
                cancelShow();
              }

              if (val && ttScope.isOpen) {
                hide();
              }
            });

            if (isOpenParse) {
              scope.$watch(isOpenParse, function(val) {
                if (ttScope && !val === ttScope.isOpen) {
                  toggleTooltipBind();
                }
              });
            }

            function prepObservers() {
              observers.length = 0;

              if (contentParse) {
                observers.push(
                  scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  })
                );

                observers.push(
                  tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  })
                );
              } else {
                observers.push(
                  attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  })
                );
              }

              observers.push(
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );

              observers.push(
                attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );
            }

            function unregisterObservers() {
              if (observers.length) {
                angular.forEach(observers, function(observer) {
                  observer();
                });
                observers.length = 0;
              }
            }

            
            
            function bodyHideTooltipBind(e) {
              if (!ttScope || !ttScope.isOpen || !tooltip) {
                return;
              }
              
              
              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                hideTooltipBind();
              }
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  element.off('click', toggleTooltipBind);
                } else {
                  element.off(trigger, showTooltipBind);
                  element.off(trigger, toggleTooltipBind);
                }
              });
              triggers.hide.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  $document.off('click', bodyHideTooltipBind);
                } else {
                  element.off(trigger, hideTooltipBind);
                }
              });
            };

            function prepTriggers() {
              var val = attrs[prefix + 'Trigger'];
              unregisterTriggers();

              triggers = getTriggers(val);

              if (triggers.show !== 'none') {
                triggers.show.forEach(function(trigger, idx) {
                  if (trigger === 'outsideClick') {
                    element.on('click', toggleTooltipBind);
                    $document.on('click', bodyHideTooltipBind);
                  } else if (trigger === triggers.hide[idx]) {
                    element.on(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element.on(trigger, showTooltipBind);
                    element.on(triggers.hide[idx], hideTooltipBind);
                  }

                  element.on('keypress', function(e) {
                    if (e.which === 27) {
                      hideTooltipBind();
                    }
                  });
                });
              }
            }

            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal;
            var appendKey = prefix + 'AppendToBody';
            if (appendKey in attrs && attrs[appendKey] === undefined) {
              appendToBodyVal = true;
            } else {
              appendToBodyVal = scope.$eval(attrs[appendKey]);
            }

            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            
            
            scope.$on('$destroy', function onDestroyTooltip() {
              unregisterTriggers();
              removeTooltip();
              openedTooltips.remove(ttScope);
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})



.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          
          
          
          
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      
      
      
      
      
      
      if (scope.placement) {
        
        
        
        
        
        
        var position = $uibPosition.parsePlacement(scope.placement);
        element.addClass(position[0]);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('uibTooltipPopup', function() {
  return {
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    replace: true,
    scope: { uibTitle: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'uib/template/popover/popover-template.html'
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', uibTitle: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'uib/template/popover/popover-html.html'
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    replace: true,
    scope: { uibTitle: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'uib/template/popover/popover.html'
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = getMaxOrDefault();

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = getMaxOrDefault();
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  
  
  $scope.$watch('maxParam', function(maxParam) {
    self.bars.forEach(function(bar) {
      bar.max = getMaxOrDefault();
      bar.recalculatePercentage();
    });
  });

  function getMaxOrDefault () {
    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
  }
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      maxParam: '=?max'
    },
    templateUrl: 'uib/template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      maxParam: '=?max',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  enableReset: true,
  titles : ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop },
    self = this;

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }

      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.enableReset = angular.isDefined($attrs.enableReset) ?
      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index >= this.titles.length) {
      return index + 1;
    }

    return this.titles[index];
  };

  $scope.rate = function(value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
      ngModelCtrl.$setViewValue(newViewValue);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.title = self.getTitle($scope.value - 1);
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    scope: {
      readonly: '=?readOnly',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'UibRatingController',
    templateUrl: 'uib/template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
    oldIndex;
  ctrl.tabs = [];

  ctrl.select = function(index, evt) {
    if (!destroyed) {
      var previousIndex = findTabIndex(oldIndex);
      var previousSelected = ctrl.tabs[previousIndex];
      if (previousSelected) {
        previousSelected.tab.onDeselect({
          $event: evt,
          $selectedIndex: index
        });
        if (evt && evt.isDefaultPrevented()) {
          return;
        }
        previousSelected.tab.active = false;
      }

      var selected = ctrl.tabs[index];
      if (selected) {
        selected.tab.onSelect({
          $event: evt
        });
        selected.tab.active = true;
        ctrl.active = selected.index;
        oldIndex = selected.index;
      } else if (!selected && angular.isDefined(oldIndex)) {
        ctrl.active = null;
        oldIndex = null;
      }
    }
  };

  ctrl.addTab = function addTab(tab) {
    ctrl.tabs.push({
      tab: tab,
      index: tab.index
    });
    ctrl.tabs.sort(function(t1, t2) {
      if (t1.index > t2.index) {
        return 1;
      }

      if (t1.index < t2.index) {
        return -1;
      }

      return 0;
    });

    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
      var newActiveIndex = findTabIndex(tab.index);
      ctrl.select(newActiveIndex);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index;
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].tab === tab) {
        index = i;
        break;
      }
    }

    if (ctrl.tabs[index].index === ctrl.active) {
      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
        index - 1 : index + 1 % ctrl.tabs.length;
      ctrl.select(newActiveTabIndex);
    }

    ctrl.tabs.splice(index, 1);
  };

  $scope.$watch('tabset.active', function(val) {
    if (angular.isDefined(val) && val !== oldIndex) {
      ctrl.select(findTabIndex(val));
    }
  });

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function findTabIndex(index) {
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].index === index) {
        return i;
      }
    }
  }
}])

.directive('uibTabset', function() {
  return {
    transclude: true,
    replace: true,
    scope: {},
    bindToController: {
      active: '=?',
      type: '@'
    },
    controller: 'UibTabsetController',
    controllerAs: 'tabset',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
    },
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ?
        scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ?
        scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tab.html';
    },
    transclude: true,
    scope: {
      heading: '@',
      index: '=?',
      classes: '@?',
      onSelect: '&select', 
      
                          
                          
      onDeselect: '&deselect'
    },
    controller: function() {
      
      
    },
    controllerAs: 'tab',
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      if (angular.isUndefined(attrs.index)) {
        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
        } else {
          scope.index = 0;
        }
      }

      if (angular.isUndefined(attrs.classes)) {
        scope.classes = '';
      }

      scope.select = function(evt) {
        if (!scope.disabled) {
          var index;
          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
            if (tabsetCtrl.tabs[i].tab === scope) {
              index = i;
              break;
            }
          }

          tabsetCtrl.select(index, evt);
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      
      
      
      
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTab',
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

      
      
      
      
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            
            
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'uib:tab-heading'
    );
  }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  showMeridian: true,
  showSeconds: false,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true,
  templateUrl: 'uib/template/timepicker/timepicker.html'
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
    watchers = [],
    ngModelCtrl = { $setViewValue: angular.noop }, 
    
    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = +value;
    }));
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = +value;
    }));
  }

  var min;
  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  }));

  var max;
  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  }));

  var disabled = false;
  if ($attrs.ngDisabled) {
    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
      disabled = value;
    }));
  }

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementSeconds = function() {
    var incrementedSelected = addSeconds(selected, secondStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementSeconds = function() {
    var decrementedSelected = addSeconds(selected, -secondStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() < 12) {
      return disabled || addMinutes(selected, 12 * 60) > max;
    }

    return disabled || addMinutes(selected, -12 * 60) < min;
  };

  var secondStep = timepickerConfig.secondStep;
  if ($attrs.secondStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
      secondStep = +value;
    }));
  }

  $scope.showSeconds = timepickerConfig.showSeconds;
  if ($attrs.showSeconds) {
    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
      $scope.showSeconds = !!value;
    }));
  }

  
  
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        
        
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    }));
  }

  
  
  function getHoursFromTemplate() {
    var hours = +$scope.hours;
    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
      hours >= 0 && hours < 24;
    if (!valid || $scope.hours === '') {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = +$scope.minutes;
    var valid = minutes >= 0 && minutes < 60;
    if (!valid || $scope.minutes === '') {
      return undefined;
    }
    return minutes;
  }

  function getSecondsFromTemplate() {
    var seconds = +$scope.seconds;
    return seconds >= 0 && seconds < 60 ? seconds : undefined;
  }

  function pad(value, noPad) {
    if (value === null) {
      return '';
    }

    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
      '0' + value : value.toString();
  }

  
  
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      
      
      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
      return e.detail || delta > 0;
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      }
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      }
      e.preventDefault();
    });

     secondsInputEl.bind('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
      }
      e.preventDefault();
    });
  };

  
  
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    hoursInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { 
        	
          e.preventDefault();
          $scope.incrementHours();
          $scope.$apply();
        } else if (e.which === 40) { 
        	
          e.preventDefault();
          $scope.decrementHours();
          $scope.$apply();
        }
      }
    });

    minutesInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { 
        	
          e.preventDefault();
          $scope.incrementMinutes();
          $scope.$apply();
        } else if (e.which === 40) { 
        	
          e.preventDefault();
          $scope.decrementMinutes();
          $scope.$apply();
        }
      }
    });

    secondsInputEl.bind('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { 
        	
          e.preventDefault();
          $scope.incrementSeconds();
          $scope.$apply();
        } else if (e.which === 40) { 
        	
          e.preventDefault();
          $scope.decrementSeconds();
          $scope.$apply();
        }
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      $scope.updateSeconds = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }

      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }

      if (angular.isDefined(invalidSeconds)) {
        $scope.invalidSeconds = invalidSeconds;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.hours === null || $scope.hours === '') {
        invalidate(true);
      } else if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours, !padHours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.minutes === null) {
        invalidate(undefined, true);
      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

    $scope.updateSeconds = function() {
      var seconds = getSecondsFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(seconds)) {
        selected.setSeconds(seconds);
        refresh('s');
      } else {
        invalidate(undefined, undefined, true);
      }
    };

    secondsInputEl.bind('blur', function(e) {
      if (modelIsEmpty()) {
        makeValid();
      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
        $scope.$apply( function() {
          $scope.seconds = pad($scope.seconds);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected < min || selected > max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  
  
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
    $scope.invalidSeconds = false;
  }

  function updateTemplate(keyboardChange) {
    if (!ngModelCtrl.$modelValue) {
      $scope.hours = null;
      $scope.minutes = null;
      $scope.seconds = null;
      $scope.meridian = meridians[0];
    } else {
      var hours = selected.getHours(),
        minutes = selected.getMinutes(),
        seconds = selected.getSeconds();

      if ($scope.showMeridian) {
        hours = hours === 0 || hours === 12 ? 12 : hours % 12; 
        
      }

      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
      if (keyboardChange !== 'm') {
        $scope.minutes = pad(minutes);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

      if (keyboardChange !== 's') {
        $scope.seconds = pad(seconds);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
  }

  function addSecondsToSelected(seconds) {
    selected = addSeconds(selected, seconds);
    refresh();
  }

  function addMinutes(selected, minutes) {
    return addSeconds(selected, minutes*60);
  }

  function addSeconds(date, seconds) {
    var dt = new Date(date.getTime() + seconds * 1000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
    return newDate;
  }

  function modelIsEmpty() {
    return ($scope.hours === null || $scope.hours === '') &&
      ($scope.minutes === null || $scope.minutes === '') &&
      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addSecondsToSelected(hourStep * 60 * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addSecondsToSelected(-hourStep * 60 * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addSecondsToSelected(minuteStep * 60);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addSecondsToSelected(-minuteStep * 60);
    }
  };

  $scope.incrementSeconds = function() {
    if (!$scope.noIncrementSeconds()) {
      addSecondsToSelected(secondStep);
    }
  };

  $scope.decrementSeconds = function() {
    if (!$scope.noDecrementSeconds()) {
      addSecondsToSelected(-secondStep);
    }
  };

  $scope.toggleMeridian = function() {
    var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

    if (!$scope.noToggleMeridian()) {
      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
      } else {
        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
      }
    }
  };

  $scope.blur = function() {
    ngModelCtrl.$setTouched();
  };

  $scope.$on('$destroy', function() {
    while (watchers.length) {
      watchers.shift()();
    }
  });
}])

.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
  return {
    require: ['uibTimepicker', '?^ngModel'],
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    
    
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
              ' but got "' + input + '".');
        }

        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl, ngModelOptions;
    
    

    
    
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }

    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
    });

    
    
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

    
    
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
      isEditable = newVal !== false;
    });

    
    
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

    
    
    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
      var evt = vals.$event;
      return evt.which === 13 || evt.which === 9;
    };

    
    
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

    
    
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

    
    
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

    var appendTo = attrs.typeaheadAppendTo ?
      originalScope.$eval(attrs.typeaheadAppendTo) : null;

    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

    
    
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

    
    
    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

    
    

    
    
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) &&
        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
        return invokeModelSetter(scope, {$$$p: newValue});
      }

      return parsedModel.assign(scope, newValue);
    };

    
    
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

    var hasFocus;

    
    
    
    
    
    
    var selected;

    
    
    
    
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);

    
    
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });

    var inputsContainer, hintInputElem;
    
    
    if (showHint) {
      inputsContainer = angular.element('<div></div>');
      inputsContainer.css('position', 'relative');
      element.after(inputsContainer);
      hintInputElem = element.clone();
      hintInputElem.attr('placeholder', '');
      hintInputElem.attr('tabindex', '-1');
      hintInputElem.val('');
      hintInputElem.css({
        'position': 'absolute',
        'top': '0px',
        'left': '0px',
        'border-color': 'transparent',
        'box-shadow': 'none',
        'opacity': 1,
        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
        'color': '#999'
      });
      element.css({
        'position': 'relative',
        'vertical-align': 'top',
        'background-color': 'transparent'
      });
      inputsContainer.append(hintInputElem);
      hintInputElem.after(element);
    }

    
    
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx, evt)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position',
      'assign-is-open': 'assignIsOpen(isOpen)',
      debounce: 'debounceUpdate'
    });
    
    
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }

    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }

    var resetHint = function() {
      if (showHint) {
        hintInputElem.val('');
      }
    };

    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
      resetHint();
    };

    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };

    
    
    
    
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });

    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }

      return false;
    };

    var getMatchesAsync = function(inputValue, evt) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        
        
        
        
        var onCurrentRequest = inputValue === modelCtrl.$viewValue;
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;

            
            
            for (var i = 0; i < matches.length; i++) {
            	
            	
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }

            scope.query = inputValue;
            
            
            
            
            
            
            recalculatePosition();

            element.attr('aria-expanded', true);

            
            
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(0, evt);
              }
            }

            if (showHint) {
              var firstLabel = scope.matches[0].label;
              if (angular.isString(inputValue) &&
                inputValue.length > 0 &&
                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
              } else {
                hintInputElem.val('');
              }
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };

    
    
    if (appendToBody) {
      angular.element($window).on('resize', fireRecalculating);
      $document.find('body').on('scroll', fireRecalculating);
    }

    
    
    
    
    var debouncedRecalculate = $$debounce(function() {
      
      
      if (scope.matches.length) {
        recalculatePosition();
      }

      scope.moveInProgress = false;
    }, eventDebounceTime);

    
    
    scope.moveInProgress = false;

    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }

      debouncedRecalculate();
    }

    
    
    
    
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }

    
    
    scope.query = undefined;

    
    
    var timeoutPromise;

    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };

    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };

    resetMatches();

    scope.assignIsOpen = function (isOpen) {
      isOpenSetter(originalScope, isOpen);
    };

    scope.select = function(activeIdx, evt) {
      
      
      var locals = {};
      var model, item;

      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);

      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals),
        $event: evt
      });

      resetMatches();

      
      
      
      
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() { element[0].focus(); }, 0, false);
      }
    };

    
    
    element.on('keydown', function(evt) {
      
      
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }

      var shouldSelect = isSelectEvent(originalScope, {$event: evt});

      /**
       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
       * or
       * shift + tab is pressed to bring focus to the previous element
       * then clear the results
       */
      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
        resetMatches();
        scope.$digest();
        return;
      }

      evt.preventDefault();
      var target;
      switch (evt.which) {
        case 27: 
        
          evt.stopPropagation();

          resetMatches();
          originalScope.$digest();
          break;
        case 38: 
        
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
          target = popUpEl.find('li')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        case 40: 
        
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
          target = popUpEl.find('li')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        default:
          if (shouldSelect) {
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
            	scope.matches[scope.activeIdx].model._componentsName = scope.$parent._componentsName;
            	scope.$emit('autocomplete:selected',scope.matches[scope.activeIdx].model);
                scope.select(scope.activeIdx, evt);
              }
            });
          }
      }
    });

    element.bind('focus', function (evt) {
      hasFocus = true;
      if (minLength === 0 && !modelCtrl.$viewValue) {
        $timeout(function() {
          getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
      }
    });

    element.bind('blur', function(evt) {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
            $$debounce(function() {
              scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur);
          } else {
            scope.select(scope.activeIdx, evt);
          }
        });
      }
      if (!isEditable && modelCtrl.$error.editable) {
        modelCtrl.$setViewValue();
        
        
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        element.val('');
      }
      hasFocus = false;
      selected = false;
    });

    
    
    var dismissClickHandler = function(evt) {
      
      
      
      
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          originalScope.$digest();
        }
      }
    };

    $document.on('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
      $document.off('click', dismissClickHandler);
      if (appendToBody || appendTo) {
        $popup.remove();
      }

      if (appendToBody) {
        angular.element($window).off('resize', fireRecalculating);
        $document.find('body').off('scroll', fireRecalculating);
      }
      
      
      popUpEl.remove();

      if (showHint) {
          inputsContainer.remove();
      }
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendTo) {
      angular.element(appendTo).eq(0).append($popup);
    } else {
      element.after($popup);
    }

    this.init = function(_modelCtrl, _ngModelOptions) {
      modelCtrl = _modelCtrl;
      ngModelOptions = _ngModelOptions;

      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);

      
      
      
      
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;

        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        }

        if (!inputValue) {
          
          
          modelCtrl.$setValidity('editable', true);
          return null;
        }

        modelCtrl.$setValidity('editable', false);
        return undefined;
      });

      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue, emptyViewValue;
        var locals = {};

        
        
        
        
        
        
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        }

        
        
        
        
        locals[parserResult.itemName] = modelValue;
        candidateViewValue = parserResult.viewMapper(originalScope, locals);
        locals[parserResult.itemName] = undefined;
        emptyViewValue = parserResult.viewMapper(originalScope, locals);

        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
      });
    };
  }])

  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
          originalScope._componentsName = attrs.name;
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&',
        assignIsOpen: '&',
        debounce: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length > 0;
          scope.assignIsOpen({ isOpen: isDropdownOpen });
          return isDropdownOpen;
        };

        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx, evt) {
          scope.matches[activeIdx].model._componentsName = scope.$parent.$parent._componentsName;
          scope.$emit('autocomplete:selected',scope.matches[activeIdx].model);
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({activeIdx: activeIdx, evt: evt});
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({activeIdx: activeIdx, evt: evt});
          }
        };
      }
    };
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      
      
      
      
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); 
        
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; 
      
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); 
        
      }
      return matchItem;
    };
  }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
    "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" +
    "  <div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
    "    <h4 class=\"panel-title\">\n" +
    "      <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "    </h4>\n" +
    "  </div>\n" +
    "  <div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
    "    <div class=\"panel-body\" ng-transclude></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
    "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
    "        <span aria-hidden=\"true\">&times;</span>\n" +
    "        <span class=\"sr-only\">Close</span>\n" +
    "    </button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
    "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
    "    <span class=\"sr-only\">previous</span>\n" +
    "  </a>\n" +
    "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
    "    <span class=\"sr-only\">next</span>\n" +
    "  </a>\n" +
    "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
    "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
    "    </li>\n" +
    "  </ol>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': active\n" +
    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
    "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
    "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
    "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
    "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
    "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
    "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepickerPopup/popup.html",
    "<div>\n" +
    "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "    <li ng-transclude></li>\n" +
    "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
    "      <span class=\"btn-group pull-left\">\n" +
    "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
    "      </span>\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/backdrop.html",
    "<div class=\"modal-backdrop\"\n" +
    "     uib-modal-animation-class=\"fade\"\n" +
    "     modal-in-class=\"in\"\n" +
    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
    "></div>\n" +
    "");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
    "    uib-modal-animation-class=\"fade\"\n" +
    "    modal-in-class=\"in\"\n" +
    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
    "    <div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\"\n" +
    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "      <div class=\"popover-content\"\n" +
    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
    "</span>\n" +
    "");
}]);

angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
    "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
    "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\"\n" +
    "         ng-repeat=\"tab in tabset.tabs\"\n" +
    "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
    "         uib-tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
    "<table class=\"uib-timepicker\">\n" +
    "  <tbody>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
    "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
    "<a href\n" +
    "   tabindex=\"-1\"\n" +
    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
    "   ng-attr-title=\"{{match.label}}\"></a>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });
/*!
 * angular-translate - v2.7.2 - 2015-06-01
 * http://github.com/angular-translate/angular-translate
 * Copyright (c) 2015 ; Licensed MIT
 */
!function(a,b){"function"==typeof define&&define.amd?define([],function(){return b()}):"object"==typeof exports?module.exports=b():b()}(this,function(){function a(a){"use strict";var b=a.storageKey(),c=a.storage(),d=function(){var d=a.preferredLanguage();angular.isString(d)?a.use(d):c.put(b,a.use())};d.displayName="fallbackFromIncorrectStorageValue",c?c.get(b)?a.use(c.get(b))["catch"](d):d():angular.isString(a.preferredLanguage())&&a.use(a.preferredLanguage())}function b(){"use strict";var a,b,c=null,d=!1,e=!1;b={sanitize:function(a,b){return"text"===b&&(a=g(a)),a},escape:function(a,b){return"text"===b&&(a=f(a)),a},sanitizeParameters:function(a,b){return"params"===b&&(a=h(a,g)),a},escapeParameters:function(a,b){return"params"===b&&(a=h(a,f)),a}},b.escaped=b.escapeParameters,this.addStrategy=function(a,c){return b[a]=c,this},this.removeStrategy=function(a){return delete b[a],this},this.useStrategy=function(a){return d=!0,c=a,this},this.$get=["$injector","$log",function(f,g){var h=function(a,c,d){return angular.forEach(d,function(d){if(angular.isFunction(d))a=d(a,c);else{if(!angular.isFunction(b[d]))throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '"+d+"'");a=b[d](a,c)}}),a},i=function(){d||e||(g.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details."),e=!0)};return f.has("$sanitize")&&(a=f.get("$sanitize")),{useStrategy:function(a){return function(b){a.useStrategy(b)}}(this),sanitize:function(a,b,d){if(c||i(),arguments.length<3&&(d=c),!d)return a;var e=angular.isArray(d)?d:[d];return h(a,b,e)}}}];var f=function(a){var b=angular.element("<div></div>");return b.text(a),b.html()},g=function(b){if(!a)throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");return a(b)},h=function(a,b){if(angular.isObject(a)){var c=angular.isArray(a)?[]:{};return angular.forEach(a,function(a,d){c[d]=h(a,b)}),c}return angular.isNumber(a)?a:b(a)}}function c(a,b,c,d){"use strict";var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t={},u=[],v=a,w=[],x="translate-cloak",y=!1,z=!1,A=".",B=0,C=!0,D="default",E={"default":function(a){return(a||"").split("-").join("_")},java:function(a){var b=(a||"").split("-").join("_"),c=b.split("_");return c.length>1?c[0].toLowerCase()+"_"+c[1].toUpperCase():b},bcp47:function(a){var b=(a||"").split("_").join("-"),c=b.split("-");return c.length>1?c[0].toLowerCase()+"-"+c[1].toUpperCase():b}},F="2.7.2",G=function(){if(angular.isFunction(d.getLocale))return d.getLocale();var a,c,e=b.$get().navigator,f=["language","browserLanguage","systemLanguage","userLanguage"];if(angular.isArray(e.languages))for(a=0;a<e.languages.length;a++)if(c=e.languages[a],c&&c.length)return c;for(a=0;a<f.length;a++)if(c=e[f[a]],c&&c.length)return c;return null};G.displayName="angular-translate/service: getFirstBrowserLanguage";var H=function(){var a=G()||"";return E[D]&&(a=E[D](a)),a};H.displayName="angular-translate/service: getLocale";var I=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},J=function(){return this.toString().replace(/^\s+|\s+$/g,"")},K=function(a){for(var b=[],c=angular.lowercase(a),d=0,e=u.length;e>d;d++)b.push(angular.lowercase(u[d]));if(I(b,c)>-1)return a;if(f){var g;for(var h in f){var i=!1,j=Object.prototype.hasOwnProperty.call(f,h)&&angular.lowercase(h)===angular.lowercase(a);if("*"===h.slice(-1)&&(i=h.slice(0,-1)===a.slice(0,h.length-1)),(j||i)&&(g=f[h],I(b,angular.lowercase(g))>-1))return g}}if(a){var k=a.split("_");if(k.length>1&&I(b,angular.lowercase(k[0]))>-1)return k[0]}return a},L=function(a,b){if(!a&&!b)return t;if(a&&!b){if(angular.isString(a))return t[a]}else angular.isObject(t[a])||(t[a]={}),angular.extend(t[a],M(b));return this};this.translations=L,this.cloakClassName=function(a){return a?(x=a,this):x};var M=function(a,b,c,d){var e,f,g,h;b||(b=[]),c||(c={});for(e in a)Object.prototype.hasOwnProperty.call(a,e)&&(h=a[e],angular.isObject(h)?M(h,b.concat(e),c,e):(f=b.length?""+b.join(A)+A+e:e,b.length&&e===d&&(g=""+b.join(A),c[g]="@:"+f),c[f]=h));return c};M.displayName="flatObject",this.addInterpolation=function(a){return w.push(a),this},this.useMessageFormatInterpolation=function(){return this.useInterpolation("$translateMessageFormatInterpolation")},this.useInterpolation=function(a){return n=a,this},this.useSanitizeValueStrategy=function(a){return c.useStrategy(a),this},this.preferredLanguage=function(a){return N(a),this};var N=function(a){return a&&(e=a),e};this.translationNotFoundIndicator=function(a){return this.translationNotFoundIndicatorLeft(a),this.translationNotFoundIndicatorRight(a),this},this.translationNotFoundIndicatorLeft=function(a){return a?(q=a,this):q},this.translationNotFoundIndicatorRight=function(a){return a?(r=a,this):r},this.fallbackLanguage=function(a){return O(a),this};var O=function(a){return a?(angular.isString(a)?(h=!0,g=[a]):angular.isArray(a)&&(h=!1,g=a),angular.isString(e)&&I(g,e)<0&&g.push(e),this):h?g[0]:g};this.use=function(a){if(a){if(!t[a]&&!o)throw new Error("$translateProvider couldn't find translationTable for langKey: '"+a+"'");return i=a,this}return i};var P=function(a){return a?(v=a,this):l?l+v:v};this.storageKey=P,this.useUrlLoader=function(a,b){return this.useLoader("$translateUrlLoader",angular.extend({url:a},b))},this.useStaticFilesLoader=function(a){return this.useLoader("$translateStaticFilesLoader",a)},this.useLoader=function(a,b){return o=a,p=b||{},this},this.useLocalStorage=function(){return this.useStorage("$translateLocalStorage")},this.useCookieStorage=function(){return this.useStorage("$translateCookieStorage")},this.useStorage=function(a){return k=a,this},this.storagePrefix=function(a){return a?(l=a,this):a},this.useMissingTranslationHandlerLog=function(){return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog")},this.useMissingTranslationHandler=function(a){return m=a,this},this.usePostCompiling=function(a){return y=!!a,this},this.forceAsyncReload=function(a){return z=!!a,this},this.uniformLanguageTag=function(a){return a?angular.isString(a)&&(a={standard:a}):a={},D=a.standard,this},this.determinePreferredLanguage=function(a){var b=a&&angular.isFunction(a)?a():H();return e=u.length?K(b):b,this},this.registerAvailableLanguageKeys=function(a,b){return a?(u=a,b&&(f=b),this):u},this.useLoaderCache=function(a){return a===!1?s=void 0:a===!0?s=!0:"undefined"==typeof a?s="$translationCache":a&&(s=a),this},this.directivePriority=function(a){return void 0===a?B:(B=a,this)},this.statefulFilter=function(a){return void 0===a?C:(C=a,this)},this.$get=["$log","$injector","$rootScope","$q",function(a,b,c,d){var f,l,u,A=b.get(n||"$translateDefaultInterpolation"),D=!1,E={},G={},H=function(a,b,c,h){if(angular.isArray(a)){var j=function(a){for(var e={},f=[],g=function(a){var f=d.defer(),g=function(b){e[a]=b,f.resolve([a,b])};return H(a,b,c,h).then(g,g),f.promise},i=0,j=a.length;j>i;i++)f.push(g(a[i]));return d.all(f).then(function(){return e})};return j(a)}var m=d.defer();a&&(a=J.apply(a));var n=function(){var a=e?G[e]:G[i];if(l=0,k&&!a){var b=f.get(v);if(a=G[b],g&&g.length){var c=I(g,b);l=0===c?1:0,I(g,e)<0&&g.push(e)}}return a}();if(n){var o=function(){ab(a,b,c,h).then(m.resolve,m.reject)};o.displayName="promiseResolved",n["finally"](o,m.reject)}else ab(a,b,c,h).then(m.resolve,m.reject);return m.promise},Q=function(a){return q&&(a=[q,a].join(" ")),r&&(a=[a,r].join(" ")),a},R=function(a){i=a,c.$emit("$translateChangeSuccess",{language:a}),k&&f.put(H.storageKey(),i),A.setLocale(i);var b=function(a,b){E[b].setLocale(i)};b.displayName="eachInterpolatorLocaleSetter",angular.forEach(E,b),c.$emit("$translateChangeEnd",{language:a})},S=function(a){if(!a)throw"No language key specified for loading.";var e=d.defer();c.$emit("$translateLoadingStart",{language:a}),D=!0;var f=s;"string"==typeof f&&(f=b.get(f));var g=angular.extend({},p,{key:a,$http:angular.extend({},{cache:f},p.$http)}),h=function(b){var d={};c.$emit("$translateLoadingSuccess",{language:a}),angular.isArray(b)?angular.forEach(b,function(a){angular.extend(d,M(a))}):angular.extend(d,M(b)),D=!1,e.resolve({key:a,table:d}),c.$emit("$translateLoadingEnd",{language:a})};h.displayName="onLoaderSuccess";var i=function(a){c.$emit("$translateLoadingError",{language:a}),e.reject(a),c.$emit("$translateLoadingEnd",{language:a})};return i.displayName="onLoaderError",b.get(o)(g).then(h,i),e.promise};if(k&&(f=b.get(k),!f.get||!f.put))throw new Error("Couldn't use storage '"+k+"', missing get() or put() method!");if(w.length){var T=function(a){var c=b.get(a);c.setLocale(e||i),E[c.getInterpolationIdentifier()]=c};T.displayName="interpolationFactoryAdder",angular.forEach(w,T)}var U=function(a){var b=d.defer();if(Object.prototype.hasOwnProperty.call(t,a))b.resolve(t[a]);else if(G[a]){var c=function(a){L(a.key,a.table),b.resolve(a.table)};c.displayName="translationTableResolver",G[a].then(c,b.reject)}else b.reject();return b.promise},V=function(a,b,c,e){var f=d.defer(),g=function(d){if(Object.prototype.hasOwnProperty.call(d,b)){e.setLocale(a);var g=d[b];"@:"===g.substr(0,2)?V(a,g.substr(2),c,e).then(f.resolve,f.reject):f.resolve(e.interpolate(d[b],c)),e.setLocale(i)}else f.reject()};return g.displayName="fallbackTranslationResolver",U(a).then(g,f.reject),f.promise},W=function(a,b,c,d){var e,f=t[a];if(f&&Object.prototype.hasOwnProperty.call(f,b)){if(d.setLocale(a),e=d.interpolate(f[b],c),"@:"===e.substr(0,2))return W(a,e.substr(2),c,d);d.setLocale(i)}return e},X=function(a,c){if(m){var d=b.get(m)(a,i,c);return void 0!==d?d:a}return a},Y=function(a,b,c,e,f){var h=d.defer();if(a<g.length){var i=g[a];V(i,b,c,e).then(h.resolve,function(){Y(a+1,b,c,e,f).then(h.resolve)})}else h.resolve(f?f:X(b,c));return h.promise},Z=function(a,b,c,d){var e;if(a<g.length){var f=g[a];e=W(f,b,c,d),e||(e=Z(a+1,b,c,d))}return e},$=function(a,b,c,d){return Y(u>0?u:l,a,b,c,d)},_=function(a,b,c){return Z(u>0?u:l,a,b,c)},ab=function(a,b,c,e){var f=d.defer(),h=i?t[i]:t,j=c?E[c]:A;if(h&&Object.prototype.hasOwnProperty.call(h,a)){var k=h[a];"@:"===k.substr(0,2)?H(k.substr(2),b,c,e).then(f.resolve,f.reject):f.resolve(j.interpolate(k,b))}else{var l;m&&!D&&(l=X(a,b)),i&&g&&g.length?$(a,b,j,e).then(function(a){f.resolve(a)},function(a){f.reject(Q(a))}):m&&!D&&l?f.resolve(e?e:l):e?f.resolve(e):f.reject(Q(a))}return f.promise},bb=function(a,b,c){var d,e=i?t[i]:t,f=A;if(E&&Object.prototype.hasOwnProperty.call(E,c)&&(f=E[c]),e&&Object.prototype.hasOwnProperty.call(e,a)){var h=e[a];d="@:"===h.substr(0,2)?bb(h.substr(2),b,c):f.interpolate(h,b)}else{var j;m&&!D&&(j=X(a,b)),i&&g&&g.length?(l=0,d=_(a,b,f)):d=m&&!D&&j?j:Q(a)}return d},cb=function(a){j===a&&(j=void 0),G[a]=void 0};if(H.preferredLanguage=function(a){return a&&N(a),e},H.cloakClassName=function(){return x},H.fallbackLanguage=function(a){if(void 0!==a&&null!==a){if(O(a),o&&g&&g.length)for(var b=0,c=g.length;c>b;b++)G[g[b]]||(G[g[b]]=S(g[b]));H.use(H.use())}return h?g[0]:g},H.useFallbackLanguage=function(a){if(void 0!==a&&null!==a)if(a){var b=I(g,a);b>-1&&(u=b)}else u=0},H.proposedLanguage=function(){return j},H.storage=function(){return f},H.use=function(a){if(!a)return i;var b=d.defer();c.$emit("$translateChangeStart",{language:a});var e=K(a);return e&&(a=e),!z&&t[a]||!o||G[a]?j===a&&G[a]?G[a].then(function(a){return b.resolve(a.key),a},function(a){return b.reject(a),d.reject(a)}):(b.resolve(a),R(a)):(j=a,G[a]=S(a).then(function(a){return L(a.key,a.table),b.resolve(a.key),R(a.key),a},function(a){return c.$emit("$translateChangeError",{language:a}),b.reject(a),c.$emit("$translateChangeEnd",{language:a}),d.reject(a)}),G[a]["finally"](function(){cb(a)})),b.promise},H.storageKey=function(){return P()},H.isPostCompilingEnabled=function(){return y},H.isForceAsyncReloadEnabled=function(){return z},H.refresh=function(a){function b(){f.resolve(),c.$emit("$translateRefreshEnd",{language:a})}function e(){f.reject(),c.$emit("$translateRefreshEnd",{language:a})}if(!o)throw new Error("Couldn't refresh translation table, no loader registered!");var f=d.defer();if(c.$emit("$translateRefreshStart",{language:a}),a)if(t[a]){var h=function(c){L(c.key,c.table),a===i&&R(i),b()};h.displayName="refreshPostProcessor",S(a).then(h,e)}else e();else{var j=[],k={};if(g&&g.length)for(var l=0,m=g.length;m>l;l++)j.push(S(g[l])),k[g[l]]=!0;i&&!k[i]&&j.push(S(i));var n=function(a){t={},angular.forEach(a,function(a){L(a.key,a.table)}),i&&R(i),b()};n.displayName="refreshPostProcessor",d.all(j).then(n,e)}return f.promise},H.instant=function(a,b,c){if(null===a||angular.isUndefined(a))return a;if(angular.isArray(a)){for(var d={},f=0,h=a.length;h>f;f++)d[a[f]]=H.instant(a[f],b,c);return d}if(angular.isString(a)&&a.length<1)return a;a&&(a=J.apply(a));var j,k=[];e&&k.push(e),i&&k.push(i),g&&g.length&&(k=k.concat(g));for(var l=0,n=k.length;n>l;l++){var o=k[l];if(t[o]&&("undefined"!=typeof t[o][a]?j=bb(a,b,c):(q||r)&&(j=Q(a))),"undefined"!=typeof j)break}return j||""===j||(j=A.interpolate(a,b),m&&!D&&(j=X(a,b))),j},H.versionInfo=function(){return F},H.loaderCache=function(){return s},H.directivePriority=function(){return B},H.statefulFilter=function(){return C},o&&(angular.equals(t,{})&&H.use(H.use()),g&&g.length))for(var db=function(a){return L(a.key,a.table),c.$emit("$translateChangeEnd",{language:a.key}),a},eb=0,fb=g.length;fb>eb;eb++){var gb=g[eb];(z||!t[gb])&&(G[gb]=S(gb).then(db))}return H}]}function d(a,b){"use strict";var c,d={},e="default";return d.setLocale=function(a){c=a},d.getInterpolationIdentifier=function(){return e},d.useSanitizeValueStrategy=function(a){return b.useStrategy(a),this},d.interpolate=function(c,d){d=d||{},d=b.sanitize(d,"params");var e=a(c)(d);return e=b.sanitize(e,"text")},d}function e(a,b,c,d,e,f){"use strict";var g=function(){return this.toString().replace(/^\s+|\s+$/g,"")};return{restrict:"AE",scope:!0,priority:a.directivePriority(),compile:function(b,h){var i=h.translateValues?h.translateValues:void 0,j=h.translateInterpolation?h.translateInterpolation:void 0,k=b[0].outerHTML.match(/translate-value-+/i),l="^(.*)("+c.startSymbol()+".*"+c.endSymbol()+")(.*)",m="^(.*)"+c.startSymbol()+"(.*)"+c.endSymbol()+"(.*)";return function(b,n,o){b.interpolateParams={},b.preText="",b.postText="";var p={},q=function(a,c,d){if(c.translateValues&&angular.extend(a,e(c.translateValues)(b.$parent)),k)for(var f in d)if(Object.prototype.hasOwnProperty.call(c,f)&&"translateValue"===f.substr(0,14)&&"translateValues"!==f){var g=angular.lowercase(f.substr(14,1))+f.substr(15);a[g]=d[f]}},r=function(a){if(angular.isFunction(r._unwatchOld)&&(r._unwatchOld(),r._unwatchOld=void 0),angular.equals(a,"")||!angular.isDefined(a)){var d=g.apply(n.text()).match(l);if(angular.isArray(d)){b.preText=d[1],b.postText=d[3],p.translate=c(d[2])(b.$parent);var e=n.text().match(m);angular.isArray(e)&&e[2]&&e[2].length&&(r._unwatchOld=b.$watch(e[2],function(a){p.translate=a,x()}))}else p.translate=n.text().replace(/^\s+|\s+$/g,"")}else p.translate=a;x()},s=function(a){o.$observe(a,function(b){p[a]=b,x()})};q(b.interpolateParams,o,h);var t=!0;o.$observe("translate",function(a){"undefined"==typeof a?r(""):""===a&&t||(p.translate=a,x()),t=!1});for(var u in o)o.hasOwnProperty(u)&&"translateAttr"===u.substr(0,13)&&s(u);if(o.$observe("translateDefault",function(a){b.defaultText=a}),i&&o.$observe("translateValues",function(a){a&&b.$parent.$watch(function(){angular.extend(b.interpolateParams,e(a)(b.$parent))})}),k){var v=function(a){o.$observe(a,function(c){var d=angular.lowercase(a.substr(14,1))+a.substr(15);b.interpolateParams[d]=c})};for(var w in o)Object.prototype.hasOwnProperty.call(o,w)&&"translateValue"===w.substr(0,14)&&"translateValues"!==w&&v(w)}var x=function(){for(var a in p)p.hasOwnProperty(a)&&void 0!==p[a]&&y(a,p[a],b,b.interpolateParams,b.defaultText)},y=function(b,c,d,e,f){c?a(c,e,j,f).then(function(a){z(a,d,!0,b)},function(a){z(a,d,!1,b)}):z(c,d,!1,b)},z=function(b,c,e,f){if("translate"===f){e||"undefined"==typeof c.defaultText||(b=c.defaultText),n.html(c.preText+b+c.postText);var g=a.isPostCompilingEnabled(),i="undefined"!=typeof h.translateCompile,j=i&&"false"!==h.translateCompile;(g&&!i||j)&&d(n.contents())(c)}else{e||"undefined"==typeof c.defaultText||(b=c.defaultText);var k=o.$attr[f];"data-"===k.substr(0,5)&&(k=k.substr(5)),k=k.substr(15),n.attr(k,b)}};(i||k||o.translateDefault)&&b.$watch("interpolateParams",x,!0);var A=f.$on("$translateChangeSuccess",x);n.text().length?r(o.translate?o.translate:""):o.translate&&r(o.translate),x(),b.$on("$destroy",A)}}}}function f(a,b){"use strict";return{compile:function(c){var d=function(){c.addClass(b.cloakClassName())},e=function(){c.removeClass(b.cloakClassName())},f=a.$on("$translateChangeEnd",function(){e(),f(),f=null});return d(),function(a,c,f){f.translateCloak&&f.translateCloak.length&&f.$observe("translateCloak",function(a){b(a).then(e,d)})}}}}function g(a,b){"use strict";var c=function(c,d,e){return angular.isObject(d)||(d=a(d)(this)),b.instant(c,d,e)};return b.statefulFilter()&&(c.$stateful=!0),c}function h(a){"use strict";return a("translations")}return angular.module("pascalprecht.translate",["ng"]).run(a),a.$inject=["$translate"],a.displayName="runTranslate",angular.module("pascalprecht.translate").provider("$translateSanitization",b),angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider",{}).provider("$translate",c),c.$inject=["$STORAGE_KEY","$windowProvider","$translateSanitizationProvider","pascalprechtTranslateOverrider"],c.displayName="displayName",angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation",d),d.$inject=["$interpolate","$translateSanitization"],d.displayName="$translateDefaultInterpolation",angular.module("pascalprecht.translate").constant("$STORAGE_KEY","NG_TRANSLATE_LANG_KEY"),angular.module("pascalprecht.translate").directive("translate",e),e.$inject=["$translate","$q","$interpolate","$compile","$parse","$rootScope"],e.displayName="translateDirective",angular.module("pascalprecht.translate").directive("translateCloak",f),f.$inject=["$rootScope","$translate"],f.displayName="translateCloakDirective",angular.module("pascalprecht.translate").filter("translate",g),g.$inject=["$parse","$translate"],g.displayName="translateFilterFactory",angular.module("pascalprecht.translate").factory("$translationCache",h),h.$inject=["$cacheFactory"],h.displayName="$translationCache","pascalprecht.translate"});

'use strict';
customDirective.controller('cenx4ImageScanController',['$scope', '$http',function($scope, $http){
	$scope.upload=function(){
		$scope.scanControl=$scope.el.find("#scanControl")[0];
		 var hosturl = [ location.protocol, "//", location.host ].join("");
		 hosturl=hosturl+"/"+URL_PATH.FILE_HEADER+'/upload.do?actionMethod=process&systemHeader='+$scope.systemHeader+"&businessId="+$scope.ngModel;
		 $scope.scanControl.InitParam(hosturl,'扫描件');
		if($scope.scanControl){
			  var result= $scope.scanControl.Upload();
			  if(result.indexOf('ifSuccess\":\"true')>-1){
				  submitTips('上传成功！','info');
				 if( $scope.filesCount==null||$scope.filesCount==undefined){
					 $scope.filesCount=0;
				 }
				 $scope.filesCount=$scope.filesCount+1;
			  }
		}

	}
	$scope.isIE=function() { 
	      if (!!window.ActiveXObject || "ActiveXObject" in window)
	          return true;
	        else
	          return false;
	}
	$scope.$on('$destroy',function() {
		$scope.scanControl=null;
		$scope.el.empty();
	});
	
}]).directive('cenx4ImageScan',function(){
	return { 
    	require: '?ngModel',
    	restrict: 'E',
    	scope: {ngModel: "=",filesCount:"=",systemHeader:"="},
    	controller: 'cenx4ImageScanController',
    	templateUrl:  'static/js/custom/directives/cnex4ImageScan/template/scan.html',
        replace: true,
        link: function (scope, el, attrs,ngModel) {
        	var businessId = getUUID();
        	ngModel.$render = function() {
        		if("" == ngModel.$viewValue || undefined == ngModel.$viewValue ){
        			scope.ngModel = businessId;
        		}
            };
            scope.el=el;
        }
    };
});


var uid = 0;

function nextUid() {
  return ++uid;
}

/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.window === obj;
}

/**
 * @ngdoc function
 * @name angular.isString
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value){return typeof value === 'string';}

/**
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }

  var length = obj.length;

  if (obj.nodeType === 1 && length) {
    return true;
  }

  return isString(obj) || Array.isArray(obj) || length === 0 ||
    typeof length === 'number' && length > 0 && (length - 1) in obj;
}

/**
 * Creates a new object without a prototype. This object is useful for lookup without having to
 * guard against prototypically inherited properties via hasOwnProperty.
 *
 * Related micro-benchmarks:
 * - http://jsperf.com/object-create2
 * - http://jsperf.com/proto-map-lookup/2
 * - http://jsperf.com/for-in-vs-object-keys2
 *
 * @returns {Object}
 */
function createMap() {
  return Object.create(null);
}

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj, nextUidFn) {
  var objType = typeof obj,
    key;

  if (objType == 'function' || (objType == 'object' && obj !== null)) {
    if (typeof (key = obj.$$hashKey) == 'function') {
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = (nextUidFn || nextUid)();
    }
  } else {
    key = obj;
  }

  return objType + ':' + key;
}

function sortByGroup(array ,group, property) {
  var unknownGroup = [],
    i, j,
    resultArray = [];
  for(i = 0; i < group.length; i++) {
    for(j = 0; j < array.length;j ++) {
      if(!array[j][property]) {
        unknownGroup.push(array[j]);
      } else if(array[j][property] === group[i]) {
        resultArray.push(array[j]);
      }
    }
  }

  resultArray = resultArray.concat(unknownGroup);

  return resultArray;
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array} array like object
 * @returns {jqLite} jqLite collection containing the nodes
 */
function getBlockNodes(nodes) {
  var node = nodes[0];
  var endNode = nodes[nodes.length - 1];
  var blockNodes = [node];

  do {
    node = node.nextSibling;
    if (!node) break;
    blockNodes.push(node);
  } while (node !== endNode);

  return angular.element(blockNodes);
}

var getBlockStart = function(block) {
  return block.clone[0];
};

var getBlockEnd = function(block) {
  return block.clone[block.clone.length - 1];
};

var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength, group) {
  scope[valueIdentifier] = value;
  if (keyIdentifier) scope[keyIdentifier] = key;
  scope.$index = index;
  scope.$first = (index === 0);
  scope.$last = (index === (arrayLength - 1));
  scope.$middle = !(scope.$first || scope.$last);
  scope.$odd = !(scope.$even = (index&1) === 0);

  if(group) {
    scope.$group = group;
  }
};

var setElementIsolateScope = function(element, scope) {
  element.data('isolateScope', scope);
};

var contains = function(array, element) {
  var length = array.length,
    i;
  if(length === 0) {
    return false;
  }
  for(i = 0;i < length; i++) {
    if(deepEquals(element, array[i])) {
      return true;
    }
  }
  return false;
};

var indexOf = function(array, element) {
  var length = array.length,
    i;
  if(length === 0) {
    return -1;
  }
  for(i = 0; i < length; i++) {
    if(deepEquals(element, array[i])) {
      return i;
    }
  }
  return -1;
};

/**
 * filter the event target for the nya-bs-option element.
 * Use this method with event delegate. (attach a event handler on an parent element and listen the special children elements)
 * @param target event.target node
 * @param parent {object} the parent, where the event handler attached.
 * @param selector {string}|{object} a class or DOM element
 * @return the filtered target or null if no element satisfied the selector.
 */
var filterTarget = function(target, parent, selector) {
  var elem = target,
    className, type = typeof selector;

  if(target == parent) {
    return null;
  } else {
    do {
      if(type === 'string') {
        className = ' ' + elem.className + ' ';
        if(elem.nodeType === 1 && className.replace(/[\t\r\n\f]/g, ' ').indexOf(selector) >= 0) {
          return elem;
        }
      } else {
        if(elem == selector) {
          return elem;
        }
      }

    } while((elem = elem.parentNode) && elem != parent && elem.nodeType !== 9);

    return null;
  }

};

var getClassList = function(element) {
  var classList,
    className = element.className.replace(/[\t\r\n\f]/g, ' ').trim();
  classList = className.split(' ');
  for(var i = 0; i < classList.length; i++) {
    if(/\s+/.test(classList[i])) {
      classList.splice(i, 1);
      i--;
    }
  }
  return classList;

};

var hasClass = function(element, className) {
  var classList = getClassList(element);
  return classList.indexOf(className) !== -1;
};

var queryChildren = function(element, classList) {
  var children = element.children(),
    length = children.length,
    child,
    valid,
    classes;
  if(length > 0) {
    for(var i = 0; i < length; i++) {
      child = children.eq(i);
      valid = true;
      classes = getClassList(child[0]);
      if(classes.length > 0) {
        for(var j = 0; j < classList.length; j++) {
          if(classes.indexOf(classList[j]) === -1) {
            valid = false;
            break;
          }
        }
      }
      if(valid) {
        return child;
      }
    }
  }
  return [];
};

/**
 * Current support only drill down one level.
 * case insensitive
 * @param element
 * @param keyword
 */
var hasKeyword = function(element, keyword) {
  var childElements,
    index, length;
  if(element.text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
    return true;
  } else {
    childElements = element.children();
    length = childElements.length;
    for(index = 0; index < length; index++) {
      if(childElements.eq(index).text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
        return true;
      }
    }
    return false;
  }
};

function sibling( cur, dir ) {
  while ( (cur = cur[dir]) && cur.nodeType !== 1) {}
  return cur;
}


var jqLite = angular.element;

var deepEquals = angular.equals;

var deepCopy = angular.copy;

var extend = angular.extend;

var nyaBsSelect = angular.module('nya.bootstrap.select', []);

/**
 * A service for configuration. the configuration is shared globally.
 * Testing ci build --jpmckearin
 */
nyaBsSelect.provider('nyaBsConfig', function() {

  var locale = null;

  var defaultText = {
    'en-us': {
      defaultNoneSelection: '',
      noSearchResult: '没有找到匹配条件的项',
      numberItemSelected: '%d items selected',
      selectAll: '全选',
      deselectAll: '全不选'
    }
  };

  var interfaceText = deepCopy(defaultText);

  /**
   * Merge with default localized text.
   * @param localeId a string formatted as languageId-countryId
   * @param obj localized text object.
   */
  this.setLocalizedText = function(localeId, obj) {
    if(!localeId) {
      throw new Error('localeId must be a string formatted as languageId-countryId');
    }
    if(!interfaceText[localeId]) {
      interfaceText[localeId] = {};
    }
    interfaceText[localeId] = extend(interfaceText[localeId], obj);
  };

  /**
   * Force to use a special locale id. if localeId is null. reset to user-agent locale.
   * @param localeId a string formatted as languageId-countryId
   */
  this.useLocale = function(localeId) {
    locale = localeId;
  };

  /**
   * get the localized text according current locale or forced locale
   * @returns localizedText
   */
  this.$get = ['$locale', function($locale){
    var localizedText;
    if(locale) {
      localizedText = interfaceText[locale];
    } else {
      localizedText = interfaceText[$locale.id];
    }
    if(!localizedText) {
      localizedText = defaultText['en-us'];
    }
    return localizedText;
  }];

});


nyaBsSelect.controller('nyaBsSelectCtrl', function(){

  var self = this;

  self.keyIdentifier = null;
  self.valueIdentifier = null;

  self.isMultiple = false;

  self.onCollectionChange = function(){};

  self.setId = function(id) {
    self.id = id || 'id#' + Math.floor(Math.random() * 10000);
  };

});
nyaBsSelect.directive('nyaBsSelect', ['$parse', '$document', '$timeout', '$compile', 'nyaBsConfig', function ($parse, $document, $timeout, $compile, nyaBsConfig) {

  var DEFAULT_NONE_SELECTION = '';

  var DROPDOWN_TOGGLE = '<button class="btn btn-default dropdown-toggle" type="button">' +
    '<span class="pull-left filter-option"></span>' +
    '<span class="pull-left special-title"></span>' +
    '&nbsp;' +
    '<span class="caret"></span>' +
    '</button>';

  var DROPDOWN_CONTAINER = '<div class="dropdown-menu open"></div>';

  var SEARCH_BOX = '<div class="bs-searchbox">' +
    '<input type="text" class="form-control">' +
    '</div>';

  var DROPDOWN_MENU = '<ul class="dropdown-menu inner"></ul>';

  var NO_SEARCH_RESULT = '<li class="no-search-result"><span>没有找到匹配条件的项</span></li>';

  var ACTIONS_BOX = '<div class="bs-actionsbox">' +
    '<div class="btn-group btn-group-sm btn-block">' +
    '<button class="actions-btn bs-select-all btn btn-default">SELECT ALL</button>' +
    '<button class="actions-btn bs-deselect-all btn btn-default">DESELECT ALL</button>' +
    '</div>' +
    '</div>';

  return {
    restrict: 'ECA',
    require: ['ngModel', 'nyaBsSelect'],
    controller: 'nyaBsSelectCtrl',
    compile: function nyaBsSelectCompile (tElement, tAttrs){
      tElement.addClass('btn-group');
      /**
       * get the default text when nothing is selected. can be template
       * @param scope, if provided, will try to compile template with given scope, will not attempt to compile the pure text.
       * @returns {*}
       */
      var getDefaultNoneSelectionContent = function(scope) {
        var content;

        if(tAttrs.titleTpl) {
          content = jqLite(tAttrs.titleTpl);
        } else if(tAttrs.title) {
          content = document.createTextNode(tAttrs.title);
        } else if(localizedText.defaultNoneSelectionTpl){
          content = jqLite(localizedText.defaultNoneSelectionTpl);
        } else if(localizedText.defaultNoneSelection) {
          content = document.createTextNode(localizedText.defaultNoneSelection);
        } else {
          content = document.createTextNode(DEFAULT_NONE_SELECTION);
        }

        if(scope && (tAttrs.titleTpl || localizedText.defaultNoneSelectionTpl)) {
          return $compile(content)(scope);
        }

        return content;
      };

      var options = tElement.children(),
        dropdownToggle = jqLite(DROPDOWN_TOGGLE),
        dropdownContainer = jqLite(DROPDOWN_CONTAINER),
        dropdownMenu = jqLite(DROPDOWN_MENU),
        searchBox,
        noSearchResult,
        actionsBox,
        classList,
        length,
        index,
        liElement,
        localizedText = nyaBsConfig,
        isMultiple = typeof tAttrs.multiple !== 'undefined',
        nyaBsOptionValue;

      classList = getClassList(tElement[0]);
      classList.forEach(function(className) {
        if(/btn-(?:primary|info|success|warning|danger|inverse)/.test(className)) {
          tElement.removeClass(className);
          dropdownToggle.removeClass('btn-default');
          dropdownToggle.addClass(className);
        }

        if(/btn-(?:lg|sm|xs)/.test(className)) {
          tElement.removeClass(className);
          dropdownToggle.addClass(className);
        }

        if(className === 'form-control') {
          dropdownToggle.addClass(className);
        }
      });

      dropdownMenu.append(options);

      length = options.length;
      for(index = 0; index < length; index++) {
        liElement = options.eq(index);
        if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
          liElement.find('a').attr('tabindex', '0');
          nyaBsOptionValue = liElement.attr('value');
          if(angular.isString(nyaBsOptionValue) && nyaBsOptionValue !== '') {
            liElement.attr('data-value', nyaBsOptionValue);
            liElement.removeAttr('value');
          }
        }
      }

      if(tAttrs.liveSearch === 'true') {
        searchBox = jqLite(SEARCH_BOX);

        if(tAttrs.noSearchTitle) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('没有找到匹配条件的项', tAttrs.noSearchTitle);
        } else if (tAttrs.noSearchTitleTpl) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('没有找到匹配条件的项', tAttrs.noSearchTitleTpl);
        }else {
          if(localizedText.noSearchResultTpl) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('没有找到匹配条件的项', localizedText.noSearchResultTpl);
          } else if(localizedText.noSearchResult) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('没有找到匹配条件的项', localizedText.noSearchResult);
          }
        }

        noSearchResult = jqLite(NO_SEARCH_RESULT);
        dropdownContainer.append(searchBox);
        dropdownMenu.append(noSearchResult);
      }

      if (tAttrs.actionsBox === 'true' && isMultiple) {
        if (localizedText.selectAllTpl) {
          ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAllTpl);
        } else if (localizedText.selectAll) {
          ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAll);
        }

        if (localizedText.deselectAllTpl) {
          ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAllTpl);
        } else if (localizedText.selectAll) {
          ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAll);
        }

        actionsBox = jqLite(ACTIONS_BOX);
        dropdownContainer.append(actionsBox);
      }

      jqLite(dropdownToggle[0].querySelector('.special-title')).append(getDefaultNoneSelectionContent());

      dropdownContainer.append(dropdownMenu);

      tElement.append(dropdownToggle);
      tElement.append(dropdownContainer);

      return function nyaBsSelectLink ($scope, $element, $attrs, ctrls) {
        var ngCtrl = ctrls[0],
          nyaBsSelectCtrl = ctrls[1],
          liHeight,
          isDisabled = false,
          previousTabIndex,
          valueExpFn,
          valueExpGetter = $parse(nyaBsSelectCtrl.valueExp),
          isMultiple = typeof $attrs.multiple !== 'undefined';

        var dropdownToggle = jqLite($element[0].querySelector('.dropdown-toggle')),
          dropdownContainer = dropdownToggle.next(),
          dropdownMenu = jqLite(dropdownContainer[0].querySelector('.dropdown-menu.inner')),
          searchBox = jqLite(dropdownContainer[0].querySelector('.bs-searchbox')),
          noSearchResult = jqLite(dropdownMenu[0].querySelector('.no-search-result')),
          actionsBox = jqLite(dropdownContainer[0].querySelector('.bs-actionsbox'));
        if(nyaBsSelectCtrl.valueExp) {
          valueExpFn = function(scope, locals) {
            return valueExpGetter(scope, locals);
          };
        }

        nyaBsSelectCtrl.setId($element.attr('id'));

        if (isMultiple) {
          nyaBsSelectCtrl.isMultiple = true;

          ngCtrl.$isEmpty = function(value) {
            return !value || value.length === 0;
          };
        }
        if(typeof $attrs.disabled !== 'undefined') {
          $scope.$watch($attrs.disabled, function(disabled){
            if(disabled) {
              dropdownToggle.addClass('disabled');
              dropdownToggle.attr('disabled', 'disabled');
              previousTabIndex = dropdownToggle.attr('tabindex');
              dropdownToggle.attr('tabindex', '-1');
              isDisabled = true;
            } else {
              dropdownToggle.removeClass('disabled');
              dropdownToggle.removeAttr('disabled');
              if(previousTabIndex) {
                dropdownToggle.attr('tabindex', previousTabIndex);
              } else {
                dropdownToggle.removeAttr('tabindex');
              }
              isDisabled = false;
            }
          });
        }

        /**
         * Do some check on modelValue. remove no existing value
         * @param values
         * @param deepWatched
         */
        nyaBsSelectCtrl.onCollectionChange = function (values, deepWatched) {
          var valuesForSelect = [],
            index,
            modelValueChanged = false,
            modelValue = deepCopy(ngCtrl.$modelValue);

          if(!modelValue) {
            return;
          }

          /**
           * Behavior change, since 2.1.0, we don't want to reset model to null or empty array when options' collection is not prepared.
           */
          if(Array.isArray(values) && values.length > 0) {
            if(valueExpFn) {
              for(index = 0; index < values.length; index++) {
                valuesForSelect.push(valueExpFn($scope, values[index]));
              }
            } else {
              for(index = 0; index < values.length; index++) {
                if(nyaBsSelectCtrl.valueIdentifier) {
                  valuesForSelect.push(values[index][nyaBsSelectCtrl.valueIdentifier]);
                } else if(nyaBsSelectCtrl.keyIdentifier) {
                  valuesForSelect.push(values[index][nyaBsSelectCtrl.keyIdentifier]);
                }
              }

            }

            if(isMultiple) {
              for(index = 0; index < modelValue.length; index++) {
                if(!contains(valuesForSelect, modelValue[index])) {
                  modelValueChanged = true;
                  modelValue.splice(index, 1);
                  index--;
                }
              }

              if(modelValueChanged) {

                ngCtrl.$setViewValue(modelValue);

                updateButtonContent();
              }

            } else {
              if(!contains(valuesForSelect, modelValue)) {
                modelValue = valuesForSelect[0];

                ngCtrl.$setViewValue(modelValue);

                updateButtonContent();
              }
            }

          }

          /**
           * if we set deep-watch="true" on nyaBsOption directive,
           * we need to refresh dropdown button content whenever a change happened in collection.
           */
          if(deepWatched) {
            updateButtonContent();
          }

        };


        dropdownMenu.on('click', function menuEventHandler (event) {
          if(isDisabled) {
            return;
          }
          if(jqLite(event.target).hasClass('dropdown-header')) {
            return;
          }
          var nyaBsOptionNode = filterTarget(event.target, dropdownMenu[0], 'nya-bs-option'),
            nyaBsOption;

          if(nyaBsOptionNode !== null) {
            nyaBsOption = jqLite(nyaBsOptionNode);
            if(nyaBsOption.hasClass('disabled')) {
              return;
            }
            selectOption(nyaBsOption);
          }
        });

        var outClick = function(event) {
          if(filterTarget(event.target, $element.parent()[0], $element[0]) === null) {
            if($element.hasClass('open')) {
              $element.triggerHandler('blur');
            }
            $element.removeClass('open');
          }
        };
        $document.on('click', outClick);
        dropdownToggle.on('blur', function() {
          if(!$element.hasClass('open')) {
            $element.triggerHandler('blur');
          }
        });
        dropdownToggle.on('click', function() {
          var nyaBsOptionNode;
          $element.toggleClass('open');
          if($element.hasClass('open') && typeof liHeight === 'undefined') {
            calcMenuSize();
          }
          if($attrs.liveSearch === 'true' && $element.hasClass('open')) {
            searchBox.children().eq(0)[0].focus();
            nyaBsOptionNode = findFocus(true);
            if(nyaBsOptionNode) {
              dropdownMenu.children().removeClass('active');
              jqLite(nyaBsOptionNode).addClass('active');
            }
          } else if($element.hasClass('open')) {
            nyaBsOptionNode = findFocus(true);
            if(nyaBsOptionNode) {
              setFocus(nyaBsOptionNode);
            }
          }
        });

        if ($attrs.actionsBox === 'true' && isMultiple) {
          actionsBox.find('button').eq(0).on('click', function () {
            setAllOptions(true);
          });
          actionsBox.find('button').eq(1).on('click', function () {
            setAllOptions(false);
          });
        }


        if($attrs.liveSearch === 'true') {
          searchBox.children().on('input', function(){
        	console.log('输入的值改变了');
            var searchKeyword = searchBox.children().val(),
              found = 0,
              options = dropdownMenu.children(),
              length = options.length,
              index,
              option,
              nyaBsOptionNode;

            if(searchKeyword) {
            	console.log('searchKeyword');
            	console.log(searchKeyword);
              for(index = 0; index < length; index++) {
                option = options.eq(index);
                if(option.hasClass('nya-bs-option')) {
                  if(!hasKeyword(option.find('a'), searchKeyword)) {
                    option.addClass('not-match');
                  } else {
                    option.removeClass('not-match');
                    found++;
                  }
                }
              }

              if(found === 0) {
                noSearchResult.addClass('show');
              } else {
                noSearchResult.removeClass('show');
              }
            } else {
              for(index = 0; index < length; index++) {
                option = options.eq(index);
                if(option.hasClass('nya-bs-option')) {
                  option.removeClass('not-match');
                }
              }
              noSearchResult.removeClass('show');
            }

            nyaBsOptionNode = findFocus(true);

            if(nyaBsOptionNode) {
              options.removeClass('active');
              jqLite(nyaBsOptionNode).addClass('active');
            }

          });
        }



        ngCtrl.$render = function() {
          var modelValue = ngCtrl.$modelValue,
            index,
            bsOptionElements = dropdownMenu.children(),
            length = bsOptionElements.length,
            value;
          if(typeof modelValue === 'undefined') {
            for(index = 0; index < length; index++) {
              if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {
                bsOptionElements.eq(index).removeClass('selected');
              }
            }
          } else {
            for(index = 0; index < length; index++) {
              if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {

                value = getOptionValue(bsOptionElements.eq(index));
                if(isMultiple) {
                  if(contains(modelValue, value)) {
                    bsOptionElements.eq(index).addClass('selected');
                  } else {
                    bsOptionElements.eq(index).removeClass('selected');
                  }
                } else {
                  if(deepEquals(modelValue, value)) {
                    bsOptionElements.eq(index).addClass('selected');
                  } else {
                    bsOptionElements.eq(index).removeClass('selected');
                  }
                }

              }
            }
          }
          updateButtonContent();
        };

        $element.on('keydown', function(event){
        	console.log(1112222);
          var keyCode = event.keyCode;

          if(keyCode !== 27 && keyCode !== 13 && keyCode !== 38 && keyCode !== 40) {
            return;
          }

          event.preventDefault();
          if(isDisabled) {
            event.stopPropagation();
            return;
          }
          var toggleButton = filterTarget(event.target, $element[0], dropdownToggle[0]),
            menuContainer,
            searchBoxContainer,
            liElement,
            nyaBsOptionNode;

          if($attrs.liveSearch === 'true') {
        	  console.log($element[0]);
        	  console.log(searchBox[0]);
            searchBoxContainer = filterTarget(event.target, $element[0], searchBox[0]);
          } else {
        	  console.log(112);
        	  console.log($element[0]);
        	  console.log(searchBox[0]);
            menuContainer = filterTarget(event.target, $element[0], dropdownContainer[0])
          }

          if(toggleButton) {
            if((keyCode === 13 || keyCode === 38 || keyCode === 40) && !$element.hasClass('open')) {

              event.stopPropagation();

              $element.addClass('open');

              if(typeof liHeight === 'undefined') {
                calcMenuSize();
              }

              if($attrs.liveSearch === 'true') {
                searchBox.children().eq(0)[0].focus();
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  dropdownMenu.children().removeClass('active');
                  jqLite(nyaBsOptionNode).addClass('active');
                }
              } else {
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            }

          } else if(menuContainer) {

            if(keyCode === 27) {
              dropdownToggle[0].focus();
              if($element.hasClass('open')) {
                $element.triggerHandler('blur');
              }
              $element.removeClass('open');
              event.stopPropagation();

            } else if(keyCode === 38) {
              event.stopPropagation();
              nyaBsOptionNode = findNextFocus(event.target.parentNode, 'previousSibling');
              if(nyaBsOptionNode) {
                setFocus(nyaBsOptionNode);
              } else {
                nyaBsOptionNode = findFocus(false);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            } else if(keyCode === 40) {
              event.stopPropagation();
              nyaBsOptionNode = findNextFocus(event.target.parentNode, 'nextSibling');
              if(nyaBsOptionNode) {
                setFocus(nyaBsOptionNode);
              } else {
                nyaBsOptionNode = findFocus(true);
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                }
              }
            } else if(keyCode === 13) {
              event.stopPropagation();
              liElement = jqLite(event.target.parentNode);
              if(liElement.hasClass('nya-bs-option')) {
                selectOption(liElement);
                if(!isMultiple) {
                  dropdownToggle[0].focus();
                }
              }
            }
          } else if(searchBoxContainer) {
            if(keyCode === 27) {
              dropdownToggle[0].focus();
              $element.removeClass('open');
              event.stopPropagation();
            } else if(keyCode === 38) {
              event.stopPropagation();

              liElement = findActive();
              if(liElement) {
                nyaBsOptionNode = findNextFocus(liElement[0], 'previousSibling');
                if(nyaBsOptionNode) {
                  liElement.removeClass('active');
                  jqLite(nyaBsOptionNode).addClass('active');
                } else {
                  nyaBsOptionNode = findFocus(false);
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  }
                }
              }

            } else if(keyCode === 40) {
              event.stopPropagation();

              liElement = findActive();
              if(liElement) {
                nyaBsOptionNode = findNextFocus(liElement[0], 'nextSibling');
                if(nyaBsOptionNode) {
                  liElement.removeClass('active');
                  jqLite(nyaBsOptionNode).addClass('active');
                } else {
                  nyaBsOptionNode = findFocus(true);
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  }
                }
              }
            } else if(keyCode === 13) {
              liElement = findActive();
              if(liElement) {
                selectOption(liElement);
                if(!isMultiple) {
                  dropdownToggle[0].focus();
                }
              }
            }
          }
        });

        function findActive() {
          var list = dropdownMenu.children(),
            i, liElement,
            length = list.length;
          for(i = 0; i < length; i++) {
            liElement = list.eq(i);
            if(liElement.hasClass('active') && liElement.hasClass('nya-bs-option') && !liElement.hasClass('not-match')) {
              return liElement;
            }
          }
          return null;
        }

        /**
         * setFocus on a nya-bs-option element. it actually set focus on its child anchor element.
         * @param elem a nya-bs-option element.
         */
        function setFocus(elem) {
          var childList = elem.childNodes,
            length = childList.length,
            child;
          for(var i = 0; i < length; i++) {
            child = childList[i];
            if(child.nodeType === 1 && child.tagName.toLowerCase() === 'a') {
              child.focus();
              break;
            }
          }
        }

        function findFocus(fromFirst) {
          var firstLiElement;
          if(fromFirst) {
            firstLiElement = dropdownMenu.children().eq(0);
          } else {
            firstLiElement = dropdownMenu.children().eq(dropdownMenu.children().length - 1);
          }

          for(var i = 0; i < dropdownMenu.children().length; i++) {
            var childElement = dropdownMenu.children().eq(i);
            if (!childElement.hasClass('not-match') && childElement.hasClass('selected')) {
              return dropdownMenu.children().eq(i)[0];
            }
          }

          if(firstLiElement.hasClass('nya-bs-option') && !firstLiElement.hasClass('disabled') && !firstLiElement.hasClass('not-match')) {
            return firstLiElement[0];
          } else {
            if(fromFirst) {
              return findNextFocus(firstLiElement[0], 'nextSibling');
            } else {
              return findNextFocus(firstLiElement[0], 'previousSibling');
            }
          }
        }

        /**
         * find next focusable element on direction
         * @param from the element traversed from
         * @param direction can be 'nextSibling' or 'previousSibling'
         * @returns the element if found, otherwise return null.
         */
        function findNextFocus(from, direction) {
          if(from && !hasClass(from, 'nya-bs-option')) {
            return;
          }
          var next = from;
          while ((next = sibling(next, direction)) && next.nodeType) {
            if(hasClass(next,'nya-bs-option') && !hasClass(next, 'disabled') && !hasClass(next, 'not-match')) {
              return next
            }
          }
          return null;
        }

        /**
         *
         */
        function setAllOptions(selectAll) {
          if (!isMultiple || isDisabled)
            return;

          var liElements,
            wv,
            viewValue;

          liElements = dropdownMenu[0].querySelectorAll('.nya-bs-option');
          if (liElements.length > 0) {
            wv = ngCtrl.$viewValue;

            viewValue = Array.isArray(wv) ? deepCopy(wv) : [];

            for (var i = 0; i < liElements.length; i++) {
              var nyaBsOption = jqLite(liElements[i]);
              if (nyaBsOption.hasClass('disabled'))
                continue;

              var value, index;

              value = getOptionValue(nyaBsOption);

              if (typeof value !== 'undefined') {
                index = indexOf(viewValue, value);
                if (selectAll && index == -1) {
                  viewValue.push(value);
                  nyaBsOption.addClass('selected');
                } else if (!selectAll && index != -1) {
                  viewValue.splice(index, 1);
                  nyaBsOption.removeClass('selected');
                }
              }
            }

            ngCtrl.$setViewValue(viewValue);
            $scope.$digest();

            updateButtonContent();
          }
        }

        /**
         * select an option represented by nyaBsOption argument. Get the option's value and update model.
         * if isMultiple = true, doesn't close dropdown menu. otherwise close the menu.
         * @param nyaBsOption the jqLite wrapped `nya-bs-option` element.
         */
        function selectOption(nyaBsOption) {
          var value,
            viewValue,
            wv = ngCtrl.$viewValue,
            index;

          value = getOptionValue(nyaBsOption);

          if(typeof value !== 'undefined') {
            if(isMultiple) {
              viewValue = Array.isArray(wv) ? deepCopy(wv) : [];
              index = indexOf(viewValue, value);
              if(index === -1) {
                viewValue.push(value);
                nyaBsOption.addClass('selected');

              } else {
                viewValue.splice(index, 1);
                nyaBsOption.removeClass('selected');

              }

            } else {
              dropdownMenu.children().removeClass('selected');
              viewValue = value;
              nyaBsOption.addClass('selected');

            }
          }
          ngCtrl.$setViewValue(viewValue);
          $scope.$digest();

          if(!isMultiple) {
            if($element.hasClass('open')) {
              $element.triggerHandler('blur');
            }
            $element.removeClass('open');
            dropdownToggle[0].focus();
          }
          updateButtonContent();
        }

        /**
         * get a value of current nyaBsOption. according to different setting.
         * - if `nya-bs-option` directive is used to populate options and a `value` attribute is specified. use expression of the attribute value.
         * - if `nya-bs-option` directive is used to populate options and no other settings, use the valueIdentifier or keyIdentifier to retrieve value from scope of current nyaBsOption.
         * - if `nya-bs-option` class is used on static options. use literal value of the `value` attribute.
         * @param nyaBsOption a jqLite wrapped `nya-bs-option` element
         */
        function getOptionValue(nyaBsOption) {
          var scopeOfOption;
          if(valueExpFn) {
            scopeOfOption = nyaBsOption.data('isolateScope');
            return valueExpFn(scopeOfOption);
          } else {
            if(nyaBsSelectCtrl.valueIdentifier || nyaBsSelectCtrl.keyIdentifier) {
              scopeOfOption = nyaBsOption.data('isolateScope');
              return scopeOfOption[nyaBsSelectCtrl.valueIdentifier] || scopeOfOption[nyaBsSelectCtrl.keyIdentifier];
            } else {
              return nyaBsOption.attr('data-value');
            }
          }

        }

        function getOptionText(nyaBsOption) {
          var item = nyaBsOption.find('a');
          if(item.children().length === 0 || item.children().eq(0).hasClass('check-mark')) {
            return item[0].firstChild.cloneNode(false);
          } else {
            return item.children().eq(0)[0].cloneNode(true);
          }
        }

        function updateButtonContent() {
          var viewValue = ngCtrl.$viewValue || '';
          $element.triggerHandler('change');
          var filterOption = jqLite(dropdownToggle[0].querySelector('.filter-option'));
          var specialTitle = jqLite(dropdownToggle[0].querySelector('.special-title'));
          if(typeof viewValue === 'undefined') {
            /**
             * Select empty option when model is undefined.
             */
            dropdownToggle.addClass('show-special-title');
            filterOption.empty();
            return;
          }
          if(isMultiple && viewValue.length === 0) {
            dropdownToggle.addClass('show-special-title');
            filterOption.empty();
          } else {
            dropdownToggle.removeClass('show-special-title');
            $timeout(function() {
              var bsOptionElements = dropdownMenu.children(),
                value,
                nyaBsOption,
                index,
                length = bsOptionElements.length || viewValue.length,
                optionTitle,
                selection = [],
                optionScopes = [],
                match,
                count,
                clone;
              
              
              if(isMultiple && $attrs.selectedTextFormat === 'count') {
                count = 1;
              } else if(isMultiple && $attrs.selectedTextFormat && (match = $attrs.selectedTextFormat.match(/\s*count\s*>\s*(\d+)\s*/))) {
                count = parseInt(match[1], 10);
              }

              if((typeof count !== 'undefined') && viewValue.length > count) {
                filterOption.empty();
                if(localizedText.numberItemSelectedTpl) {
                  filterOption.append(jqLite(localizedText.numberItemSelectedTpl.replace('%d', viewValue.length)));
                } else if(localizedText.numberItemSelected) {
                  filterOption.append(document.createTextNode(localizedText.numberItemSelected.replace('%d', viewValue.length)));
                } else {
                  filterOption.append(document.createTextNode(viewValue.length + ' items selected'));
                }
                return;
              }

              for(index = 0; index < length; index++) {
                nyaBsOption = bsOptionElements.eq(index);
                if(nyaBsOption.hasClass('nya-bs-option')) {
                  value = getOptionValue(nyaBsOption);
                  if(isMultiple) {
                    if(Array.isArray(viewValue) && contains(viewValue, value)) {
                      optionTitle = nyaBsOption.attr('title');
                      if(optionTitle) {
                        selection.push(document.createTextNode(optionTitle));
                      } else {
                        selection.push(getOptionText(nyaBsOption));
                        optionScopes.push(nyaBsOption.data('isolateScope'))
                      }

                    }
                  } else {
                    if(deepEquals(viewValue, value)) {
                      optionTitle = nyaBsOption.attr('title');
                      if(optionTitle) {
                        selection.push(document.createTextNode(optionTitle));
                      } else {
                        selection.push(getOptionText(nyaBsOption));
                        optionScopes.push(nyaBsOption.data('isolateScope'))
                      }
                    }
                  }

                }
              }

              if(selection.length === 0) {
                filterOption.empty();
                dropdownToggle.addClass('show-special-title');
              } else if(selection.length === 1) {
                dropdownToggle.removeClass('show-special-title');
                filterOption.empty();
                clone = $compile (selection[0])(optionScopes[0]);
                filterOption.append(clone);
              } else {
                dropdownToggle.removeClass('show-special-title');
                filterOption.empty();
                for(index = 0; index < selection.length; index++) {
                  clone = $compile (selection[index])(optionScopes[index]);
                  filterOption.append(clone);
                  if(index < selection.length -1) {
                    filterOption.append(document.createTextNode(', '));
                  }
                }
              }

            });
          }

        }

        function calcMenuSize(){

          var liElements = dropdownMenu.find('li'),
            length = liElements.length,
            liElement,
            i;
          for(i = 0; i < length; i++) {
            liElement = liElements.eq(i);
            if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
              liHeight = liElement[0].clientHeight;
              break;
            }
          }

          if(/\d+/.test($attrs.size)) {
            var dropdownSize = parseInt($attrs.size, 10);
            dropdownMenu.css('max-height', (dropdownSize * liHeight) + 'px');
            dropdownMenu.css('overflow-y', 'auto');
          }

        }

        $scope.$on('$destroy', function() {
          dropdownMenu.off();
          dropdownToggle.off();
          if (searchBox.off) searchBox.off();
          $document.off('click', outClick);
        });

      };
    }
  };
}]);

nyaBsSelect.directive('nyaBsOption', ['$parse', function($parse){

  var BS_OPTION_REGEX = /^\s*(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/;

  return {
    restrict: 'A',
    transclude: 'element',
    priority: 1000,
    terminal: true,
    require: ['^nyaBsSelect', '^ngModel'],
    compile: function nyaBsOptionCompile (tElement, tAttrs) {

      var expression = tAttrs.nyaBsOption;
      var nyaBsOptionEndComment = document.createComment(' end nyaBsOption: ' + expression + ' ');
      var match = expression.match(BS_OPTION_REGEX);

      if(!match) {
        throw new Error('invalid expression');
      }

      var valueExp = tAttrs.value,
        valueExpGetter = valueExp ? $parse(valueExp) : null;

      var valueIdentifier = match[3] || match[1],
        keyIdentifier = match[2],
        collectionExp = match[4],
        groupByExpGetter = match[5] ? $parse(match[5]) : null,
        trackByExp = match[6];

      var trackByIdArrayFn,
        trackByIdObjFn,
        trackByIdExpFn,
        trackByExpGetter;
      var hashFnLocals = {$id: hashKey};
      var groupByFn, locals = {};

      if(trackByExp) {
        trackByExpGetter = $parse(trackByExp);
      } else {
        trackByIdArrayFn = function(key, value) {
          return hashKey(value);
        };
        trackByIdObjFn = function(key) {
          return key;
        };
      }
      return function nyaBsOptionLink($scope, $element, $attr, ctrls, $transclude) {

        var nyaBsSelectCtrl = ctrls[0],
          ngCtrl = ctrls[1],
          valueExpFn,
          deepWatched,
          valueExpLocals = {};

        if(trackByExpGetter) {
          trackByIdExpFn = function(key, value, index) {
            if (keyIdentifier) {
              hashFnLocals[keyIdentifier] = key;
            }
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        }

        if(groupByExpGetter) {
          groupByFn = function(key, value) {
            if(keyIdentifier) {
              locals[keyIdentifier] = key;
            }
            locals[valueIdentifier] = value;
            return groupByExpGetter($scope, locals);
          }
        }

        if(keyIdentifier) {
          nyaBsSelectCtrl.keyIdentifier = keyIdentifier;
        }
        if(valueIdentifier) {
          nyaBsSelectCtrl.valueIdentifier = valueIdentifier;
        }

        if(valueExpGetter) {
          nyaBsSelectCtrl.valueExp = valueExp;
          valueExpFn = function(key, value) {
            if(keyIdentifier) {
              valueExpLocals[keyIdentifier] = key;
            }
            valueExpLocals[valueIdentifier] = value;
            return valueExpGetter($scope, valueExpLocals);
          }

        }


        var lastBlockMap = createMap();

        if($attr.deepWatch === 'true') {
          deepWatched = true;
          $scope.$watch(collectionExp, nyaBsOptionAction, true);
        } else {
          deepWatched = false;
          $scope.$watchCollection(collectionExp, nyaBsOptionAction);
        }

        function nyaBsOptionAction(collection) {
          var index,

            previousNode = $element[0],     

            key, value,
            trackById,
            trackByIdFn,
            collectionKeys,
            collectionLength,
            nextBlockMap = createMap(),
            nextBlockOrder,
            block,
            groupName,
            nextNode,
            group,
            lastGroup,

            removedClone, 

            values = [],
            valueObj; 

          if(groupByFn) {
            group = [];
          }

          if(isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            collectionKeys = [];
            for (var itemKey in collection) {
              if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
                collectionKeys.push(itemKey);
              }
            }
            collectionKeys.sort();
          }
          collectionLength = collectionKeys.length;
          nextBlockOrder = new Array(collectionLength);

          for(index = 0; index < collectionLength; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);

            valueObj = {};
            if(keyIdentifier) {
              valueObj[keyIdentifier] = key;
            }

            valueObj[valueIdentifier] = value;
            values.push(valueObj);

            if(groupByFn) {
              groupName = groupByFn(key, value);
              if(group.indexOf(groupName) === -1 && groupName) {
                group.push(groupName);
              }
            }

            if(lastBlockMap[trackById]) {
              block = lastBlockMap[trackById];
              delete lastBlockMap[trackById];

              if(groupByFn) {
                block.group = groupName;
              }
              block.key = key;
              block.value = value;

              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            } else if(nextBlockMap[trackById]) {
              nextBlockOrder.forEach(function(block) {
                if(block && block.scope) {
                  lastBlockMap[block.id] = block;
                }
              });
              throw new Error("Duplicates in a select are not allowed. Use 'track by' expression to specify unique keys.");
            } else {
              nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined, key: key, value: value};
              nextBlockMap[trackById] = true;
              if(groupName) {
                nextBlockOrder[index].group = groupName;
              }
            }
          }

          if(group && group.length > 0) {

            nextBlockOrder = sortByGroup(nextBlockOrder, group, 'group');
          }

          for( var blockKey in lastBlockMap) {
            block = lastBlockMap[blockKey];
            removedClone = getBlockNodes(block.clone);
            removedClone.removeData('isolateScope');
            removedClone.remove();
            block.scope.$destroy();
          }

          for(index = 0; index < collectionLength; index++) {
            block = nextBlockOrder[index];
            if(block.scope) {

              nextNode = previousNode;
              if(getBlockStart(block) != nextNode) {
                jqLite(previousNode).after(block.clone);
              }
              previousNode = getBlockEnd(block);

              updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
            } else {
              $transclude(function nyaBsOptionTransclude(clone, scope) {
                setElementIsolateScope(clone, scope);

                block.scope = scope;

                var endNode = nyaBsOptionEndComment.cloneNode(false);
                clone[clone.length++] = endNode;

                jqLite(previousNode).after(clone);

                clone.addClass('nya-bs-option');

                if(valueExpFn) {
                  value = valueExpFn(block.key, block.value);
                } else {
                  value = block.value || block.key;
                }

                if(nyaBsSelectCtrl.isMultiple) {
                  if(Array.isArray(ngCtrl.$modelValue) && contains(ngCtrl.$modelValue, value)) {
                    clone.addClass('selected');
                  }
                } else {
                  if(deepEquals(value, ngCtrl.$modelValue)) {
                    clone.addClass('selected');
                  }
                }

                previousNode = endNode;
                block.clone = clone;
                nextBlockMap[block.id] = block;
                updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
              });

            }

            if(group) {
              if(!lastGroup || lastGroup !== block.group) {
                block.clone.addClass('first-in-group');
              } else {
                block.clone.removeClass('first-in-group');
              }

              lastGroup = block.group;

              block.clone.addClass('group-item');
            }
          }

          lastBlockMap = nextBlockMap;

          nyaBsSelectCtrl.onCollectionChange(values, deepWatched);
        }
      };
    }
  }
}]);

/**
 * angular-strap
 * @version v2.3.8 - 2016-03-31
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
    'use strict';
    bsCompilerService.$inject = ['$q', '$http', '$injector', '$compile', '$controller', '$templateCache'];
    angular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions']).provider('$tooltip', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            customClass: '',
            prefixClass: 'tooltip',
            prefixEvent: 'tooltip',
            container: false,
            target: false,
            placement: 'top',
            templateUrl: 'tooltip/tooltip.tpl.html',
            template: '',
            titleTemplate: false,
            trigger: 'hover focus',
            keyboard: false,
            html: false,
            show: false,
            title: '',
            type: '',
            delay: 0,
            autoClose: false,
            bsEnabled: true,
            viewport: {
                selector: 'body',
                padding: 0
            }
        };
        this.$get = ['$window', '$rootScope', '$bsCompiler', '$q', '$templateCache', '$http', '$animate', '$sce', 'dimensions', '$$rAF', '$timeout', function($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {
            var isTouch = 'createTouch' in $window.document;
            var $body = angular.element($window.document);

            function TooltipFactory(element, config) {
                var $tooltip = {};
                var options = $tooltip.$options = angular.extend({}, defaults, config);
                var promise = $tooltip.$promise = $bsCompiler.compile(options);
                var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                var nodeName = element[0].nodeName.toLowerCase();
                if (options.delay && angular.isString(options.delay)) {
                    var split = options.delay.split(',').map(parseFloat);
                    options.delay = split.length > 1 ? {
                        show: split[0],
                        hide: split[1]
                    } : split[0];
                }
                $tooltip.$id = options.id || element.attr('id') || '';
                if (options.title) {
                    scope.title = $sce.trustAsHtml(options.title);
                }
                scope.$setEnabled = function(isEnabled) {
                    scope.$$postDigest(function() {
                        $tooltip.setEnabled(isEnabled);
                    });
                };
                scope.$hide = function() {
                    scope.$$postDigest(function() {
                        $tooltip.hide();
                    });
                };
                scope.$show = function() {
                    scope.$$postDigest(function() {
                        $tooltip.show();
                    });
                };
                scope.$toggle = function() {
                    scope.$$postDigest(function() {
                        $tooltip.toggle();
                    });
                };
                $tooltip.$isShown = scope.$isShown = false;
                var timeout;
                var hoverState;
                var compileData;
                var tipElement;
                var tipContainer;
                var tipScope;
                promise.then(function(data) {
                    compileData = data;
                    $tooltip.init();
                });
                $tooltip.init = function() {
                    if (options.delay && angular.isNumber(options.delay)) {
                        options.delay = {
                            show: options.delay,
                            hide: options.delay
                        };
                    }
                    if (options.container === 'self') {
                        tipContainer = element;
                    } else if (angular.isElement(options.container)) {
                        tipContainer = options.container;
                    } else if (options.container) {
                        tipContainer = findElement(options.container);
                    }
                    bindTriggerEvents();
                    if (options.target) {
                        options.target = angular.isElement(options.target) ? options.target : findElement(options.target);
                    }
                    if (options.show) {
                        scope.$$postDigest(function() {
                            if (options.trigger === 'focus') {
                                element[0].focus();
                            } else {
                                $tooltip.show();
                            }
                        });
                    }
                };
                $tooltip.destroy = function() {
                    unbindTriggerEvents();
                    destroyTipElement();
                    scope.$destroy();
                };
                $tooltip.enter = function() {
                    clearTimeout(timeout);
                    hoverState = 'in';
                    if (!options.delay || !options.delay.show) {
                        return $tooltip.show();
                    }
                    timeout = setTimeout(function() {
                        if (hoverState === 'in') $tooltip.show();
                    }, options.delay.show);
                };
                $tooltip.show = function() {
                    if (!options.bsEnabled || $tooltip.$isShown) return;
                    scope.$emit(options.prefixEvent + '.show.before', $tooltip);
                    var parent;
                    var after;
                    if (options.container) {
                        parent = tipContainer;
                        if (tipContainer[0].lastChild) {
                            after = angular.element(tipContainer[0].lastChild);
                        } else {
                            after = null;
                        }
                    } else {
                        parent = null;
                        after = element;
                    }
                    if (tipElement) destroyTipElement();
                    tipScope = $tooltip.$scope.$new();
                    tipElement = $tooltip.$element = compileData.link(tipScope, function(clonedElement, scope) {});
                    tipElement.css({
                        top: '-9999px',
                        left: '-9999px',
                        right: 'auto',
                        display: 'block',
                        visibility: 'hidden'
                    });
                    if (options.animation) tipElement.addClass(options.animation);
                    if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);
                    if (options.customClass) tipElement.addClass(options.customClass);
                    if (after) {
                        after.after(tipElement);
                    } else {
                        parent.prepend(tipElement);
                    }
                    $tooltip.$isShown = scope.$isShown = true;
                    safeDigest(scope);
                    $tooltip.$applyPlacement();
                    if (angular.version.minor <= 2) {
                        $animate.enter(tipElement, parent, after, enterAnimateCallback);
                    } else {
                        $animate.enter(tipElement, parent, after).then(enterAnimateCallback);
                    }
                    safeDigest(scope);
                    $$rAF(function() {
                        if (tipElement) tipElement.css({
                            visibility: 'visible'
                        });
                        if (options.keyboard) {
                            if (options.trigger !== 'focus') {
                                $tooltip.focus();
                            }
                            bindKeyboardEvents();
                        }
                    });
                    if (options.autoClose) {
                        bindAutoCloseEvents();
                    }
                };

                function enterAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.show', $tooltip);
                }
                $tooltip.leave = function() {
                    clearTimeout(timeout);
                    hoverState = 'out';
                    if (!options.delay || !options.delay.hide) {
                        return $tooltip.hide();
                    }
                    timeout = setTimeout(function() {
                        if (hoverState === 'out') {
                            $tooltip.hide();
                        }
                    }, options.delay.hide);
                };
                var _blur;
                var _tipToHide;
                $tooltip.hide = function(blur) {
                    if (!$tooltip.$isShown) return;
                    scope.$emit(options.prefixEvent + '.hide.before', $tooltip);
                    _blur = blur;
                    _tipToHide = tipElement;
                    if (angular.version.minor <= 2) {
                        $animate.leave(tipElement, leaveAnimateCallback);
                    } else {
                        $animate.leave(tipElement).then(leaveAnimateCallback);
                    }
                    $tooltip.$isShown = scope.$isShown = false;
                    safeDigest(scope);
                    if (options.keyboard && tipElement !== null) {
                        unbindKeyboardEvents();
                    }
                    if (options.autoClose && tipElement !== null) {
                        unbindAutoCloseEvents();
                    }
                };

                function leaveAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.hide', $tooltip);
                    if (tipElement === _tipToHide) {
                        if (_blur && options.trigger === 'focus') {
                            return element[0].blur();
                        }
                        destroyTipElement();
                    }
                }
                $tooltip.toggle = function(evt) {
                    if (evt) {
                        evt.preventDefault();
                    }
                    if ($tooltip.$isShown) {
                        $tooltip.leave();
                    } else {
                        $tooltip.enter();
                    }
                };
                $tooltip.focus = function() {
                    tipElement[0].focus();
                };
                $tooltip.setEnabled = function(isEnabled) {
                    options.bsEnabled = isEnabled;
                };
                $tooltip.setViewport = function(viewport) {
                    options.viewport = viewport;
                };
                $tooltip.$applyPlacement = function() {
                    if (!tipElement) return;
                    var placement = options.placement;
                    var autoToken = /\s?auto?\s?/i;
                    var autoPlace = autoToken.test(placement);
                    if (autoPlace) {
                        placement = placement.replace(autoToken, '') || defaults.placement;
                    }
                    tipElement.addClass(options.placement);
                    var elementPosition = getPosition();
                    var tipWidth = tipElement.prop('offsetWidth');
                    var tipHeight = tipElement.prop('offsetHeight');
                    $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);
                    if (autoPlace) {
                        var originalPlacement = placement;
                        var viewportPosition = getPosition($tooltip.$viewport);
                        if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {
                            placement = originalPlacement.replace('bottom', 'top');
                        } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {
                            placement = originalPlacement.replace('top', 'bottom');
                        }
                        if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {
                            placement = placement.replace('left', 'right');
                        } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {
                            placement = placement.replace('right', 'left');
                        }
                        tipElement.removeClass(originalPlacement).addClass(placement);
                    }
                    var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);
                    applyPlacement(tipPosition, placement);
                };
                $tooltip.$onKeyUp = function(evt) {
                    if (evt.which === 27 && $tooltip.$isShown) {
                        $tooltip.hide();
                        evt.stopPropagation();
                    }
                };
                $tooltip.$onFocusKeyUp = function(evt) {
                    if (evt.which === 27) {
                        element[0].blur();
                        evt.stopPropagation();
                    }
                };
                $tooltip.$onFocusElementMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if ($tooltip.$isShown) {
                        element[0].blur();
                    } else {
                        element[0].focus();
                    }
                };

                function bindTriggerEvents() {
                    var triggers = options.trigger.split(' ');
                    angular.forEach(triggers, function(trigger) {
                        if (trigger === 'click' || trigger === 'contextmenu') {
                            element.on(trigger, $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            if (nodeName === 'button' && trigger !== 'hover') {
                                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                            }
                        }
                    });
                }

                function unbindTriggerEvents() {
                    var triggers = options.trigger.split(' ');
                    for (var i = triggers.length; i--;) {
                        var trigger = triggers[i];
                        if (trigger === 'click' || trigger === 'contextmenu') {
                            element.off(trigger, $tooltip.toggle);
                        } else if (trigger !== 'manual') {
                            element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
                            element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
                            if (nodeName === 'button' && trigger !== 'hover') {
                                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
                            }
                        }
                    }
                }

                function bindKeyboardEvents() {
                    if (options.trigger !== 'focus') {
                        tipElement.on('keyup', $tooltip.$onKeyUp);
                    } else {
                        element.on('keyup', $tooltip.$onFocusKeyUp);
                    }
                }

                function unbindKeyboardEvents() {
                    if (options.trigger !== 'focus') {
                        tipElement.off('keyup', $tooltip.$onKeyUp);
                    } else {
                        element.off('keyup', $tooltip.$onFocusKeyUp);
                    }
                }
                var _autoCloseEventsBinded = false;

                function bindAutoCloseEvents() {
                    $timeout(function() {
                        tipElement.on('click', stopEventPropagation);
                        $body.on('click', $tooltip.hide);
                        _autoCloseEventsBinded = true;
                    }, 0, false);
                }

                function unbindAutoCloseEvents() {
                    if (_autoCloseEventsBinded) {
                        tipElement.off('click', stopEventPropagation);
                        $body.off('click', $tooltip.hide);
                        _autoCloseEventsBinded = false;
                    }
                }

                function stopEventPropagation(event) {
                    event.stopPropagation();
                }

                function getPosition($element) {
                    $element = $element || (options.target || element);
                    var el = $element[0];
                    var isBody = el.tagName === 'BODY';
                    var elRect = el.getBoundingClientRect();
                    var rect = {};
                    for (var p in elRect) {
                        rect[p] = elRect[p];
                    }
                    if (rect.width === null) {
                        rect = angular.extend({}, rect, {
                            width: elRect.right - elRect.left,
                            height: elRect.bottom - elRect.top
                        });
                    }
                    var elOffset = isBody ? {
                        top: 0,
                        left: 0
                    } : dimensions.offset(el);
                    var scroll = {
                        scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0
                    };
                    var outerDims = isBody ? {
                        width: document.documentElement.clientWidth,
                        height: $window.innerHeight
                    } : null;
                    return angular.extend({}, rect, scroll, outerDims, elOffset);
                }

                function getCalculatedOffset(placement, position, actualWidth, actualHeight) {
                    var offset;
                    var split = placement.split('-');
                    switch (split[0]) {
                        case 'right':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left + position.width
                            };
                            break;

                        case 'bottom':
                            offset = {
                                top: position.top + position.height,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;

                        case 'left':
                            offset = {
                                top: position.top + position.height / 2 - actualHeight / 2,
                                left: position.left - actualWidth
                            };
                            break;

                        default:
                            offset = {
                                top: position.top - actualHeight,
                                left: position.left + position.width / 2 - actualWidth / 2
                            };
                            break;
                    }
                    if (!split[1]) {
                        return offset;
                    }
                    if (split[0] === 'top' || split[0] === 'bottom') {
                        switch (split[1]) {
                            case 'left':
                                offset.left = position.left;
                                break;

                            case 'right':
                                offset.left = position.left + position.width - actualWidth;
                                break;

                            default:
                                break;
                        }
                    } else if (split[0] === 'left' || split[0] === 'right') {
                        switch (split[1]) {
                            case 'top':
                                offset.top = position.top - actualHeight + position.height;
                                break;

                            case 'bottom':
                                offset.top = position.top;
                                break;

                            default:
                                break;
                        }
                    }
                    return offset;
                }

                function applyPlacement(offset, placement) {
                    var tip = tipElement[0];
                    var width = tip.offsetWidth;
                    var height = tip.offsetHeight;
                    var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);
                    var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);
                    if (isNaN(marginTop)) marginTop = 0;
                    if (isNaN(marginLeft)) marginLeft = 0;
                    offset.top = offset.top + marginTop;
                    offset.left = offset.left + marginLeft;
                    dimensions.setOffset(tip, angular.extend({
                        using: function(props) {
                            tipElement.css({
                                top: Math.round(props.top) + 'px',
                                left: Math.round(props.left) + 'px',
                                right: ''
                            });
                        }
                    }, offset), 0);
                    var actualWidth = tip.offsetWidth;
                    var actualHeight = tip.offsetHeight;
                    if (placement === 'top' && actualHeight !== height) {
                        offset.top = offset.top + height - actualHeight;
                    }
                    if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;
                    var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
                    if (delta.left) {
                        offset.left += delta.left;
                    } else {
                        offset.top += delta.top;
                    }
                    dimensions.setOffset(tip, offset);
                    if (/top|right|bottom|left/.test(placement)) {
                        var isVertical = /top|bottom/.test(placement);
                        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
                        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
                        replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);
                    }
                }

                function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {
                    var delta = {
                        top: 0,
                        left: 0
                    };
                    if (!$tooltip.$viewport) return delta;
                    var viewportPadding = options.viewport && options.viewport.padding || 0;
                    var viewportDimensions = getPosition($tooltip.$viewport);
                    if (/right|left/.test(placement)) {
                        var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;
                        var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;
                        if (topEdgeOffset < viewportDimensions.top) {
                            delta.top = viewportDimensions.top - topEdgeOffset;
                        } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
                        }
                    } else {
                        var leftEdgeOffset = position.left - viewportPadding;
                        var rightEdgeOffset = position.left + viewportPadding + actualWidth;
                        if (leftEdgeOffset < viewportDimensions.left) {
                            delta.left = viewportDimensions.left - leftEdgeOffset;
                        } else if (rightEdgeOffset > viewportDimensions.right) {
                            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
                        }
                    }
                    return delta;
                }

                function replaceArrow(delta, dimension, isHorizontal) {
                    var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);
                    $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isHorizontal ? 'top' : 'left', '');
                }

                function destroyTipElement() {
                    clearTimeout(timeout);
                    if ($tooltip.$isShown && tipElement !== null) {
                        if (options.autoClose) {
                            unbindAutoCloseEvents();
                        }
                        if (options.keyboard) {
                            unbindKeyboardEvents();
                        }
                    }
                    if (tipScope) {
                        tipScope.$destroy();
                        tipScope = null;
                    }
                    if (tipElement) {
                        tipElement.remove();
                        tipElement = $tooltip.$element = null;
                    }
                }
                return $tooltip;
            }

            function safeDigest(scope) {
                scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
            }

            function findElement(query, element) {
                return angular.element((element || document).querySelectorAll(query));
            }
            return TooltipFactory;
        }];
    }).directive('bsTooltip', ['$window', '$location', '$sce', '$tooltip', '$$rAF', function($window, $location, $sce, $tooltip, $$rAF) {
        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {
                var tooltip;
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
                        options[key] = false;
                    }
                });
                var dataTarget = element.attr('data-target');
                if (angular.isDefined(dataTarget)) {
                    if (falseValueRegExp.test(dataTarget)) {
                        options.target = false;
                    } else {
                        options.target = dataTarget;
                    }
                }
                if (!scope.hasOwnProperty('title')) {
                    scope.title = '';
                }
                attr.$observe('title', function(newValue) {
                    if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {
                        var oldValue = scope.title;
                        scope.title = $sce.trustAsHtml(newValue);
                        if (angular.isDefined(oldValue)) {
                            $$rAF(function() {
                                if (tooltip) tooltip.$applyPlacement();
                            });
                        }
                    }
                });
                attr.$observe('disabled', function(newValue) {
                    if (newValue && tooltip.$isShown) {
                        tooltip.hide();
                    }
                });
                if (attr.bsTooltip) {
                    scope.$watch(attr.bsTooltip, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend(scope, newValue);
                        } else {
                            scope.title = newValue;
                        }
                        if (angular.isDefined(oldValue)) {
                            $$rAF(function() {
                                if (tooltip) tooltip.$applyPlacement();
                            });
                        }
                    }, true);
                }
                if (attr.bsShow) {
                    scope.$watch(attr.bsShow, function(newValue, oldValue) {
                        if (!tooltip || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);
                        if (newValue === true) {
                            tooltip.show();
                        } else {
                            tooltip.hide();
                        }
                    });
                }
                if (attr.bsEnabled) {
                    scope.$watch(attr.bsEnabled, function(newValue, oldValue) {
                        if (!tooltip || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);
                        if (newValue === false) {
                            tooltip.setEnabled(false);
                        } else {
                            tooltip.setEnabled(true);
                        }
                    });
                }
                if (attr.viewport) {
                    scope.$watch(attr.viewport, function(newValue) {
                        if (!tooltip || !angular.isDefined(newValue)) return;
                        tooltip.setViewport(newValue);
                    });
                }
                tooltip = $tooltip(element, options);
                scope.$on('$destroy', function() {
                    if (tooltip) tooltip.destroy();
                    options = null;
                    tooltip = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions']).provider('$typeahead', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'typeahead',
            prefixEvent: '$typeahead',
            placement: 'bottom-left',
            templateUrl: 'typeahead/typeahead.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            minLength: 1,
            filter: 'bsAsyncFilter',
            limit: 6,
            autoSelect: false,
            comparator: '',
            trimValue: true
        };
        this.$get = ['$window', '$rootScope', '$tooltip', '$$rAF', '$timeout', function($window, $rootScope, $tooltip, $$rAF, $timeout) {
            function TypeaheadFactory(element, controller, config) {
                var $typeahead = {};
                var options = angular.extend({}, defaults, config);
                $typeahead = $tooltip(element, options);
                var parentScope = config.scope;
                var scope = $typeahead.$scope;
                scope.$resetMatches = function() {
                    scope.$matches = [];
                    scope.$activeIndex = options.autoSelect ? 0 : -1;
                };
                scope.$resetMatches();
                scope.$activate = function(index) {
                    scope.$$postDigest(function() {
                        $typeahead.activate(index);
                    });
                };
                scope.$select = function(index, evt) {
                    scope.$$postDigest(function() {
                        $typeahead.select(index);
                    });
                };
                scope.$isVisible = function() {
                    return $typeahead.$isVisible();
                };
                $typeahead.update = function(matches) {
                    scope.$matches = matches;
                    if (scope.$activeIndex >= matches.length) {
                        scope.$activeIndex = options.autoSelect ? 0 : -1;
                    }
                    safeDigest(scope);
                    $$rAF($typeahead.$applyPlacement);
                };
                $typeahead.activate = function(index) {
                    scope.$activeIndex = index;
                };
                $typeahead.select = function(index) {
                    if (index === -1) return;
                    var value = scope.$matches[index].value;
                    controller.$setViewValue(value);
                    controller.$render();
                    scope.$resetMatches();
                    if (parentScope) parentScope.$digest();
                    scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);
                };
                $typeahead.$isVisible = function() {
                    if (!options.minLength || !controller) {
                        return !!scope.$matches.length;
                    }
                    return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;
                };
                $typeahead.$getIndex = function(value) {
                    var index;
                    for (index = scope.$matches.length; index--;) {
                        if (angular.equals(scope.$matches[index].value, value)) break;
                    }
                    return index;
                };
                $typeahead.$onMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                };
                $typeahead.$onKeyDown = function(evt) {
                    if (!/(38|40|13)/.test(evt.keyCode)) return;
                    if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }
                    if (evt.keyCode === 13 && scope.$matches.length) {
                        $typeahead.select(scope.$activeIndex);
                    } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {
                        scope.$activeIndex--;
                    } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {
                        scope.$activeIndex++;
                    } else if (angular.isUndefined(scope.$activeIndex)) {
                        scope.$activeIndex = 0;
                    }
                    scope.$digest();
                };
                var show = $typeahead.show;
                $typeahead.show = function() {
                    show();
                    $timeout(function() {
                        if ($typeahead.$element) {
                            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);
                            if (options.keyboard) {
                                if (element) element.on('keydown', $typeahead.$onKeyDown);
                            }
                        }
                    }, 0, false);
                };
                var hide = $typeahead.hide;
                $typeahead.hide = function() {
                    if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);
                    if (options.keyboard) {
                        if (element) element.off('keydown', $typeahead.$onKeyDown);
                    }
                    if (!options.autoSelect) {
                        $typeahead.activate(-1);
                    }
                    hide();
                };
                return $typeahead;
            }

            function safeDigest(scope) {
                scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
            }
            TypeaheadFactory.defaults = defaults;
            return TypeaheadFactory;
        }];
    }).filter('bsAsyncFilter', ['$filter', function($filter) {
        return function(array, expression, comparator) {
            if (array && angular.isFunction(array.then)) {
                return array.then(function(results) {
                    return $filter('filter')(results, expression, comparator);
                });
            }
            return $filter('filter')(array, expression, comparator);
        };
    }]).directive('bsTypeahead', ['$window', '$parse', '$q', '$typeahead', '$parseOptions', function($window, $parse, $q, $typeahead, $parseOptions) {
        var defaults = $typeahead.defaults;
        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                element.off('change');
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container', 'trimValue', 'filter'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                });
                if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');
                var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;
                var limit = options.limit || defaults.limit;
                var comparator = options.comparator || defaults.comparator;
                var bsOptions = attr.bsOptions;
                if (filter) {
                    bsOptions += ' | ' + filter + ':$viewValue';
                    if (comparator) bsOptions += ':' + comparator;
                }
                if (limit) bsOptions += ' | limitTo:' + limit;
                var parsedOptions = $parseOptions(bsOptions);
                var typeahead = $typeahead(element, controller, options);
                if (options.watchOptions) {
                    var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').replace(/\(.*\)/g, '').trim();
                    scope.$watchCollection(watchedOptions, function(newValue, oldValue) {
                        parsedOptions.valuesFn(scope, controller).then(function(values) {
                            typeahead.update(values);
                            controller.$render();
                        });
                    });
                }
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    scope.$modelValue = newValue;
                    parsedOptions.valuesFn(scope, controller).then(function(values) {
                        if (options.selectMode && !values.length && newValue.length > 0) {
                            controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));
                            return;
                        }
                        if (values.length > limit) values = values.slice(0, limit);
                        typeahead.update(values);
                        controller.$render();
                    });
                });
                controller.$formatters.push(function(modelValue) {
                    var displayValue = parsedOptions.displayValue(modelValue);
                    if (displayValue) {
                        return displayValue;
                    }
                    if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {
                        return modelValue;
                    }
                    return '';
                });
                controller.$render = function() {
                    if (controller.$isEmpty(controller.$viewValue)) {
                        return element.val('');
                    }
                    var index = typeahead.$getIndex(controller.$modelValue);
                    var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;
                    selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;
                    var value = selected ? selected.toString().replace(/<(?:.|\n)*?>/gm, '') : '';
                    element.val(options.trimValue === false ? value : value.trim());
                };
                scope.$on('$destroy', function() {
                    if (typeahead) typeahead.destroy();
                    options = null;
                    typeahead = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip']).provider('$timepicker', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'timepicker',
            placement: 'bottom-right',
            templateUrl: 'timepicker/timepicker.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            useNative: true,
            timeType: 'date',
            timeFormat: 'shortTime',
            timezone: null,
            modelTimeFormat: null,
            autoclose: false,
            minTime: -Infinity,
            maxTime: +Infinity,
            length: 5,
            hourStep: 1,
            minuteStep: 5,
            secondStep: 5,
            roundDisplay: false,
            iconUp: 'fa fa-angle-up',
            iconDown: 'fa fa-angle-down',
            arrowBehavior: 'pager'
        };
        this.$get = ['$window', '$document', '$rootScope', '$sce', '$dateFormatter', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {
            var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
            var isTouch = 'createTouch' in $window.document && isNative;
            if (!defaults.lang) {
                defaults.lang = $dateFormatter.getDefaultLocale();
            }

            function timepickerFactory(element, controller, config) {
                var $timepicker = $tooltip(element, angular.extend({}, defaults, config));
                var parentScope = config.scope;
                var options = $timepicker.$options;
                var scope = $timepicker.$scope;
                var lang = options.lang;
                var formatDate = function(date, format, timezone) {
                    return $dateFormatter.formatDate(date, format, lang, timezone);
                };

                function floorMinutes(time) {
                    var coeff = 1e3 * 60 * options.minuteStep;
                    return new Date(Math.floor(time.getTime() / coeff) * coeff);
                }
                var selectedIndex = 0;
                var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();
                var startDate = controller.$dateValue || defaultDate;
                var viewDate = {
                    hour: startDate.getHours(),
                    meridian: startDate.getHours() < 12,
                    minute: startDate.getMinutes(),
                    second: startDate.getSeconds(),
                    millisecond: startDate.getMilliseconds()
                };
                var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);
                var hoursFormat = $dateFormatter.hoursFormat(format);
                var timeSeparator = $dateFormatter.timeSeparator(format);
                var minutesFormat = $dateFormatter.minutesFormat(format);
                var secondsFormat = $dateFormatter.secondsFormat(format);
                var showSeconds = $dateFormatter.showSeconds(format);
                var showAM = $dateFormatter.showAM(format);
                scope.$iconUp = options.iconUp;
                scope.$iconDown = options.iconDown;
                scope.$select = function(date, index) {
                    $timepicker.select(date, index);
                };
                scope.$moveIndex = function(value, index) {
                    $timepicker.$moveIndex(value, index);
                };
                scope.$switchMeridian = function(date) {
                    $timepicker.switchMeridian(date);
                };
                $timepicker.update = function(date) {
                    if (angular.isDate(date) && !isNaN(date.getTime())) {
                        $timepicker.$date = date;
                        angular.extend(viewDate, {
                            hour: date.getHours(),
                            minute: date.getMinutes(),
                            second: date.getSeconds(),
                            millisecond: date.getMilliseconds()
                        });
                        $timepicker.$build();
                    } else if (!$timepicker.$isBuilt) {
                        $timepicker.$build();
                    }
                };
                $timepicker.select = function(date, index, keep) {
                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);
                    if (!angular.isDate(date)) date = new Date(date);
                    if (index === 0) controller.$dateValue.setHours(date.getHours());
                    else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());
                    else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());
                    controller.$setViewValue(angular.copy(controller.$dateValue));
                    controller.$render();
                    if (options.autoclose && !keep) {
                        $timeout(function() {
                            $timepicker.hide(true);
                        });
                    }
                };
                $timepicker.switchMeridian = function(date) {
                    if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {
                        return;
                    }
                    var hours = (date || controller.$dateValue).getHours();
                    controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);
                    controller.$setViewValue(angular.copy(controller.$dateValue));
                    controller.$render();
                };
                $timepicker.$build = function() {
                    var i;
                    var midIndex = scope.midIndex = parseInt(options.length / 2, 10);
                    var hours = [];
                    var hour;
                    for (i = 0; i < options.length; i++) {
                        hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);
                        hours.push({
                            date: hour,
                            label: formatDate(hour, hoursFormat),
                            selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),
                            disabled: $timepicker.$isDisabled(hour, 0)
                        });
                    }
                    var minutes = [];
                    var minute;
                    for (i = 0; i < options.length; i++) {
                        minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);
                        minutes.push({
                            date: minute,
                            label: formatDate(minute, minutesFormat),
                            selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),
                            disabled: $timepicker.$isDisabled(minute, 1)
                        });
                    }
                    var seconds = [];
                    var second;
                    for (i = 0; i < options.length; i++) {
                        second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);
                        seconds.push({
                            date: second,
                            label: formatDate(second, secondsFormat),
                            selected: $timepicker.$date && $timepicker.$isSelected(second, 2),
                            disabled: $timepicker.$isDisabled(second, 2)
                        });
                    }
                    var rows = [];
                    for (i = 0; i < options.length; i++) {
                        if (showSeconds) {
                            rows.push([hours[i], minutes[i], seconds[i]]);
                        } else {
                            rows.push([hours[i], minutes[i]]);
                        }
                    }
                    scope.rows = rows;
                    scope.showSeconds = showSeconds;
                    scope.showAM = showAM;
                    scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;
                    scope.timeSeparator = timeSeparator;
                    $timepicker.$isBuilt = true;
                };
                $timepicker.$isSelected = function(date, index) {
                    if (!$timepicker.$date) return false;
                    else if (index === 0) {
                        return date.getHours() === $timepicker.$date.getHours();
                    } else if (index === 1) {
                        return date.getMinutes() === $timepicker.$date.getMinutes();
                    } else if (index === 2) {
                        return date.getSeconds() === $timepicker.$date.getSeconds();
                    }
                };
                $timepicker.$isDisabled = function(date, index) {
                    var selectedTime;
                    if (index === 0) {
                        selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;
                    } else if (index === 1) {
                        selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;
                    } else if (index === 2) {
                        selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;
                    }
                    return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;
                };
                scope.$arrowAction = function(value, index) {
                    if (options.arrowBehavior === 'picker') {
                        $timepicker.$setTimeByStep(value, index);
                    } else {
                        $timepicker.$moveIndex(value, index);
                    }
                };
                $timepicker.$setTimeByStep = function(value, index) {
                    var newDate = new Date($timepicker.$date || startDate);
                    var hours = newDate.getHours();
                    var minutes = newDate.getMinutes();
                    var seconds = newDate.getSeconds();
                    if (index === 0) {
                        newDate.setHours(hours - parseInt(options.hourStep, 10) * value);
                    } else if (index === 1) {
                        newDate.setMinutes(minutes - parseInt(options.minuteStep, 10) * value);
                    } else if (index === 2) {
                        newDate.setSeconds(seconds - parseInt(options.secondStep, 10) * value);
                    }
                    $timepicker.select(newDate, index, true);
                };
                $timepicker.$moveIndex = function(value, index) {
                    var targetDate;
                    if (index === 0) {
                        targetDate = new Date(1970, 0, 1, viewDate.hour + value * options.length, viewDate.minute, viewDate.second);
                        angular.extend(viewDate, {
                            hour: targetDate.getHours()
                        });
                    } else if (index === 1) {
                        targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + value * options.length * options.minuteStep, viewDate.second);
                        angular.extend(viewDate, {
                            minute: targetDate.getMinutes()
                        });
                    } else if (index === 2) {
                        targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + value * options.length * options.secondStep);
                        angular.extend(viewDate, {
                            second: targetDate.getSeconds()
                        });
                    }
                    $timepicker.$build();
                };
                $timepicker.$onMouseDown = function(evt) {
                    if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();
                    evt.stopPropagation();
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {
                            targetEl = targetEl.parent();
                        }
                        targetEl.triggerHandler('click');
                    }
                };
                $timepicker.$onKeyDown = function(evt) {
                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (evt.keyCode === 13) {
                        $timepicker.hide(true);
                        return;
                    }
                    var newDate = new Date($timepicker.$date);
                    var hours = newDate.getHours();
                    var hoursLength = formatDate(newDate, hoursFormat).length;
                    var minutes = newDate.getMinutes();
                    var minutesLength = formatDate(newDate, minutesFormat).length;
                    var seconds = newDate.getSeconds();
                    var secondsLength = formatDate(newDate, secondsFormat).length;
                    var sepLength = 1;
                    var lateralMove = /(37|39)/.test(evt.keyCode);
                    var count = 2 + showSeconds * 1 + showAM * 1;
                    if (lateralMove) {
                        if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;
                        else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;
                    }
                    var selectRange = [0, hoursLength];
                    var incr = 0;
                    if (evt.keyCode === 38) incr = -1;
                    if (evt.keyCode === 40) incr = +1;
                    var isSeconds = selectedIndex === 2 && showSeconds;
                    var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;
                    if (selectedIndex === 0) {
                        newDate.setHours(hours + incr * parseInt(options.hourStep, 10));
                        hoursLength = formatDate(newDate, hoursFormat).length;
                        selectRange = [0, hoursLength];
                    } else if (selectedIndex === 1) {
                        newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));
                        minutesLength = formatDate(newDate, minutesFormat).length;
                        selectRange = [hoursLength + sepLength, minutesLength];
                    } else if (isSeconds) {
                        newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));
                        secondsLength = formatDate(newDate, secondsFormat).length;
                        selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];
                    } else if (isMeridian) {
                        if (!lateralMove) $timepicker.switchMeridian();
                        selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];
                    }
                    $timepicker.select(newDate, selectedIndex, true);
                    createSelection(selectRange[0], selectRange[1]);
                    parentScope.$digest();
                };

                function createSelection(start, length) {
                    var end = start + length;
                    if (element[0].createTextRange) {
                        var selRange = element[0].createTextRange();
                        selRange.collapse(true);
                        selRange.moveStart('character', start);
                        selRange.moveEnd('character', end);
                        selRange.select();
                    } else if (element[0].setSelectionRange) {
                        element[0].setSelectionRange(start, end);
                    } else if (angular.isUndefined(element[0].selectionStart)) {
                        element[0].selectionStart = start;
                        element[0].selectionEnd = end;
                    }
                }

                function focusElement() {
                    element[0].focus();
                }
                var _init = $timepicker.init;
                $timepicker.init = function() {
                    if (isNative && options.useNative) {
                        element.prop('type', 'time');
                        element.css('-webkit-appearance', 'textfield');
                        return;
                    } else if (isTouch) {
                        element.prop('type', 'text');
                        element.attr('readonly', 'true');
                        element.on('click', focusElement);
                    }
                    _init();
                };
                var _destroy = $timepicker.destroy;
                $timepicker.destroy = function() {
                    if (isNative && options.useNative) {
                        element.off('click', focusElement);
                    }
                    _destroy();
                };
                var _show = $timepicker.show;
                $timepicker.show = function() {
                    if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;
                    _show();
                    $timeout(function() {
                        if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
                        if (options.keyboard) {
                            if (element) element.on('keydown', $timepicker.$onKeyDown);
                        }
                    }, 0, false);
                };
                var _hide = $timepicker.hide;
                $timepicker.hide = function(blur) {
                    if (!$timepicker.$isShown) return;
                    if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
                    if (options.keyboard) {
                        if (element) element.off('keydown', $timepicker.$onKeyDown);
                    }
                    _hide(blur);
                };
                return $timepicker;
            }
            timepickerFactory.defaults = defaults;
            return timepickerFactory;
        }];
    }).directive('bsTimepicker', ['$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$timepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {
        var defaults = $timepicker.defaults;
        var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
                        options[key] = false;
                    }
                });
                if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm:ss';
                var timepicker = $timepicker(element, controller, options);
                options = timepicker.$options;
                var lang = options.lang;
                var formatDate = function(date, format, timezone) {
                    return $dateFormatter.formatDate(date, format, lang, timezone);
                };
                if (attr.bsShow) {
                    scope.$watch(attr.bsShow, function(newValue, oldValue) {
                        if (!timepicker || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);
                        if (newValue === true) {
                            timepicker.show();
                        } else {
                            timepicker.hide();
                        }
                    });
                }
                var dateParser = $dateParser({
                    format: options.timeFormat,
                    lang: lang
                });
                angular.forEach(['minTime', 'maxTime'], function(key) {
                    if (angular.isDefined(attr[key])) {
                        attr.$observe(key, function(newValue) {
                            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);
                            if (!isNaN(timepicker.$options[key])) timepicker.$build();
                            validateAgainstMinMaxTime(controller.$dateValue);
                        });
                    }
                });
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    timepicker.update(controller.$dateValue);
                }, true);

                function validateAgainstMinMaxTime(parsedTime) {
                    if (!angular.isDate(parsedTime)) return;
                    var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;
                    var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;
                    var isValid = isMinValid && isMaxValid;
                    controller.$setValidity('date', isValid);
                    controller.$setValidity('min', isMinValid);
                    controller.$setValidity('max', isMaxValid);
                    if (!isValid) {
                        return;
                    }
                    controller.$dateValue = parsedTime;
                }
                controller.$parsers.unshift(function(viewValue) {
                    var date;
                    if (!viewValue) {
                        controller.$setValidity('date', true);
                        return null;
                    }
                    var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);
                    if (!parsedTime || isNaN(parsedTime.getTime())) {
                        controller.$setValidity('date', false);
                        return undefined;
                    }
                    validateAgainstMinMaxTime(parsedTime);
                    if (options.timeType === 'string') {
                        date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);
                        return formatDate(date, options.modelTimeFormat || options.timeFormat);
                    }
                    date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);
                    if (options.timeType === 'number') {
                        return date.getTime();
                    } else if (options.timeType === 'unix') {
                        return date.getTime() / 1e3;
                    } else if (options.timeType === 'iso') {
                        return date.toISOString();
                    }
                    return new Date(date);
                });
                controller.$formatters.push(function(modelValue) {
                    var date;
                    if (angular.isUndefined(modelValue) || modelValue === null) {
                        date = NaN;
                    } else if (angular.isDate(modelValue)) {
                        date = modelValue;
                    } else if (options.timeType === 'string') {
                        date = dateParser.parse(modelValue, null, options.modelTimeFormat);
                    } else if (options.timeType === 'unix') {
                        date = new Date(modelValue * 1e3);
                    } else {
                        date = new Date(modelValue);
                    }
                    controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);
                    return getTimeFormattedString();
                });
                controller.$render = function() {
                    element.val(getTimeFormattedString());
                };

                function getTimeFormattedString() {
                    return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);
                }
                scope.$on('$destroy', function() {
                    if (timepicker) timepicker.destroy();
                    options = null;
                    timepicker = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.tab', []).provider('$tab', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            template: 'tab/tab.tpl.html',
            navClass: 'nav-tabs',
            activeClass: 'active'
        };
        var controller = this.controller = function($scope, $element, $attrs) {
            var self = this;
            self.$options = angular.copy(defaults);
            angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {
                if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
            });
            $scope.$navClass = self.$options.navClass;
            $scope.$activeClass = self.$options.activeClass;
            self.$panes = $scope.$panes = [];
            self.$activePaneChangeListeners = self.$viewChangeListeners = [];
            self.$push = function(pane) {
                if (angular.isUndefined(self.$panes.$active)) {
                    $scope.$setActive(pane.name || 0);
                }
                self.$panes.push(pane);
            };
            self.$remove = function(pane) {
                var index = self.$panes.indexOf(pane);
                var active = self.$panes.$active;
                var activeIndex;
                if (angular.isString(active)) {
                    activeIndex = self.$panes.map(function(pane) {
                        return pane.name;
                    }).indexOf(active);
                } else {
                    activeIndex = self.$panes.$active;
                }
                self.$panes.splice(index, 1);
                if (index < activeIndex) {
                    activeIndex--;
                } else if (index === activeIndex && activeIndex === self.$panes.length) {
                    activeIndex--;
                }
                if (activeIndex >= 0 && activeIndex < self.$panes.length) {
                    self.$setActive(self.$panes[activeIndex].name || activeIndex);
                } else {
                    self.$setActive();
                }
            };
            self.$setActive = $scope.$setActive = function(value) {
                self.$panes.$active = value;
                self.$activePaneChangeListeners.forEach(function(fn) {
                    fn();
                });
            };
            self.$isActive = $scope.$isActive = function($pane, $index) {
                return self.$panes.$active === $pane.name || self.$panes.$active === $index;
            };
        };
        this.$get = function() {
            var $tab = {};
            $tab.defaults = defaults;
            $tab.controller = controller;
            return $tab;
        };
    }).directive('bsTabs', ['$window', '$animate', '$tab', '$parse', function($window, $animate, $tab, $parse) {
        var defaults = $tab.defaults;
        return {
            require: ['?ngModel', 'bsTabs'],
            transclude: true,
            scope: true,
            controller: ['$scope', '$element', '$attrs', $tab.controller],
            templateUrl: function(element, attr) {
                return attr.template || defaults.template;
            },
            link: function postLink(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var bsTabsCtrl = controllers[1];
                if (ngModelCtrl) {
                    bsTabsCtrl.$activePaneChangeListeners.push(function() {
                        ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);
                    });
                    ngModelCtrl.$formatters.push(function(modelValue) {
                        bsTabsCtrl.$setActive(modelValue);
                        return modelValue;
                    });
                }
                if (attrs.bsActivePane) {
                    var parsedBsActivePane = $parse(attrs.bsActivePane);
                    bsTabsCtrl.$activePaneChangeListeners.push(function() {
                        parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);
                    });
                    scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {
                        bsTabsCtrl.$setActive(newValue);
                    }, true);
                }
            }
        };
    }]).directive('bsPane', ['$window', '$animate', '$sce', function($window, $animate, $sce) {
        return {
            require: ['^?ngModel', '^bsTabs'],
            scope: true,
            link: function postLink(scope, element, attrs, controllers) {
                var bsTabsCtrl = controllers[1];
                element.addClass('tab-pane');
                attrs.$observe('title', function(newValue, oldValue) {
                    scope.title = $sce.trustAsHtml(newValue);
                });
                scope.name = attrs.name;
                if (bsTabsCtrl.$options.animation) {
                    element.addClass(bsTabsCtrl.$options.animation);
                }
                attrs.$observe('disabled', function(newValue, oldValue) {
                    scope.disabled = scope.$eval(newValue);
                });
                bsTabsCtrl.$push(scope);
                scope.$on('$destroy', function() {
                    bsTabsCtrl.$remove(scope);
                });

                function render() {
                    var index = bsTabsCtrl.$panes.indexOf(scope);
                    $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);
                }
                bsTabsCtrl.$activePaneChangeListeners.push(function() {
                    render();
                });
                render();
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions']).provider('$select', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'select',
            prefixEvent: '$select',
            placement: 'bottom-left',
            templateUrl: 'select/select.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            multiple: false,
            allNoneButtons: false,
            sort: true,
            caretHtml: '&nbsp;<span class="caret"></span>',
            placeholder: 'Choose among the following...',
            allText: 'All',
            noneText: 'None',
            maxLength: 3,
            maxLengthHtml: 'selected',
            iconCheckmark: 'glyphicon glyphicon-ok'
        };
        this.$get = ['$window', '$document', '$rootScope', '$tooltip', '$timeout', function($window, $document, $rootScope, $tooltip, $timeout) {
            var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
            var isTouch = 'createTouch' in $window.document && isNative;

            function SelectFactory(element, controller, config) {
                var $select = {};
                var options = angular.extend({}, defaults, config);
                $select = $tooltip(element, options);
                var scope = $select.$scope;
                scope.$matches = [];
                if (options.multiple) {
                    scope.$activeIndex = [];
                } else {
                    scope.$activeIndex = -1;
                }
                scope.$isMultiple = options.multiple;
                scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;
                scope.$iconCheckmark = options.iconCheckmark;
                scope.$allText = options.allText;
                scope.$noneText = options.noneText;
                scope.$activate = function(index) {
                    scope.$$postDigest(function() {
                        $select.activate(index);
                    });
                };
                scope.$select = function(index, evt) {
                    scope.$$postDigest(function() {
                        $select.select(index);
                    });
                };
                scope.$isVisible = function() {
                    return $select.$isVisible();
                };
                scope.$isActive = function(index) {
                    return $select.$isActive(index);
                };
                scope.$selectAll = function() {
                    for (var i = 0; i < scope.$matches.length; i++) {
                        if (!scope.$isActive(i)) {
                            scope.$select(i);
                        }
                    }
                };
                scope.$selectNone = function() {
                    for (var i = 0; i < scope.$matches.length; i++) {
                        if (scope.$isActive(i)) {
                            scope.$select(i);
                        }
                    }
                };
                $select.update = function(matches) {
                    scope.$matches = matches;
                    $select.$updateActiveIndex();
                };
                $select.activate = function(index) {
                    if (options.multiple) {
                        if ($select.$isActive(index)) {
                            scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);
                        } else {
                            scope.$activeIndex.push(index);
                        }
                        if (options.sort) scope.$activeIndex.sort(function(a, b) {
                            return a - b;
                        });
                    } else {
                        scope.$activeIndex = index;
                    }
                    return scope.$activeIndex;
                };
                $select.select = function(index) {
                    var value = scope.$matches[index].value;
                    scope.$apply(function() {
                        $select.activate(index);
                        if (options.multiple) {
                            controller.$setViewValue(scope.$activeIndex.map(function(index) {
                                if (angular.isUndefined(scope.$matches[index])) {
                                    return null;
                                }
                                return scope.$matches[index].value;
                            }));
                        } else {
                            controller.$setViewValue(value);
                            $select.hide();
                        }
                    });
                    scope.$emit(options.prefixEvent + '.select', value, index, $select);
                };
                $select.$updateActiveIndex = function() {
                    if (options.multiple) {
                        if (angular.isArray(controller.$modelValue)) {
                            scope.$activeIndex = controller.$modelValue.map(function(value) {
                                return $select.$getIndex(value);
                            });
                        } else {
                            scope.$activeIndex = [];
                        }
                    } else {
                        if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {
                            scope.$activeIndex = $select.$getIndex(controller.$modelValue);
                        } else {
                            scope.$activeIndex = -1;
                        }
                    }
                };
                $select.$isVisible = function() {
                    if (!options.minLength || !controller) {
                        return scope.$matches.length;
                    }
                    return scope.$matches.length && controller.$viewValue.length >= options.minLength;
                };
                $select.$isActive = function(index) {
                    if (options.multiple) {
                        return scope.$activeIndex.indexOf(index) !== -1;
                    }
                    return scope.$activeIndex === index;
                };
                $select.$getIndex = function(value) {
                    var index;
                    for (index = scope.$matches.length; index--;) {
                        if (angular.equals(scope.$matches[index].value, value)) break;
                    }
                    return index;
                };
                $select.$onMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        targetEl.triggerHandler('click');
                    }
                };
                $select.$onKeyDown = function(evt) {
                    if (!/(9|13|38|40)/.test(evt.keyCode)) return;
                    if (evt.keyCode !== 9) {
                        evt.preventDefault();
                        evt.stopPropagation();
                    }
                    if (options.multiple && evt.keyCode === 9) {
                        return $select.hide();
                    }
                    if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {
                        return $select.select(scope.$activeIndex);
                    }
                    if (!options.multiple) {
                        if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;
                        else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;
                        else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;
                        else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
                        scope.$digest();
                    }
                };
                $select.$isIE = function() {
                    var ua = $window.navigator.userAgent;
                    return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;
                };
                $select.$selectScrollFix = function(e) {
                    if ($document[0].activeElement.tagName === 'UL') {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        e.target.focus();
                    }
                };
                var _show = $select.show;
                $select.show = function() {
                    _show();
                    if (options.multiple) {
                        $select.$element.addClass('select-multiple');
                    }
                    $timeout(function() {
                        $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $select.$onKeyDown);
                        }
                    }, 0, false);
                };
                var _hide = $select.hide;
                $select.hide = function() {
                    if (!options.multiple && angular.isUndefined(controller.$modelValue)) {
                        scope.$activeIndex = -1;
                    }
                    $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $select.$onKeyDown);
                    }
                    _hide(true);
                };
                return $select;
            }
            SelectFactory.defaults = defaults;
            return SelectFactory;
        }];
    }).directive('bsSelect', ['$window', '$parse', '$q', '$select', '$parseOptions', function($window, $parse, $q, $select, $parseOptions) {
        var defaults = $select.defaults;
        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                var options = {
                    scope: scope,
                    placeholder: defaults.placeholder
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
                        options[key] = false;
                    }
                });
                var dataMultiple = element.attr('data-multiple');
                if (angular.isDefined(dataMultiple)) {
                    if (falseValueRegExp.test(dataMultiple)) {
                        options.multiple = false;
                    } else {
                        options.multiple = dataMultiple;
                    }
                }
                if (element[0].nodeName.toLowerCase() === 'select') {
                    var inputEl = element;
                    inputEl.css('display', 'none');
                    element = angular.element('<button type="button" class="btn btn-default"></button>');
                    inputEl.after(element);
                }
                var parsedOptions = $parseOptions(attr.bsOptions);
                var select = $select(element, controller, options);
                if (select.$isIE()) {
                    element[0].addEventListener('blur', select.$selectScrollFix);
                }
                var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').trim();
                scope.$watch(watchedOptions, function(newValue, oldValue) {
                    parsedOptions.valuesFn(scope, controller).then(function(values) {
                        select.update(values);
                        controller.$render();
                    });
                }, true);
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    select.$updateActiveIndex();
                    controller.$render();
                }, true);
                controller.$render = function() {
                    var selected;
                    var index;
                    if (options.multiple && angular.isArray(controller.$modelValue)) {
                        selected = controller.$modelValue.map(function(value) {
                            index = select.$getIndex(value);
                            return index !== -1 ? select.$scope.$matches[index].label : false;
                        }).filter(angular.isDefined);
                        if (selected.length > (options.maxLength || defaults.maxLength)) {
                            selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);
                        } else {
                            selected = selected.join(', ');
                        }
                    } else {
                        index = select.$getIndex(controller.$modelValue);
                        selected = index !== -1 ? select.$scope.$matches[index].label : false;
                    }
                    element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));
                };
                if (options.multiple) {
                    controller.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
                scope.$on('$destroy', function() {
                    if (select) select.destroy();
                    options = null;
                    select = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions']).provider('$scrollspy', function() {
        var spies = this.$$spies = {};
        var defaults = this.defaults = {
            debounce: 150,
            throttle: 100,
            offset: 100
        };
        this.$get = ['$window', '$document', '$rootScope', 'dimensions', 'debounce', 'throttle', function($window, $document, $rootScope, dimensions, debounce, throttle) {
            var windowEl = angular.element($window);
            var docEl = angular.element($document.prop('documentElement'));
            var bodyEl = angular.element($window.document.body);

            function nodeName(element, name) {
                return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();
            }

            function ScrollSpyFactory(config) {
                var options = angular.extend({}, defaults, config);
                if (!options.element) options.element = bodyEl;
                var isWindowSpy = nodeName(options.element, 'body');
                var scrollEl = isWindowSpy ? windowEl : options.element;
                var scrollId = isWindowSpy ? 'window' : options.id;
                if (spies[scrollId]) {
                    spies[scrollId].$$count++;
                    return spies[scrollId];
                }
                var $scrollspy = {};
                var unbindViewContentLoaded;
                var unbindIncludeContentLoaded;
                var trackedElements = $scrollspy.$trackedElements = [];
                var sortedElements = [];
                var activeTarget;
                var debouncedCheckPosition;
                var throttledCheckPosition;
                var debouncedCheckOffsets;
                var viewportHeight;
                var scrollTop;
                $scrollspy.init = function() {
                    this.$$count = 1;
                    debouncedCheckPosition = debounce(this.checkPosition, options.debounce);
                    throttledCheckPosition = throttle(this.checkPosition, options.throttle);
                    scrollEl.on('click', this.checkPositionWithEventLoop);
                    windowEl.on('resize', debouncedCheckPosition);
                    scrollEl.on('scroll', throttledCheckPosition);
                    debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);
                    unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);
                    unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);
                    debouncedCheckOffsets();
                    if (scrollId) {
                        spies[scrollId] = $scrollspy;
                    }
                };
                $scrollspy.destroy = function() {
                    this.$$count--;
                    if (this.$$count > 0) {
                        return;
                    }
                    scrollEl.off('click', this.checkPositionWithEventLoop);
                    windowEl.off('resize', debouncedCheckPosition);
                    scrollEl.off('scroll', throttledCheckPosition);
                    unbindViewContentLoaded();
                    unbindIncludeContentLoaded();
                    if (scrollId) {
                        delete spies[scrollId];
                    }
                };
                $scrollspy.checkPosition = function() {
                    if (!sortedElements.length) return;
                    scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;
                    viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));
                    if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {
                        return $scrollspy.$activateElement(sortedElements[0]);
                    }
                    for (var i = sortedElements.length; i--;) {
                        if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;
                        if (activeTarget === sortedElements[i].target) continue;
                        if (scrollTop < sortedElements[i].offsetTop) continue;
                        if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;
                        return $scrollspy.$activateElement(sortedElements[i]);
                    }
                };
                $scrollspy.checkPositionWithEventLoop = function() {
                    setTimeout($scrollspy.checkPosition, 1);
                };
                $scrollspy.$activateElement = function(element) {
                    if (activeTarget) {
                        var activeElement = $scrollspy.$getTrackedElement(activeTarget);
                        if (activeElement) {
                            activeElement.source.removeClass('active');
                            if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {
                                activeElement.source.parent().parent().removeClass('active');
                            }
                        }
                    }
                    activeTarget = element.target;
                    element.source.addClass('active');
                    if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {
                        element.source.parent().parent().addClass('active');
                    }
                };
                $scrollspy.$getTrackedElement = function(target) {
                    return trackedElements.filter(function(obj) {
                        return obj.target === target;
                    })[0];
                };
                $scrollspy.checkOffsets = function() {
                    angular.forEach(trackedElements, function(trackedElement) {
                        var targetElement = document.querySelector(trackedElement.target);
                        trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;
                        if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;
                    });
                    sortedElements = trackedElements.filter(function(el) {
                        return el.offsetTop !== null;
                    }).sort(function(a, b) {
                        return a.offsetTop - b.offsetTop;
                    });
                    debouncedCheckPosition();
                };
                $scrollspy.trackElement = function(target, source) {
                    trackedElements.push({
                        target: target,
                        source: source
                    });
                };
                $scrollspy.untrackElement = function(target, source) {
                    var toDelete;
                    for (var i = trackedElements.length; i--;) {
                        if (trackedElements[i].target === target && trackedElements[i].source === source) {
                            toDelete = i;
                            break;
                        }
                    }
                    trackedElements.splice(toDelete, 1);
                };
                $scrollspy.activate = function(i) {
                    trackedElements[i].addClass('active');
                };
                $scrollspy.init();
                return $scrollspy;
            }
            return ScrollSpyFactory;
        }];
    }).directive('bsScrollspy', ['$rootScope', 'debounce', 'dimensions', '$scrollspy', function($rootScope, debounce, dimensions, $scrollspy) {
        return {
            restrict: 'EAC',
            link: function postLink(scope, element, attr) {
                var options = {
                    scope: scope
                };
                angular.forEach(['offset', 'target'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var scrollspy = $scrollspy(options);
                scrollspy.trackElement(options.target, element);
                scope.$on('$destroy', function() {
                    if (scrollspy) {
                        scrollspy.untrackElement(options.target, element);
                        scrollspy.destroy();
                    }
                    options = null;
                    scrollspy = null;
                });
            }
        };
    }]).directive('bsScrollspyList', ['$rootScope', 'debounce', 'dimensions', '$scrollspy', function($rootScope, debounce, dimensions, $scrollspy) {
        return {
            restrict: 'A',
            compile: function postLink(element, attr) {
                var children = element[0].querySelectorAll('li > a[href]');
                angular.forEach(children, function(child) {
                    var childEl = angular.element(child);
                    childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip']).provider('$popover', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            customClass: '',
            container: false,
            target: false,
            placement: 'right',
            templateUrl: 'popover/popover.tpl.html',
            contentTemplate: false,
            trigger: 'click',
            keyboard: true,
            html: false,
            title: '',
            content: '',
            delay: 0,
            autoClose: false
        };
        this.$get = ['$tooltip', function($tooltip) {
            function PopoverFactory(element, config) {
                var options = angular.extend({}, defaults, config);
                var $popover = $tooltip(element, options);
                if (options.content) {
                    $popover.$scope.content = options.content;
                }
                return $popover;
            }
            return PopoverFactory;
        }];
    }).directive('bsPopover', ['$window', '$sce', '$popover', function($window, $sce, $popover) {
        var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;
        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr) {
                var popover;
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container', 'autoClose'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                });
                var dataTarget = element.attr('data-target');
                if (angular.isDefined(dataTarget)) {
                    if (falseValueRegExp.test(dataTarget)) {
                        options.target = false;
                    } else {
                        options.target = dataTarget;
                    }
                }
                angular.forEach(['title', 'content'], function(key) {
                    if (attr[key]) {
                        attr.$observe(key, function(newValue, oldValue) {
                            scope[key] = $sce.trustAsHtml(newValue);
                            if (angular.isDefined(oldValue)) {
                                requestAnimationFrame(function() {
                                    if (popover) popover.$applyPlacement();
                                });
                            }
                        });
                    }
                });
                if (attr.bsPopover) {
                    scope.$watch(attr.bsPopover, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend(scope, newValue);
                        } else {
                            scope.content = newValue;
                        }
                        if (angular.isDefined(oldValue)) {
                            requestAnimationFrame(function() {
                                if (popover) popover.$applyPlacement();
                            });
                        }
                    }, true);
                }
                if (attr.bsShow) {
                    scope.$watch(attr.bsShow, function(newValue, oldValue) {
                        if (!popover || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);
                        if (newValue === true) {
                            popover.show();
                        } else {
                            popover.hide();
                        }
                    });
                }
                if (attr.viewport) {
                    scope.$watch(attr.viewport, function(newValue) {
                        if (!popover || !angular.isDefined(newValue)) return;
                        popover.setViewport(newValue);
                    });
                }
                popover = $popover(element, options);
                scope.$on('$destroy', function() {
                    if (popover) popover.destroy();
                    options = null;
                    popover = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.navbar', []).provider('$navbar', function() {
        var defaults = this.defaults = {
            activeClass: 'active',
            routeAttr: 'data-match-route',
            strict: false
        };
        this.$get = function() {
            return {
                defaults: defaults
            };
        };
    }).directive('bsNavbar', ['$window', '$location', '$navbar', function($window, $location, $navbar) {
        var defaults = $navbar.defaults;
        return {
            restrict: 'A',
            link: function postLink(scope, element, attr, controller) {
                var options = angular.copy(defaults);
                angular.forEach(Object.keys(defaults), function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                scope.$watch(function() {
                    return $location.path();
                }, function(newValue, oldValue) {
                    var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');
                    angular.forEach(liElements, function(li) {
                        var liElement = angular.element(li);
                        var pattern = liElement.attr(options.routeAttr).replace('/', '\\/');
                        if (options.strict) {
                            pattern = '^' + pattern + '$';
                        }
                        var regexp = new RegExp(pattern, 'i');
                        if (regexp.test(newValue)) {
                            liElement.addClass(options.activeClass);
                        } else {
                            liElement.removeClass(options.activeClass);
                        }
                    });
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip']).provider('$dropdown', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'dropdown',
            prefixEvent: 'dropdown',
            placement: 'bottom-left',
            templateUrl: 'dropdown/dropdown.tpl.html',
            trigger: 'click',
            container: false,
            keyboard: true,
            html: false,
            delay: 0
        };
        this.$get = ['$window', '$rootScope', '$tooltip', '$timeout', function($window, $rootScope, $tooltip, $timeout) {
            var bodyEl = angular.element($window.document.body);
            var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;

            function DropdownFactory(element, config) {
                var $dropdown = {};
                var options = angular.extend({}, defaults, config);
                $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                $dropdown = $tooltip(element, options);
                var parentEl = element.parent();
                $dropdown.$onKeyDown = function(evt) {
                    if (!/(38|40)/.test(evt.keyCode)) return;
                    evt.preventDefault();
                    evt.stopPropagation();
                    var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));
                    if (!items.length) return;
                    var index;
                    angular.forEach(items, function(el, i) {
                        if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;
                    });
                    if (evt.keyCode === 38 && index > 0) index--;
                    else if (evt.keyCode === 40 && index < items.length - 1) index++;
                    else if (angular.isUndefined(index)) index = 0;
                    items.eq(index)[0].focus();
                };
                var show = $dropdown.show;
                $dropdown.show = function() {
                    show();
                    $timeout(function() {
                        if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);
                        bodyEl.on('click', onBodyClick);
                    }, 0, false);
                    if (parentEl.hasClass('dropdown')) parentEl.addClass('open');
                };
                var hide = $dropdown.hide;
                $dropdown.hide = function() {
                    if (!$dropdown.$isShown) return;
                    if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);
                    bodyEl.off('click', onBodyClick);
                    if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');
                    hide();
                };
                var destroy = $dropdown.destroy;
                $dropdown.destroy = function() {
                    bodyEl.off('click', onBodyClick);
                    destroy();
                };

                function onBodyClick(evt) {
                    if (evt.target === element[0]) return;
                    return evt.target !== element[0] && $dropdown.hide();
                }
                return $dropdown;
            }
            return DropdownFactory;
        }];
    }).directive('bsDropdown', ['$window', '$sce', '$dropdown', function($window, $sce, $dropdown) {
        return {
            restrict: 'EAC',
            scope: true,
            compile: function(tElement, tAttrs) {
                if (!tAttrs.bsDropdown) {
                    var nextSibling = tElement[0].nextSibling;
                    while (nextSibling && nextSibling.nodeType !== 1) {
                        nextSibling = nextSibling.nextSibling;
                    }
                    if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {
                        tAttrs.template = nextSibling.outerHTML;
                        tAttrs.templateUrl = undefined;
                        nextSibling.parentNode.removeChild(nextSibling);
                    }
                }
                return function postLink(scope, element, attr) {
                    var options = {
                        scope: scope
                    };
                    angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function(key) {
                        if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];
                    });
                    var falseValueRegExp = /^(false|0|)$/i;
                    angular.forEach(['html', 'container'], function(key) {
                        if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                    });
                    if (attr.bsDropdown) {
                        scope.$watch(attr.bsDropdown, function(newValue, oldValue) {
                            scope.content = newValue;
                        }, true);
                    }
                    var dropdown = $dropdown(element, options);
                    if (attr.bsShow) {
                        scope.$watch(attr.bsShow, function(newValue, oldValue) {
                            if (!dropdown || !angular.isDefined(newValue)) return;
                            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);
                            if (newValue === true) {
                                dropdown.show();
                            } else {
                                dropdown.hide();
                            }
                        });
                    }
                    scope.$on('$destroy', function() {
                        if (dropdown) dropdown.destroy();
                        options = null;
                        dropdown = null;
                    });
                };
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions']).provider('$modal', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            backdropAnimation: 'am-fade',
            customClass: '',
            prefixClass: 'modal',
            prefixEvent: 'modal',
            placement: 'top',
            templateUrl: 'modal/modal.tpl.html',
            template: '',
            contentTemplate: false,
            container: false,
            element: null,
            backdrop: true,
            keyboard: true,
            html: false,
            show: true,
            size: null
        };
        this.$get = ['$window', '$rootScope', '$bsCompiler', '$animate', '$timeout', '$sce', 'dimensions', function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {
            var forEach = angular.forEach;
            var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;
            var bodyElement = angular.element($window.document.body);
            var backdropCount = 0;
            var dialogBaseZindex = 1050;
            var backdropBaseZindex = 1040;
            var validSizes = {
                lg: 'modal-lg',
                sm: 'modal-sm'
            };

            function ModalFactory(config) {
                var $modal = {};
                var options = $modal.$options = angular.extend({}, defaults, config);
                var promise = $modal.$promise = $bsCompiler.compile(options);
                var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();
                if (!options.element && !options.container) {
                    options.container = 'body';
                }
                $modal.$id = options.id || options.element && options.element.attr('id') || '';
                forEach(['title', 'content'], function(key) {
                    if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);
                });
                scope.$hide = function() {
                    scope.$$postDigest(function() {
                        $modal.hide();
                    });
                };
                scope.$show = function() {
                    scope.$$postDigest(function() {
                        $modal.show();
                    });
                };
                scope.$toggle = function() {
                    scope.$$postDigest(function() {
                        $modal.toggle();
                    });
                };
                $modal.$isShown = scope.$isShown = false;
                var compileData;
                var modalElement;
                var modalScope;
                var backdropElement = angular.element('<div class="' + options.prefixClass + '-backdrop"/>');
                backdropElement.css({
                    position: 'fixed',
                    top: '0px',
                    left: '0px',
                    bottom: '0px',
                    right: '0px'
                });
                promise.then(function(data) {
                    compileData = data;
                    $modal.init();
                });
                $modal.init = function() {
                    if (options.show) {
                        scope.$$postDigest(function() {
                            $modal.show();
                        });
                    }
                };
                $modal.destroy = function() {
                    destroyModalElement();
                    if (backdropElement) {
                        backdropElement.remove();
                        backdropElement = null;
                    }
                    scope.$destroy();
                };
                $modal.show = function() {
                    if ($modal.$isShown) return;
                    var parent;
                    var after;
                    if (angular.isElement(options.container)) {
                        parent = options.container;
                        after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;
                    } else {
                        if (options.container) {
                            parent = findElement(options.container);
                            after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;
                        } else {
                            parent = null;
                            after = options.element;
                        }
                    }
                    if (modalElement) destroyModalElement();
                    modalScope = $modal.$scope.$new();
                    modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});
                    if (options.backdrop) {
                        modalElement.css({
                            'z-index': dialogBaseZindex + backdropCount * 20
                        });
                        backdropElement.css({
                            'z-index': backdropBaseZindex + backdropCount * 20
                        });
                        backdropCount++;
                    }
                    if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {
                        return;
                    }
                    modalElement.css({
                        display: 'block'
                    }).addClass(options.placement);
                    if (options.customClass) {
                        modalElement.addClass(options.customClass);
                    }
                    if (options.size && validSizes[options.size]) {
                        angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);
                    }
                    if (options.animation) {
                        if (options.backdrop) {
                            backdropElement.addClass(options.backdropAnimation);
                        }
                        modalElement.addClass(options.animation);
                    }
                    if (options.backdrop) {
                        $animate.enter(backdropElement, bodyElement, null);
                    }
                    if (angular.version.minor <= 2) {
                        $animate.enter(modalElement, parent, after, enterAnimateCallback);
                    } else {
                        $animate.enter(modalElement, parent, after).then(enterAnimateCallback);
                    }
                    $modal.$isShown = scope.$isShown = true;
                    safeDigest(scope);
                    var el = modalElement[0];
                    requestAnimationFrame(function() {
                        el.focus();
                    });
                    bodyElement.addClass(options.prefixClass + '-open');
                    if (options.animation) {
                        bodyElement.addClass(options.prefixClass + '-with-' + options.animation);
                    }
                    bindBackdropEvents();
                    bindKeyboardEvents();
                };

                function enterAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.show', $modal);
                }
                $modal.hide = function() {
                    if (!$modal.$isShown) return;
                    if (options.backdrop) {
                        backdropCount--;
                    }
                    if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {
                        return;
                    }
                    if (angular.version.minor <= 2) {
                        $animate.leave(modalElement, leaveAnimateCallback);
                    } else {
                        $animate.leave(modalElement).then(leaveAnimateCallback);
                    }
                    if (options.backdrop) {
                        $animate.leave(backdropElement);
                    }
                    $modal.$isShown = scope.$isShown = false;
                    safeDigest(scope);
                    unbindBackdropEvents();
                    unbindKeyboardEvents();
                };

                function leaveAnimateCallback() {
                    scope.$emit(options.prefixEvent + '.hide', $modal);
                    bodyElement.removeClass(options.prefixClass + '-open');
                    if (options.animation) {
                        bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);
                    }
                }
                $modal.toggle = function() {
                    if ($modal.$isShown) {
                        $modal.hide();
                    } else {
                        $modal.show();
                    }
                };
                $modal.focus = function() {
                    modalElement[0].focus();
                };
                $modal.$onKeyUp = function(evt) {
                    if (evt.which === 27 && $modal.$isShown) {
                        $modal.hide();
                        evt.stopPropagation();
                    }
                };

                function bindBackdropEvents() {
                    if (options.backdrop) {
                        modalElement.on('click', hideOnBackdropClick);
                        backdropElement.on('click', hideOnBackdropClick);
                        backdropElement.on('wheel', preventEventDefault);
                    }
                }

                function unbindBackdropEvents() {
                    if (options.backdrop) {
                        modalElement.off('click', hideOnBackdropClick);
                        backdropElement.off('click', hideOnBackdropClick);
                        backdropElement.off('wheel', preventEventDefault);
                    }
                }

                function bindKeyboardEvents() {
                    if (options.keyboard) {
                        modalElement.on('keyup', $modal.$onKeyUp);
                    }
                }

                function unbindKeyboardEvents() {
                    if (options.keyboard) {
                        modalElement.off('keyup', $modal.$onKeyUp);
                    }
                }

                function hideOnBackdropClick(evt) {
                    if (evt.target !== evt.currentTarget) return;
                    if (options.backdrop === 'static') {
                        $modal.focus();
                    } else {
                        $modal.hide();
                    }
                }

                function preventEventDefault(evt) {
                    evt.preventDefault();
                }

                function destroyModalElement() {
                    if ($modal.$isShown && modalElement !== null) {
                        unbindBackdropEvents();
                        unbindKeyboardEvents();
                    }
                    if (modalScope) {
                        modalScope.$destroy();
                        modalScope = null;
                    }
                    if (modalElement) {
                        modalElement.remove();
                        modalElement = $modal.$element = null;
                    }
                }
                return $modal;
            }

            function safeDigest(scope) {
                scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
            }

            function findElement(query, element) {
                return angular.element((element || document).querySelectorAll(query));
            }
            return ModalFactory;
        }];
    }).directive('bsModal', ['$window', '$sce', '$modal', function($window, $sce, $modal) {
        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {
                var options = {
                    scope: scope,
                    element: element,
                    show: false
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                if (options.modalClass) {
                    options.customClass = options.modalClass;
                }
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                });
                angular.forEach(['title', 'content'], function(key) {
                    if (attr[key]) {
                        attr.$observe(key, function(newValue, oldValue) {
                            scope[key] = $sce.trustAsHtml(newValue);
                        });
                    }
                });
                if (attr.bsModal) {
                    scope.$watch(attr.bsModal, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend(scope, newValue);
                        } else {
                            scope.content = newValue;
                        }
                    }, true);
                }
                var modal = $modal(options);
                element.on(attr.trigger || 'click', modal.toggle);
                scope.$on('$destroy', function() {
                    if (modal) modal.destroy();
                    options = null;
                    modal = null;
                });
            }
        };
    }]);
    if (angular.version.minor < 3 && angular.version.dot < 14) {
        angular.module('ng').factory('$$rAF', ['$window', '$timeout', function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        }]);
    }
    angular.module('mgcrea.ngStrap.helpers.parseOptions', []).provider('$parseOptions', function() {
        var defaults = this.defaults = {
            regexp: /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/
        };
        this.$get = ['$parse', '$q', function($parse, $q) {
            function ParseOptionsFactory(attr, config) {
                var $parseOptions = {};
                var options = angular.extend({}, defaults, config);
                $parseOptions.$values = [];
                var match;
                var displayFn;
                var valueName;
                var keyName;
                var groupByFn;
                var valueFn;
                var valuesFn;
                $parseOptions.init = function() {
                    $parseOptions.$match = match = attr.match(options.regexp);
                    displayFn = $parse(match[2] || match[1]);
                    valueName = match[4] || match[6];
                    keyName = match[5];
                    groupByFn = $parse(match[3] || '');
                    valueFn = $parse(match[2] ? match[1] : valueName);
                    valuesFn = $parse(match[7]);
                };
                $parseOptions.valuesFn = function(scope, controller) {
                    return $q.when(valuesFn(scope, controller)).then(function(values) {
                        if (!angular.isArray(values)) {
                            values = [];
                        }
                        $parseOptions.$values = values.length ? parseValues(values, scope) : [];
                        return $parseOptions.$values;
                    });
                };
                $parseOptions.displayValue = function(modelValue) {
                    var scope = {};
                    scope[valueName] = modelValue;
                    return displayFn(scope);
                };

                function parseValues(values, scope) {
                    return values.map(function(match, index) {
                        var locals = {};
                        var label;
                        var value;
                        locals[valueName] = match;
                        label = displayFn(scope, locals);
                        value = valueFn(scope, locals);
                        return {
                            label: label,
                            value: value,
                            index: index
                        };
                    });
                }
                $parseOptions.init();
                return $parseOptions;
            }
            return ParseOptionsFactory;
        }];
    });
    angular.module('mgcrea.ngStrap.helpers.dimensions', []).factory('dimensions', function() {
        var fn = {};
        var nodeName = fn.nodeName = function(element, name) {
            return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();
        };
        fn.css = function(element, prop, extra) {
            var value;
            if (element.currentStyle) {
                value = element.currentStyle[prop];
            } else if (window.getComputedStyle) {
                value = window.getComputedStyle(element)[prop];
            } else {
                value = element.style[prop];
            }
            return extra === true ? parseFloat(value) || 0 : value;
        };
        fn.offset = function(element) {
            var boxRect = element.getBoundingClientRect();
            var docElement = element.ownerDocument;
            return {
                width: boxRect.width || element.offsetWidth,
                height: boxRect.height || element.offsetHeight,
                top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),
                left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)
            };
        };
        fn.setOffset = function(element, options, i) {
            var curPosition;
            var curLeft;
            var curCSSTop;
            var curTop;
            var curOffset;
            var curCSSLeft;
            var calculatePosition;
            var position = fn.css(element, 'position');
            var curElem = angular.element(element);
            var props = {};
            if (position === 'static') {
                element.style.position = 'relative';
            }
            curOffset = fn.offset(element);
            curCSSTop = fn.css(element, 'top');
            curCSSLeft = fn.css(element, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = fn.position(element);
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (angular.isFunction(options)) {
                options = options.call(element, i, curOffset);
            }
            if (options.top !== null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left !== null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(curElem, props);
            } else {
                curElem.css({
                    top: props.top + 'px',
                    left: props.left + 'px'
                });
            }
        };
        fn.position = function(element) {
            var offsetParentRect = {
                top: 0,
                left: 0
            };
            var offsetParentEl;
            var offset;
            if (fn.css(element, 'position') === 'fixed') {
                offset = element.getBoundingClientRect();
            } else {
                offsetParentEl = offsetParentElement(element);
                offset = fn.offset(element);
                if (!nodeName(offsetParentEl, 'html')) {
                    offsetParentRect = fn.offset(offsetParentEl);
                }
                offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);
                offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);
            }
            return {
                width: element.offsetWidth,
                height: element.offsetHeight,
                top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),
                left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)
            };
        };

        function offsetParentElement(element) {
            var docElement = element.ownerDocument;
            var offsetParent = element.offsetParent || docElement;
            if (nodeName(offsetParent, '#document')) return docElement.documentElement;
            while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElement.documentElement;
        }
        fn.height = function(element, outer) {
            var value = element.offsetHeight;
            if (outer) {
                value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);
            } else {
                value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);
            }
            return value;
        };
        fn.width = function(element, outer) {
            var value = element.offsetWidth;
            if (outer) {
                value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);
            } else {
                value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);
            }
            return value;
        };
        return fn;
    });
    angular.module('mgcrea.ngStrap.helpers.debounce', []).factory('debounce', ['$timeout', function($timeout) {
        return function(func, wait, immediate) {
            var timeout = null;
            return function() {
                var context = this;
                var args = arguments;
                var callNow = immediate && !timeout;
                if (timeout) {
                    $timeout.cancel(timeout);
                }
                timeout = $timeout(function later() {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                }, wait, false);
                if (callNow) {
                    func.apply(context, args);
                }
                return timeout;
            };
        };
    }]).factory('throttle', ['$timeout', function($timeout) {
        return function(func, wait, options) {
            var timeout = null;
            if (!options) options = {};
            return function() {
                var context = this;
                var args = arguments;
                if (!timeout) {
                    if (options.leading !== false) {
                        func.apply(context, args);
                    }
                    timeout = $timeout(function later() {
                        timeout = null;
                        if (options.trailing !== false) {
                            func.apply(context, args);
                        }
                    }, wait, false);
                }
            };
        };
    }]);
    angular.module('mgcrea.ngStrap.helpers.dateParser', []).provider('$dateParser', ['$localeProvider', function($localeProvider) {
        function ParseDate() {
            this.year = 1970;
            this.month = 0;
            this.day = 1;
            this.hours = 0;
            this.minutes = 0;
            this.seconds = 0;
            this.milliseconds = 0;
        }
        ParseDate.prototype.setMilliseconds = function(value) {
            this.milliseconds = value;
        };
        ParseDate.prototype.setSeconds = function(value) {
            this.seconds = value;
        };
        ParseDate.prototype.setMinutes = function(value) {
            this.minutes = value;
        };
        ParseDate.prototype.setHours = function(value) {
            this.hours = value;
        };
        ParseDate.prototype.getHours = function() {
            return this.hours;
        };
        ParseDate.prototype.setDate = function(value) {
            this.day = value;
        };
        ParseDate.prototype.setMonth = function(value) {
            this.month = value;
        };
        ParseDate.prototype.setFullYear = function(value) {
            this.year = value;
        };
        ParseDate.prototype.fromDate = function(value) {
            this.year = value.getFullYear();
            this.month = value.getMonth();
            this.day = value.getDate();
            this.hours = value.getHours();
            this.minutes = value.getMinutes();
            this.seconds = value.getSeconds();
            this.milliseconds = value.getMilliseconds();
            return this;
        };
        ParseDate.prototype.toDate = function() {
            return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);
        };
        var proto = ParseDate.prototype;

        function noop() {}

        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }

        function indexOfCaseInsensitive(array, value) {
            var len = array.length;
            var str = value.toString().toLowerCase();
            for (var i = 0; i < len; i++) {
                if (array[i].toLowerCase() === str) {
                    return i;
                }
            }
            return -1;
        }
        var defaults = this.defaults = {
            format: 'shortDate',
            strict: false
        };
        this.$get = ['$locale', 'dateFilter', function($locale, dateFilter) {
            var DateParserFactory = function(config) {
                var options = angular.extend({}, defaults, config);
                var $dateParser = {};
                var regExpMap = {
                    sss: '[0-9]{3}',
                    ss: '[0-5][0-9]',
                    s: options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                    mm: '[0-5][0-9]',
                    m: options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
                    HH: '[01][0-9]|2[0-3]',
                    H: options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',
                    hh: '[0][1-9]|[1][012]',
                    h: options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                    a: 'AM|PM',
                    EEEE: $locale.DATETIME_FORMATS.DAY.join('|'),
                    EEE: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                    dd: '0[1-9]|[12][0-9]|3[01]',
                    d: options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',
                    MMMM: $locale.DATETIME_FORMATS.MONTH.join('|'),
                    MMM: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                    MM: '0[1-9]|1[012]',
                    M: options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
                    yyyy: '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',
                    yy: '[0-9]{2}',
                    y: options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'
                };
                var setFnMap = {
                    sss: proto.setMilliseconds,
                    ss: proto.setSeconds,
                    s: proto.setSeconds,
                    mm: proto.setMinutes,
                    m: proto.setMinutes,
                    HH: proto.setHours,
                    H: proto.setHours,
                    hh: proto.setHours,
                    h: proto.setHours,
                    EEEE: noop,
                    EEE: noop,
                    dd: proto.setDate,
                    d: proto.setDate,
                    a: function(value) {
                        var hours = this.getHours() % 12;
                        return this.setHours(value.match(/pm/i) ? hours + 12 : hours);
                    },
                    MMMM: function(value) {
                        return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value));
                    },
                    MMM: function(value) {
                        return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value));
                    },
                    MM: function(value) {
                        return this.setMonth(1 * value - 1);
                    },
                    M: function(value) {
                        return this.setMonth(1 * value - 1);
                    },
                    yyyy: proto.setFullYear,
                    yy: function(value) {
                        return this.setFullYear(2e3 + 1 * value);
                    },
                    y: function(value) {
                        return 1 * value <= 50 && value.length === 2 ? this.setFullYear(2e3 + 1 * value) : this.setFullYear(1 * value);
                    }
                };
                var regex;
                var setMap;
                $dateParser.init = function() {
                    $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;
                    regex = regExpForFormat($dateParser.$format);
                    setMap = setMapForFormat($dateParser.$format);
                };
                $dateParser.isValid = function(date) {
                    if (angular.isDate(date)) return !isNaN(date.getTime());
                    return regex.test(date);
                };
                $dateParser.parse = function(value, baseDate, format, timezone) {
                    if (format) format = $locale.DATETIME_FORMATS[format] || format;
                    if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);
                    var formatRegex = format ? regExpForFormat(format) : regex;
                    var formatSetMap = format ? setMapForFormat(format) : setMap;
                    var matches = formatRegex.exec(value);
                    if (!matches) return false;
                    var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));
                    for (var i = 0; i < matches.length - 1; i++) {
                        if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);
                    }
                    var newDate = date.toDate();
                    if (parseInt(date.day, 10) !== newDate.getDate()) {
                        return false;
                    }
                    return newDate;
                };
                $dateParser.getDateForAttribute = function(key, value) {
                    var date;
                    if (value === 'today') {
                        var today = new Date();
                        date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, key === 'minDate' ? 0 : -1);
                    } else if (angular.isString(value) && value.match(/^".+"$/)) {
                        date = new Date(value.substr(1, value.length - 2));
                    } else if (isNumeric(value)) {
                        date = new Date(parseInt(value, 10));
                    } else if (angular.isString(value) && value.length === 0) {
                        date = key === 'minDate' ? -Infinity : +Infinity;
                    } else {
                        date = new Date(value);
                    }
                    return date;
                };
                $dateParser.getTimeForAttribute = function(key, value) {
                    var time;
                    if (value === 'now') {
                        time = new Date().setFullYear(1970, 0, 1);
                    } else if (angular.isString(value) && value.match(/^".+"$/)) {
                        time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);
                    } else if (isNumeric(value)) {
                        time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);
                    } else if (angular.isString(value) && value.length === 0) {
                        time = key === 'minTime' ? -Infinity : +Infinity;
                    } else {
                        time = $dateParser.parse(value, new Date(1970, 0, 1, 0));
                    }
                    return time;
                };
                $dateParser.daylightSavingAdjust = function(date) {
                    if (!date) {
                        return null;
                    }
                    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                    return date;
                };
                $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {
                    if (!date) {
                        return null;
                    }
                    if (timezone && timezone === 'UTC') {
                        date = new Date(date.getTime());
                        date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());
                    }
                    return date;
                };

                function regExpForFormat(format) {
                    var re = buildDateAbstractRegex(format);
                    return buildDateParseRegex(re);
                }

                function buildDateAbstractRegex(format) {
                    var escapedFormat = escapeReservedSymbols(format);
                    var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\'');
                    var literalRegex = /('(?:\\'|.)*?')/;
                    var formatParts = escapedLiteralFormat.split(literalRegex);
                    var dateElements = Object.keys(regExpMap);
                    var dateRegexParts = [];
                    angular.forEach(formatParts, function(part) {
                        if (isFormatStringLiteral(part)) {
                            part = trimLiteralEscapeChars(part);
                        } else {
                            for (var i = 0; i < dateElements.length; i++) {
                                part = part.split(dateElements[i]).join('${' + i + '}');
                            }
                        }
                        dateRegexParts.push(part);
                    });
                    return dateRegexParts.join('');
                }

                function escapeReservedSymbols(text) {
                    return text.replace(/\\/g, '[\\\\]').replace(/-/g, '[-]').replace(/\./g, '[.]').replace(/\*/g, '[*]').replace(/\+/g, '[+]').replace(/\?/g, '[?]').replace(/\$/g, '[$]').replace(/\^/g, '[^]').replace(/\//g, '[/]').replace(/\\s/g, '[\\s]');
                }

                function isFormatStringLiteral(text) {
                    return /^'.*'$/.test(text);
                }

                function trimLiteralEscapeChars(text) {
                    return text.replace(/^'(.*)'$/, '$1');
                }

                function buildDateParseRegex(abstractRegex) {
                    var dateElements = Object.keys(regExpMap);
                    var re = abstractRegex;
                    for (var i = 0; i < dateElements.length; i++) {
                        re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');
                    }
                    return new RegExp('^' + re + '$', ['i']);
                }

                function setMapForFormat(format) {
                    var re = buildDateAbstractRegex(format);
                    return buildDateParseValuesMap(re);
                }

                function buildDateParseValuesMap(abstractRegex) {
                    var dateElements = Object.keys(regExpMap);
                    var valuesRegex = new RegExp('\\${(\\d+)}', 'g');
                    var valuesMatch;
                    var keyIndex;
                    var valueKey;
                    var valueFunction;
                    var valuesFunctionMap = [];
                    while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {
                        keyIndex = valuesMatch[1];
                        valueKey = dateElements[keyIndex];
                        valueFunction = setFnMap[valueKey];
                        valuesFunctionMap.push(valueFunction);
                    }
                    return valuesFunctionMap;
                }
                $dateParser.init();
                return $dateParser;
            };
            return DateParserFactory;
        }];
    }]);
    angular.module('mgcrea.ngStrap.helpers.dateFormatter', []).service('$dateFormatter', ['$locale', 'dateFilter', function($locale, dateFilter) {
        this.getDefaultLocale = function() {
            return $locale.id;
        };
        this.getDatetimeFormat = function(format, lang) {
            return $locale.DATETIME_FORMATS[format] || format;
        };
        this.weekdaysShort = function(lang) {
            return $locale.DATETIME_FORMATS.SHORTDAY;
        };

        function splitTimeFormat(format) {
            return /(h+)([:\.])?(m+)([:\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);
        }
        this.hoursFormat = function(timeFormat) {
            return splitTimeFormat(timeFormat)[0];
        };
        this.minutesFormat = function(timeFormat) {
            return splitTimeFormat(timeFormat)[2];
        };
        this.secondsFormat = function(timeFormat) {
            return splitTimeFormat(timeFormat)[4];
        };
        this.timeSeparator = function(timeFormat) {
            return splitTimeFormat(timeFormat)[1];
        };
        this.showSeconds = function(timeFormat) {
            return !!splitTimeFormat(timeFormat)[4];
        };
        this.showAM = function(timeFormat) {
            return !!splitTimeFormat(timeFormat)[5];
        };
        this.formatDate = function(date, format, lang, timezone) {
            return dateFilter(date, format, timezone);
        };
    }]);
    angular.module('mgcrea.ngStrap.core', []).service('$bsCompiler', bsCompilerService);

    function bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
        this.compile = function(options) {
            if (options.template && /\.html$/.test(options.template)) {
                console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');
                options.templateUrl = options.template;
                options.template = '';
            }
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = angular.copy(options.resolve || {});
            var locals = angular.copy(options.locals || {});
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
                if (angular.isString(value)) {
                    resolve[key] = $injector.get(value);
                } else {
                    resolve[key] = $injector.invoke(value);
                }
            });
            angular.extend(resolve, locals);
            if (template) {
                resolve.$template = $q.when(template);
            } else if (templateUrl) {
                resolve.$template = fetchTemplate(templateUrl);
            } else {
                throw new Error('Missing `template` / `templateUrl` option.');
            }
            if (options.titleTemplate) {
                resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)]).then(function(templates) {
                    var templateEl = angular.element(templates[0]);
                    findElement('[ng-bind="title"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);
                    return templateEl[0].outerHTML;
                });
            }
            if (options.contentTemplate) {
                resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)]).then(function(templates) {
                    var templateEl = angular.element(templates[0]);
                    var contentEl = findElement('[ng-bind="content"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);
                    if (!options.templateUrl) contentEl.next().remove();
                    return templateEl[0].outerHTML;
                });
            }
            return $q.all(resolve).then(function(locals) {
                var template = transformTemplate(locals.$template);
                if (options.html) {
                    template = template.replace(/ng-bind="/gi, 'ng-bind-html="');
                }
                var element = angular.element('<div>').html(template.trim()).contents();
                var linkFn = $compile(element);
                return {
                    locals: locals,
                    element: element,
                    link: function link(scope) {
                        locals.$scope = scope;
                        if (controller) {
                            var invokeCtrl = $controller(controller, locals, true);
                            if (bindToController) {
                                angular.extend(invokeCtrl.instance, locals);
                            }
                            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();
                            element.data('$ngControllerController', ctrl);
                            element.children().data('$ngControllerController', ctrl);
                            if (controllerAs) {
                                scope[controllerAs] = ctrl;
                            }
                        }
                        return linkFn.apply(null, arguments);
                    }
                };
            });
        };

        function findElement(query, element) {
            return angular.element((element || document).querySelectorAll(query));
        }
        var fetchPromises = {};

        function fetchTemplate(template) {
            if (fetchPromises[template]) return fetchPromises[template];
            return fetchPromises[template] = $http.get(template, {
                cache: $templateCache
            }).then(function(res) {
                return res.data;
            });
        }
    }
    angular.module('mgcrea.ngStrap.datepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip']).provider('$datepicker', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'datepicker',
            placement: 'bottom-right',
            templateUrl: 'datepicker/datepicker.tpl.html',
            trigger: 'focus',
            container: false,
            keyboard: true,
            html: false,
            delay: 0,
            useNative: false,
            dateType: 'date',
            dateFormat: 'shortDate',
            timezone: null,
            modelDateFormat: null,
            dayFormat: 'dd',
            monthFormat: 'MMM',
            yearFormat: 'yyyy',
            monthTitleFormat: 'MMMM yyyy',
            yearTitleFormat: 'yyyy',
            strictFormat: false,
            autoclose: false,
            minDate: -Infinity,
            maxDate: +Infinity,
            startView: 0,
            minView: 0,
            startWeek: 0,
            daysOfWeekDisabled: '',
            iconLeft: 'arrow fa fa-angle-left date',
            iconRight: 'arrow fa fa-angle-right date'
        };
        this.$get = ['$window', '$document', '$rootScope', '$sce', '$dateFormatter', 'datepickerViews', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {
            var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
            var isTouch = 'createTouch' in $window.document && isNative;
            if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();

            function DatepickerFactory(element, controller, config) {
                var $datepicker = $tooltip(element, angular.extend({}, defaults, config));
                var parentScope = config.scope;
                var options = $datepicker.$options;
                var scope = $datepicker.$scope;
                if (options.startView) options.startView -= options.minView;
                var pickerViews = datepickerViews($datepicker);
                $datepicker.$views = pickerViews.views;
                var viewDate = pickerViews.viewDate;
                scope.$mode = options.startView;
                scope.$iconLeft = options.iconLeft;
                scope.$iconRight = options.iconRight;
                var $picker = $datepicker.$views[scope.$mode];
                scope.$select = function(date) {
                    $datepicker.select(date);
                };
                scope.$selectPane = function(value) {
                    $datepicker.$selectPane(value);
                };
                scope.$toggleMode = function() {
                    $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);
                };
                $datepicker.update = function(date) {
                    if (angular.isDate(date) && !isNaN(date.getTime())) {
                        $datepicker.$date = date;
                        $picker.update.call($picker, date);
                    }
                    $datepicker.$build(true);
                };
                $datepicker.updateDisabledDates = function(dateRanges) {
                    options.disabledDateRanges = dateRanges;
                    for (var i = 0, l = scope.rows.length; i < l; i++) {
                        angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);
                    }
                };
                $datepicker.select = function(date, keep) {
                    if (!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);
                    if (!scope.$mode || keep) {
                        controller.$setViewValue(angular.copy(date));
                        controller.$render();
                        if (options.autoclose && !keep) {
                            $timeout(function() {
                                $datepicker.hide(true);
                            });
                        }
                    } else {
                        angular.extend(viewDate, {
                            year: date.getFullYear(),
                            month: date.getMonth(),
                            date: date.getDate()
                        });
                        $datepicker.setMode(scope.$mode - 1);
                        $datepicker.$build();
                    }
                };
                $datepicker.setMode = function(mode) {
                    scope.$mode = mode;
                    $picker = $datepicker.$views[scope.$mode];
                    $datepicker.$build();
                };
                $datepicker.$build = function(pristine) {
                    if (pristine === true && $picker.built) return;
                    if (pristine === false && !$picker.built) return;
                    $picker.build.call($picker);
                };
                $datepicker.$updateSelected = function() {
                    for (var i = 0, l = scope.rows.length; i < l; i++) {
                        angular.forEach(scope.rows[i], updateSelected);
                    }
                };
                $datepicker.$isSelected = function(date) {
                    return $picker.isSelected(date);
                };
                $datepicker.$setDisabledEl = function(el) {
                    el.disabled = $picker.isDisabled(el.date);
                };
                $datepicker.$selectPane = function(value) {
                    var steps = $picker.steps;
                    var targetDate = new Date(Date.UTC(viewDate.year + (steps.year || 0) * value, viewDate.month + (steps.month || 0) * value, 1));
                    angular.extend(viewDate, {
                        year: targetDate.getUTCFullYear(),
                        month: targetDate.getUTCMonth(),
                        date: targetDate.getUTCDate()
                    });
                    $datepicker.$build();
                };
                $datepicker.$onMouseDown = function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (isTouch) {
                        var targetEl = angular.element(evt.target);
                        if (targetEl[0].nodeName.toLowerCase() !== 'button') {
                            targetEl = targetEl.parent();
                        }
                        targetEl.triggerHandler('click');
                    }
                };
                $datepicker.$onKeyDown = function(evt) {
                    if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (evt.keyCode === 13) {
                        if (!scope.$mode) {
                            $datepicker.hide(true);
                        } else {
                            scope.$apply(function() {
                                $datepicker.setMode(scope.$mode - 1);
                            });
                        }
                        return;
                    }
                    $picker.onKeyDown(evt);
                    parentScope.$digest();
                };

                function updateSelected(el) {
                    el.selected = $datepicker.$isSelected(el.date);
                }

                function focusElement() {
                    element[0].focus();
                }
                var _init = $datepicker.init;
                $datepicker.init = function() {
                    if (isNative && options.useNative) {
                        element.prop('type', 'date');
                        element.css('-webkit-appearance', 'textfield');
                        return;
                    } else if (isTouch) {
                        element.prop('type', 'text');
                        element.attr('readonly', 'true');
                        element.on('click', focusElement);
                    }
                    _init();
                };
                var _destroy = $datepicker.destroy;
                $datepicker.destroy = function() {
                    if (isNative && options.useNative) {
                        element.off('click', focusElement);
                    }
                    _destroy();
                };
                var _show = $datepicker.show;
                $datepicker.show = function() {
                    if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;
                    _show();
                    $timeout(function() {
                        if (!$datepicker.$isShown) return;
                        $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
                        if (options.keyboard) {
                            element.on('keydown', $datepicker.$onKeyDown);
                        }
                    }, 0, false);
                };
                var _hide = $datepicker.hide;
                $datepicker.hide = function(blur) {
                    if (!$datepicker.$isShown) return;
                    $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
                    if (options.keyboard) {
                        element.off('keydown', $datepicker.$onKeyDown);
                    }
                    _hide(blur);
                };
                return $datepicker;
            }
            DatepickerFactory.defaults = defaults;
            return DatepickerFactory;
        }];
    }).directive('bsDatepicker', ['$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$datepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {
        var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
        return {
            restrict: 'EAC',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                var options = {
                    scope: scope
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['html', 'container', 'autoclose', 'useNative'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
                        options[key] = false;
                    }
                });
                var datepicker = $datepicker(element, controller, options);
                options = datepicker.$options;
                if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';
                var lang = options.lang;
                var formatDate = function(date, format) {
                    return $dateFormatter.formatDate(date, format, lang);
                };
                var dateParser = $dateParser({
                    format: options.dateFormat,
                    lang: lang,
                    strict: options.strictFormat
                });
                if (attr.bsShow) {
                    scope.$watch(attr.bsShow, function(newValue, oldValue) {
                        if (!datepicker || !angular.isDefined(newValue)) return;
                        if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);
                        if (newValue === true) {
                            datepicker.show();
                        } else {
                            datepicker.hide();
                        }
                    });
                }
                angular.forEach(['minDate', 'maxDate'], function(key) {
                    if (angular.isDefined(attr[key])) {
                        attr.$observe(key, function(newValue) {
                            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);
                            if (!isNaN(datepicker.$options[key])) datepicker.$build(false);
                            validateAgainstMinMaxDate(controller.$dateValue);
                        });
                    }
                });
                if (angular.isDefined(attr.dateFormat)) {
                    attr.$observe('dateFormat', function(newValue) {
                        datepicker.$options.dateFormat = newValue;
                    });
                }
                scope.$watch(attr.ngModel, function(newValue, oldValue) {
                    datepicker.update(controller.$dateValue);
                }, true);

                function normalizeDateRanges(ranges) {
                    if (!ranges || !ranges.length) return null;
                    return ranges;
                }
                if (angular.isDefined(attr.disabledDates)) {
                    scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {
                        disabledRanges = normalizeDateRanges(disabledRanges);
                        previousValue = normalizeDateRanges(previousValue);
                        if (disabledRanges) {
                            datepicker.updateDisabledDates(disabledRanges);
                        }
                    });
                }

                function validateAgainstMinMaxDate(parsedDate) {
                    if (!angular.isDate(parsedDate)) return;
                    var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;
                    var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;
                    var isValid = isMinValid && isMaxValid;
                    controller.$setValidity('date', isValid);
                    controller.$setValidity('min', isMinValid);
                    controller.$setValidity('max', isMaxValid);
                    if (isValid) controller.$dateValue = parsedDate;
                }
                controller.$parsers.unshift(function(viewValue) {
                    var date;
                    if (!viewValue) {
                        controller.$setValidity('date', true);
                        return null;
                    }
                    var parsedDate = dateParser.parse(viewValue, controller.$dateValue);
                    if (!parsedDate || isNaN(parsedDate.getTime())) {
                        controller.$setValidity('date', false);
                        return;
                    }
                    validateAgainstMinMaxDate(parsedDate);
                    if (options.dateType === 'string') {
                        date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);
                        return formatDate(date, options.modelDateFormat || options.dateFormat);
                    }
                    date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);
                    if (options.dateType === 'number') {
                        return date.getTime();
                    } else if (options.dateType === 'unix') {
                        return date.getTime() / 1e3;
                    } else if (options.dateType === 'iso') {
                        return date.toISOString();
                    }
                    return new Date(date);
                });
                controller.$formatters.push(function(modelValue) {
                    var date;
                    if (angular.isUndefined(modelValue) || modelValue === null) {
                        date = NaN;
                    } else if (angular.isDate(modelValue)) {
                        date = modelValue;
                    } else if (options.dateType === 'string') {
                        date = dateParser.parse(modelValue, null, options.modelDateFormat);
                    } else if (options.dateType === 'unix') {
                        date = new Date(modelValue * 1e3);
                    } else {
                        date = new Date(modelValue);
                    }
                    controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);
                    return getDateFormattedString();
                });
                controller.$render = function() {
                    element.val(getDateFormattedString());
                };

                function getDateFormattedString() {
                    return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);
                }
                scope.$on('$destroy', function() {
                    if (datepicker) datepicker.destroy();
                    options = null;
                    datepicker = null;
                });
            }
        };
    }]).provider('datepickerViews', function() {
        function split(arr, size) {
            var arrays = [];
            while (arr.length > 0) {
                arrays.push(arr.splice(0, size));
            }
            return arrays;
        }

        function mod(n, m) {
            return (n % m + m) % m;
        }
        this.$get = ['$dateFormatter', '$dateParser', '$sce', function($dateFormatter, $dateParser, $sce) {
            return function(picker) {
                var scope = picker.$scope;
                var options = picker.$options;
                var lang = options.lang;
                var formatDate = function(date, format) {
                    return $dateFormatter.formatDate(date, format, lang);
                };
                var dateParser = $dateParser({
                    format: options.dateFormat,
                    lang: lang,
                    strict: options.strictFormat
                });
                var weekDaysMin = $dateFormatter.weekdaysShort(lang);
                var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));
                var weekDaysLabelsHtml = $sce.trustAsHtml('<th class="dow text-center">' + weekDaysLabels.join('</th><th class="dow text-center">') + '</th>');
                var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());
                var viewDate = {
                    year: startDate.getFullYear(),
                    month: startDate.getMonth(),
                    date: startDate.getDate()
                };
                var views = [{
                    format: options.dayFormat,
                    split: 7,
                    steps: {
                        month: 1
                    },
                    update: function(date, force) {
                        if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {
                            viewDate.date = picker.$date.getDate();
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);
                        var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();
                        var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);
                        var firstDateOffset = firstDate.getTimezoneOffset();
                        var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();
                        if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 6e4);
                        var days = [];
                        var day;
                        for (var i = 0; i < 42; i++) {
                            day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));
                            days.push({
                                date: day,
                                isToday: day.toDateString() === today,
                                label: formatDate(day, this.format),
                                selected: picker.$date && this.isSelected(day),
                                muted: day.getMonth() !== viewDate.month,
                                disabled: this.isDisabled(day)
                            });
                        }
                        scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);
                        scope.showLabels = true;
                        scope.labels = weekDaysLabelsHtml;
                        scope.rows = split(days, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();
                    },
                    isDisabled: function(date) {
                        var time = date.getTime();
                        if (time < options.minDate || time > options.maxDate) return true;
                        if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;
                        if (options.disabledDateRanges) {
                            for (var i = 0; i < options.disabledDateRanges.length; i++) {
                                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                    onKeyDown: function(evt) {
                        if (!picker.$date) {
                            return;
                        }
                        var actualTime = picker.$date.getTime();
                        var newDate;
                        if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);
                        else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);
                        else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);
                        else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);
                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }, {
                    name: 'month',
                    format: options.monthFormat,
                    split: 4,
                    steps: {
                        year: 1
                    },
                    update: function(date, force) {
                        if (!this.built || date.getFullYear() !== viewDate.year) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getMonth() !== viewDate.month) {
                            angular.extend(viewDate, {
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var months = [];
                        var month;
                        for (var i = 0; i < 12; i++) {
                            month = new Date(viewDate.year, i, 1);
                            months.push({
                                date: month,
                                label: formatDate(month, this.format),
                                selected: picker.$isSelected(month),
                                disabled: this.isDisabled(month)
                            });
                        }
                        scope.title = formatDate(month, options.yearTitleFormat);
                        scope.showLabels = false;
                        scope.rows = split(months, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();
                    },
                    isDisabled: function(date) {
                        var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);
                        return lastDate < options.minDate || date.getTime() > options.maxDate;
                    },
                    onKeyDown: function(evt) {
                        if (!picker.$date) {
                            return;
                        }
                        var actualMonth = picker.$date.getMonth();
                        var newDate = new Date(picker.$date);
                        if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1);
                        else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4);
                        else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1);
                        else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);
                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }, {
                    name: 'year',
                    format: options.yearFormat,
                    split: 4,
                    steps: {
                        year: 12
                    },
                    update: function(date, force) {
                        if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$build();
                        } else if (date.getFullYear() !== viewDate.year) {
                            angular.extend(viewDate, {
                                year: picker.$date.getFullYear(),
                                month: picker.$date.getMonth(),
                                date: picker.$date.getDate()
                            });
                            picker.$updateSelected();
                        }
                    },
                    build: function() {
                        var firstYear = viewDate.year - viewDate.year % (this.split * 3);
                        var years = [];
                        var year;
                        for (var i = 0; i < 12; i++) {
                            year = new Date(firstYear + i, 0, 1);
                            years.push({
                                date: year,
                                label: formatDate(year, this.format),
                                selected: picker.$isSelected(year),
                                disabled: this.isDisabled(year)
                            });
                        }
                        scope.title = years[0].label + '-' + years[years.length - 1].label;
                        scope.showLabels = false;
                        scope.rows = split(years, this.split);
                        this.built = true;
                    },
                    isSelected: function(date) {
                        return picker.$date && date.getFullYear() === picker.$date.getFullYear();
                    },
                    isDisabled: function(date) {
                        var lastDate = +new Date(date.getFullYear() + 1, 0, 0);
                        return lastDate < options.minDate || date.getTime() > options.maxDate;
                    },
                    onKeyDown: function(evt) {
                        if (!picker.$date) {
                            return;
                        }
                        var actualYear = picker.$date.getFullYear();
                        var newDate = new Date(picker.$date);
                        if (evt.keyCode === 37) newDate.setYear(actualYear - 1);
                        else if (evt.keyCode === 38) newDate.setYear(actualYear - 4);
                        else if (evt.keyCode === 39) newDate.setYear(actualYear + 1);
                        else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);
                        if (!this.isDisabled(newDate)) picker.select(newDate, true);
                    }
                }];
                return {
                    views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,
                    viewDate: viewDate
                };
            };
        }];
    });
    angular.module('mgcrea.ngStrap.collapse', []).provider('$collapse', function() {
        var defaults = this.defaults = {
            animation: 'am-collapse',
            disallowToggle: false,
            activeClass: 'in',
            startCollapsed: false,
            allowMultiple: false
        };
        var controller = this.controller = function($scope, $element, $attrs) {
            var self = this;
            self.$options = angular.copy(defaults);
            angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function(key) {
                if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
            });
            var falseValueRegExp = /^(false|0|)$/i;
            angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function(key) {
                if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {
                    self.$options[key] = false;
                }
            });
            self.$toggles = [];
            self.$targets = [];
            self.$viewChangeListeners = [];
            self.$registerToggle = function(element) {
                self.$toggles.push(element);
            };
            self.$registerTarget = function(element) {
                self.$targets.push(element);
            };
            self.$unregisterToggle = function(element) {
                var index = self.$toggles.indexOf(element);
                self.$toggles.splice(index, 1);
            };
            self.$unregisterTarget = function(element) {
                var index = self.$targets.indexOf(element);
                self.$targets.splice(index, 1);
                if (self.$options.allowMultiple) {
                    deactivateItem(element);
                }
                fixActiveItemIndexes(index);
                self.$viewChangeListeners.forEach(function(fn) {
                    fn();
                });
            };
            self.$targets.$active = !self.$options.startCollapsed ? [0] : [];
            self.$setActive = $scope.$setActive = function(value) {
                if (angular.isArray(value)) {
                    self.$targets.$active = value;
                } else if (!self.$options.disallowToggle && isActive(value)) {
                    deactivateItem(value);
                } else {
                    activateItem(value);
                }
                self.$viewChangeListeners.forEach(function(fn) {
                    fn();
                });
            };
            self.$activeIndexes = function() {
                if (self.$options.allowMultiple) {
                    return self.$targets.$active;
                }
                return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;
            };

            function fixActiveItemIndexes(index) {
                var activeIndexes = self.$targets.$active;
                for (var i = 0; i < activeIndexes.length; i++) {
                    if (index < activeIndexes[i]) {
                        activeIndexes[i] = activeIndexes[i] - 1;
                    }
                    if (activeIndexes[i] === self.$targets.length) {
                        activeIndexes[i] = self.$targets.length - 1;
                    }
                }
            }

            function isActive(value) {
                var activeItems = self.$targets.$active;
                return activeItems.indexOf(value) !== -1;
            }

            function deactivateItem(value) {
                var index = self.$targets.$active.indexOf(value);
                if (index !== -1) {
                    self.$targets.$active.splice(index, 1);
                }
            }

            function activateItem(value) {
                if (!self.$options.allowMultiple) {
                    self.$targets.$active.splice(0, 1);
                }
                if (self.$targets.$active.indexOf(value) === -1) {
                    self.$targets.$active.push(value);
                }
            }
        };
        this.$get = function() {
            var $collapse = {};
            $collapse.defaults = defaults;
            $collapse.controller = controller;
            return $collapse;
        };
    }).directive('bsCollapse', ['$window', '$animate', '$collapse', function($window, $animate, $collapse) {
        return {
            require: ['?ngModel', 'bsCollapse'],
            controller: ['$scope', '$element', '$attrs', $collapse.controller],
            link: function postLink(scope, element, attrs, controllers) {
                var ngModelCtrl = controllers[0];
                var bsCollapseCtrl = controllers[1];
                if (ngModelCtrl) {
                    bsCollapseCtrl.$viewChangeListeners.push(function() {
                        ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());
                    });
                    ngModelCtrl.$formatters.push(function(modelValue) {
                        if (angular.isArray(modelValue)) {
                            bsCollapseCtrl.$setActive(modelValue);
                        } else {
                            var activeIndexes = bsCollapseCtrl.$activeIndexes();
                            if (angular.isArray(activeIndexes)) {
                                if (activeIndexes.indexOf(modelValue * 1) === -1) {
                                    bsCollapseCtrl.$setActive(modelValue * 1);
                                }
                            } else if (activeIndexes !== modelValue * 1) {
                                bsCollapseCtrl.$setActive(modelValue * 1);
                            }
                        }
                        return modelValue;
                    });
                }
            }
        };
    }]).directive('bsCollapseToggle', function() {
        return {
            require: ['^?ngModel', '^bsCollapse'],
            link: function postLink(scope, element, attrs, controllers) {
                var bsCollapseCtrl = controllers[1];
                element.attr('data-toggle', 'collapse');
                bsCollapseCtrl.$registerToggle(element);
                scope.$on('$destroy', function() {
                    bsCollapseCtrl.$unregisterToggle(element);
                });
                element.on('click', function() {
                    if (!attrs.disabled) {
                        var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);
                        bsCollapseCtrl.$setActive(index * 1);
                        scope.$apply();
                    }
                });
            }
        };
    }).directive('bsCollapseTarget', ['$animate', function($animate) {
        return {
            require: ['^?ngModel', '^bsCollapse'],
            link: function postLink(scope, element, attrs, controllers) {
                var bsCollapseCtrl = controllers[1];
                element.addClass('collapse');
                if (bsCollapseCtrl.$options.animation) {
                    element.addClass(bsCollapseCtrl.$options.animation);
                }
                bsCollapseCtrl.$registerTarget(element);
                scope.$on('$destroy', function() {
                    bsCollapseCtrl.$unregisterTarget(element);
                });

                function render() {
                    var index = bsCollapseCtrl.$targets.indexOf(element);
                    var active = bsCollapseCtrl.$activeIndexes();
                    var action = 'removeClass';
                    if (angular.isArray(active)) {
                        if (active.indexOf(index) !== -1) {
                            action = 'addClass';
                        }
                    } else if (index === active) {
                        action = 'addClass';
                    }
                    $animate[action](element, bsCollapseCtrl.$options.activeClass);
                }
                bsCollapseCtrl.$viewChangeListeners.push(function() {
                    render();
                });
                render();
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.button', []).provider('$button', function() {
        var defaults = this.defaults = {
            activeClass: 'active',
            toggleEvent: 'click'
        };
        this.$get = function() {
            return {
                defaults: defaults
            };
        };
    }).directive('bsCheckboxGroup', function() {
        return {
            restrict: 'A',
            require: 'ngModel',
            compile: function postLink(element, attr) {
                element.attr('data-toggle', 'buttons');
                element.removeAttr('ng-model');
                var children = element[0].querySelectorAll('input[type="checkbox"]');
                angular.forEach(children, function(child) {
                    var childEl = angular.element(child);
                    childEl.attr('bs-checkbox', '');
                    childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));
                });
            }
        };
    }).directive('bsCheckbox', ['$button', '$$rAF', function($button, $$rAF) {
        var defaults = $button.defaults;
        var constantValueRegExp = /^(true|false|\d+)$/;
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                var options = defaults;
                var isInput = element[0].nodeName === 'INPUT';
                var activeElement = isInput ? element.parent() : element;
                var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;
                if (constantValueRegExp.test(attr.trueValue)) {
                    trueValue = scope.$eval(attr.trueValue);
                }
                var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;
                if (constantValueRegExp.test(attr.falseValue)) {
                    falseValue = scope.$eval(attr.falseValue);
                }
                var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';
                if (hasExoticValues) {
                    controller.$parsers.push(function(viewValue) {
                        return viewValue ? trueValue : falseValue;
                    });
                    controller.$formatters.push(function(modelValue) {
                        return angular.equals(modelValue, trueValue);
                    });
                    scope.$watch(attr.ngModel, function(newValue, oldValue) {
                        controller.$render();
                    });
                }
                controller.$render = function() {
                    var isActive = angular.equals(controller.$modelValue, trueValue);
                    $$rAF(function() {
                        if (isInput) element[0].checked = isActive;
                        activeElement.toggleClass(options.activeClass, isActive);
                    });
                };
                element.bind(options.toggleEvent, function() {
                    scope.$apply(function() {
                        if (!isInput) {
                            controller.$setViewValue(!activeElement.hasClass('active'));
                        }
                        if (!hasExoticValues) {
                            controller.$render();
                        }
                    });
                });
            }
        };
    }]).directive('bsRadioGroup', function() {
        return {
            restrict: 'A',
            require: 'ngModel',
            compile: function postLink(element, attr) {
                element.attr('data-toggle', 'buttons');
                element.removeAttr('ng-model');
                var children = element[0].querySelectorAll('input[type="radio"]');
                angular.forEach(children, function(child) {
                    angular.element(child).attr('bs-radio', '');
                    angular.element(child).attr('ng-model', attr.ngModel);
                });
            }
        };
    }).directive('bsRadio', ['$button', '$$rAF', function($button, $$rAF) {
        var defaults = $button.defaults;
        var constantValueRegExp = /^(true|false|\d+)$/;
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function postLink(scope, element, attr, controller) {
                var options = defaults;
                var isInput = element[0].nodeName === 'INPUT';
                var activeElement = isInput ? element.parent() : element;
                var value;
                attr.$observe('value', function(v) {
                    if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {
                        value = scope.$eval(v);
                    } else {
                        value = v;
                    }
                    controller.$render();
                });
                controller.$render = function() {
                    var isActive = angular.equals(controller.$modelValue, value);
                    $$rAF(function() {
                        if (isInput) element[0].checked = isActive;
                        activeElement.toggleClass(options.activeClass, isActive);
                    });
                };
                element.bind(options.toggleEvent, function() {
                    scope.$apply(function() {
                        controller.$setViewValue(value);
                        controller.$render();
                    });
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal']).provider('$alert', function() {
        var defaults = this.defaults = {
            animation: 'am-fade',
            prefixClass: 'alert',
            prefixEvent: 'alert',
            placement: null,
            templateUrl: 'alert/alert.tpl.html',
            container: false,
            element: null,
            backdrop: false,
            keyboard: true,
            show: true,
            duration: false,
            type: false,
            dismissable: true
        };
        this.$get = ['$modal', '$timeout', function($modal, $timeout) {
            function AlertFactory(config) {
                var $alert = {};
                var options = angular.extend({}, defaults, config);
                $alert = $modal(options);
                $alert.$scope.dismissable = !!options.dismissable;
                if (options.type) {
                    $alert.$scope.type = options.type;
                }
                var show = $alert.show;
                if (options.duration) {
                    $alert.show = function() {
                        show();
                        $timeout(function() {
                            $alert.hide();
                        }, options.duration * 1e3);
                    };
                }
                return $alert;
            }
            return AlertFactory;
        }];
    }).directive('bsAlert', ['$window', '$sce', '$alert', function($window, $sce, $alert) {
        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {
                var options = {
                    scope: scope,
                    element: element,
                    show: false
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                });
                if (!scope.hasOwnProperty('title')) {
                    scope.title = '';
                }
                angular.forEach(['title', 'content', 'type'], function(key) {
                    if (attr[key]) {
                        attr.$observe(key, function(newValue, oldValue) {
                            scope[key] = $sce.trustAsHtml(newValue);
                        });
                    }
                });
                if (attr.bsAlert) {
                    scope.$watch(attr.bsAlert, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend(scope, newValue);
                        } else {
                            scope.content = newValue;
                        }
                    }, true);
                }
                var alert = $alert(options);
                element.on(attr.trigger || 'click', alert.toggle);
                scope.$on('$destroy', function() {
                    if (alert) alert.destroy();
                    options = null;
                    alert = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal']).provider('$aside', function() {
        var defaults = this.defaults = {
            animation: 'am-fade-and-slide-right',
            prefixClass: 'aside',
            prefixEvent: 'aside',
            placement: 'right',
            templateUrl: 'aside/aside.tpl.html',
            contentTemplate: false,
            container: false,
            element: null,
            backdrop: true,
            keyboard: true,
            html: false,
            show: true
        };
        this.$get = ['$modal', function($modal) {
            function AsideFactory(config) {
                var $aside = {};
                var options = angular.extend({}, defaults, config);
                $aside = $modal(options);
                return $aside;
            }
            return AsideFactory;
        }];
    }).directive('bsAside', ['$window', '$sce', '$aside', function($window, $sce, $aside) {
        return {
            restrict: 'EAC',
            scope: true,
            link: function postLink(scope, element, attr, transclusion) {
                var options = {
                    scope: scope,
                    element: element,
                    show: false
                };
                angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {
                    if (angular.isDefined(attr[key])) options[key] = attr[key];
                });
                var falseValueRegExp = /^(false|0|)$/i;
                angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {
                    if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
                });
                angular.forEach(['title', 'content'], function(key) {
                    if (attr[key]) {
                        attr.$observe(key, function(newValue, oldValue) {
                            scope[key] = $sce.trustAsHtml(newValue);
                        });
                    }
                });
                if (attr.bsAside) {
                    scope.$watch(attr.bsAside, function(newValue, oldValue) {
                        if (angular.isObject(newValue)) {
                            angular.extend(scope, newValue);
                        } else {
                            scope.content = newValue;
                        }
                    }, true);
                }
                var aside = $aside(options);
                element.on(attr.trigger || 'click', aside.toggle);
                scope.$on('$destroy', function() {
                    if (aside) aside.destroy();
                    options = null;
                    aside = null;
                });
            }
        };
    }]);
    angular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce']).provider('$affix', function() {
        var defaults = this.defaults = {
            offsetTop: 'auto',
            inlineStyles: true
        };
        this.$get = ['$window', 'debounce', 'dimensions', function($window, debounce, dimensions) {
            var bodyEl = angular.element($window.document.body);
            var windowEl = angular.element($window);

            function AffixFactory(element, config) {
                var $affix = {};
                var options = angular.extend({}, defaults, config);
                var targetEl = options.target;
                var reset = 'affix affix-top affix-bottom';
                var setWidth = false;
                var initialAffixTop = 0;
                var initialOffsetTop = 0;
                var offsetTop = 0;
                var offsetBottom = 0;
                var affixed = null;
                var unpin = null;
                var parent = element.parent();
                if (options.offsetParent) {
                    if (options.offsetParent.match(/^\d+$/)) {
                        for (var i = 0; i < options.offsetParent * 1 - 1; i++) {
                            parent = parent.parent();
                        }
                    } else {
                        parent = angular.element(options.offsetParent);
                    }
                }
                $affix.init = function() {
                    this.$parseOffsets();
                    initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;
                    setWidth = !element[0].style.width;
                    targetEl.on('scroll', this.checkPosition);
                    targetEl.on('click', this.checkPositionWithEventLoop);
                    windowEl.on('resize', this.$debouncedOnResize);
                    this.checkPosition();
                    this.checkPositionWithEventLoop();
                };
                $affix.destroy = function() {
                    targetEl.off('scroll', this.checkPosition);
                    targetEl.off('click', this.checkPositionWithEventLoop);
                    windowEl.off('resize', this.$debouncedOnResize);
                };
                $affix.checkPositionWithEventLoop = function() {
                    setTimeout($affix.checkPosition, 1);
                };
                $affix.checkPosition = function() {
                    var scrollTop = getScrollTop();
                    var position = dimensions.offset(element[0]);
                    var elementHeight = dimensions.height(element[0]);
                    var affix = getRequiredAffixClass(unpin, position, elementHeight);
                    if (affixed === affix) return;
                    affixed = affix;
                    if (affix === 'top') {
                        unpin = null;
                        if (setWidth) {
                            element.css('width', '');
                        }
                        if (options.inlineStyles) {
                            element.css('position', options.offsetParent ? '' : 'relative');
                            element.css('top', '');
                        }
                    } else if (affix === 'bottom') {
                        if (options.offsetUnpin) {
                            unpin = -(options.offsetUnpin * 1);
                        } else {
                            unpin = position.top - scrollTop;
                        }
                        if (setWidth) {
                            element.css('width', '');
                        }
                        if (options.inlineStyles) {
                            element.css('position', options.offsetParent ? '' : 'relative');
                            element.css('top', options.offsetParent ? '' : bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop + 'px');
                        }
                    } else {
                        unpin = null;
                        if (setWidth) {
                            element.css('width', element[0].offsetWidth + 'px');
                        }
                        if (options.inlineStyles) {
                            element.css('position', 'fixed');
                            element.css('top', initialAffixTop + 'px');
                        }
                    }
                    element.removeClass(reset).addClass('affix' + (affix !== 'middle' ? '-' + affix : ''));
                };
                $affix.$onResize = function() {
                    $affix.$parseOffsets();
                    $affix.checkPosition();
                };
                $affix.$debouncedOnResize = debounce($affix.$onResize, 50);
                $affix.$parseOffsets = function() {
                    var initialPosition = element.css('position');
                    if (options.inlineStyles) {
                        element.css('position', options.offsetParent ? '' : 'relative');
                    }
                    if (options.offsetTop) {
                        if (options.offsetTop === 'auto') {
                            options.offsetTop = '+0';
                        }
                        if (options.offsetTop.match(/^[-+]\d+$/)) {
                            initialAffixTop = -options.offsetTop * 1;
                            if (options.offsetParent) {
                                offsetTop = dimensions.offset(parent[0]).top + options.offsetTop * 1;
                            } else {
                                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + options.offsetTop * 1;
                            }
                        } else {
                            offsetTop = options.offsetTop * 1;
                        }
                    }
                    if (options.offsetBottom) {
                        if (options.offsetParent && options.offsetBottom.match(/^[-+]\d+$/)) {
                            offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + options.offsetBottom * 1 + 1;
                        } else {
                            offsetBottom = options.offsetBottom * 1;
                        }
                    }
                    if (options.inlineStyles) {
                        element.css('position', initialPosition);
                    }
                };

                function getRequiredAffixClass(_unpin, position, elementHeight) {
                    var scrollTop = getScrollTop();
                    var scrollHeight = getScrollHeight();
                    if (scrollTop <= offsetTop) {
                        return 'top';
                    } else if (_unpin !== null && scrollTop + _unpin <= position.top) {
                        return 'middle';
                    } else if (offsetBottom !== null && position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom) {
                        return 'bottom';
                    }
                    return 'middle';
                }

                function getScrollTop() {
                    return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;
                }

                function getScrollHeight() {
                    return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;
                }
                $affix.init();
                return $affix;
            }
            return AffixFactory;
        }];
    }).directive('bsAffix', ['$affix', '$window', function($affix, $window) {
        return {
            restrict: 'EAC',
            require: '^?bsAffixTarget',
            link: function postLink(scope, element, attr, affixTarget) {
                var options = {
                    scope: scope,
                    target: affixTarget ? affixTarget.$element : angular.element($window)
                };
                angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {
                    if (angular.isDefined(attr[key])) {
                        var option = attr[key];
                        if (/true/i.test(option)) option = true;
                        if (/false/i.test(option)) option = false;
                        options[key] = option;
                    }
                });
                var affix = $affix(element, options);
                scope.$on('$destroy', function() {
                    if (affix) affix.destroy();
                    options = null;
                    affix = null;
                });
            }
        };
    }]).directive('bsAffixTarget', function() {
        return {
            controller: ['$element', function($element) {
                this.$element = $element;
            }]
        };
    });
    angular.module('mgcrea.ngStrap', ['mgcrea.ngStrap.modal', 'mgcrea.ngStrap.aside', 'mgcrea.ngStrap.alert', 'mgcrea.ngStrap.button', 'mgcrea.ngStrap.select', 'mgcrea.ngStrap.datepicker', 'mgcrea.ngStrap.timepicker', 'mgcrea.ngStrap.navbar', 'mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.popover', 'mgcrea.ngStrap.dropdown', 'mgcrea.ngStrap.typeahead', 'mgcrea.ngStrap.scrollspy', 'mgcrea.ngStrap.affix', 'mgcrea.ngStrap.tab', 'mgcrea.ngStrap.collapse']);
})(window, document);
/**
 * angular-strap
 * @version v2.3.8 - 2016-03-31
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
  'use strict';
  angular.module('mgcrea.ngStrap.aside').run([ '$templateCache', function($templateCache) {
    $templateCache.put('aside/aside.tpl.html', '<div class="aside" tabindex="-1" role="dialog"><div class="aside-dialog"><div class="aside-content"><div class="aside-header" ng-show="title"><button type="button" class="close" ng-click="$hide()">&times;</button><h4 class="aside-title" ng-bind="title"></h4></div><div class="aside-body" ng-bind="content"></div><div class="aside-footer"><button type="button" class="btn btn-default" ng-click="$hide()">Close</button></div></div></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.alert').run([ '$templateCache', function($templateCache) {
    $templateCache.put('alert/alert.tpl.html', '<div class="alert" ng-class="[type ? \'alert-\' + type : null]"><button type="button" class="close" ng-if="dismissable" ng-click="$hide()">&times;</button> <strong ng-bind="title"></strong>&nbsp;<span ng-bind-html="content"></span></div>');
  } ]);
  angular.module('mgcrea.ngStrap.datepicker').run([ '$templateCache', function($templateCache) {
    $templateCache.put('datepicker/datepicker.tpl.html', '<div class="dropdown-menu datepicker" ng-class="\'datepicker-mode-\' + $mode" style="max-width: 320px"><table style="table-layout: fixed; height: 100%; width: 100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$selectPane(-1)"><i class="{{$iconLeft}}"></i></button></th><th colspan="{{ rows[0].length - 2 }}"><button tabindex="-1" type="button" class="btn btn-default btn-block text-strong" ng-click="$toggleMode()"><strong style="text-transform: capitalize" ng-bind="title"></strong></button></th><th><button tabindex="-1" type="button" class="btn btn-default pull-right" ng-click="$selectPane(+1)"><i class="{{$iconRight}}"></i></button></th></tr><tr ng-if="showLabels" ng-bind-html="labels"></tr></thead><tbody><tr ng-repeat="(i, row) in rows" height="{{ 100 / rows.length }}%"><td class="text-center" ng-repeat="(j, el) in row"><button tabindex="-1" type="button" class="btn btn-default" style="width: 100%" ng-class="{\'btn-primary\': el.selected, \'btn-info btn-today\': el.isToday && !el.selected}" ng-click="$select(el.date)" ng-disabled="el.disabled"><span ng-class="{\'text-muted\': el.muted}" ng-bind="el.label"></span></button></td></tr></tbody></table></div>');
  } ]);
  angular.module('mgcrea.ngStrap.modal').run([ '$templateCache', function($templateCache) {
    $templateCache.put('modal/modal.tpl.html', '<div class="modal" tabindex="-1" role="dialog" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header" ng-show="title"><button type="button" class="close" aria-label="Close" ng-click="$hide()"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" ng-bind="title"></h4></div><div class="modal-body" ng-bind="content"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="$hide()">Close</button></div></div></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.dropdown').run([ '$templateCache', function($templateCache) {
    $templateCache.put('dropdown/dropdown.tpl.html', '<ul tabindex="-1" class="dropdown-menu" role="menu" ng-show="content && content.length"><li role="presentation" ng-class="{divider: item.divider, active: item.active}" ng-repeat="item in content"><a role="menuitem" tabindex="-1" ng-href="{{item.href}}" ng-if="!item.divider && item.href" target="{{item.target || \'\'}}" ng-bind="item.text"></a> <a role="menuitem" tabindex="-1" href="javascript:void(0)" ng-if="!item.divider && item.click" ng-click="$eval(item.click);$hide()" ng-bind="item.text"></a></li></ul>');
  } ]);
  angular.module('mgcrea.ngStrap.popover').run([ '$templateCache', function($templateCache) {
    $templateCache.put('popover/popover.tpl.html', '<div class="popover" tabindex="-1"><div class="arrow"></div><h3 class="popover-title" ng-bind="title" ng-show="title"></h3><div class="popover-content" ng-bind="content"></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.select').run([ '$templateCache', function($templateCache) {
    $templateCache.put('select/select.tpl.html', '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select"><li ng-if="$showAllNoneButtons"><div class="btn-group" style="margin-bottom: 5px; margin-left: 5px"><button type="button" class="btn btn-default btn-xs" ng-click="$selectAll()">{{$allText}}</button> <button type="button" class="btn btn-default btn-xs" ng-click="$selectNone()">{{$noneText}}</button></div></li><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index)}"><a style="cursor: default" role="menuitem" tabindex="-1" ng-click="$select($index, $event)"><i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index)"></i> <span ng-bind="match.label"></span></a></li></ul>');
  } ]);
  angular.module('mgcrea.ngStrap.tab').run([ '$templateCache', function($templateCache) {
    $templateCache.put('tab/tab.tpl.html', '<ul class="nav" ng-class="$navClass" role="tablist"><li role="presentation" ng-repeat="$pane in $panes track by $index" ng-class="[ $isActive($pane, $index) ? $activeClass : \'\', $pane.disabled ? \'disabled\' : \'\' ]"><a role="tab" data-toggle="tab" ng-click="!$pane.disabled && $setActive($pane.name || $index)" data-index="{{ $index }}" ng-bind-html="$pane.title" aria-controls="$pane.title"></a></li></ul><div ng-transclude class="tab-content"></div>');
  } ]);
  angular.module('mgcrea.ngStrap.timepicker').run([ '$templateCache', function($templateCache) {
    $templateCache.put('timepicker/timepicker.tpl.html', '<div class="dropdown-menu timepicker" style="min-width: 0px;width: auto"><table height="100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 0)"><i class="{{ $iconUp }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 1)"><i class="{{ $iconUp }}"></i></button></th><th ng-if="showSeconds">&nbsp;</th><th ng-if="showSeconds"><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 2)"><i class="{{ $iconUp }}"></i></button></th></tr></thead><tbody><tr ng-repeat="(i, row) in rows"><td class="text-center"><button tabindex="-1" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[0].selected}" ng-click="$select(row[0].date, 0)" ng-disabled="row[0].disabled"><span ng-class="{\'text-muted\': row[0].muted}" ng-bind="row[0].label"></span></button></td><td><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td class="text-center"><button tabindex="-1" ng-if="row[1].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[1].selected}" ng-click="$select(row[1].date, 1)" ng-disabled="row[1].disabled"><span ng-class="{\'text-muted\': row[1].muted}" ng-bind="row[1].label"></span></button></td><td ng-if="showSeconds"><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td ng-if="showSeconds" class="text-center"><button tabindex="-1" ng-if="row[2].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[2].selected}" ng-click="$select(row[2].date, 2)" ng-disabled="row[2].disabled"><span ng-class="{\'text-muted\': row[2].muted}" ng-bind="row[2].label"></span></button></td><td ng-if="showAM">&nbsp;</td><td ng-if="showAM"><button tabindex="-1" ng-show="i == midIndex - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !!isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">AM</button> <button tabindex="-1" ng-show="i == midIndex + 1 - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">PM</button></td></tr></tbody><tfoot><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 0)"><i class="{{ $iconDown }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 1)"><i class="{{ $iconDown }}"></i></button></th><th ng-if="showSeconds">&nbsp;</th><th ng-if="showSeconds"><button ng-if="showSeconds" tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 2)"><i class="{{ $iconDown }}"></i></button></th></tr></tfoot></table></div>');
  } ]);
  angular.module('mgcrea.ngStrap.typeahead').run([ '$templateCache', function($templateCache) {
    $templateCache.put('typeahead/typeahead.tpl.html', '<ul tabindex="-1" class="typeahead dropdown-menu" ng-show="$isVisible()" role="select"><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $index == $activeIndex}"><a role="menuitem" tabindex="-1" ng-click="$select($index, $event)" ng-bind="match.label"></a></li></ul>');
  } ]);
  angular.module('mgcrea.ngStrap.tooltip').run([ '$templateCache', function($templateCache) {
    $templateCache.put('tooltip/tooltip.tpl.html', '<div class="tooltip in" ng-show="title"><div class="tooltip-arrow"></div><div class="tooltip-inner" ng-bind="title"></div></div>');
  } ]);
})(window, document);
(function() {
  var app;
  app = angular.module('selectAddress', []);
  app.directive('selectAddress', ['$http', '$q', '$compile',function($http, $q, $compile) {
    var cityURL, delay, templateURL;
    delay = $q.defer();
    templateURL =  'static/js/directives/custom/selectAddress/template/address_template.html';
    cityURL =  URL_PATH.CMD_HEADER + '/public/cmd/getAddresses';
    return {
      restrict: 'A',
      scope: {
        p: '=',
        a: '=',
        c: '=',
        d: '=',
        ngModel: '='
      },
      link: function(scope, element, attrs) {
    	  /*初始化模板*/
          $http.get(templateURL).success(function(template) {
              var $template;
              $template = $compile(template)(scope);
              $('body').append($template);
              popup.element = $($template[2]);
              popup.init();
          });
          
        var popup = {
          element: null,
          backdrop: null,
          show: function() {
            this.element.addClass('active');
          },
          hide: function() {
            this.element.removeClass('active');
            return false;
          },
          resize: function() {
            if (!this.element) {
              return;
            }
            this.element.css({
              'margin-left': -this.element.width() / 2
            });
            return false;
          },
          focus: function() {
            $('[ng-model="d"]').focus();
            return false;
          },
          init: function() {
            element.on('click keydown', function(event) {
        	  if(undefined == scope.p && undefined == scope.provinces){
        		  getAddresses();
        	  }
        	  popup.show();
              event.stopPropagation();
              return false;
            });
            this.element.on('click', function(event) {
              return event.stopPropagation();
            });
            return setTimeout((function(_this) {
              return function() {
                _this.element.show();
                return _this.resize();
              };
            })(this), 500);
          }
        };
       
        scope.aSet = {
	        p: function(p) {
	          scope.p = p;
	          scope.c = null;
	          scope.a = null;
	        },
	        c: function(c) {
	          scope.c = c;
	          scope.a = null;
	        },
	        a: function(a) {
	          scope.a = a;
	          popup.focus();
	        }
	      };
        
        /*获取地址数据*/
        function getAddresses(){
        	$http.get(cityURL).success(function(data) {
        		scope.provinces = data;
        		
        		if(scope.ngModel){
           		 	var ngModelArr = scope.ngModel.split(" ");
          		    if (!scope.p && ngModelArr[0]) {
                      scope.p = ngModelArr[0];
                    }
                    if (!scope.c && ngModelArr[1]) {
                      scope.c = ngModelArr[1];
                    }
                    if (!scope.a && ngModelArr[2]) {
                  	  scope.a = ngModelArr[2];
                    }
        		}
                
                scope.clear = function() {
                  scope.p = null;
                  scope.c = null;
                  scope.a = null;
                  scope.ngModel = null;
                };
                scope.submit = function() {
                	
              		scope.ngModel = '';
                    if (scope.p) {
                      scope.ngModel += scope.p;
                    }
                    if (scope.c) {
                      scope.ngModel += " " + scope.c;
                    }
                    if (scope.a) {
                      scope.ngModel += " " + scope.a;
                    }
                    
                   popup.hide();
                };
                scope.$watch('p', function(newV) {
                  var v, _i, _len, _results;
                  if (newV) {
                    _results = [];
                    for (_i = 0, _len = data.length; _i < _len; _i++) {
                      v = data[_i];
                      if (v.p === newV) {
                        _results.push(scope.cities = v.c);
                      }
                    }
                    return _results;
                  } else {
                    return scope.cities = [];
                  }
                });
                scope.$watch('c', function(newV) {
                  var v, _i, _len, _ref, _results;
                  if (newV) {
                	  _ref = scope.cities;
                      _results = [];
                	  if(_ref){
                          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            v = _ref[_i];
                            if (v.n === newV) {
                              _results.push(scope.dists = v.a);
                            }
                          }
                	  }
                	  return _results;
                  } else {
                    return scope.dists = [];
                  }
                });
        	});
        };
      }
    };
  }]);

}).call(this);


/*! jQuery UI - v1.11.4+CommonJS - 2015-08-28
* http://jqueryui.com
* Includes: widget.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		define([ "jquery" ], factory );

	} else if ( typeof exports === "object" ) {

		factory( require( "jquery" ) );

	} else {

		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			try {

				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			} catch ( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		_proto: $.extend( {}, prototype ),
		_childConstructors: []
	});

	basePrototype = new base();
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						$.widget.extend( {}, value );
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {

			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat(args) );
			}

			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				element.ownerDocument :
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );

		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		event.target = this.element[ 0 ];

		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;



}));

!function(e){"use strict";var t=function(e,i,a){var o,r,n=document.createElement("img");if(n.onerror=i,n.onload=function(){!r||a&&a.noRevoke||t.revokeObjectURL(r),i&&i(t.scale(n,a))},t.isInstanceOf("Blob",e)||t.isInstanceOf("File",e))o=r=t.createObjectURL(e),n._type=e.type;else{if("string"!=typeof e)return!1;o=e,a&&a.crossOrigin&&(n.crossOrigin=a.crossOrigin)}return o?(n.src=o,n):t.readFile(e,function(e){var t=e.target;t&&t.result?n.src=t.result:i&&i(e)})},i=window.createObjectURL&&window||window.URL&&URL.revokeObjectURL&&URL||window.webkitURL&&webkitURL;t.isInstanceOf=function(e,t){return Object.prototype.toString.call(t)==="[object "+e+"]"},t.transformCoordinates=function(){},t.getTransformedOptions=function(e,t){var i,a,o,r,n=t.aspectRatio;if(!n)return t;i={};for(a in t)t.hasOwnProperty(a)&&(i[a]=t[a]);return i.crop=!0,o=e.naturalWidth||e.width,r=e.naturalHeight||e.height,o/r>n?(i.maxWidth=r*n,i.maxHeight=r):(i.maxWidth=o,i.maxHeight=o/n),i},t.renderImageToCanvas=function(e,t,i,a,o,r,n,s,l,d){return e.getContext("2d").drawImage(t,i,a,o,r,n,s,l,d),e},t.hasCanvasOption=function(e){return e.canvas||e.crop||!!e.aspectRatio},t.scale=function(e,i){function a(){var e=Math.max((s||y)/y,(l||v)/v);e>1&&(y*=e,v*=e)}function o(){var e=Math.min((r||y)/y,(n||v)/v);1>e&&(y*=e,v*=e)}i=i||{};var r,n,s,l,d,u,c,g,f,h,m,p=document.createElement("canvas"),S=e.getContext||t.hasCanvasOption(i)&&p.getContext,b=e.naturalWidth||e.width,x=e.naturalHeight||e.height,y=b,v=x;if(S&&(i=t.getTransformedOptions(e,i),c=i.left||0,g=i.top||0,i.sourceWidth?(d=i.sourceWidth,void 0!==i.right&&void 0===i.left&&(c=b-d-i.right)):d=b-c-(i.right||0),i.sourceHeight?(u=i.sourceHeight,void 0!==i.bottom&&void 0===i.top&&(g=x-u-i.bottom)):u=x-g-(i.bottom||0),y=d,v=u),r=i.maxWidth,n=i.maxHeight,s=i.minWidth,l=i.minHeight,S&&r&&n&&i.crop?(y=r,v=n,m=d/u-r/n,0>m?(u=n*d/r,void 0===i.top&&void 0===i.bottom&&(g=(x-u)/2)):m>0&&(d=r*u/n,void 0===i.left&&void 0===i.right&&(c=(b-d)/2))):((i.contain||i.cover)&&(s=r=r||s,l=n=n||l),i.cover?(o(),a()):(a(),o())),S){if(f=i.pixelRatio,f>1&&(p.style.width=y+"px",p.style.height=v+"px",y*=f,v*=f,p.getContext("2d").scale(f,f)),h=i.downsamplingRatio,h>0&&1>h&&d>y&&u>v)for(;d*h>y;)p.width=d*h,p.height=u*h,t.renderImageToCanvas(p,e,c,g,d,u,0,0,p.width,p.height),d=p.width,u=p.height,e=document.createElement("canvas"),e.width=d,e.height=u,t.renderImageToCanvas(e,p,0,0,d,u,0,0,d,u);return p.width=y,p.height=v,t.transformCoordinates(p,i),t.renderImageToCanvas(p,e,c,g,d,u,0,0,y,v)}return e.width=y,e.height=v,e},t.createObjectURL=function(e){return i?i.createObjectURL(e):!1},t.revokeObjectURL=function(e){return i?i.revokeObjectURL(e):!1},t.readFile=function(e,t,i){if(window.FileReader){var a=new FileReader;if(a.onload=a.onerror=t,i=i||"readAsDataURL",a[i])return a[i](e),a}return!1},"function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:e.loadImage=t}(window),function(e){"use strict";"function"==typeof define&&define.amd?define(["./load-image"],e):e("object"==typeof module&&module.exports?require("./load-image"):window.loadImage)}(function(e){"use strict";var t=e.hasCanvasOption,i=e.transformCoordinates,a=e.getTransformedOptions;e.hasCanvasOption=function(i){return!!i.orientation||t.call(e,i)},e.transformCoordinates=function(t,a){i.call(e,t,a);var o=t.getContext("2d"),r=t.width,n=t.height,s=t.style.width,l=t.style.height,d=a.orientation;if(d&&!(d>8))switch(d>4&&(t.width=n,t.height=r,t.style.width=l,t.style.height=s),d){case 2:o.translate(r,0),o.scale(-1,1);break;case 3:o.translate(r,n),o.rotate(Math.PI);break;case 4:o.translate(0,n),o.scale(1,-1);break;case 5:o.rotate(.5*Math.PI),o.scale(1,-1);break;case 6:o.rotate(.5*Math.PI),o.translate(0,-n);break;case 7:o.rotate(.5*Math.PI),o.translate(r,-n),o.scale(-1,1);break;case 8:o.rotate(-.5*Math.PI),o.translate(-r,0)}},e.getTransformedOptions=function(t,i){var o,r,n=a.call(e,t,i),s=n.orientation;if(!s||s>8||1===s)return n;o={};for(r in n)n.hasOwnProperty(r)&&(o[r]=n[r]);switch(n.orientation){case 2:o.left=n.right,o.right=n.left;break;case 3:o.left=n.right,o.top=n.bottom,o.right=n.left,o.bottom=n.top;break;case 4:o.top=n.bottom,o.bottom=n.top;break;case 5:o.left=n.top,o.top=n.left,o.right=n.bottom,o.bottom=n.right;break;case 6:o.left=n.top,o.top=n.right,o.right=n.bottom,o.bottom=n.left;break;case 7:o.left=n.bottom,o.top=n.right,o.right=n.top,o.bottom=n.left;break;case 8:o.left=n.bottom,o.top=n.left,o.right=n.top,o.bottom=n.right}return n.orientation>4&&(o.maxWidth=n.maxHeight,o.maxHeight=n.maxWidth,o.minWidth=n.minHeight,o.minHeight=n.minWidth,o.sourceWidth=n.sourceHeight,o.sourceHeight=n.sourceWidth),o}}),function(e){"use strict";"function"==typeof define&&define.amd?define(["./load-image"],e):e("object"==typeof module&&module.exports?require("./load-image"):window.loadImage)}(function(e){"use strict";var t=window.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice);e.blobSlice=t&&function(){var e=this.slice||this.webkitSlice||this.mozSlice;return e.apply(this,arguments)},e.metaDataParsers={jpeg:{65505:[]}},e.parseMetaData=function(t,i,a){a=a||{};var o=this,r=a.maxMetaDataSize||262144,n={},s=!(window.DataView&&t&&t.size>=12&&"image/jpeg"===t.type&&e.blobSlice);(s||!e.readFile(e.blobSlice.call(t,0,r),function(t){if(t.target.error)return console.log(t.target.error),void i(n);var r,s,l,d,u=t.target.result,c=new DataView(u),g=2,f=c.byteLength-4,h=g;if(65496===c.getUint16(0)){for(;f>g&&(r=c.getUint16(g),r>=65504&&65519>=r||65534===r);){if(s=c.getUint16(g+2)+2,g+s>c.byteLength){console.log("Invalid meta data: Invalid segment size.");break}if(l=e.metaDataParsers.jpeg[r])for(d=0;d<l.length;d+=1)l[d].call(o,c,g,s,n,a);g+=s,h=g}!a.disableImageHead&&h>6&&(u.slice?n.imageHead=u.slice(0,h):n.imageHead=new Uint8Array(u).subarray(0,h))}else console.log("Invalid JPEG file: Missing JPEG marker.");i(n)},"readAsArrayBuffer"))&&i(n)}}),function(e){"use strict";"function"==typeof define&&define.amd?define(["./load-image","./load-image-meta"],e):"object"==typeof module&&module.exports?e(require("./load-image"),require("./load-image-meta")):e(window.loadImage)}(function(e){"use strict";e.ExifMap=function(){return this},e.ExifMap.prototype.map={Orientation:274},e.ExifMap.prototype.get=function(e){return this[e]||this[this.map[e]]},e.getExifThumbnail=function(e,t,i){var a,o,r;if(!i||t+i>e.byteLength)return void console.log("Invalid Exif data: Invalid thumbnail data.");for(a=[],o=0;i>o;o+=1)r=e.getUint8(t+o),a.push((16>r?"0":"")+r.toString(16));return"data:image/jpeg,%"+a.join("%")},e.exifTagTypes={1:{getValue:function(e,t){return e.getUint8(t)},size:1},2:{getValue:function(e,t){return String.fromCharCode(e.getUint8(t))},size:1,ascii:!0},3:{getValue:function(e,t,i){return e.getUint16(t,i)},size:2},4:{getValue:function(e,t,i){return e.getUint32(t,i)},size:4},5:{getValue:function(e,t,i){return e.getUint32(t,i)/e.getUint32(t+4,i)},size:8},9:{getValue:function(e,t,i){return e.getInt32(t,i)},size:4},10:{getValue:function(e,t,i){return e.getInt32(t,i)/e.getInt32(t+4,i)},size:8}},e.exifTagTypes[7]=e.exifTagTypes[1],e.getExifValue=function(t,i,a,o,r,n){var s,l,d,u,c,g,f=e.exifTagTypes[o];if(!f)return void console.log("Invalid Exif data: Invalid tag type.");if(s=f.size*r,l=s>4?i+t.getUint32(a+8,n):a+8,l+s>t.byteLength)return void console.log("Invalid Exif data: Invalid data offset.");if(1===r)return f.getValue(t,l,n);for(d=[],u=0;r>u;u+=1)d[u]=f.getValue(t,l+u*f.size,n);if(f.ascii){for(c="",u=0;u<d.length&&(g=d[u],"\x00"!==g);u+=1)c+=g;return c}return d},e.parseExifTag=function(t,i,a,o,r){var n=t.getUint16(a,o);r.exif[n]=e.getExifValue(t,i,a,t.getUint16(a+2,o),t.getUint32(a+4,o),o)},e.parseExifTags=function(e,t,i,a,o){var r,n,s;if(i+6>e.byteLength)return void console.log("Invalid Exif data: Invalid directory offset.");if(r=e.getUint16(i,a),n=i+2+12*r,n+4>e.byteLength)return void console.log("Invalid Exif data: Invalid directory size.");for(s=0;r>s;s+=1)this.parseExifTag(e,t,i+2+12*s,a,o);return e.getUint32(n,a)},e.parseExifData=function(t,i,a,o,r){if(!r.disableExif){var n,s,l,d=i+10;if(1165519206===t.getUint32(i+4)){if(d+8>t.byteLength)return void console.log("Invalid Exif data: Invalid segment size.");if(0!==t.getUint16(i+8))return void console.log("Invalid Exif data: Missing byte alignment offset.");switch(t.getUint16(d)){case 18761:n=!0;break;case 19789:n=!1;break;default:return void console.log("Invalid Exif data: Invalid byte alignment marker.")}if(42!==t.getUint16(d+2,n))return void console.log("Invalid Exif data: Missing TIFF marker.");s=t.getUint32(d+4,n),o.exif=new e.ExifMap,s=e.parseExifTags(t,d,d+s,n,o),s&&!r.disableExifThumbnail&&(l={exif:{}},s=e.parseExifTags(t,d,d+s,n,l),l.exif[513]&&(o.exif.Thumbnail=e.getExifThumbnail(t,d+l.exif[513],l.exif[514]))),o.exif[34665]&&!r.disableExifSub&&e.parseExifTags(t,d,d+o.exif[34665],n,o),o.exif[34853]&&!r.disableExifGps&&e.parseExifTags(t,d,d+o.exif[34853],n,o)}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData)}),function(e){"use strict";"function"==typeof define&&define.amd?define(["./load-image","./load-image-exif"],e):"object"==typeof module&&module.exports?e(require("./load-image"),require("./load-image-exif")):e(window.loadImage)}(function(e){"use strict";e.ExifMap.prototype.tags={256:"ImageWidth",257:"ImageHeight",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer",40965:"InteroperabilityIFDPointer",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},e.ExifMap.prototype.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"top-left",2:"top-right",3:"bottom-right",4:"bottom-left",5:"left-top",6:"right-top",7:"right-bottom",8:"left-bottom"}},e.ExifMap.prototype.getText=function(e){var t=this.get(e);switch(e){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[e][t];case"ExifVersion":case"FlashpixVersion":return String.fromCharCode(t[0],t[1],t[2],t[3]);case"ComponentsConfiguration":return this.stringValues[e][t[0]]+this.stringValues[e][t[1]]+this.stringValues[e][t[2]]+this.stringValues[e][t[3]];case"GPSVersionID":return t[0]+"."+t[1]+"."+t[2]+"."+t[3]}return String(t)},function(e){var t,i=e.tags,a=e.map;for(t in i)i.hasOwnProperty(t)&&(a[i[t]]=t)}(e.ExifMap.prototype),e.ExifMap.prototype.getAll=function(){var e,t,i={};for(e in this)this.hasOwnProperty(e)&&(t=this.tags[e],t&&(i[t]=this.getText(t)));return i}});

!function(t){"use strict";var e=t.HTMLCanvasElement&&t.HTMLCanvasElement.prototype,o=t.Blob&&function(){try{return Boolean(new Blob)}catch(t){return!1}}(),n=o&&t.Uint8Array&&function(){try{return 100===new Blob([new Uint8Array(100)]).size}catch(t){return!1}}(),r=t.BlobBuilder||t.WebKitBlobBuilder||t.MozBlobBuilder||t.MSBlobBuilder,a=/^data:((.*?)(;charset=.*?)?)(;base64)?,/,i=(o||r)&&t.atob&&t.ArrayBuffer&&t.Uint8Array&&function(t){var e,i,l,u,b,c,d,B,f;if(e=t.match(a),!e)throw new Error("invalid data URI");for(i=e[2]?e[1]:"text/plain"+(e[3]||";charset=US-ASCII"),l=!!e[4],u=t.slice(e[0].length),b=l?atob(u):decodeURIComponent(u),c=new ArrayBuffer(b.length),d=new Uint8Array(c),B=0;B<b.length;B+=1)d[B]=b.charCodeAt(B);return o?new Blob([n?d:c],{type:i}):(f=new r,f.append(c),f.getBlob(i))};t.HTMLCanvasElement&&!e.toBlob&&(e.mozGetAsFile?e.toBlob=function(t,o,n){t(n&&e.toDataURL&&i?i(this.toDataURL(o,n)):this.mozGetAsFile("blob",o))}:e.toDataURL&&i&&(e.toBlob=function(t,e,o){t(i(this.toDataURL(e,o)))})),"function"==typeof define&&define.amd?define(function(){return i}):"object"==typeof module&&module.exports?module.exports=i:t.dataURLtoBlob=i}(window);

!function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper"],t):(window.blueimp=window.blueimp||{},window.blueimp.Gallery=t(window.blueimp.helper||window.jQuery))}(function(t){"use strict";function e(t,i){return void 0===document.body.style.maxHeight?null:this&&this.options===e.prototype.options?t&&t.length?(this.list=t,this.num=t.length,this.initOptions(i),void this.initialize()):void this.console.log("blueimp Gallery: No or empty list provided as first argument.",t):new e(t,i)}return t.extend(e.prototype,{options:{container:"#blueimp-gallery",slidesContainer:"div",titleElement:"h3",displayClass:"blueimp-gallery-display",controlsClass:"blueimp-gallery-controls",singleClass:"blueimp-gallery-single",leftEdgeClass:"blueimp-gallery-left",rightEdgeClass:"blueimp-gallery-right",playingClass:"blueimp-gallery-playing",slideClass:"slide",slideLoadingClass:"slide-loading",slideErrorClass:"slide-error",slideContentClass:"slide-content",toggleClass:"toggle",prevClass:"prev",nextClass:"next",closeClass:"close",playPauseClass:"play-pause",typeProperty:"type",titleProperty:"title",urlProperty:"href",srcsetProperty:"urlset",displayTransition:!0,clearSlides:!0,stretchImages:!1,toggleControlsOnReturn:!0,toggleControlsOnSlideClick:!0,toggleSlideshowOnSpace:!0,enableKeyboardNavigation:!0,closeOnEscape:!0,closeOnSlideClick:!0,closeOnSwipeUpOrDown:!0,emulateTouchEvents:!0,stopTouchEventsPropagation:!1,hidePageScrollbars:!0,disableScroll:!0,carousel:!1,continuous:!0,unloadElements:!0,startSlideshow:!1,slideshowInterval:5e3,index:0,preloadRange:2,transitionSpeed:400,slideshowTransitionSpeed:void 0,event:void 0,onopen:void 0,onopened:void 0,onslide:void 0,onslideend:void 0,onslidecomplete:void 0,onclose:void 0,onclosed:void 0},carouselOptions:{hidePageScrollbars:!1,toggleControlsOnReturn:!1,toggleSlideshowOnSpace:!1,enableKeyboardNavigation:!1,closeOnEscape:!1,closeOnSlideClick:!1,closeOnSwipeUpOrDown:!1,disableScroll:!1,startSlideshow:!0},console:window.console&&"function"==typeof window.console.log?window.console:{log:function(){}},support:function(e){function i(){var t,i,s=o.transition;document.body.appendChild(e),s&&(t=s.name.slice(0,-9)+"ransform",void 0!==e.style[t]&&(e.style[t]="translateZ(0)",i=window.getComputedStyle(e).getPropertyValue(s.prefix+"transform"),o.transform={prefix:s.prefix,name:t,translate:!0,translateZ:!!i&&"none"!==i})),void 0!==e.style.backgroundSize&&(o.backgroundSize={},e.style.backgroundSize="contain",o.backgroundSize.contain="contain"===window.getComputedStyle(e).getPropertyValue("background-size"),e.style.backgroundSize="cover",o.backgroundSize.cover="cover"===window.getComputedStyle(e).getPropertyValue("background-size")),document.body.removeChild(e)}var s,o={touch:void 0!==window.ontouchstart||window.DocumentTouch&&document instanceof DocumentTouch},n={webkitTransition:{end:"webkitTransitionEnd",prefix:"-webkit-"},MozTransition:{end:"transitionend",prefix:"-moz-"},OTransition:{end:"otransitionend",prefix:"-o-"},transition:{end:"transitionend",prefix:""}};for(s in n)if(n.hasOwnProperty(s)&&void 0!==e.style[s]){o.transition=n[s],o.transition.name=s;break}return document.body?i():t(document).on("DOMContentLoaded",i),o}(document.createElement("div")),requestAnimationFrame:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame,initialize:function(){return this.initStartIndex(),this.initWidget()===!1?!1:(this.initEventListeners(),this.onslide(this.index),this.ontransitionend(),void(this.options.startSlideshow&&this.play()))},slide:function(t,e){window.clearTimeout(this.timeout);var i,s,o,n=this.index;if(n!==t&&1!==this.num){if(e||(e=this.options.transitionSpeed),this.support.transform){for(this.options.continuous||(t=this.circle(t)),i=Math.abs(n-t)/(n-t),this.options.continuous&&(s=i,i=-this.positions[this.circle(t)]/this.slideWidth,i!==s&&(t=-i*this.num+t)),o=Math.abs(n-t)-1;o;)o-=1,this.move(this.circle((t>n?t:n)-o-1),this.slideWidth*i,0);t=this.circle(t),this.move(n,this.slideWidth*i,e),this.move(t,0,e),this.options.continuous&&this.move(this.circle(t-i),-(this.slideWidth*i),0)}else t=this.circle(t),this.animate(n*-this.slideWidth,t*-this.slideWidth,e);this.onslide(t)}},getIndex:function(){return this.index},getNumber:function(){return this.num},prev:function(){(this.options.continuous||this.index)&&this.slide(this.index-1)},next:function(){(this.options.continuous||this.index<this.num-1)&&this.slide(this.index+1)},play:function(t){var e=this;window.clearTimeout(this.timeout),this.interval=t||this.options.slideshowInterval,this.elements[this.index]>1&&(this.timeout=this.setTimeout(!this.requestAnimationFrame&&this.slide||function(t,i){e.animationFrameId=e.requestAnimationFrame.call(window,function(){e.slide(t,i)})},[this.index+1,this.options.slideshowTransitionSpeed],this.interval)),this.container.addClass(this.options.playingClass)},pause:function(){window.clearTimeout(this.timeout),this.interval=null,this.container.removeClass(this.options.playingClass)},add:function(t){var e;for(t.concat||(t=Array.prototype.slice.call(t)),this.list.concat||(this.list=Array.prototype.slice.call(this.list)),this.list=this.list.concat(t),this.num=this.list.length,this.num>2&&null===this.options.continuous&&(this.options.continuous=!0,this.container.removeClass(this.options.leftEdgeClass)),this.container.removeClass(this.options.rightEdgeClass).removeClass(this.options.singleClass),e=this.num-t.length;e<this.num;e+=1)this.addSlide(e),this.positionSlide(e);this.positions.length=this.num,this.initSlides(!0)},resetSlides:function(){this.slidesContainer.empty(),this.unloadAllSlides(),this.slides=[]},handleClose:function(){var t=this.options;this.destroyEventListeners(),this.pause(),this.container[0].style.display="none",this.container.removeClass(t.displayClass).removeClass(t.singleClass).removeClass(t.leftEdgeClass).removeClass(t.rightEdgeClass),t.hidePageScrollbars&&(document.body.style.overflow=this.bodyOverflowStyle),this.options.clearSlides&&this.resetSlides(),this.options.onclosed&&this.options.onclosed.call(this)},close:function(){function t(i){i.target===e.container[0]&&(e.container.off(e.support.transition.end,t),e.handleClose())}var e=this;this.options.onclose&&this.options.onclose.call(this),this.support.transition&&this.options.displayTransition?(this.container.on(this.support.transition.end,t),this.container.removeClass(this.options.displayClass)):this.handleClose()},circle:function(t){return(this.num+t%this.num)%this.num},move:function(t,e,i){this.translateX(t,e,i),this.positions[t]=e},translate:function(t,e,i,s){var o=this.slides[t].style,n=this.support.transition,l=this.support.transform;o[n.name+"Duration"]=s+"ms",o[l.name]="translate("+e+"px, "+i+"px)"+(l.translateZ?" translateZ(0)":"")},translateX:function(t,e,i){this.translate(t,e,0,i)},translateY:function(t,e,i){this.translate(t,0,e,i)},animate:function(t,e,i){if(!i)return void(this.slidesContainer[0].style.left=e+"px");var s=this,o=(new Date).getTime(),n=window.setInterval(function(){var l=(new Date).getTime()-o;return l>i?(s.slidesContainer[0].style.left=e+"px",s.ontransitionend(),void window.clearInterval(n)):void(s.slidesContainer[0].style.left=(e-t)*(Math.floor(l/i*100)/100)+t+"px")},4)},preventDefault:function(t){t.preventDefault?t.preventDefault():t.returnValue=!1},stopPropagation:function(t){t.stopPropagation?t.stopPropagation():t.cancelBubble=!0},onresize:function(){this.initSlides(!0)},onmousedown:function(t){t.which&&1===t.which&&"VIDEO"!==t.target.nodeName&&(t.preventDefault(),(t.originalEvent||t).touches=[{pageX:t.pageX,pageY:t.pageY}],this.ontouchstart(t))},onmousemove:function(t){this.touchStart&&((t.originalEvent||t).touches=[{pageX:t.pageX,pageY:t.pageY}],this.ontouchmove(t))},onmouseup:function(t){this.touchStart&&(this.ontouchend(t),delete this.touchStart)},onmouseout:function(e){if(this.touchStart){var i=e.target,s=e.relatedTarget;(!s||s!==i&&!t.contains(i,s))&&this.onmouseup(e)}},ontouchstart:function(t){this.options.stopTouchEventsPropagation&&this.stopPropagation(t);var e=(t.originalEvent||t).touches[0];this.touchStart={x:e.pageX,y:e.pageY,time:Date.now()},this.isScrolling=void 0,this.touchDelta={}},ontouchmove:function(t){this.options.stopTouchEventsPropagation&&this.stopPropagation(t);var e,i,s=(t.originalEvent||t).touches[0],o=(t.originalEvent||t).scale,n=this.index;if(!(s.length>1||o&&1!==o))if(this.options.disableScroll&&t.preventDefault(),this.touchDelta={x:s.pageX-this.touchStart.x,y:s.pageY-this.touchStart.y},e=this.touchDelta.x,void 0===this.isScrolling&&(this.isScrolling=this.isScrolling||Math.abs(e)<Math.abs(this.touchDelta.y)),this.isScrolling)this.options.closeOnSwipeUpOrDown&&this.translateY(n,this.touchDelta.y+this.positions[n],0);else for(t.preventDefault(),window.clearTimeout(this.timeout),this.options.continuous?i=[this.circle(n+1),n,this.circle(n-1)]:(this.touchDelta.x=e/=!n&&e>0||n===this.num-1&&0>e?Math.abs(e)/this.slideWidth+1:1,i=[n],n&&i.push(n-1),n<this.num-1&&i.unshift(n+1));i.length;)n=i.pop(),this.translateX(n,e+this.positions[n],0)},ontouchend:function(t){this.options.stopTouchEventsPropagation&&this.stopPropagation(t);var e,i,s,o,n,l=this.index,a=this.options.transitionSpeed,r=this.slideWidth,h=Number(Date.now()-this.touchStart.time)<250,d=h&&Math.abs(this.touchDelta.x)>20||Math.abs(this.touchDelta.x)>r/2,c=!l&&this.touchDelta.x>0||l===this.num-1&&this.touchDelta.x<0,u=!d&&this.options.closeOnSwipeUpOrDown&&(h&&Math.abs(this.touchDelta.y)>20||Math.abs(this.touchDelta.y)>this.slideHeight/2);this.options.continuous&&(c=!1),e=this.touchDelta.x<0?-1:1,this.isScrolling?u?this.close():this.translateY(l,0,a):d&&!c?(i=l+e,s=l-e,o=r*e,n=-r*e,this.options.continuous?(this.move(this.circle(i),o,0),this.move(this.circle(l-2*e),n,0)):i>=0&&i<this.num&&this.move(i,o,0),this.move(l,this.positions[l]+o,a),this.move(this.circle(s),this.positions[this.circle(s)]+o,a),l=this.circle(s),this.onslide(l)):this.options.continuous?(this.move(this.circle(l-1),-r,a),this.move(l,0,a),this.move(this.circle(l+1),r,a)):(l&&this.move(l-1,-r,a),this.move(l,0,a),l<this.num-1&&this.move(l+1,r,a))},ontouchcancel:function(t){this.touchStart&&(this.ontouchend(t),delete this.touchStart)},ontransitionend:function(t){var e=this.slides[this.index];t&&e!==t.target||(this.interval&&this.play(),this.setTimeout(this.options.onslideend,[this.index,e]))},oncomplete:function(e){var i,s=e.target||e.srcElement,o=s&&s.parentNode;s&&o&&(i=this.getNodeIndex(o),t(o).removeClass(this.options.slideLoadingClass),"error"===e.type?(t(o).addClass(this.options.slideErrorClass),this.elements[i]=3):this.elements[i]=2,s.clientHeight>this.container[0].clientHeight&&(s.style.maxHeight=this.container[0].clientHeight),this.interval&&this.slides[this.index]===o&&this.play(),this.setTimeout(this.options.onslidecomplete,[i,o]))},onload:function(t){this.oncomplete(t)},onerror:function(t){this.oncomplete(t)},onkeydown:function(t){switch(t.which||t.keyCode){case 13:this.options.toggleControlsOnReturn&&(this.preventDefault(t),this.toggleControls());break;case 27:this.options.closeOnEscape&&(this.close(),t.stopImmediatePropagation());break;case 32:this.options.toggleSlideshowOnSpace&&(this.preventDefault(t),this.toggleSlideshow());break;case 37:this.options.enableKeyboardNavigation&&(this.preventDefault(t),this.prev());break;case 39:this.options.enableKeyboardNavigation&&(this.preventDefault(t),this.next())}},handleClick:function(e){function i(e){return t(o).hasClass(e)||t(n).hasClass(e)}var s=this.options,o=e.target||e.srcElement,n=o.parentNode;i(s.toggleClass)?(this.preventDefault(e),this.toggleControls()):i(s.prevClass)?(this.preventDefault(e),this.prev()):i(s.nextClass)?(this.preventDefault(e),this.next()):i(s.closeClass)?(this.preventDefault(e),this.close()):i(s.playPauseClass)?(this.preventDefault(e),this.toggleSlideshow()):n===this.slidesContainer[0]?s.closeOnSlideClick?(this.preventDefault(e),this.close()):s.toggleControlsOnSlideClick&&(this.preventDefault(e),this.toggleControls()):n.parentNode&&n.parentNode===this.slidesContainer[0]&&s.toggleControlsOnSlideClick&&(this.preventDefault(e),this.toggleControls())},onclick:function(t){return this.options.emulateTouchEvents&&this.touchDelta&&(Math.abs(this.touchDelta.x)>20||Math.abs(this.touchDelta.y)>20)?void delete this.touchDelta:this.handleClick(t)},updateEdgeClasses:function(t){t?this.container.removeClass(this.options.leftEdgeClass):this.container.addClass(this.options.leftEdgeClass),t===this.num-1?this.container.addClass(this.options.rightEdgeClass):this.container.removeClass(this.options.rightEdgeClass)},handleSlide:function(t){this.options.continuous||this.updateEdgeClasses(t),this.loadElements(t),this.options.unloadElements&&this.unloadElements(t),this.setTitle(t)},onslide:function(t){this.index=t,this.handleSlide(t),this.setTimeout(this.options.onslide,[t,this.slides[t]])},setTitle:function(t){var e=this.slides[t].firstChild.title,i=this.titleElement;i.length&&(this.titleElement.empty(),e&&i[0].appendChild(document.createTextNode(e)))},setTimeout:function(t,e,i){var s=this;return t&&window.setTimeout(function(){t.apply(s,e||[])},i||0)},imageFactory:function(e,i){function s(e){if(!o){if(e={type:e.type,target:n},!n.parentNode)return a.setTimeout(s,[e]);o=!0,t(r).off("load error",s),d&&"load"===e.type&&(n.style.background='url("'+h+'") center no-repeat',n.style.backgroundSize=d),i(e)}}var o,n,l,a=this,r=this.imagePrototype.cloneNode(!1),h=e,d=this.options.stretchImages;return"string"!=typeof h&&(h=this.getItemProperty(e,this.options.urlProperty),l=this.getItemProperty(e,this.options.titleProperty)),d===!0&&(d="contain"),d=this.support.backgroundSize&&this.support.backgroundSize[d]&&d,d?n=this.elementPrototype.cloneNode(!1):(n=r,r.draggable=!1),l&&(n.title=l),t(r).on("load error",s),r.src=h,n},createElement:function(e,i){var s=e&&this.getItemProperty(e,this.options.typeProperty),o=s&&this[s.split("/")[0]+"Factory"]||this.imageFactory,n=e&&o.call(this,e,i),l=this.getItemProperty(e,this.options.srcsetProperty);return n||(n=this.elementPrototype.cloneNode(!1),this.setTimeout(i,[{type:"error",target:n}])),l&&n.setAttribute("srcset",l),t(n).addClass(this.options.slideContentClass),n},loadElement:function(e){this.elements[e]||(this.slides[e].firstChild?this.elements[e]=t(this.slides[e]).hasClass(this.options.slideErrorClass)?3:2:(this.elements[e]=1,t(this.slides[e]).addClass(this.options.slideLoadingClass),this.slides[e].appendChild(this.createElement(this.list[e],this.proxyListener))))},loadElements:function(t){var e,i=Math.min(this.num,2*this.options.preloadRange+1),s=t;for(e=0;i>e;e+=1)s+=e*(e%2===0?-1:1),s=this.circle(s),this.loadElement(s)},unloadElements:function(t){var e,i;for(e in this.elements)this.elements.hasOwnProperty(e)&&(i=Math.abs(t-e),i>this.options.preloadRange&&i+this.options.preloadRange<this.num&&(this.unloadSlide(e),delete this.elements[e]))},addSlide:function(t){var e=this.slidePrototype.cloneNode(!1);e.setAttribute("data-index",t),this.slidesContainer[0].appendChild(e),this.slides.push(e)},positionSlide:function(t){var e=this.slides[t];e.style.width=this.slideWidth+"px",this.support.transform&&(e.style.left=t*-this.slideWidth+"px",this.move(t,this.index>t?-this.slideWidth:this.index<t?this.slideWidth:0,0))},initSlides:function(e){var i,s;for(e||(this.positions=[],this.positions.length=this.num,this.elements={},this.imagePrototype=document.createElement("img"),this.elementPrototype=document.createElement("div"),this.slidePrototype=document.createElement("div"),t(this.slidePrototype).addClass(this.options.slideClass),this.slides=this.slidesContainer[0].children,i=this.options.clearSlides||this.slides.length!==this.num),this.slideWidth=this.container[0].offsetWidth,this.slideHeight=this.container[0].offsetHeight,this.slidesContainer[0].style.width=this.num*this.slideWidth+"px",i&&this.resetSlides(),s=0;s<this.num;s+=1)i&&this.addSlide(s),this.positionSlide(s);this.options.continuous&&this.support.transform&&(this.move(this.circle(this.index-1),-this.slideWidth,0),this.move(this.circle(this.index+1),this.slideWidth,0)),this.support.transform||(this.slidesContainer[0].style.left=this.index*-this.slideWidth+"px")},unloadSlide:function(t){var e,i;e=this.slides[t],i=e.firstChild,null!==i&&e.removeChild(i)},unloadAllSlides:function(){var t,e;for(t=0,e=this.slides.length;e>t;t++)this.unloadSlide(t)},toggleControls:function(){var t=this.options.controlsClass;this.container.hasClass(t)?this.container.removeClass(t):this.container.addClass(t)},toggleSlideshow:function(){this.interval?this.pause():this.play()},getNodeIndex:function(t){return parseInt(t.getAttribute("data-index"),10)},getNestedProperty:function(t,e){return e.replace(/\[(?:'([^']+)'|"([^"]+)"|(\d+))\]|(?:(?:^|\.)([^\.\[]+))/g,function(e,i,s,o,n){var l=n||i||s||o&&parseInt(o,10);e&&t&&(t=t[l])}),t},getDataProperty:function(e,i){if(e.getAttribute){var s=e.getAttribute("data-"+i.replace(/([A-Z])/g,"-$1").toLowerCase());if("string"==typeof s){if(/^(true|false|null|-?\d+(\.\d+)?|\{[\s\S]*\}|\[[\s\S]*\])$/.test(s))try{return t.parseJSON(s)}catch(o){}return s}}},getItemProperty:function(t,e){var i=t[e];return void 0===i&&(i=this.getDataProperty(t,e),void 0===i&&(i=this.getNestedProperty(t,e))),i},initStartIndex:function(){var t,e=this.options.index,i=this.options.urlProperty;if(e&&"number"!=typeof e)for(t=0;t<this.num;t+=1)if(this.list[t]===e||this.getItemProperty(this.list[t],i)===this.getItemProperty(e,i)){e=t;break}this.index=this.circle(parseInt(e,10)||0)},initEventListeners:function(){function e(t){var e=i.support.transition&&i.support.transition.end===t.type?"transitionend":t.type;i["on"+e](t)}var i=this,s=this.slidesContainer;t(window).on("resize",e),t(document.body).on("keydown",e),this.container.on("click",e),this.support.touch?s.on("touchstart touchmove touchend touchcancel",e):this.options.emulateTouchEvents&&this.support.transition&&s.on("mousedown mousemove mouseup mouseout",e),this.support.transition&&s.on(this.support.transition.end,e),this.proxyListener=e},destroyEventListeners:function(){var e=this.slidesContainer,i=this.proxyListener;t(window).off("resize",i),t(document.body).off("keydown",i),this.container.off("click",i),this.support.touch?e.off("touchstart touchmove touchend touchcancel",i):this.options.emulateTouchEvents&&this.support.transition&&e.off("mousedown mousemove mouseup mouseout",i),this.support.transition&&e.off(this.support.transition.end,i)},handleOpen:function(){this.options.onopened&&this.options.onopened.call(this)},initWidget:function(){function e(t){t.target===i.container[0]&&(i.container.off(i.support.transition.end,e),i.handleOpen())}var i=this;return this.container=t(this.options.container),this.container.length?(this.slidesContainer=this.container.find(this.options.slidesContainer).first(),this.slidesContainer.length?(this.titleElement=this.container.find(this.options.titleElement).first(),1===this.num&&this.container.addClass(this.options.singleClass),this.options.onopen&&this.options.onopen.call(this),this.support.transition&&this.options.displayTransition?this.container.on(this.support.transition.end,e):this.handleOpen(),this.options.hidePageScrollbars&&(this.bodyOverflowStyle=document.body.style.overflow,document.body.style.overflow="hidden"),this.container[0].style.display="block",this.initSlides(),void this.container.addClass(this.options.displayClass)):(this.console.log("blueimp Gallery: Slides container not found.",this.options.slidesContainer),!1)):(this.console.log("blueimp Gallery: Widget container not found.",this.options.container),!1)},initOptions:function(e){this.options=t.extend({},this.options),(e&&e.carousel||this.options.carousel&&(!e||e.carousel!==!1))&&t.extend(this.options,this.carouselOptions),t.extend(this.options,e),this.num<3&&(this.options.continuous=this.options.continuous?null:!1),this.support.transition||(this.options.emulateTouchEvents=!1),this.options.event&&this.preventDefault(this.options.event)}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper","./blueimp-gallery"],t):t(window.blueimp.helper||window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";t.extend(e.prototype.options,{fullScreen:!1});var i=e.prototype.initialize,s=e.prototype.close;return t.extend(e.prototype,{getFullScreenElement:function(){return document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement},requestFullScreen:function(t){t.requestFullscreen?t.requestFullscreen():t.webkitRequestFullscreen?t.webkitRequestFullscreen():t.mozRequestFullScreen?t.mozRequestFullScreen():t.msRequestFullscreen&&t.msRequestFullscreen()},exitFullScreen:function(){document.exitFullscreen?document.exitFullscreen():document.webkitCancelFullScreen?document.webkitCancelFullScreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.msExitFullscreen&&document.msExitFullscreen()},initialize:function(){i.call(this),this.options.fullScreen&&!this.getFullScreenElement()&&this.requestFullScreen(this.container[0])},close:function(){this.getFullScreenElement()===this.container[0]&&this.exitFullScreen(),s.call(this)}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper","./blueimp-gallery"],t):t(window.blueimp.helper||window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";t.extend(e.prototype.options,{indicatorContainer:"ol",activeIndicatorClass:"active",thumbnailProperty:"thumbnail",thumbnailIndicators:!0});var i=e.prototype.initSlides,s=e.prototype.addSlide,o=e.prototype.resetSlides,n=e.prototype.handleClick,l=e.prototype.handleSlide,a=e.prototype.handleClose;return t.extend(e.prototype,{createIndicator:function(e){var i,s,o=this.indicatorPrototype.cloneNode(!1),n=this.getItemProperty(e,this.options.titleProperty),l=this.options.thumbnailProperty;return this.options.thumbnailIndicators&&(l&&(i=this.getItemProperty(e,l)),void 0===i&&(s=e.getElementsByTagName&&t(e).find("img")[0],s&&(i=s.src)),i&&(o.style.backgroundImage='url("'+i+'")')),n&&(o.title=n),o},addIndicator:function(t){if(this.indicatorContainer.length){var e=this.createIndicator(this.list[t]);e.setAttribute("data-index",t),this.indicatorContainer[0].appendChild(e),this.indicators.push(e)}},setActiveIndicator:function(e){this.indicators&&(this.activeIndicator&&this.activeIndicator.removeClass(this.options.activeIndicatorClass),this.activeIndicator=t(this.indicators[e]),this.activeIndicator.addClass(this.options.activeIndicatorClass))},initSlides:function(t){t||(this.indicatorContainer=this.container.find(this.options.indicatorContainer),this.indicatorContainer.length&&(this.indicatorPrototype=document.createElement("li"),this.indicators=this.indicatorContainer[0].children)),i.call(this,t)},addSlide:function(t){s.call(this,t),this.addIndicator(t)},resetSlides:function(){o.call(this),this.indicatorContainer.empty(),this.indicators=[]},handleClick:function(t){var e=t.target||t.srcElement,i=e.parentNode;if(i===this.indicatorContainer[0])this.preventDefault(t),this.slide(this.getNodeIndex(e));else{if(i.parentNode!==this.indicatorContainer[0])return n.call(this,t);this.preventDefault(t),this.slide(this.getNodeIndex(i))}},handleSlide:function(t){l.call(this,t),this.setActiveIndicator(t)},handleClose:function(){this.activeIndicator&&this.activeIndicator.removeClass(this.options.activeIndicatorClass),a.call(this)}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper","./blueimp-gallery"],t):t(window.blueimp.helper||window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";t.extend(e.prototype.options,{videoContentClass:"video-content",videoLoadingClass:"video-loading",videoPlayingClass:"video-playing",videoPosterProperty:"poster",videoSourcesProperty:"sources"});var i=e.prototype.handleSlide;return t.extend(e.prototype,{handleSlide:function(t){i.call(this,t),this.playingVideo&&this.playingVideo.pause()},videoFactory:function(e,i,s){var o,n,l,a,r,h=this,d=this.options,c=this.elementPrototype.cloneNode(!1),u=t(c),p=[{type:"error",target:c}],y=s||document.createElement("video"),m=this.getItemProperty(e,d.urlProperty),f=this.getItemProperty(e,d.typeProperty),g=this.getItemProperty(e,d.titleProperty),v=this.getItemProperty(e,d.videoPosterProperty),C=this.getItemProperty(e,d.videoSourcesProperty);if(u.addClass(d.videoContentClass),g&&(c.title=g),y.canPlayType)if(m&&f&&y.canPlayType(f))y.src=m;else for(;C&&C.length;)if(n=C.shift(),m=this.getItemProperty(n,d.urlProperty),f=this.getItemProperty(n,d.typeProperty),m&&f&&y.canPlayType(f)){y.src=m;break}return v&&(y.poster=v,o=this.imagePrototype.cloneNode(!1),t(o).addClass(d.toggleClass),o.src=v,o.draggable=!1,c.appendChild(o)),l=document.createElement("a"),l.setAttribute("target","_blank"),s||l.setAttribute("download",g),l.href=m,y.src&&(y.controls=!0,(s||t(y)).on("error",function(){h.setTimeout(i,p)}).on("pause",function(){a=!1,u.removeClass(h.options.videoLoadingClass).removeClass(h.options.videoPlayingClass),r&&h.container.addClass(h.options.controlsClass),delete h.playingVideo,h.interval&&h.play()}).on("playing",function(){a=!1,u.removeClass(h.options.videoLoadingClass).addClass(h.options.videoPlayingClass),h.container.hasClass(h.options.controlsClass)?(r=!0,h.container.removeClass(h.options.controlsClass)):r=!1}).on("play",function(){window.clearTimeout(h.timeout),a=!0,u.addClass(h.options.videoLoadingClass),h.playingVideo=y}),t(l).on("click",function(t){h.preventDefault(t),a?y.pause():y.play()}),c.appendChild(s&&s.element||y)),c.appendChild(l),this.setTimeout(i,[{type:"load",target:c}]),c}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper","./blueimp-gallery-video"],t):t(window.blueimp.helper||window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";if(!window.postMessage)return e;t.extend(e.prototype.options,{vimeoVideoIdProperty:"vimeo",vimeoPlayerUrl:"//player.vimeo.com/video/VIDEO_ID?api=1&player_id=PLAYER_ID",vimeoPlayerIdPrefix:"vimeo-player-",vimeoClickToPlay:!0});var i=e.prototype.textFactory||e.prototype.imageFactory,s=function(t,e,i,s){this.url=t,this.videoId=e,this.playerId=i,this.clickToPlay=s,this.element=document.createElement("div"),this.listeners={}},o=0;return t.extend(s.prototype,{canPlayType:function(){return!0},on:function(t,e){return this.listeners[t]=e,this},loadAPI:function(){function e(){!s&&o.playOnReady&&o.play(),s=!0}for(var i,s,o=this,n="//f.vimeocdn.com/js/froogaloop2.min.js",l=document.getElementsByTagName("script"),a=l.length;a;)if(a-=1,l[a].src===n){i=l[a];break}i||(i=document.createElement("script"),i.src=n),t(i).on("load",e),l[0].parentNode.insertBefore(i,l[0]),/loaded|complete/.test(i.readyState)&&e()},onReady:function(){var t=this;this.ready=!0,this.player.addEvent("play",function(){t.hasPlayed=!0,t.onPlaying()}),this.player.addEvent("pause",function(){t.onPause()}),this.player.addEvent("finish",function(){t.onPause()}),this.playOnReady&&this.play()},onPlaying:function(){this.playStatus<2&&(this.listeners.playing(),this.playStatus=2)},onPause:function(){this.listeners.pause(),delete this.playStatus},insertIframe:function(){var t=document.createElement("iframe");t.src=this.url.replace("VIDEO_ID",this.videoId).replace("PLAYER_ID",this.playerId),t.id=this.playerId,this.element.parentNode.replaceChild(t,this.element),this.element=t},play:function(){var t=this;this.playStatus||(this.listeners.play(),this.playStatus=1),this.ready?!this.hasPlayed&&(this.clickToPlay||window.navigator&&/iP(hone|od|ad)/.test(window.navigator.platform))?this.onPlaying():this.player.api("play"):(this.playOnReady=!0,window.$f?this.player||(this.insertIframe(),this.player=$f(this.element),this.player.addEvent("ready",function(){t.onReady()})):this.loadAPI())},pause:function(){this.ready?this.player.api("pause"):this.playStatus&&(delete this.playOnReady,this.listeners.pause(),delete this.playStatus)}}),t.extend(e.prototype,{VimeoPlayer:s,textFactory:function(t,e){var n=this.options,l=this.getItemProperty(t,n.vimeoVideoIdProperty);return l?(void 0===this.getItemProperty(t,n.urlProperty)&&(t[n.urlProperty]="//vimeo.com/"+l),o+=1,this.videoFactory(t,e,new s(n.vimeoPlayerUrl,l,n.vimeoPlayerIdPrefix+o,n.vimeoClickToPlay))):i.call(this,t,e)}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["./blueimp-helper","./blueimp-gallery-video"],t):t(window.blueimp.helper||window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";if(!window.postMessage)return e;t.extend(e.prototype.options,{youTubeVideoIdProperty:"youtube",youTubePlayerVars:{wmode:"transparent"},youTubeClickToPlay:!0});var i=e.prototype.textFactory||e.prototype.imageFactory,s=function(t,e,i){this.videoId=t,this.playerVars=e,this.clickToPlay=i,this.element=document.createElement("div"),this.listeners={}};return t.extend(s.prototype,{canPlayType:function(){return!0},on:function(t,e){return this.listeners[t]=e,this},loadAPI:function(){var t,e=this,i=window.onYouTubeIframeAPIReady,s="//www.youtube.com/iframe_api",o=document.getElementsByTagName("script"),n=o.length;for(window.onYouTubeIframeAPIReady=function(){i&&i.apply(this),e.playOnReady&&e.play()};n;)if(n-=1,o[n].src===s)return;t=document.createElement("script"),t.src=s,o[0].parentNode.insertBefore(t,o[0])},onReady:function(){this.ready=!0,this.playOnReady&&this.play()},onPlaying:function(){this.playStatus<2&&(this.listeners.playing(),this.playStatus=2)},onPause:function(){e.prototype.setTimeout.call(this,this.checkSeek,null,2e3)},checkSeek:function(){(this.stateChange===YT.PlayerState.PAUSED||this.stateChange===YT.PlayerState.ENDED)&&(this.listeners.pause(),delete this.playStatus)},onStateChange:function(t){switch(t.data){case YT.PlayerState.PLAYING:this.hasPlayed=!0,this.onPlaying();break;case YT.PlayerState.PAUSED:case YT.PlayerState.ENDED:this.onPause()}this.stateChange=t.data},onError:function(t){this.listeners.error(t)},play:function(){var t=this;this.playStatus||(this.listeners.play(),this.playStatus=1),this.ready?!this.hasPlayed&&(this.clickToPlay||window.navigator&&/iP(hone|od|ad)/.test(window.navigator.platform))?this.onPlaying():this.player.playVideo():(this.playOnReady=!0,window.YT&&YT.Player?this.player||(this.player=new YT.Player(this.element,{videoId:this.videoId,playerVars:this.playerVars,events:{onReady:function(){t.onReady()},onStateChange:function(e){t.onStateChange(e)},onError:function(e){t.onError(e)}}})):this.loadAPI())},pause:function(){this.ready?this.player.pauseVideo():this.playStatus&&(delete this.playOnReady,this.listeners.pause(),delete this.playStatus)}}),t.extend(e.prototype,{YouTubePlayer:s,textFactory:function(t,e){var o=this.options,n=this.getItemProperty(t,o.youTubeVideoIdProperty);return n?(void 0===this.getItemProperty(t,o.urlProperty)&&(t[o.urlProperty]="//www.youtube.com/watch?v="+n),void 0===this.getItemProperty(t,o.videoPosterProperty)&&(t[o.videoPosterProperty]="//img.youtube.com/vi/"+n+"/maxresdefault.jpg"),this.videoFactory(t,e,new s(n,o.youTubePlayerVars,o.youTubeClickToPlay))):i.call(this,t,e)}}),e}),function(t){"use strict";"function"==typeof define&&define.amd?define(["jquery","./blueimp-gallery"],t):t(window.jQuery,window.blueimp.Gallery)}(function(t,e){"use strict";t(document).on("click","[data-gallery]",function(i){var s=t(this).data("gallery"),o=t(s),n=o.length&&o||t(e.prototype.options.container),l={onopen:function(){n.data("gallery",this).trigger("open")},onopened:function(){n.trigger("opened")},onslide:function(){n.trigger("slide",arguments)},onslideend:function(){n.trigger("slideend",arguments)},onslidecomplete:function(){n.trigger("slidecomplete",arguments)},onclose:function(){n.trigger("close")},onclosed:function(){n.trigger("closed").removeData("gallery")}},a=t.extend(n.data(),{container:n[0],index:this,event:i},l),r=t('[data-gallery="'+s+'"]');return a.filter&&(r=r.filter(a.filter)),new e(r,a)})});

/*
 * jQuery Iframe Transport Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* global define, require, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    var counter = 0;

    $.ajaxTransport('iframe', function (options) {
        if (options.async) {
            var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',
                form,
                iframe,
                addParamChar;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    counter += 1;
                    iframe = $(
                        '<iframe src="' + initialIframeSrc +
                            '" name="iframe-transport-' + counter + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                try {
                                    response = iframe.contents();
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                $('<iframe src="' + initialIframeSrc + '"></iframe>')
                                    .appendTo(form);
                                window.setTimeout(function () {
                                    form.remove();
                                }, 0);
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                .prop('encoding', 'multipart/form-data');
                            options.fileInput.removeAttr('form');
                        }
                        form.submit();
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                $(input)
                                    .prop('name', clone.prop('name'))
                                    .attr('form', clone.attr('form'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        iframe
                            .unbind('load')
                            .prop('src', initialIframeSrc);
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe xml': function (iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :
                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||
                            $(xmlDoc.body).html());
            },
            'iframe script': function (iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

/*
 * jQuery File Upload Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, document, location, Blob, FormData */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(
            require('jquery'),
            require('./vendor/jquery.ui.widget')
        );
    } else {
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    $.support.fileInput = !(new RegExp(
        '(Android (1\\.[0156]|2\\.[01]))' +
            '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
            '|(w(eb)?OSBrowser)|(webOS)' +
            '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
        $('<input type="file">').prop('disabled'));

    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    function getDragHandler(type) {
        var isDragOver = type === 'dragover';
        return function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&
                    this._trigger(
                        type,
                        $.Event(type, {delegatedEvent: e})
                    ) !== false) {
                e.preventDefault();
                if (isDragOver) {
                    dataTransfer.dropEffect = 'copy';
                }
            }
        };
    }

    $.widget('blueimp.fileupload', {

        options: {
            dropZone: $(document),
            pasteZone: undefined,
            fileInput: undefined,
            replaceFileInput: true,
            paramName: undefined,
            singleFileUploads: true,
            limitMultiFileUploads: undefined,
            limitMultiFileUploadSize: undefined,
            limitMultiFileUploadSizeOverhead: 512,
            sequentialUploads: false,
            limitConcurrentUploads: undefined,
            forceIframeTransport: false,
            redirect: undefined,
            redirectParamName: undefined,
            postMessage: undefined,
            multipart: true,
            maxChunkSize: undefined,
            uploadedBytes: undefined,
            recalculateProgress: true,
            progressInterval: 100,
            bitrateInterval: 500,
            autoUpload: true,

            messages: {
                uploadedBytes: 'Uploaded bytes exceed file size'
            },

            i18n: function (message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function (key, value) {
                        message = message.replace('{' + key + '}', value);
                    });
                }
                return message;
            },

            formData: function (form) {
                return form.serializeArray();
            },

            add: function (e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                if (data.autoUpload || (data.autoUpload !== false &&
                        $(this).fileupload('option', 'autoUpload'))) {
                    data.process().done(function () {
                        data.submit();
                    });
                }
            },

            processData: false,
            contentType: false,
            cache: false,
            timeout: 0
        },

        _specialOptions: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _blobSlice: $.support.blobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },

        _BitrateTimer: function () {
            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if ($.type(options.formData) === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === 'object') {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            var progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },

        _initResponseObject: function (obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                this._trigger(
                    'progress',
                    $.Event('progress', {delegatedEvent: e}),
                    data
                );
                this._trigger(
                    'progressall',
                    $.Event('progressall', {delegatedEvent: e}),
                    this._progress
                );
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _isInstanceOf: function (type, obj) {
            return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        },

        _initXHRData: function (options) {
            var that = this,
                formData,
                file = options.files[0],
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = $.type(options.paramName) === 'array' ?
                    options.paramName[0] : options.paramName;
            options.headers = $.extend({}, options.headers);
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type || 'application/octet-stream';
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: ($.type(options.paramName) === 'array' &&
                                    options.paramName[index]) || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf('FormData', options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            if (that._isInstanceOf('File', file) ||
                                    that._isInstanceOf('Blob', file)) {
                                formData.append(
                                    ($.type(options.paramName) === 'array' &&
                                        options.paramName[index]) || paramName,
                                    file,
                                    file.uploadName || file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            var targetHost = $('<a></a>').prop('href', options.url).prop('host');
            options.dataType = 'iframe ' + (options.dataType || '');
            options.formData = this._getFormData(options);
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options);
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            options.type = (options.type ||
                ($.type(options.form.prop('method')) === 'string' &&
                    options.form.prop('method')) || ''
                ).toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        _addConvenienceMethods: function (e, data) {
            var that = this,
                getPromise = function (args) {
                    return $.Deferred().resolveWith(that, args).promise();
                };
            data.process = function (resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue =
                        (this._processQueue || getPromise([this])).then(
                            function () {
                                if (data.errorThrown) {
                                    return $.Deferred()
                                        .rejectWith(that, [data]).promise();
                                }
                                return getPromise(arguments);
                            }
                        ).then(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise([this]);
            };
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger(
                            'submit',
                            $.Event('submit', {delegatedEvent: e}),
                            this
                        ) !== false) && that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                this.errorThrown = 'abort';
                that._trigger('fail', null, this);
                return that._getXHRPromise(false);
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.processing = function () {
                return !this.jqXHR && this._processQueue && that
                    ._getDeferredState(this._processQueue) === 'pending';
            };
            data.progress = function () {
                return this._progress;
            };
            data.response = function () {
                return this._response;
            };
        },

        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        _chunkedUpload: function (options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes,
                mcs = options.maxChunkSize || fs,
                slice = this._blobSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n('uploadedBytes');
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            upload = function () {
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                o.chunkSize = o.blob.size;
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                that._initXHRData(o);
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        if (currentLoaded + o.chunkSize - o._progress.loaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                this._trigger('start');
                this._bitrateTimer = new this._BitrateTimer();
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total,
                response = options._response;
            if (options._progress.loaded < total) {
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            this._trigger('always', null, options);
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger(
                            'send',
                            $.Event('send', {delegatedEvent: e}),
                            options
                        ) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        that._sending -= 1;
                        that._active -= 1;
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                        if (that._active === 0) {
                            that._trigger('stop');
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.then(send);
                } else {
                    this._sequence = this._sequence.then(send, send);
                    pipe = this._sequence;
                }
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                files = data.files,
                filesLength = files.length,
                limit = options.limitMultiFileUploads,
                limitSize = options.limitMultiFileUploadSize,
                overhead = options.limitMultiFileUploadSizeOverhead,
                batchSize = 0,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i,
                j = 0;
            if (!filesLength) {
                return false;
            }
            if (limitSize && files[0].size === undefined) {
                limitSize = undefined;
            }
            if (!(options.singleFileUploads || limit || limitSize) ||
                    !this._isXHRUpload(options)) {
                fileSet = [files];
                paramNameSet = [paramName];
            } else if (!(options.singleFileUploads || limitSize) && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i += limit) {
                    fileSet.push(files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else if (!options.singleFileUploads && limitSize) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i = i + 1) {
                    batchSize += files[i].size + overhead;
                    if (i + 1 === filesLength ||
                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||
                            (limit && i + 1 - j >= limit)) {
                        fileSet.push(files.slice(j, i + 1));
                        paramNameSlice = paramName.slice(j, i + 1);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                        j = i + 1;
                        batchSize = 0;
                    }
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = files;
            $.each(fileSet || files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger(
                    'add',
                    $.Event('add', {delegatedEvent: e}),
                    newData
                );
                return result;
            });
            return result;
        },

        _replaceFileInput: function (data) {
            var input = data.fileInput,
                inputClone = input.clone(true),
                restoreFocus = input.is(document.activeElement);
            data.fileInputClone = inputClone;
            $('<form></form>').append(inputClone)[0].reset();
            input.after(inputClone).detach();
            if (restoreFocus) {
                inputClone.focus();
            }
            $.cleanData(input.unbind('remove'));
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    dfd.resolve([e]);
                },
                successHandler = function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                },
                readEntries = function () {
                    dirReader.readEntries(function (results) {
                        if (!results.length) {
                            successHandler(entries);
                        } else {
                            entries = entries.concat(results);
                            readEntries();
                        }
                    }, errorHandler);
                },
                dirReader, entries = [];
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                readEntries();
            } else {
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).then(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).then(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data);
                }
                if (that._trigger(
                        'change',
                        $.Event('change', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                    e.originalEvent.clipboardData.items,
                data = {files: []};
            if (items && items.length) {
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger(
                        'paste',
                        $.Event('paste', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    this._onAdd(e, data);
                }
            }
        },

        _onDrop: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this,
                dataTransfer = e.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function (files) {
                    data.files = files;
                    if (that._trigger(
                            'drop',
                            $.Event('drop', {delegatedEvent: e}),
                            data
                        ) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },

        _onDragOver: getDragHandler('dragover'),

        _onDragEnter: getDragHandler('dragenter'),

        _onDragLeave: getDragHandler('dragleave'),

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop,
                    dragenter: this._onDragEnter,
                    dragleave: this._onDragLeave
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            if ($.support.fileInput) {
                this._on(this.options.fileInput, {
                    change: this._onChange
                });
            }
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _getRegExp: function (str) {
            var parts = str.split('/'),
                modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join('/'), modifiers);
        },

        _isRegExpOption: function (key, value) {
            return key !== 'url' && $.type(value) === 'string' &&
                /^\/.*\/[igm]{0,3}$/.test(value);
        },

        _initDataAttributes: function () {
            var that = this,
                options = this.options,
                data = this.element.data();
            $.each(
                this.element[0].attributes,
                function (index, attr) {
                    var key = attr.name.toLowerCase(),
                        value;
                    if (/^data-/.test(key)) {
                        key = key.slice(5).replace(/-[a-z]/g, function (str) {
                            return str.charAt(1).toUpperCase();
                        });
                        value = data[key];
                        if (that._isRegExpOption(key, value)) {
                            value = that._getRegExp(value);
                        }
                        options[key] = value;
                    }
                }
            );
        },

        _create: function () {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        active: function () {
            return this._active;
        },

        progress: function () {
            return this._progress;
        },

        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            if (!files.length) {
                                dfd.reject();
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data);
                            jqXHR.then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

/*
 * jQuery File Upload Processing Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            './jquery.fileupload'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(
            window.jQuery
        );
    }
}(function ($) {
    'use strict';

    var originalAdd = $.blueimp.fileupload.prototype.options.add;

    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            processQueue: [
                /*
                {
                    action: 'log',
                    type: 'debug'
                }
                */
            ],
            add: function (e, data) {
                var $this = $(this);
                data.process(function () {
                    return $this.fileupload('process', data);
                });
                originalAdd.call(this, e, data);
            }
        },

        processActions: {
            /*
            log: function (data, options) {
                console[options.type](
                    'Processing "' + data.files[data.index].name + '"'
                );
            }
            */
        },

        _processFile: function (data, originalData) {
            var that = this,
                dfd = $.Deferred().resolveWith(that, [data]),
                chain = dfd.promise();
            this._trigger('process', null, data);
            $.each(data.processQueue, function (i, settings) {
                var func = function (data) {
                    if (originalData.errorThrown) {
                        return $.Deferred()
                                .rejectWith(that, [originalData]).promise();
                    }
                    return that.processActions[settings.action].call(
                        that,
                        data,
                        settings
                    );
                };
                chain = chain.then(func, settings.always && func);
            });
            chain
                .done(function () {
                    that._trigger('processdone', null, data);
                    that._trigger('processalways', null, data);
                })
                .fail(function () {
                    that._trigger('processfail', null, data);
                    that._trigger('processalways', null, data);
                });
            return chain;
        },

        _transformProcessQueue: function (options) {
            var processQueue = [];
            $.each(options.processQueue, function () {
                var settings = {},
                    action = this.action,
                    prefix = this.prefix === true ? action : this.prefix;
                $.each(this, function (key, value) {
                    if ($.type(value) === 'string' &&
                            value.charAt(0) === '@') {
                        settings[key] = options[
                            value.slice(1) || (prefix ? prefix +
                                key.charAt(0).toUpperCase() + key.slice(1) : key)
                        ];
                    } else {
                        settings[key] = value;
                    }

                });
                processQueue.push(settings);
            });
            options.processQueue = processQueue;
        },

        processing: function () {
            return this._processing;
        },

        process: function (data) {
            var that = this,
                options = $.extend({}, this.options, data);
            if (options.processQueue && options.processQueue.length) {
                this._transformProcessQueue(options);
                if (this._processing === 0) {
                    this._trigger('processstart');
                }
                $.each(data.files, function (index) {
                    var opts = index ? $.extend({}, options) : options,
                        func = function () {
                            if (data.errorThrown) {
                                return $.Deferred()
                                        .rejectWith(that, [data]).promise();
                            }
                            return that._processFile(opts, data);
                        };
                    opts.index = index;
                    that._processing += 1;
                    that._processingQueue = that._processingQueue.then(func, func)
                        .always(function () {
                            that._processing -= 1;
                            if (that._processing === 0) {
                                that._trigger('processstop');
                            }
                        });
                });
            }
            return this._processingQueue;
        },

        _create: function () {
            this._super();
            this._processing = 0;
            this._processingQueue = $.Deferred().resolveWith(this)
                .promise();
        }

    });

}));

/*
 * jQuery File Upload Image Preview & Resize Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, Blob */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'load-image',
            'load-image-meta',
            'load-image-exif',
            'canvas-to-blob',
            './jquery.fileupload-process'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(
            require('jquery'),
            require('blueimp-load-image/js/load-image'),
            require('blueimp-load-image/js/load-image-meta'),
            require('blueimp-load-image/js/load-image-exif'),
            require('blueimp-canvas-to-blob'),
            require('./jquery.fileupload-process')
        );
    } else {
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadImageMetaData',
            disableImageHead: '@',
            disableExif: '@',
            disableExifThumbnail: '@',
            disableExifSub: '@',
            disableExifGps: '@',
            disabled: '@disableImageMetaDataLoad'
        },
        {
            action: 'loadImage',
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            noRevoke: '@',
            disabled: '@disableImageLoad'
        },
        {
            action: 'resizeImage',
            prefix: 'image',
            maxWidth: '@',
            maxHeight: '@',
            minWidth: '@',
            minHeight: '@',
            crop: '@',
            orientation: '@',
            forceResize: '@',
            disabled: '@disableImageResize'
        },
        {
            action: 'saveImage',
            quality: '@imageQuality',
            type: '@imageType',
            disabled: '@disableImageResize'
        },
        {
            action: 'saveImageMetaData',
            disabled: '@disableImageMetaDataSave'
        },
        {
            action: 'resizeImage',
            prefix: 'preview',
            maxWidth: '@',
            maxHeight: '@',
            minWidth: '@',
            minHeight: '@',
            crop: '@',
            orientation: '@',
            thumbnail: '@',
            canvas: '@',
            disabled: '@disableImagePreview'
        },
        {
            action: 'setImage',
            name: '@imagePreviewName',
            disabled: '@disableImagePreview'
        },
        {
            action: 'deleteImageReferences',
            disabled: '@disableImageReferencesDeletion'
        }
    );

    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            loadImageFileTypes: /^image\/(gif|jpeg|png|svg\+xml)$/,
            loadImageMaxFileSize: 10000000, /* 10MB*/
            imageMaxWidth: 1920,
            imageMaxHeight: 1080,
            imageOrientation: false,
            imageCrop: false,
            disableImageResize: true,
            previewMaxWidth: 80,
            previewMaxHeight: 80,
            previewOrientation: true,
            previewThumbnail: true,
            previewCrop: false,
            previewCanvas: true
        },

        processActions: {

            loadImage: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred();
                if (($.type(options.maxFileSize) === 'number' &&
                            file.size > options.maxFileSize) ||
                        (options.fileTypes &&
                            !options.fileTypes.test(file.type)) ||
                        !loadImage(
                            file,
                            function (img) {
                                if (img.src) {
                                    data.img = img;
                                }
                                dfd.resolveWith(that, [data]);
                            },
                            options
                        )) {
                    return data;
                }
                return dfd.promise();
            },

            resizeImage: function (data, options) {
                if (options.disabled || !(data.canvas || data.img)) {
                    return data;
                }
                options = $.extend({canvas: true}, options);
                var that = this,
                    dfd = $.Deferred(),
                    img = (options.canvas && data.canvas) || data.img,
                    resolve = function (newImg) {
                        if (newImg && (newImg.width !== img.width ||
                                newImg.height !== img.height ||
                                options.forceResize)) {
                            data[newImg.getContext ? 'canvas' : 'img'] = newImg;
                        }
                        data.preview = newImg;
                        dfd.resolveWith(that, [data]);
                    },
                    thumbnail;
                if (data.exif) {
                    if (options.orientation === true) {
                        options.orientation = data.exif.get('Orientation');
                    }
                    if (options.thumbnail) {
                        thumbnail = data.exif.get('Thumbnail');
                        if (thumbnail) {
                            loadImage(thumbnail, resolve, options);
                            return dfd.promise();
                        }
                    }
                    if (data.orientation) {
                        delete options.orientation;
                    } else {
                        data.orientation = options.orientation;
                    }
                }
                if (img) {
                    resolve(loadImage.scale(img, options));
                    return dfd.promise();
                }
                return data;
            },

            saveImage: function (data, options) {
                if (!data.canvas || options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred();
                if (data.canvas.toBlob) {
                    data.canvas.toBlob(
                        function (blob) {
                            if (!blob.name) {
                                if (file.type === blob.type) {
                                    blob.name = file.name;
                                } else if (file.name) {
                                    blob.name = file.name.replace(
                                        /\.\w+$/,
                                        '.' + blob.type.substr(6)
                                    );
                                }
                            }
                            if (file.type !== blob.type) {
                                delete data.imageHead;
                            }
                            data.files[data.index] = blob;
                            dfd.resolveWith(that, [data]);
                        },
                        options.type || file.type,
                        options.quality
                    );
                } else {
                    return data;
                }
                return dfd.promise();
            },

            loadImageMetaData: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    dfd = $.Deferred();
                loadImage.parseMetaData(data.files[data.index], function (result) {
                    $.extend(data, result);
                    dfd.resolveWith(that, [data]);
                }, options);
                return dfd.promise();
            },

            saveImageMetaData: function (data, options) {
                if (!(data.imageHead && data.canvas &&
                        data.canvas.toBlob && !options.disabled)) {
                    return data;
                }
                var file = data.files[data.index],
                    blob = new Blob([
                        data.imageHead,
                        this._blobSlice.call(file, 20)
                    ], {type: file.type});
                blob.name = file.name;
                data.files[data.index] = blob;
                return data;
            },

            setImage: function (data, options) {
                if (data.preview && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = data.preview;
                }
                return data;
            },

            deleteImageReferences: function (data, options) {
                if (!options.disabled) {
                    delete data.img;
                    delete data.canvas;
                    delete data.preview;
                    delete data.imageHead;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Audio Preview Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'load-image',
            './jquery.fileupload-process'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(
            require('jquery'),
            require('load-image')
        );
    } else {
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadAudio',
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            disabled: '@disableAudioPreview'
        },
        {
            action: 'setAudio',
            name: '@audioPreviewName',
            disabled: '@disableAudioPreview'
        }
    );

    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            loadAudioFileTypes: /^audio\/.*$/
        },

        _audioElement: document.createElement('audio'),

        processActions: {

            loadAudio: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var file = data.files[data.index],
                    url,
                    audio;
                if (this._audioElement.canPlayType &&
                        this._audioElement.canPlayType(file.type) &&
                        ($.type(options.maxFileSize) !== 'number' ||
                            file.size <= options.maxFileSize) &&
                        (!options.fileTypes ||
                            options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        audio = this._audioElement.cloneNode(false);
                        audio.src = url;
                        audio.controls = true;
                        data.audio = audio;
                        return data;
                    }
                }
                return data;
            },

            setAudio: function (data, options) {
                if (data.audio && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = data.audio;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Video Preview Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'load-image',
            './jquery.fileupload-process'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(
            require('jquery'),
            require('load-image')
        );
    } else {
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadVideo',
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            disabled: '@disableVideoPreview'
        },
        {
            action: 'setVideo',
            name: '@videoPreviewName',
            disabled: '@disableVideoPreview'
        }
    );

    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            loadVideoFileTypes: /^video\/.*$/
        },

        _videoElement: document.createElement('video'),

        processActions: {

            loadVideo: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var file = data.files[data.index],
                    url,
                    video;
                if (this._videoElement.canPlayType &&
                        this._videoElement.canPlayType(file.type) &&
                        ($.type(options.maxFileSize) !== 'number' ||
                            file.size <= options.maxFileSize) &&
                        (!options.fileTypes ||
                            options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        video = this._videoElement.cloneNode(false);
                        video.src = url;
                        video.controls = true;
                        data.video = video;
                        return data;
                    }
                }
                return data;
            },

            setVideo: function (data, options) {
                if (data.video && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = data.video;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Validation Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* global define, require, window */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            './jquery.fileupload-process'
        ], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(
            window.jQuery
        );
    }
}(function ($) {
    'use strict';

    $.blueimp.fileupload.prototype.options.processQueue.push(
        {
            action: 'validate',
            always: true,
            acceptFileTypes: '@',
            maxFileSize: '@',
            minFileSize: '@',
            maxNumberOfFiles: '@',
            disabled: '@disableValidation'
        }
    );

    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {

            getNumberOfFiles: $.noop,

            messages: {
                maxNumberOfFiles: 'Maximum number of files exceeded',
                acceptFileTypes: 'File type not allowed',
                maxFileSize: 'File is too large',
                minFileSize: 'File is too small'
            }
        },

        processActions: {

            validate: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var dfd = $.Deferred(),
                    settings = this.options,
                    file = data.files[data.index],
                    fileSize;
                if (options.minFileSize || options.maxFileSize) {
                    fileSize = file.size;
                }
                if ($.type(options.maxNumberOfFiles) === 'number' &&
                        (settings.getNumberOfFiles() || 0) + data.files.length >
                            options.maxNumberOfFiles) {
                    file.error = settings.i18n('maxNumberOfFiles');
                } else if (options.acceptFileTypes &&
                        !(options.acceptFileTypes.test(file.type) ||
                        options.acceptFileTypes.test(file.name))) {
                    file.error = settings.i18n('acceptFileTypes');
                } else if (fileSize > options.maxFileSize) {
                    file.error = settings.i18n('maxFileSize');
                } else if ($.type(fileSize) === 'number' &&
                        fileSize < options.minFileSize) {
                    file.error = settings.i18n('minFileSize');
                } else {
                    delete file.error;
                }
                if (file.error || data.files.error) {
                    data.files.error = true;
                    dfd.rejectWith(this, [data]);
                } else {
                    dfd.resolveWith(this, [data]);
                }
                return dfd.promise();
            }

        }

    });

}));

/*
 * jQuery File Upload AngularJS Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, angular */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'angular',
            './jquery.fileupload-image',
            './jquery.fileupload-audio',
            './jquery.fileupload-video',
            './jquery.fileupload-validate'
        ], factory);
    } else {
        factory();
    }
}(function () {
    'use strict';

    angular.module('blueimp.fileupload', [])

        .provider('fileUpload', function () {
            var scopeEvalAsync = function (expression) {
                    var scope = angular.element(this)
                            .fileupload('option', 'scope');
                    scope.$evalAsync(expression);
                },
                addFileMethods = function (scope, data) {
                    var files = data.files,
                        file = files[0];
                    angular.forEach(files, function (file, index) {
                        file._index = index;
                        file.$state = function () {
                            return data.state();
                        };
                        file.$processing = function () {
                            return data.processing();
                        };
                        file.$progress = function () {
                            return data.progress();
                        };
                        file.$response = function () {
                            return data.response();
                        };
                    });
                    file.$submit = function () {
                        if (!file.error) {
                            return data.submit();
                        }
                    };
                    file.$cancel = function () {
                        return data.abort();
                    };
                },
                $config;
            $config = this.defaults = {
                handleResponse: function (e, data) {
                    var files = data.result && data.result.files;
                    if (files) {
                        data.scope.replace(data.files, files);
                    } else if (data.errorThrown ||
                            data.textStatus === 'error') {
                        data.files[0].error = data.errorThrown ||
                            data.textStatus;
                    }
                },
                add: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var scope = data.scope,
                        filesCopy = [];
                    angular.forEach(data.files, function (file) {
                        filesCopy.push(file);
                    });
                    scope.$parent.$applyAsync(function () {
                        addFileMethods(scope, data);
                        var method = scope.option('prependFiles') ?
                                'unshift' : 'push';
                        Array.prototype[method].apply(scope.queue, data.files);
                    });
                    data.process(function () {
                        return scope.process(data);
                    }).always(function () {
                        scope.$parent.$applyAsync(function () {
                            addFileMethods(scope, data);
                            scope.replace(filesCopy, data.files);
                        });
                    }).then(function () {
                        if ((scope.option('autoUpload') ||
                                data.autoUpload) &&
                                data.autoUpload !== false) {
                            data.submit();
                        }
                    });
                },
                done: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var that = this;
                    data.scope.$apply(function () {
                        data.handleResponse.call(that, e, data);
                    });
                },
                fail: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var that = this,
                        scope = data.scope;
                    if (data.errorThrown === 'abort') {
                        scope.clear(data.files);
                        return;
                    }
                    scope.$apply(function () {
                        data.handleResponse.call(that, e, data);
                    });
                },
                stop: scopeEvalAsync,
                processstart: scopeEvalAsync,
                processstop: scopeEvalAsync,
                getNumberOfFiles: function () {
                    var scope = this.scope;
                    return scope.queue.length - scope.processing();
                },
                dataType: 'json',
                autoUpload: false
            };
            this.$get = [
                function () {
                    return {
                        defaults: $config
                    };
                }
            ];
        })

        .provider('formatFileSizeFilter', function () {
            var $config = {
                units: [
                    {size: 1000000000, suffix: ' GB'},
                    {size: 1000000, suffix: ' MB'},
                    {size: 1000, suffix: ' KB'}
                ]
            };
            this.defaults = $config;
            this.$get = function () {
                return function (bytes) {
                    if (!angular.isNumber(bytes)) {
                        return '';
                    }
                    var unit = true,
                        i = 0,
                        prefix,
                        suffix;
                    while (unit) {
                        unit = $config.units[i];
                        prefix = unit.prefix || '';
                        suffix = unit.suffix || '';
                        if (i === $config.units.length - 1 || bytes >= unit.size) {
                            return prefix + (bytes / unit.size).toFixed(2) + suffix;
                        }
                        i += 1;
                    }
                };
            };
        })

        .controller('FileUploadController', [
            '$scope', '$element', '$attrs', '$window', 'fileUpload',
            function ($scope, $element, $attrs, $window, fileUpload) {
                var uploadMethods = {
                    progress: function () {
                        return $element.fileupload('progress');
                    },
                    active: function () {
                        return $element.fileupload('active');
                    },
                    option: function (option, data) {
                        if (arguments.length === 1) {
                            return $element.fileupload('option', option);
                        }
                        $element.fileupload('option', option, data);
                    },
                    add: function (data) {
                        return $element.fileupload('add', data);
                    },
                    send: function (data) {
                        return $element.fileupload('send', data);
                    },
                    process: function (data) {
                        return $element.fileupload('process', data);
                    },
                    processing: function (data) {
                        return $element.fileupload('processing', data);
                    }
                };
                $scope.disabled = !$window.jQuery.support.fileInput;
                $scope.queue = $scope.queue || [];
                $scope.clear = function (files) {
                    var queue = this.queue,
                        i = queue.length,
                        file = files,
                        length = 1;
                    if (angular.isArray(files)) {
                        file = files[0];
                        length = files.length;
                    }
                    while (i) {
                        i -= 1;
                        if (queue[i] === file) {
                            return queue.splice(i, length);
                        }
                    }
                };
                $scope.replace = function (oldFiles, newFiles) {
                    var queue = this.queue,
                        file = oldFiles[0],
                        i,
                        j;
                    for (i = 0; i < queue.length; i += 1) {
                        if (queue[i] === file) {
                            for (j = 0; j < newFiles.length; j += 1) {
                                queue[i + j] = newFiles[j];
                            }
                            return;
                        }
                    }
                };
                $scope.applyOnQueue = function (method) {
                    var list = this.queue.slice(0),
                        i,
                        file;
                    for (i = 0; i < list.length; i += 1) {
                        file = list[i];
                        if (file[method]) {
                            file[method]();
                        }
                    }
                };
                $scope.submit = function () {
                    this.applyOnQueue('$submit');
                };
                $scope.cancel = function () {
                    this.applyOnQueue('$cancel');
                };
                angular.extend($scope, uploadMethods);
                $element.fileupload(angular.extend(
                    {scope: $scope},
                    fileUpload.defaults
                )).on('fileuploadadd', function (e, data) {
                    data.scope = $scope;
                    setTimeout(function () {
                    },1000);
                }).on('fileuploadfail', function (e, data) {
                    if (data.errorThrown === 'abort') {
                        return;
                    }
                    if (data.dataType &&
                            data.dataType.indexOf('json') === data.dataType.length - 4) {
                        try {
                            data.result = angular.fromJson(data.jqXHR.responseText);
                        } catch (ignore) {}
                    }
                }).on([
                    'fileuploadadd',
                    'fileuploadsubmit',
                    'fileuploadsend',
                    'fileuploaddone',
                    'fileuploadfail',
                    'fileuploadalways',
                    'fileuploadprogress',
                    'fileuploadprogressall',
                    'fileuploadstart',
                    'fileuploadstop',
                    'fileuploadchange',
                    'fileuploadpaste',
                    'fileuploaddrop',
                    'fileuploaddragover',
                    'fileuploadchunksend',
                    'fileuploadchunkdone',
                    'fileuploadchunkfail',
                    'fileuploadchunkalways',
                    'fileuploadprocessstart',
                    'fileuploadprocess',
                    'fileuploadprocessdone',
                    'fileuploadprocessfail',
                    'fileuploadprocessalways',
                    'fileuploadprocessstop'
                ].join(' '), function (e, data) {
                    $scope.$parent.$applyAsync(function () {
                        if ($scope.$emit(e.type, data).defaultPrevented) {
                            e.preventDefault();
                        }
                    });
                }).on('remove', function () {
                    var method;
                    for (method in uploadMethods) {
                        if (uploadMethods.hasOwnProperty(method)) {
                            delete $scope[method];
                        }
                    }
                });
                $scope.$watch(
                    $attrs.fileUpload,
                    function (newOptions) {
                        if (newOptions) {
                            $element.fileupload('option', newOptions);
                        }
                    }
                );
            }
        ])

        .controller('FileUploadProgressController', [
            '$scope', '$attrs', '$parse',
            function ($scope, $attrs, $parse) {
                var fn = $parse($attrs.fileUploadProgress),
                    update = function () {
                        var progress = fn($scope);
                        if (!progress || !progress.total) {
                            return;
                        }
                        $scope.num = Math.floor(
                            progress.loaded / progress.total * 100
                        );
                    };
                update();
                $scope.$watch(
                    $attrs.fileUploadProgress + '.loaded',
                    function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            update();
                        }
                    }
                );
            }
        ])

        .controller('FileUploadPreviewController', [
            '$scope', '$element', '$attrs',
            function ($scope, $element, $attrs) {
                $scope.$watch(
                    $attrs.fileUploadPreview + '.preview',
                    function (preview) {
                        $element.empty();
                        if (preview) {
                            $element.append(preview);
                        }
                    }
                );
            }
        ])

        .directive('fileUpload', function () {
            return {
                controller: 'FileUploadController',
                scope: true
            };
        })

        .directive('fileUploadProgress', function () {
            return {
                controller: 'FileUploadProgressController',
                scope: true
            };
        })

        .directive('fileUploadPreview', function () {
            return {
                controller: 'FileUploadPreviewController'
            };
        })

        .directive('download', function () {
            return function (scope, elm) {
                elm.on('dragstart', function (e) {
                    try {
                        e.originalEvent.dataTransfer.setData(
                            'DownloadURL',
                            [
                                'application/octet-stream',
                                elm.prop('download'),
                                elm.prop('href')
                            ].join(':')
                        );
                    } catch (ignore) {}
                });
            };
        });

}));

'use strict';
var cnex4_fileUpload_url = URL_PATH.FILE_HEADER + '/upload.do?actionMethod=process',
    cnex4_getFiles_url = URL_PATH.FILE_HEADER + '/getFiles.do?actionMethod=getFiles',
    cnex4_deleteFile_url = URL_PATH.FILE_HEADER + '/deleteFile.do?actionMethod=deleteFile';
customDirective.provider('cexn4FileUpload', function() {
        var scopeEvalAsync = function(expression) {
                var scope = angular.element(this)
                    .fileupload('option', 'scope');
                scope.$evalAsync(expression);
            },
            addFileMethods = function(scope, data) {
                var files = data.files,
                    file = files[0];
                angular.forEach(files, function(file, index) {
                    file._index = index;
                    file.$state = function() {
                        return data.state();
                    };
                    file.$processing = function() {
                        return data.processing();
                    };
                    file.$progress = function() {
                        return data.progress();
                    };
                    file.$response = function() {
                        return data.response();
                    };
                });
                file.$submit = function() {
                    if (!file.error) {
                        return data.submit();
                    }
                };
                file.$cancel = function() {
                    return data.abort();
                };
            },
            $config;
        $config = this.defaults = {
            handleResponse: function(e, data) {
                var files = data.result && data.result.files;
                if (files) {
                    data.scope.replace(data.files, files);
                } else if (data.errorThrown ||
                    data.textStatus === 'error') {
                    data.files[0].error = data.errorThrown ||
                        data.textStatus;
                }
            },
            add: function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var scope = data.scope,
                    filesCopy = [];
                angular.forEach(data.files, function(file) {
                    filesCopy.push(file);
                });
                scope.$parent.$applyAsync(function() {
                    addFileMethods(scope, data);
                    var method = scope.option('prependFiles') ?
                        'unshift' : 'push';
                    Array.prototype[method].apply(scope.queue, data.files);
                });
                data.process(function() {
                    return scope.process(data);
                }).always(function() {
                    scope.$parent.$applyAsync(function() {
                        addFileMethods(scope, data);
                        scope.replace(filesCopy, data.files);
                    });
                }).then(function() {
                    if ((scope.option('autoUpload') ||
                            data.autoUpload) &&
                        data.autoUpload !== false) {
                        data.submit();
                    }
                });
            },
            done: function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var that = this;
                data.scope.$apply(function() {
                    data.handleResponse.call(that, e, data);
                });
            },
            fail: function(e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                var that = this,
                    scope = data.scope;
                if (data.errorThrown === 'abort') {
                    scope.clear(data.files);
                    return;
                }
                scope.$apply(function() {
                    data.handleResponse.call(that, e, data);
                });
            },
            stop: scopeEvalAsync,
            processstart: scopeEvalAsync,
            processstop: scopeEvalAsync,
            getNumberOfFiles: function() {
                var scope = this.scope;
                return scope.queue.length - scope.processing();
            },
            dataType: 'json',
            autoUpload: false
        };
        this.$get = [
            function() {
                return {
                    defaults: $config
                };
            }
        ];
    })
    .provider('cexn4FormatFileSizeFilter', function() {
        var $config = {
            units: [
                { size: 1000000000, suffix: ' GB' },
                { size: 1000000, suffix: ' MB' },
                { size: 1000, suffix: ' KB' }
            ]
        };
        this.defaults = $config;
        this.$get = function() {
            return function(bytes) {
                if (!angular.isNumber(bytes)) {
                    return '';
                }
                var unit = true,
                    i = 0,
                    prefix,
                    suffix;
                while (unit) {
                    unit = $config.units[i];
                    prefix = unit.prefix || '';
                    suffix = unit.suffix || '';
                    if (i === $config.units.length - 1 || bytes >= unit.size) {
                        return prefix + (bytes / unit.size).toFixed(2) + suffix;
                    }
                    i += 1;
                }
            };
        };
    })
    .config(['$httpProvider', 'cexn4FileUploadProvider',
        function($httpProvider, cexn4FileUploadProvider) {
            delete $httpProvider.defaults.headers.common['X-Requested-With'];
            cexn4FileUploadProvider.defaults.redirect = window.location.href.replace(
                /\/[^\/]*$/,
                '/cors/result.html?%s'
            );
            angular.extend(cexn4FileUploadProvider.defaults, {
                disableImageResize: /Android(?!.*Chrome)|Opera/
                    .test(window.navigator.userAgent),
                maxFileSize: 999000,
                acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i
            });
        }
    ])
    .controller('cnex4FileUploadController', ['$scope', '$compile', '$http', function($scope, $compile, $http) {
        var iconPathHead = 'static/js/directives/custom/cnex4FileUpload/images/';
        $scope.getImageIcon = function(fileName) {
            var fileExt = fileName.substr(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();
            if ('xls' === fileExt || 'xlsx' === fileExt) {
                return iconPathHead + 'excel.png';
            } else if ('doc' === fileExt || 'docx' === fileExt) {
                return iconPathHead + 'word.png';
            } else if ('ppt' === fileExt || 'pptx' === fileExt) {
                return iconPathHead + 'ppt.png';
            } else if ('pdf' === fileExt) {
                return iconPathHead + 'pdf.png';
            } else if ('zip' === fileExt) {
                return iconPathHead + 'zip.png';
            } else if ('exe' === fileExt) {
                return iconPathHead + 'exe.png';
            } else if ('txt' === fileExt) {
                return iconPathHead + 'text.png';
            } else if ('html' === fileExt || 'htm' === fileExt) {
                return iconPathHead + 'html.png';
            } else {
                return undefined;
            }
        }

        /*是否显示图片预览*/
        $scope.isShowPreview = false;

        /*是否为多附件组件*/
        /*var cnex4Multiple = $scope.cnex4Multiple || false;*/

        /*添加文件按钮是否显示*/
        $scope.addFileBtnIsShow = true;

        /*是否显示删除按钮*/
        $scope.showDelete = false;

        /*$scope.files = [];*/
        $scope.addFiles = [];

        $scope.disableDeleteFilesArr = new Map();

        $scope.$on("fileSelected", function(event, args) {
            $scope.$apply(function() {
                if (args.file) {
                    if (args.file.size > 20000000) {
                        submitTips('文件大小不能超过20M', 'warning');
                    } else if (!$scope.cnex4Multiple && $scope.queue && $scope.queue.length > 0) {
                        submitTips('只能上传单个附件！', 'warning');
                    } else {
                        $scope.saveFiles(args.file);
                    }
                }
            });
        });

        $scope.saveFiles = function(file) {
            $http({
                method: 'POST',
                url: cnex4_fileUpload_url,
                headers: { 'Content-Type': undefined },
                transformRequest: function(data) {
                    var formData = new FormData();
                    formData.append("businessId", data.businessId);
                    formData.append("systemHeader", data.systemHeader);
                    formData.append("file", file);
                    return formData;
                },
                data: { businessId: $scope.ngModel, files: file, systemHeader: $scope.systemHeader || "system" }
            }).success(function(data, status, headers, config) {
                $scope.getFiles(false);
                console.log("success!");
            }).error(function(data, status, headers, config) {
                console.log("failed!");
            });
        };

        $scope.getFiles = function(onlyAdd) {
            var businessIds = $scope.ngModel;
            if (angular.isArray($scope.ngModel)) {
                businessIds = $scope.ngModel.toString();
            }
            $http({
                    method: 'POST',
                    url: cnex4_getFiles_url,
                    data: { businessIds: businessIds },
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    transformRequest: function(obj) {
                        var str = [];
                        for (var p in obj) {
                            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                        }
                        return str.join("&");
                    }
                })
                .success(function(data, status, headers, config) {
                    if ($scope.cnex4ShowBtn) {
                        angular.forEach(data.data, function(file) {
                            file.onlyAdd = true;
                        });
                    } else {
                        if (onlyAdd) {
                            angular.forEach(data.data, function(file) {
                                file.onlyAdd = onlyAdd;
                                $scope.disableDeleteFilesArr.put(file.id, file.id);
                            });
                        } else {
                            angular.forEach(data.data, function(file) {
                                if ($scope.disableDeleteFilesArr.get(file.id)) {
                                    file.onlyAdd = true;
                                } else {
                                    file.onlyAdd = onlyAdd;
                                }
                            });
                        }
                    }
                    $scope.queue = data.data;
                    $scope.files = [];

                    if ($scope.cnex4Multiple == false || $scope.cnex4Multiple == "false") {
                        if (data.data != null && data.data.length > 0) {
                            $scope.addFileBtnIsShow = false;
                            $scope.filesCount = data.data.length;
                        } else {
                            $scope.addFileBtnIsShow = true;
                        }
                    } else {
                        if (data.data != null && data.data.length > 0) {
                            if (data.data.length >= $scope.maxFilesCount) {
                                $scope.addFileBtnIsShow = false;
                            } else {
                                $scope.addFileBtnIsShow = true;
                            }
                            if ($scope.minFilesCount != null && data.data.length <= $scope.minFilesCount) {
                                $scope.showDelete = true;
                            } else {
                                $scope.showDelete = false;
                            }
                            $scope.filesCount = data.data.length;
                        }
                    }
                    if ($scope.cnex4ShowBtn == true || $scope.cnex4ShowBtn == "true") {
                        $scope.addFileBtnIsShow = false;
                        $scope.deleteFileBtnIsShow = false;
                    } else {
                        $scope.deleteFileBtnIsShow = true;
                    }
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };

        $scope.deleteFile = function(fileId) {
            $http({
                    method: 'GET',
                    url: cnex4_deleteFile_url + "&fileId=" + fileId
                })
                .success(function(data, status, headers, config) {
                    $scope.getFiles(false);
                    $scope.filesCount--;
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };
        $scope.showPreview = function(preViewURL, fileType) {
            if (!(isImage(fileType) || isOffice(fileType))) {
                return;
            }
            var jsPanelKey = uuid(10);

            controllerProvider.register(jsPanelKey, function($scope, $controller) {

                $scope.viewUrl = preViewURL;
                $scope.fileType = fileType;
                $scope.rootElementId = jsPanelKey;

                $controller("FileOnlineReaderController", { $scope: $scope });


            });
            var modal = "<div  ng-controller='" + jsPanelKey + "'>";
            $http.get('static/js/directives/custom/cnex4FileUpload/template/file_online_read.html').success(function(res) {
                modal += res
                modal += "</div>";
                var jsPanel = $.jsPanel({
                    id: jsPanelKey,
                    selector: '.content',
                    headerTitle: "文件在线浏览",
                    contentSize: { width: 800, height: 500 },
                    theme: 'dark',
                    position: 'center',
                    content: $compile(modal)($scope),
                    draggable: {
                        containment: "parent"
                    }

                });

            });
        }
    }])
    .controller('huatekFileUploadAndPreview', ['$scope', '$compile', '$http', function($scope, $compile, $http) {
        var iconPathHead = 'static/js/directives/custom/cnex4FileUpload/images/';
        $scope.getImageIcon = function(fileName) {
            var fileExt = fileName.substr(fileName.lastIndexOf(".") + 1, fileName.length).toLowerCase();
            if ('xls' === fileExt || 'xlsx' === fileExt) {
                return iconPathHead + 'excel.png';
            } else if ('doc' === fileExt || 'docx' === fileExt) {
                return iconPathHead + 'word.png';
            } else if ('ppt' === fileExt || 'pptx' === fileExt) {
                return iconPathHead + 'ppt.png';
            } else if ('pdf' === fileExt) {
                return iconPathHead + 'pdf.png';
            } else if ('zip' === fileExt) {
                return iconPathHead + 'zip.png';
            } else if ('exe' === fileExt) {
                return iconPathHead + 'exe.png';
            } else if ('txt' === fileExt) {
                return iconPathHead + 'text.png';
            } else if ('html' === fileExt || 'htm' === fileExt) {
                return iconPathHead + 'html.png';
            } else {
                return undefined;
            }
        }

        /*是否显示图片预览*/
        $scope.isShowPreview = false;

        /*是否为多附件组件*/
        /*var cnex4Multiple = $scope.cnex4Multiple || false;*/

        /*添加文件按钮是否显示*/
        $scope.addFileBtnIsShow = true;

        /*是否显示删除按钮*/
        $scope.showDelete = false;

        /*$scope.files = [];*/
        $scope.addFiles = [];

        $scope.disableDeleteFilesArr = new Map();

        $scope.$on("fileSelected", function(event, args) {
            $scope.$apply(function() {
                if (args.file) {
                    if (args.file.size > 20000000) {
                        submitTips('文件大小不能超过20M', 'warning');
                    } else if (!$scope.cnex4Multiple && $scope.queue && $scope.queue.length > 0) {
                        submitTips('只能上传单个附件！', 'warning');
                    } else {
                        $scope.saveFiles(args.file);
                    }
                }
            });
        });

        $scope.saveFiles = function(file) {
            $http({
                method: 'POST',
                url: cnex4_fileUpload_url,
                headers: { 'Content-Type': undefined },
                transformRequest: function(data) {
                    var formData = new FormData();
                    formData.append("businessId", data.businessId);
                    formData.append("systemHeader", data.systemHeader);
                    formData.append("file", file);
                    return formData;
                },
                data: { businessId: $scope.ngModel, files: file, systemHeader: $scope.systemHeader || "system" }
            }).success(function(data, status, headers, config) {
                $scope.getFiles(false);
                console.log("success!");
            }).error(function(data, status, headers, config) {
                console.log("failed!");
            });
        };

        $scope.getFiles = function(onlyAdd) {
            var businessIds = $scope.ngModel;
            if (angular.isArray($scope.ngModel)) {
                businessIds = $scope.ngModel.toString();
            }
            $http({
                    method: 'POST',
                    url: cnex4_getFiles_url,
                    data: { businessIds: businessIds },
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    transformRequest: function(obj) {
                        var str = [];
                        for (var p in obj) {
                            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                        }
                        return str.join("&");
                    }
                })
                .success(function(data, status, headers, config) {
                    if ($scope.cnex4ShowBtn) {
                        angular.forEach(data.data, function(file) {
                            file.onlyAdd = true;
                        });
                    } else {
                        if (onlyAdd) {
                            angular.forEach(data.data, function(file) {
                                file.onlyAdd = onlyAdd;
                                $scope.disableDeleteFilesArr.put(file.id, file.id);
                            });
                        } else {
                            angular.forEach(data.data, function(file) {
                                if ($scope.disableDeleteFilesArr.get(file.id)) {
                                    file.onlyAdd = true;
                                } else {
                                    file.onlyAdd = onlyAdd;
                                }
                            });
                        }
                    }
                    $scope.queue = data.data;
                    $scope.files = [];

                    if ($scope.cnex4Multiple == false || $scope.cnex4Multiple == "false") {
                        if (data.data != null && data.data.length > 0) {
                            $scope.addFileBtnIsShow = false;
                            $scope.filesCount = data.data.length;
                        } else {
                            $scope.addFileBtnIsShow = true;
                        }
                    } else {
                        if (data.data != null && data.data.length > 0) {
                            if (data.data.length >= $scope.maxFilesCount) {
                                $scope.addFileBtnIsShow = false;
                            } else {
                                $scope.addFileBtnIsShow = true;
                            }
                            if ($scope.minFilesCount != null && data.data.length <= $scope.minFilesCount) {
                                $scope.showDelete = true;
                            } else {
                                $scope.showDelete = false;
                            }
                            $scope.filesCount = data.data.length;
                        }
                    }
                    if ($scope.cnex4ShowBtn == true || $scope.cnex4ShowBtn == "true") {
                        $scope.addFileBtnIsShow = false;
                        $scope.deleteFileBtnIsShow = false;
                    } else {
                        $scope.deleteFileBtnIsShow = true;
                    }
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };

        $scope.deleteFile = function(fileId) {
            $http({
                    method: 'GET',
                    url: cnex4_deleteFile_url + "&fileId=" + fileId
                })
                .success(function(data, status, headers, config) {
                    $scope.getFiles(false);
                    $scope.filesCount--;
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };
        $scope.showPreview = function(preViewURL, fileType) {
            if (!(isImage(fileType) || isOffice(fileType))) {
                return;
            }
            var jsPanelKey = uuid(10);

            controllerProvider.register(jsPanelKey, function($scope, $controller) {

                $scope.viewUrl = preViewURL;
                $scope.fileType = fileType;
                $scope.rootElementId = jsPanelKey;

                $controller("FileOnlineReaderController", { $scope: $scope });


            });
            var modal = "<div  ng-controller='" + jsPanelKey + "'>";
            $http.get('static/js/directives/custom/cnex4FileUpload/template/file_online_read.html').success(function(res) {
                modal += res
                modal += "</div>";
                var jsPanel = $.jsPanel({
                    id: jsPanelKey,
                    selector: '.content',
                    headerTitle: "文件在线浏览",
                    contentSize: { width: 800, height: 500 },
                    theme: 'dark',
                    position: 'center',
                    content: $compile(modal)($scope),
                    draggable: {
                        containment: "parent"
                    }

                });

            });
        }
        $scope.showImage = null;
        $scope.rotate = 0;

        $scope.turnLeft = function() {
            $scope.rotate += -90;
        };
        $scope.turnRight = function() {
            $scope.rotate += 90;
        };
        /*点击图片切换*/
       /* $scope.clickImageForChange = function(image) {
            $scope.rotate = 0;
            $scope.setChoose(image);
        };*/
        /*/*点击左右切换*/
       /* $scope.clickNextForChange = function(index, position) {
            $scope.rotate = 0;
            if ($scope.queue != null && $scope.queue.length > 0) {
                if ("up" === position) {
                    index = index * 1 - 1;
                } else {
                    index = index * 1 + 1;
                }
                if (index < 0) {
                    index = $scope.queue.length - 1;
                } else if (index >= $scope.queue.length) {
                    index = 0;
                }
                $scope.setChoose($scope.queue[index]);
            }
        }*/
        var ind = ''
        /*点击图片切换*/
        $scope.clickImageForChange = function(image) {
            $scope.rotate = 0;
            ind = $scope.queue.indexOf(image)
            console.log(ind)
            $scope.setChoose(image);
        };
        /*点击左右切换*/
        $scope.clickNextForChange = function(index, position) {
            // console.log(index)
            // console.log($scope.queue);
            ind = $scope.queue.indexOf(index)
            $scope.rotate = 0;
            console.log($scope.queue[ind])
            if (ind !== -1) {
                if ("up" === position && ind >0) {
                    console.log('zuo')
                    ind--;
                } else if('down' === position && ind<$scope.queue.length-1) {
                    console.log('you')
                    ind++;
                }
            }
            $scope.setChoose($scope.queue[ind]);
        }


        /*设置选中样式*/
        $scope.setChoose = function(image) {
            angular.forEach($scope.queue, function(image) {
                image.css = "ps-item";
            });
            $scope.showImage = image;
            $scope.showImage.css = "ps-item ps-selected";
        };
    }])
    .controller('cenx4ImagePreviewController', ['$scope', '$http', function($scope, $http) {
        $scope.showImage = null;
        $scope.rotate = 0;

        $scope.turnLeft = function() {
            $scope.rotate += -90;
        };
        $scope.turnRight = function() {
            $scope.rotate += 90;
        };

        $scope.getFiles = function(newValue) {
            var businessIds = newValue;
            if (angular.isArray(newValue)) {
                businessIds = newValue.toString();
            }
            $http({
                    method: 'POST',
                    url: cnex4_getFiles_url,
                    data: { businessIds: businessIds },
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    transformRequest: function(obj) {
                        var str = [];
                        for (var p in obj) {
                            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                        }
                        return str.join("&");
                    }
                })
                .success(function(data, status, headers, config) {
                    if (undefined == data.data || data.data.length < 1) {
                        $scope.queue = [];
                        $scope.showImage = {};
                    } else {
                        $scope.queue = data.data;
                        angular.forEach($scope.queue, function(image, index) {
                            image.index = index;
                        });
                        $scope.showImage = $scope.queue[0];
                        $scope.showImage.css = "ps-item ps-selected";
                    }
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };
        /*设置选中样式*/
        $scope.setChoose = function(image) {
            angular.forEach($scope.queue, function(image) {
                image.css = "ps-item";
            });
            $scope.showImage = image;
            $scope.showImage.css = "ps-item ps-selected";
        };
    }])
    .controller('cenx4ImagePreviewListController', ['$scope', '$http', function($scope, $http) {
        $scope.showImage = null;
        $scope.getFiles = function() {
            var businessIds = $scope.ngModel;
            if (angular.isArray($scope.ngModel)) {
                businessIds = $scope.ngModel.toString();
            };
            $http({
                    method: 'POST',
                    url: cnex4_getFiles_url,
                    data: { businessIds: businessIds },
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    transformRequest: function(obj) {
                        var str = [];
                        for (var p in obj) {
                            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                        }
                        return str.join("&");
                    }
                })
                .success(function(data, status, headers, config) {
                    $scope.queue = data.data;
                })
                .error(function(data, status, headers, config) {
                    console.log("load files failed!");
                });
        };
    }])
    .controller('FileOnlineReaderController', ['$scope', '$http', function($scope, $http) {
        $scope.isImage = isImage($scope.fileType);
        $scope.isVideo = isVideo($scope.fileType);
        $scope.$watch('$viewContentLoaded', function() {
            if ($scope.isImage) {

                setTimeout($scope.startZoom, 200);
            }

        });
        $scope.zoomButtonClickHandler = function(e) {
            var scaleToAdd = 0.8;
            if (e.target.id == 'zoomOutButton')
                scaleToAdd = -scaleToAdd;
            $('#imageFullScreen', $("#" + $scope.rootElementId)).smartZoom('zoom', scaleToAdd);
        };
        $scope.startZoom = function() {
            $('#imageFullScreen', $("#" + $scope.rootElementId)).smartZoom({ 'containerClass': 'zoomableContainer' });
        }
        $scope.moveButtonClickHandler = function(e) {
            var pixelsToMoveOnX = 0;
            var pixelsToMoveOnY = 0;

            switch (e.target.id) {
                case "leftPositionMap":
                    pixelsToMoveOnX = 50;
                    break;
                case "rightPositionMap":
                    pixelsToMoveOnX = -50;
                    break;
                case "topPositionMap":
                    pixelsToMoveOnY = 50;
                    break;
                case "bottomPositionMap":
                    pixelsToMoveOnY = -50;
                    break;
            }
            $('#imageFullScreen', $("#" + $scope.rootElementId)).smartZoom('pan', pixelsToMoveOnX, pixelsToMoveOnY);
        };

    }])
    .directive('cenx4FileUpload', function() {
        return {
            require: '?ngModel',
            restrict: 'E',
            scope: { ngModel: '=', filesCount: "=", cnex4Multiple: '=', systemHeader: "=", maxFilesCount: "=", minFilesCount: "=", cnex4ShowBtn: "=", cnex4OnlyAdd: "=" },
            controller: 'cnex4FileUploadController',
            templateUrl: 'static/js/directives/custom/cnex4FileUpload/template/cnex4FileUpload_template.html',
            replace: true,
            link: function(scope, el, attrs, ngModel) {
                var businessId = getUUID();
                ngModel.$render = function() {
                    if ("" != ngModel.$viewValue && undefined != ngModel.$viewValue && ngModel.$viewValue != businessId) {
                        scope.getFiles(scope.cnex4OnlyAdd);
                    } else {
                        scope.ngModel = businessId;
                    }
                };
                if (scope.cnex4ShowBtn == true || scope.cnex4ShowBtn == "true") {
                    scope.addFileBtnIsShow = false;
                    scope.deleteFileBtnIsShow = false;
                } else {
                    scope.deleteFileBtnIsShow = true;
                }
                el.bind('change', function(event) {
                    var files = event.target.files;
                    for (var i = 0; i < files.length; i++) {
                        scope.$emit("fileSelected", { file: files[i] });
                    }
                });
            }
        };
    })
    .directive('cenx4FileUploadAndPreview', function() {
        return {
            require: '?ngModel',
            restrict: 'E',
            scope: { ngModel: '=', filesCount: "=", cnex4Multiple: '=', systemHeader: "=", maxFilesCount: "=", minFilesCount: "=", cnex4ShowBtn: "=", cnex4OnlyAdd: "=" },
            controller: 'huatekFileUploadAndPreview',
            templateUrl: 'static/js/directives/custom/cnex4FileUpload/template/huatekFile_upload_preview.html',
            replace: true,
            link: function(scope, el, attrs, ngModel) {
                var businessId = getUUID();
                ngModel.$render = function() {
                    if ("" != ngModel.$viewValue && undefined != ngModel.$viewValue && ngModel.$viewValue != businessId) {
                        scope.getFiles(scope.cnex4OnlyAdd);
                    } else {
                        scope.ngModel = businessId;
                    }
                };
                if (scope.cnex4ShowBtn == true || scope.cnex4ShowBtn == "true") {
                    scope.addFileBtnIsShow = false;
                    scope.deleteFileBtnIsShow = false;
                } else {
                    scope.deleteFileBtnIsShow = true;
                }
                el.bind('change', function(event) {
                    var files = event.target.files;
                    for (var i = 0; i < files.length; i++) {
                        scope.$emit("fileSelected", { file: files[i] });
                    }
                });
            }
        };
    })
    .directive('cenx4ImagePreview', function() {
        return {
            require: '?ngModel',
            restrict: 'E',
            scope: { ngModel: '=' },
            controller: 'cenx4ImagePreviewController',
            templateUrl: 'static/js/directives/custom/cnex4FileUpload/template/cnex4Image_preview.html',
            replace: true,
            link: function(scope, el, attrs, ngModel) {
                /*如果设置成readOnly，直接不显示*/
                scope.$watch('ngModel', function(newValue, oldValue, scope) {
                    if (("" != newValue && undefined != newValue) || newValue != oldValue) {
                        scope.getFiles(newValue);
                    }
                });
            }
        };
    })
    .directive('cenx4ImagePreviewList', function() {
        return {
            require: '?ngModel',
            restrict: 'E',
            scope: { ngModel: '=' },
            controller: 'cenx4ImagePreviewListController',
            templateUrl: 'static/js/directives/custom/cnex4FileUpload/template/cnex4Image_previewList.html',
            replace: true,
            link: function(scope, el, attrs, ngModel) {
                scope.$watch('ngModel', function(newValue, oldValue, scope) {
                    if ("" != newValue && undefined != newValue) {
                        scope.getFiles(ngModel.$viewValue);
                    }
                });
            }
        };
    });
/*
Copyright 2012 Igor Vaynberg

Version: 3.4.8 Timestamp: Thu May  1 09:50:32 EDT 2014

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false 
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (e) {
            var k = e.which;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }

            if (e.metaKey) return true;

            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

    DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo('body');

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        if (a.constructor === String) return a+'' === b+''; 
        if (b.constructor === String) return b+'' === a+''; 
        return false;
    }

    /**
     * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }

    $document.on("mousemove", function (e) {
        lastMousePosition.x = e.pageX;
        lastMousePosition.y = e.pageY;
    });

    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $("body").append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = dest.attr("class");
        if (classes) {
            classes = '' + classes; 
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }
        classes = src.attr("class");
        if (classes) {
            classes = '' + classes; 
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);
                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }
        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, 
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, 
                    url = ajaxUrl, 
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    deprecated = {
                        type: options.type || 'GET', 
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        var results = options.results(data, query.page);
                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, 
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; 

         if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

         if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            if (!$.isFunction(text)) {
                dataText = dataItem.text; 
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {id: this, text: this});
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof(formatter) === 'string') return true;
        throw new Error(formatterName +" must be a string, function, or falsy value");
    }

    function evaluate(val) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 1);
            return val.apply(null, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input,
            dupe = false, 
            token,
            index, 
            i, l,
            separator; 

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; 

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        Array.prototype.forEach.call(arguments, function (element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $("<span>", {
                    role: "status",
                    "aria-live": "polite"
                })
                .addClass("select2-hidden-accessible")
                .appendTo(document.body);

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerEventName= this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $("body");

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss));
            this.container.addClass(evaluate(opts.containerCssClass));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); 

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.nextSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                this.initSelection();

                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2");

            this.close();

            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element
                    .removeClass("select2-offscreen")
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id, liveRegion=this.liveRegion;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");
                            label.attr("ng-click", "selectAutoCompleteEvent()");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            container.append(node);
                        }

                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function(list, item) { list.push(item); };
            }
            else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        monitorSource: function () {
            var el = this.opts.element, sync, observer;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            sync = this.bind(function () {

                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                this.container.addClass(evaluate(this.opts.containerCssClass));

                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));

            });

            /*IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)*/            
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", sync);
                });
            }
            
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    mutations.forEach(sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            this.opts.element.click();

            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        disable: function() {
            this.enable(false);
        },

        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        opened: function () {
            return this.container.hasClass("select2-dropdown-open");
        },

        positionDropdown: function() {
            var $dropdown = this.dropdown,
                offset = this.container.offset(),
                height = this.container.outerHeight(false),
                width = this.container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                $dropdown.show();

                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss));

            $dropdown.css(css);
        },

        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        clearDropdownAlignmentPreference: function() {
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        opening: function() {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            mask = $("#select2-drop-mask");
            if (mask.length == 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); 
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();


            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        clearSearch: function () {

        },

        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize);
        },

        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {


                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            hb = child.offset().top + child.outerHeight(true);

            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(true);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = child.offset().top - results.offset().top;

            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y);
            }
        },

        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function() {
            this._touchMoved = true;
        },

        clearTouchMoved: function() {
          this._touchMoved = false;
        },

        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                this.removeHighlight();
            }
        },

        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, 
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                        element: this.opts.element,
                        term: term,
                        page: page,
                        context: context,
                        matcher: this.opts.matcher,
                        callback: this.bind(function (data) {

                    if (!self.opened()) return;


                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                    self.postprocessResults(data, false, false);

                    if (data.more===true) {
                        more.detach().appendTo(results).text(evaluate(self.opts.formatLoadMore, page+1));
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    } else {
                        more.remove();
                    }
                    self.positionDropdown();
                    self.resultsPage = page;
                    self.context = data.context;
                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                queryNumber;

            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                    term: search.val(),
                    page: this.resultsPage,
                    context: null,
                    matcher: opts.matcher,
                    callback: this.bind(function (data) {
                var def; 

                if (queryNumber != this.queryCount) {
                  return;
                }

                if (!this.opened()) {
                    this.search.removeClass("select2-active");
                    return;
                }

                this.context = (data.context===undefined) ? null : data.context;
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            this.opts.createSearchChoicePosition(data.results, def);
                        }
                    }
                }

                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, search.val()) + "</li>");
                    return;
                }

                results.empty();
                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                    results.append("<li class='select2-more-results'>" + self.opts.escapeMarkup(evaluate(opts.formatLoadMore, this.resultsPage)) + "</li>");
                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                }

                this.postprocessResults(data, initial);

                postRender();

                this.opts.element.trigger({ type: "select2-loaded", items: data });
            })});
        },

        cancel: function () {
            this.close();
        },

        blur: function () {
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        focusSearch: function () {
            focus(this.search);
        },

        selectHighlighted: function (options) {
            if (this._touchMoved) {
              this.clearTouchMoved();
              return;
            }
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || 
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                           (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
               }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {


        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
            this.results.attr("id", "select2-results-"+idSuffix);
            this.search.attr("aria-owns", "select2-results-"+idSuffix);

            this.focusser.attr("id", "s2id_autogen"+idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                this.clear();
                killEventImmediately(e);
                this.close();
                this.selection.focus();
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");
            this.setPlaceholder();

        },

        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { 
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false;  
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        getPlaceholder: function() {
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;


            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }


            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;


            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator);
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            this.search.attr("id", "s2id_autogen"+nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("input paste", this.bind(function() {
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus:true});
                        this.close();
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");

            this.clearSearch();
        },

        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        self.clearSearch();
                    }
                });
            }
        },

        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        opening: function () {
            this.clearPlaceholder(); 
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.updateResults(true);
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        focus: function () {
            this.close();
            this.search.focus();
        },

        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        updateSelection: function (data) {
            var ids = [], filtered = [], self = this;

            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        this.updateResults(true);
                    } else {
                        if(this.nextSearchTerm != undefined){
                            this.search.val(this.nextSearchTerm);
                            this.updateResults();
                            this.search.select();
                        }
                    }
                    this.positionDropdown();
                } else {
                    this.close();
                    this.search.width(10);
                }
            }

            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith("<div>"+formatted+"</div>");
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
              choice.find(".select2-search-choice-close")
                  .on("mousedown", killEvent)
                  .on("click dblclick", this.bind(function (e) {
                  if (!this.isInterfaceEnabled()) return;

                  this.unselect($(e.target));
                  this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                  killEvent(e);
                  this.close();
                  this.focusSearch();
              })).on("focus", this.bind(function () {
                  if (!this.isInterfaceEnabled()) return;
                  this.container.addClass("select2-container-active");
                  this.dropdown.addClass("select2-drop-active");
              }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false){
                self.highlight(0);
            }

            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.search.val()) + "</li>");
                    }
                }
            }

        },

        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
              searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator);
            }
        },

        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                        	i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            this.search.width(0);
            this.searchContainer.hide();
        },

        onSortEnd:function() {

            var val=[], self=this;

            this.searchContainer.show();
            this.searchContainer.appendTo(this.searchContainer.parent());
            this.resizeSearch();

            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                 return this.selection
                     .children(".select2-search-choice")
                     .map(function() { return $(this).data("select2-data"); })
                     .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false;
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(result.text, query.term, markup, escapeMarkup);
            return markup.join("");
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(data.text) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return data.css;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        formatMatches: function (matches) { return matches + " results are available, use up and down arrow keys to navigate."; },
        formatNoMatches: function () { return "没有找到匹配条件的项"; },
        formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1? "" : "s"); },
        formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1? "" : "s"); },
        formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
        formatLoadMore: function (pageNumber) { return "Loading more results…"; },
        formatSearching: function () { return "查询中…"; },
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            var supportsTouchEvents = (('ontouchstart' in window) ||
                                       (navigator.msMaxTouchPoints > 0));

            if (!supportsTouchEvents) {
                return true;
            }

            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));

/**
 * select2封装
 * @param {scope} ng-model 选中的ID
 * @param {scope} select2-model 选中的详细内容
 * @param {scope} config 自定义配置
 * @param {String} [query] 内置的配置 (怎么也还得默认一个config)
 * @example
 * <input select2 ng-model="a" select2-model="b" config="config" type="text" placeholder="占位符" />
 * <input select2 ng-model="a" select2-model="b" config="default" query="member" type="text" placeholder="占位符" />
 * <select select2 ng-model="b" class="form-control"></select>
 */
angular.module('huatek.select2', []).directive('select2', function (select2Query) {
    return {
        restrict: 'A',
        scope: {
            config: '=',
            ngModel: '=',
            select2Model: '=',
            select2Items: '='
        },
        link: function (scope, element, attrs) {
        	
            var tagName = element[0].tagName,
                config = {
                    allowClear: true,
                    multiple: !!attrs.multiple,
                    placeholder: attrs.placeholder || ' '   
                };
            	  
            var dataMap = new Map();
            if(tagName === 'SELECT') {
                var $element = $(element);
                delete config.multiple;
                $element
                    .prepend('<option value=""></option>')
                    .val('')
                    .select2(config);
                scope.$watch('ngModel', function (newVal) {
                    setTimeout(function () {
                        $element.find('[value^="?"]').remove();    
                        $element.select2('val', newVal);
                    },1000);	
                }, true);
                
                $element.on('click', function () {
                	if(dataMap.size() < 1){
                		dataMap = getMap(scope.select2Items,'_returnField');
                	}
                	if(null != $element.select2('data')){
                		var data = dataMap.get($element.select2('data').id);
                    	console.log(dataMap);
                    	data._componentsName = attrs.name;
                    	scope.$emit('select2:selected',data);
                	}
                });
                
                return false;
            }

            if(tagName === 'INPUT') {
                var $element = $(element);
                if(attrs.query) {
                    scope.config = select2Query[attrs.query]();
                }

                scope.$watch('config', function () {
                    angular.extend(config, scope.config);
                    $element.select2('destroy').select2(config);
                }, true);

                $element.on('change', function () {
                    scope.$apply(function () {
                        scope.select2Model = $element.select2('data');
                    });
                });

                scope.$watch('select2Model', function (newVal) {
                    $element.select2('data', newVal);
                }, true);

                scope.$watch('ngModel', function (newVal) {
                    if(config.ajax || config.multiple) { return false }
                    $element.select2('val', newVal);
                }, true);
            }
        }
    }
}).factory('select2Query', function ($timeout) {
    return {
        testAJAX: function () {
    	var config = {
                minimumInputLength: 1,
                ajax: {
                    url: "http://localhost:8888/static/directives/select2/testJson.json",
                    dataType: 'jsonp',
                    data: function (term) {
                        return {
                            q: term,
                            page_limit: 10,
                            apikey: "ju6z9mjyajq2djue3gbvv26t"
                        };
                    },
                    results: function (data, page) {
                        return {results: data.movies};
                    }
                },
                formatResult: function (data) {
                    return data.title;
                },
                formatSelection: function (data) {
                    return data.title;
                }
            };

            return config;
        }
    }
});

/*as.controller('appCtrl', function ($scope, $timeout) {
    $scope.config1 = {
        data: [],
        placeholder: '尚无数据'
    };

    $timeout(function () {
        $scope.config1.data = [{id:1,text:'bug'},{id:2,text:'duplicate'},{id:3,text:'invalid'},{id:4,text:'wontfix'}]
        $scope.config1.placeholder = '加载完毕'
    }, 1000);


    $scope.config2 = [
        {id: 6, text: '来自ng-repeat'},
        {id: 7, text: '来自ng-repeat'},
        {id: 8, text: '来自ng-repeat'}
    ];

    $scope.config3 = {
        data: [{id:1,text:'bug'},{id:2,text:'duplicate'},{id:3,text:'invalid'},{id:4,text:'wontfix'}]
    };

});*/


angular.module('oi.select', []);
angular.module('oi.select').directive('oiSelect', ['$document', '$q', '$timeout', '$parse', '$interpolate', '$injector', '$filter', '$animate', 'oiUtils', 'oiSelect', function($document, $q, $timeout, $parse, $interpolate, $injector, $filter, $animate, oiUtils, oiSelect) {
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    var VALUES_REGEXP     = /([^\(\)\s\|\s]*)\s*(\(.*\))?\s*(\|?\s*.+)?/;

    return {
        restrict: 'AE',
        templateUrl: 'static/js/directives/thirdPart/oi-select/0.2.21/src/template.html',
        require: 'ngModel',
        scope: {},
        compile: function (element, attrs) {
            var optionsExp = attrs.oiOptions,
                match = optionsExp ? optionsExp.match(NG_OPTIONS_REGEXP) : ['', 'i', '', '', '', 'i', '', '', ''];

            if (!match) {
                throw new Error("Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_'");
            }

            var selectAsName          = / as /.test(match[0]) && match[1],    
                displayName           = match[2] || match[1],                 
                valueName             = match[5] || match[7],                 
                keyName               = match[6],                             
                groupByName           = match[3] || '',                       
                disableWhenName       = match[4] || '',                       
                trackByName           = match[9] || displayName,              
                valueMatches          = match[8].match(VALUES_REGEXP),        
                valueTitle            = valueName,
                keyTitle              = keyName;

            if (keyName) { 
                valueName             = 'i';
                selectAsName          = valueName + '.' + (selectAsName || valueTitle);
                trackByName           = valueName + '.' + keyName;
                displayName           = valueName + '.' + displayName;
                keyName               = valueName + '.' + keyName;
                groupByName           = groupByName     ? valueName + '.' + groupByName: undefined;
                disableWhenName       = disableWhenName ? valueName + '.' + disableWhenName: undefined;
            }

            var valuesName            = valueMatches[1],                      
                filteredValuesName    = valuesName + (valueMatches[3] || ''), 
                valuesFnName          = valuesName + (valueMatches[2] || ''); 

            var selectAsFn            = selectAsName && $parse(selectAsName),
                displayFn             = $parse(displayName),
                groupByFn             = $parse(groupByName),
                disableWhenFn         = $parse(disableWhenName),
                filteredValuesFn      = $parse(filteredValuesName),
                valuesFn              = $parse(valuesFnName),
                trackByFn             = $parse(trackByName);

            var multiplePlaceholderFn = $interpolate(attrs.multiplePlaceholder || ''),
                listPlaceholderFn     = $interpolate(attrs.listPlaceholder || ''),
                placeholderFn         = $interpolate(attrs.placeholder || ''),
                optionsFn             = $parse(attrs.oiSelectOptions),
                isOldAngular          = angular.version.major <= 1 && angular.version.minor <= 3;

            var keyUpDownWerePressed,
                matchesWereReset,
                timeoutPromise,
                lastQuery,
                removedItem,
                multiple,
                multipleLimit,
                newItemFn;

            return function(scope, element, attrs, ctrl) {
                ctrl.$isEmpty = function(value) { return !exists(value) };

                var inputElement        = element.find('input'),
                    listElement         = angular.element(element[0].querySelector('.select-dropdown')),
                    placeholder         = placeholderFn(scope),
                    multiplePlaceholder = multiplePlaceholderFn(scope),
                    listPlaceholder     = listPlaceholderFn(scope),
                    elementOptions      = optionsFn(scope.$parent) || {},
                    options             = angular.extend({cleanModel: elementOptions.newItem === 'prompt'}, oiSelect.options, elementOptions),
                    editItem            = options.editItem,
                    editItemIsCorrected = editItem === 'correct',
                    waitTime            = 0;

                if (editItem === true || editItem === 'correct') {
                    editItem = 'oiSelectEditItem';
                }
                var editItemFn   = editItem ? $injector.get(editItem) : angular.noop,
                    removeItemFn = $parse(options.removeItemFn);

                match = options.searchFilter.split(':');
                var searchFilter = $filter(match[0]),
                    searchFilterOptionsFn = $parse(match[1]);

                match = options.dropdownFilter.split(':');
                var dropdownFilter = $filter(match[0]),
                    dropdownFilterOptionsFn = $parse(match[1]);

                match = options.listFilter.split(':');
                var listFilter = $filter(match[0]),
                    listFilterOptionsFn = $parse(match[1]);

                match = options.groupFilter.split(':');
                var groupFilter = $filter(match[0]),
                    groupFilterOptionsFn = $parse(match[1]);

                if (options.newItemFn) {
                    newItemFn = $parse(options.newItemFn);

                } else {
                    newItemFn = function(scope, locals) {
                        return (optionsFn(locals) || {}).newItemModel || locals.$query;
                    };
                }

                if (options.cleanModel && (!editItem || editItemIsCorrected)) {
                    element.addClass('cleanMode');
                }

                var unbindFocusBlur = oiUtils.bindFocusBlur(element, inputElement);

                if (angular.isDefined(attrs.autofocus)) {
                    $timeout(function() {
                        inputElement[0].focus();
                    });
                }

                if (angular.isDefined(attrs.readonly)) {
                    inputElement.attr('readonly', true)
                }

                if (angular.isDefined(attrs.tabindex)) {
                    inputElement.attr('tabindex', attrs.tabindex);
                    element[0].removeAttribute('tabindex');
                }

                if (options.maxlength) {
                    inputElement.attr('maxlength', options.maxlength);
                }

                attrs.$observe('disabled', function(value) {
                    inputElement.prop('disabled', value);

                    if (multiple && ctrl.$modelValue && ctrl.$modelValue.length) {
                        scope.inputHide = value;
                    }
                });

                scope.$on('$destroy', unbindFocusBlur);

                scope.$parent.$watch(attrs.multipleLimit, function(value) {
                     multipleLimit = Number(value) || Infinity;
                });

                scope.$parent.$watch(attrs.multiple, function(multipleValue) {
                    multiple = multipleValue === undefined ? angular.isDefined(attrs.multiple) : multipleValue;

                    element[multiple ? 'addClass' : 'removeClass']('multiple');
                });

                function valueChangedManually() { 
                    if (editItemIsCorrected) {
                        element.removeClass('cleanMode');
                    }
                    editItemIsCorrected = false;
                }

                scope.$parent.$watch(attrs.ngModel, function(value, oldValue) {
                    var output = compact(value),
                        promise = $q.when(output);

                    modifyPlaceholder();

                    if (exists(oldValue) && value !== oldValue) {
                        valueChangedManually();
                    }

                    if (!multiple) {
                        restoreInput();
                    }

                    if (selectAsFn && exists(value)) {
                        promise = getMatches(null, value)
                            .then(function(collection) {
                                return oiUtils.intersection(output, collection, null, selectAs);
                            });
                        timeoutPromise = null; 
                    }

                    if (multiple && attrs.disabled && !exists(value)) { 
                        scope.inputHide = false;
                    }

                    promise.then(function(collection) {
                        scope.output = collection;

                        if (collection.length !== output.length) {
                            scope.removeItem(collection.length);
                        }
                    });
                });

                scope.$watch('query', function(inputValue, oldValue) {
                    if (saveOn(inputValue.slice(0, -1), inputValue.slice(-1))) return;

                    if (String(inputValue).length < options.minlength) return;
                    
                    if (inputValue !== oldValue && (!scope.oldQuery || inputValue) && !matchesWereReset) {
                        listElement[0].scrollTop = 0;

                        if (inputValue) {
                            getMatches(inputValue);
                            scope.oldQuery = null;
                        } else if (multiple) {
                            resetMatches();
                            matchesWereReset = true;
                        }
                    }
                    matchesWereReset = false;
                });

                scope.$watch('groups', function(groups) {
                    if (oiUtils.groupsIsEmpty(groups)) {
                        scope.isOpen = false;

                    } else if (!scope.isOpen && !attrs.disabled) {
                        scope.isOpen = true;
                        scope.isFocused = true;
                    }
                });

                scope.$watch('isFocused', function(isFocused) {
                    $animate[isFocused ? 'addClass' : 'removeClass'](element, 'focused', !isOldAngular && {
                        tempClasses: 'focused-animate'
                    });
                });

                scope.$watch('isOpen', function(isOpen) {
                    $animate[isOpen ? 'addClass' : 'removeClass'](element, 'open', !isOldAngular && {
                        tempClasses: 'open-animate'
                    });
                });

                scope.$watch('isEmptyList', function(isEmptyList) {
                    $animate[isEmptyList ? 'addClass' : 'removeClass'](element, 'emptyList', !isOldAngular && {
                        tempClasses: 'emptyList-animate'
                    });
                });

                scope.$watch('showLoader', function(isLoading) {
                    $animate[isLoading ? 'addClass' : 'removeClass'](element, 'loading', !isOldAngular && {
                        tempClasses: 'loading-animate'
                    });
                });

                scope.addItem = function addItem(option) {
                	/*此处应该传播选中事件，将选中对象传播出去*/
                	option._componentsName = attrs.name;
                	scope.$emit('select2:selected',option);
                    lastQuery = scope.query;

                    if (multiple && oiUtils.intersection(scope.output, [option], trackBy, trackBy).length) return;

                    if (scope.output.length >= multipleLimit) {
                        blinkClass('limited');

                        return;
                    }

                    var optionGroup = scope.groups[getGroupName(option)] = scope.groups[getGroupName(option)] || [];
                    var modelOption = selectAsFn ? selectAs(option) : option;

                    optionGroup.splice(optionGroup.indexOf(option), 1);

                    if (multiple) {
                        ctrl.$setViewValue(angular.isArray(ctrl.$modelValue) ? ctrl.$modelValue.concat(modelOption) : [modelOption]);

                    } else {
                        ctrl.$setViewValue(modelOption);
                        restoreInput();
                    }

                    if (oiUtils.groupsIsEmpty(scope.groups)) {
                        scope.groups = {}; 
                    }

                    if (!multiple && !options.closeList) {
                        resetMatches({query: true});
                    }

                    valueChangedManually();

                    scope.oldQuery = scope.oldQuery || scope.query;
                    scope.query = '';
                    scope.backspaceFocus = false;
                };

                scope.removeItem = function removeItem(position) {
                    if (attrs.disabled || multiple && position < 0) return;

                    removedItem = multiple ? ctrl.$modelValue[position] : ctrl.$modelValue;

                    $q.when(removeItemFn(scope.$parent, {$item: removedItem}))
                        .then(function() {
                            if (!multiple && !scope.inputHide) return;

                            if (multiple) {
                                ctrl.$modelValue.splice(position, 1);
                                ctrl.$setViewValue([].concat(ctrl.$modelValue));

                            } else  {
                                cleanInput();

                                if (options.cleanModel) {
                                    ctrl.$setViewValue(undefined);
                                }
                            }

                            if (multiple || !scope.backspaceFocus) {
                                scope.query = editItemFn(removedItem, lastQuery, getLabel, editItemIsCorrected, element) || '';
                            }

                            if (multiple && options.closeList) {
                                resetMatches({query: true});
                            }
                        })
                };

                scope.setSelection = function(index) {
                    if (!keyUpDownWerePressed && scope.selectorPosition !== index) {
                        setOption(listElement, index);
                    } else {
                        keyUpDownWerePressed = false;
                    }
                };

                scope.keyUp = function keyUp(event) {
                    switch (event.keyCode) {
                        case 8: 
                            if (!scope.query.length && (!multiple || !scope.output.length)) {
                                resetMatches();
                            }
                    }
                };

                scope.keyDown = function keyDown(event) {
                    var top    = 0,
                        bottom = scope.order.length - 1;

                    switch (event.keyCode) {
                        case 38: 
                            scope.selectorPosition = angular.isNumber(scope.selectorPosition) ? scope.selectorPosition : top;
                            setOption(listElement, scope.selectorPosition === top ? bottom : scope.selectorPosition - 1);
                            keyUpDownWerePressed = true;
                            break;

                        case 40: 
                            scope.selectorPosition = angular.isNumber(scope.selectorPosition) ? scope.selectorPosition : top - 1;
                            setOption(listElement, scope.selectorPosition === bottom ? top : scope.selectorPosition + 1);
                            keyUpDownWerePressed = true;
                            if (!scope.query.length && !scope.isOpen) {
                                getMatches();
                            }
                            if (scope.inputHide) {
                                cleanInput();
                            }

                            break;

                        case 37: /* left */
                        case 39: /* right */
                            break;

                        case 9: /* tab */
                            saveOn('tab');
                            break;

                        case 13: /* enter */
                            saveOn('enter');
                            event.preventDefault(); 
                            break;

                        case 32: /* space */
                            saveOn('space');
                            break;

                        case 27: /* esc */
                            if (!multiple) {
                                restoreInput();

                                if (options.cleanModel) {
                                    ctrl.$setViewValue(removedItem);
                                }
                            }
                            resetMatches();
                            break;

                        case 8: /* backspace */
                            if (!scope.query.length) {
                                if (!multiple || editItem) {
                                    scope.backspaceFocus = true;
                                }
                                if (scope.backspaceFocus && scope.output && (!multiple || scope.output.length)) { 
                                    scope.removeItem(scope.output.length - 1);

                                    if (editItem) {
                                        event.preventDefault();
                                    }
                                    break;
                                }
                                scope.backspaceFocus = !scope.backspaceFocus;
                                break;
                            }
                        default: /* any key */
                            if (scope.inputHide) {
                                cleanInput();
                            }
                            scope.backspaceFocus = false;
                            return false; 
                    }
                };

                scope.getSearchLabel = function(item) {
                    var label = getLabel(item);

                    return searchFilter(label, scope.oldQuery || scope.query, item, searchFilterOptionsFn(scope.$parent), element);
                };

                scope.getDropdownLabel = function(item) {
                    var label = getLabel(item);

                    return dropdownFilter(label, scope.oldQuery || scope.query, item, dropdownFilterOptionsFn(scope.$parent), element);
                };

                scope.getGroupLabel = function(group, items) {
                    return groupFilter(group, scope.oldQuery || scope.query, items, groupFilterOptionsFn(scope.$parent), element);
                };

                scope.getDisableWhen = getDisableWhen;


                resetMatches();

                element[0].addEventListener('click', click, true); 
                scope.$on('$destroy', function() {
                  element[0].removeEventListener('click', click, true);
                });
                element.on('focus', focus);
                element.on('blur', blur);

                function blinkClass(name, delay) {
                    delay = delay || 150;

                    element.addClass(name);

                    $timeout(function() {
                        element.removeClass(name);
                    }, delay);
                }

                function cleanInput() {
                    scope.listItemHide = true;
                    scope.inputHide = false;
                }

                function restoreInput() {
                    var modelExists = exists(ctrl.$modelValue);
                    scope.listItemHide = !modelExists;
                    scope.inputHide = modelExists;
                }

                function click(event) {
                    if (scope.query.length < options.minlength) return;
                    
                    if (oiUtils.contains(element[0], event.target, 'disabled')) return;

                    if (scope.output.length >= multipleLimit && oiUtils.contains(element[0], event.target, 'select-dropdown')) return;

                    if (scope.inputHide) {
                        scope.removeItem(0); 
                    }

                    if (scope.isOpen && options.closeList && (event.target.nodeName !== 'INPUT' || !scope.query.length)) { 
                        resetMatches({query: options.editItem && !editItemIsCorrected});
                        scope.$evalAsync();
                    } else {
                        getMatches(scope.query);
                    }
                }

                function focus(event) {
                    if (scope.isFocused) return;

                    scope.isFocused = true;

                    if (attrs.disabled) return;

                    scope.backspaceFocus = false;
                }


                function blur(event) {
                    scope.isFocused = false;

                    if (!multiple) {
                        restoreInput();
                    }

                    if (!saveOn('blur')) {
                        resetMatches();
                    }
                    scope.$evalAsync();
                }

                function saveOn(query, triggerName) {
                    if (!triggerName) {
                        triggerName = query;
                        query = scope.query;
                    }

                    var isTriggered    = options.saveTrigger.split(' ').indexOf(triggerName) + 1,
                        isNewItem      = options.newItem && query,
                        selectedOrder  = triggerName !== 'blur' ? scope.order[scope.selectorPosition] : null, 
                        itemPromise;
                    if (isTriggered && (isNewItem || selectedOrder && !getDisableWhen(selectedOrder))) {
                        scope.showLoader = true;
                        itemPromise = $q.when(selectedOrder || newItemFn(scope.$parent, {$query: query}));
                       
                        itemPromise.then(function(data) {
                                if (data === undefined) {
                                   return $q.reject();
                                }

                                scope.addItem(data);

                                var bottom = scope.order.length - 1;

                                if (scope.selectorPosition === bottom) {
                                    setOption(listElement, 0); 
                                }
                                options.newItemFn && !selectedOrder || $timeout(angular.noop); 
                                resetMatches();
                            }).catch(function() {
                                blinkClass('invalid-item');
                                scope.showLoader = false;
                            });

                        return true;
                    }
                }

                function modifyPlaceholder() {
                    var currentPlaceholder = multiple && exists(ctrl.$modelValue) ? multiplePlaceholder : placeholder;
                    inputElement.attr('placeholder', currentPlaceholder);
                }

                function trackBy(item) {
                    return oiUtils.getValue(valueName, item, scope.$parent, trackByFn);
                }

                function selectAs(item) {
                    return oiUtils.getValue(valueName, item, scope.$parent, selectAsFn);
                }

                function getLabel(item) {
                    return oiUtils.getValue(valueName, item, scope.$parent, displayFn);
                }

                function getDisableWhen(item) {
                    return scope.isEmptyList || oiUtils.getValue(valueName, item, scope.$parent, disableWhenFn);
                }

                function getGroupName(option) {
                    return oiUtils.getValue(valueName, option, scope.$parent, groupByFn) || '';
                }

                function filter(list) {
                    return oiUtils.getValue(valuesName, list, scope.$parent, filteredValuesFn);
                }

                function compact(value) {
                    value = value instanceof Array ? value : value ? [value]: [];

                    return value.filter(function(item) {
                        return item !== undefined && (item instanceof Array && item.length || selectAsFn || getLabel(item));
                    });
                }

                function exists(value) {
                    return !!compact(value).length;
                }

                function getMatches(query, selectedAs) {
                    scope.isEmptyList = false;

                    if (timeoutPromise && waitTime) {
                        $timeout.cancel(timeoutPromise); 
                    }

                    timeoutPromise = $timeout(function() {
                        var values = valuesFn(scope.$parent, {$query: query, $selectedAs: selectedAs}) || '';

                        scope.selectorPosition = options.newItem === 'prompt' ? false : 0;

                        if (!query && !selectedAs) {
                            scope.oldQuery = null;
                        }

                        if (values.$promise && !values.$resolved || angular.isFunction(values.then)) {
                            waitTime = options.debounce;
                        }

                        scope.showLoader = true;

                        return $q.when(values.$promise || values)
                            .then(function(values) {

                                scope.groups = {};

                                if (values && keyName) {
                                    var arr = [];

                                    angular.forEach(values, function (value, key) {
                                        if (key.toString().charAt(0) !== '$') {
                                            var item = {};

                                            item[keyTitle] = key;
                                            item[valueTitle] = value;
                                            arr.push(item);
                                        }
                                    });

                                    values = arr;
                                }

                                if (values && !selectedAs) {
                                    var outputValues = multiple ? scope.output : [];
                                    var filteredList = listFilter(values, query, getLabel, listFilterOptionsFn(scope.$parent), element);
                                    var withoutIntersection = oiUtils.intersection(filteredList, outputValues, trackBy, trackBy, true);
                                    var filteredOutput = filter(withoutIntersection);

                                    if (!filteredOutput.length) {
                                        scope.isEmptyList = true;

                                        if (listPlaceholder) {
                                            var context = {};

                                            displayFn.assign(context, listPlaceholder);
                                            filteredOutput = [context[valueName]]
                                        }
                                    }

                                    scope.groups = group(filteredOutput);
                                }
                                updateGroupPos();

                                return values;
                            }).finally(function(){
                                scope.showLoader = false;

                                if (options.closeList && !options.cleanModel) { 
                                    $timeout(function() {
                                        setOption(listElement, 0);
                                    });
                                }
                            });
                    }, waitTime);

                    return timeoutPromise;
                }

                function updateGroupPos() {
                    var i, key, value, collectionKeys = [], groupCount = 0;

                    scope.order = [];
                    scope.groupPos = {};

                    for (key in scope.groups) {
                        if (scope.groups.hasOwnProperty(key) && key.charAt(0) != '$') {
                            collectionKeys.push(key);
                        }
                    }

                    if (isOldAngular) {
                        collectionKeys.sort(); 
                    }

                    for (i = 0; i < collectionKeys.length; i++) {
                        key = collectionKeys[i];
                        value = scope.groups[key];

                        scope.order = scope.order.concat(value);
                        scope.groupPos[key] = groupCount;
                        groupCount += value.length
                    }
                }

                function resetMatches(options) {
                    options = options || {};

                    scope.oldQuery = null;
                    scope.backspaceFocus = false; 
                    scope.groups = {};
                    scope.order = [];
                    scope.showLoader = false;
                    scope.isOpen = false;
                    waitTime = 0;

                    if (!options.query)   {
                        scope.query = '';
                    }

                    if (timeoutPromise) {
                        $timeout.cancel(timeoutPromise);
                    }
                }

                function setOption(listElement, position) {
                    scope.selectorPosition = position;
                    oiUtils.scrollActiveOption(listElement[0], listElement.find('li')[position]);
                }

                function group(input) {
                    var optionGroups = {'':[]},
                        optionGroupName,
                        optionGroup;

                    for (var i = 0; i < input.length; i++) {
                        optionGroupName = getGroupName(input[i]);

                        if (!(optionGroup = optionGroups[optionGroupName])) {
                            optionGroup = optionGroups[optionGroupName] = [];
                        }
                        optionGroup.push(input[i]);
                    }

                    return optionGroups;
                }
            }
        }
    }
}]);

angular.module('oi.select')

.filter('oiSelectGroup', ['$sce', function($sce) {
    return function(label) {
        return $sce.trustAsHtml(label);
    };
}])

.filter('oiSelectCloseIcon', ['$sce', function($sce) {
    return function(label) {
        var closeIcon = '<span class="close select-search-list-item_selection-remove">×</span>';

        return $sce.trustAsHtml(label + closeIcon);
    };
}])

.filter('oiSelectHighlight', ['$sce', 'oiSelectEscape', function($sce, oiSelectEscape) {
    return function(label, query) {
        var html;

        if (query.length > 0 || angular.isNumber(query)) {
            label = label.toString();
            query = oiSelectEscape(query);

            html = label.replace(new RegExp(query, 'gi'), '<strong>$&</strong>');
        } else {
            html = label;
        }

        return $sce.trustAsHtml(html);
    };
}])

.filter('oiSelectAscSort', ['oiSelectEscape', function(oiSelectEscape) {
    function ascSort(input, query, getLabel, options) {
        var i, j, isFound, output, output1 = [], output2 = [], output3 = [], output4 = [];

        if (query) {
            query = oiSelectEscape(query).toLocaleLowerCase();

            for (i = 0, isFound = false; i < input.length; i++) {
                isFound = getLabel(input[i]).toLocaleLowerCase().match(new RegExp(query));

                if (!isFound && options && (options.length || options.fields)) {
                    for (j = 0; j < options.length; j++) {
                        if (isFound) break;

                        isFound = String(input[i][options[j]]).toLocaleLowerCase().match(new RegExp(query));
                    }
                }

                if (isFound) {
                    output1.push(input[i]);
                }
            }
            for (i = 0; i < output1.length; i++) {
                if (getLabel(output1[i]).toLocaleLowerCase().match(new RegExp('^' + query))) {
                    output2.push(output1[i]);
                } else {
                    output3.push(output1[i]);
                }
            }
            output = output2.concat(output3);

            if (options && (options === true || options.all)) {
                inputLabel: for (i = 0; i < input.length; i++) {
                    for (j = 0; j < output.length; j++) {
                        if (input[i] === output[j]) {
                            continue inputLabel;
                        }
                    }
                    output4.push(input[i]);
                }
                output = output.concat(output4);
            }
        } else {
            output = [].concat(input);
        }

        return output;
    }

    return ascSort;
}])

.filter('none', function() {
    return function(input) {
        return input;
    };
});
angular.module('oi.select')

.provider('oiSelect', function() {
    return {
        options: {
            debounce:       500,
            searchFilter:   'oiSelectCloseIcon',
            dropdownFilter: 'oiSelectHighlight',
            listFilter:     'oiSelectAscSort',
            groupFilter:    'oiSelectGroup',
            editItem:       false,
            newItem:        false,
            closeList:      true,
            saveTrigger:    'enter tab blur',
            minlength:      0
        },
        version: {
            full: '0.2.21',
            major: 0,
            minor: 2,
            dot: 21
        },
        $get: function() {
            return {
                options: this.options,
                version: this.version
            };
        }
    };
})

.factory('oiSelectEscape', function() {
    var rEscapableCharacters = /[-\/\\^$*+?.()|[\]{}]/g;  
    var sEscapeMatch = '\\$&';

    return function(string) {
        return String(string).replace(rEscapableCharacters, sEscapeMatch);
    };
})

.factory('oiSelectEditItem', function() {
    return function(removedItem, lastQuery, getLabel, itemIsCorrected) {
        return itemIsCorrected ? '' : getLabel(removedItem);
    };
})

.factory('oiUtils', ['$document', '$timeout', function($document, $timeout) {
    /**
     * Check to see if a DOM element is a descendant of another DOM element.
     *
     * @param {DOM element} container
     * @param {DOM element} contained
     * @param {string} class name of element in container
     * @returns {boolean}
     */
    function contains(container, contained, className) {
        var current = contained;

        while (current && current.ownerDocument && current.nodeType !== 11) {
            if (className) {
                if (current === container) {
                    return false;
                }
                if (current.className.indexOf(className) >= 0) { 
                    return true;
                }
            } else {
                if (current === container) {
                    return true;
                }
            }
            current = current.parentNode;
        }

        return false;
    }

    /**
     * Simulate focus/blur events of the inner input element to the outer element
     *
     * @param {element} outer element
     * @param {element} inner input element
     * @returns {function} deregistration function for listeners.
     */
    function bindFocusBlur(element, inputElement) {
        var isFocused, isMousedown, isBlur;

        $document[0].addEventListener('click', clickHandler, true);
        element[0].addEventListener('mousedown', mousedownHandler, true);
        element[0].addEventListener('blur', blurHandler, true);
        inputElement.on('focus', focusHandler);

        function blurHandler(event) {
            if (event && event.target.nodeName !== 'INPUT') return; 

            isBlur = false;
            isFocused = false;

            if (isMousedown) {
                isBlur = true;
                return;
            }

            $timeout(function () {
                element.triggerHandler('blur'); 
            });
        }

        function focusHandler() {
            if (!isFocused) {
                isFocused = true;

                $timeout(function () {
                    element.triggerHandler('focus'); 
                });
            }
        }

        function mousedownHandler() {
            isMousedown = true;
        }

        function clickHandler(event) {
            isMousedown = false;

            var activeElement = event.target;
            var isSelectElement = contains(element[0], activeElement);

            if (isBlur && !isSelectElement) {
                blurHandler();
            }

            if (isSelectElement && activeElement.nodeName !== 'INPUT') {
                $timeout(function () {
                    inputElement[0].focus();
                });
            }

            if (!isSelectElement && isFocused) {
                isFocused = false;
            }
        }

        return function () {
            $document[0].removeEventListener('click', clickHandler, true);
            element[0].removeEventListener('mousedown', mousedownHandler, true);
            element[0].removeEventListener('blur', blurHandler, true);
            inputElement.off('focus', focusHandler);
        }
    }

    /**
     * Sets the selected item in the dropdown menu
     * of available options.
     *
     * @param {object} list
     * @param {object} item
     */
    function scrollActiveOption(list, item) {
        var y, height_menu, height_item, scroll, scroll_top, scroll_bottom;

        if (item) {
            height_menu = list.offsetHeight;
            height_item = getWidthOrHeight(item, 'height', 'margin'); 
            scroll = list.scrollTop || 0;
            y = getOffset(item).top - getOffset(list).top + scroll;
            scroll_top = y;
            scroll_bottom = y - height_menu + height_item;

            if (y + height_item > height_menu + scroll) {
                list.scrollTop = scroll_bottom;
            } else if (y < scroll) {
                list.scrollTop = scroll_top;
            }
        }
    }

    var core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i");

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ?
                4 :
                name === 'width' ? 1 : 0,

            val = 0,
            cssExpand = ['Top', 'Right', 'Bottom', 'Left'];

        function getStyleValue(name) {
            return parseFloat(styles[name]);
        }

        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += getStyleValue(extra + cssExpand[i]);
            }

            if (isBorderBox) {
                if (extra === 'content') {
                    val -= getStyleValue('padding' + cssExpand[i]);
                }

                if (extra !== 'margin') {
                    val -= getStyleValue('border' + cssExpand[i] + 'Width');
                }
            } else {
                val += getStyleValue('padding' + cssExpand[i]);

                if (extra !== 'padding') {
                    val += getStyleValue('border' + cssExpand[i] + 'Width');
                }
            }
        }

        return val;
    }

    function getOffset(elem) {
        var docElem, win,
            box = elem.getBoundingClientRect(),
            doc = elem && elem.ownerDocument;

        if (!doc) {
            return;
        }

        docElem = doc.documentElement;
        win = getWindow(doc);

        return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        };
    }

    function getWindow(elem) {
        return elem != null && elem === elem.window ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    function getWidthOrHeight(elem, name, extra) {

        var valueIsBorderBox = true,
            val = name === 'width' ? elem.offsetWidth : elem.offsetHeight,
            styles = window.getComputedStyle(elem, null),

            isBorderBox = false; 

        if (val <= 0 || val == null) {
            val = styles[name];

            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            if (rnumnonpx.test(val)) {
                return val;
            }

            val = parseFloat(val) || 0;
        }

        return val + augmentWidthOrHeight(elem, name, extra || ( isBorderBox ? "border" : "content" ), valueIsBorderBox, styles);
    }

    function groupsIsEmpty(groups) {
        for (var k in groups) {
            if (groups.hasOwnProperty(k) && groups[k].length) {
                return false;
            }
        }
        return true;
    }

    function intersection(xArr, yArr, xFilter, yFilter, invert) {
        var i, j, n, filteredX, filteredY, out = invert ? [].concat(xArr) : [];

        for (i = 0, n = xArr.length; i < xArr.length; i++) {
            filteredX = xFilter ? xFilter(xArr[i]) : xArr[i];

            for (j = 0; j < yArr.length; j++) {
                filteredY = yFilter ? yFilter(yArr[j]) : yArr[j];

                if (angular.equals(filteredX, filteredY, xArr, yArr, i, j)) {
                    invert ? out.splice(i + out.length - n, 1) : out.push(yArr[j]);
                    break;
                }
            }
        }
        return out;
    }

    function getValue(valueName, item, scope, getter) {
        var locals = {};

        valueName.split('.').reduce(function (previousValue, currentItem, index, arr) {
            return previousValue[currentItem] = index < arr.length - 1 ? {} : item;
        }, locals);

        return getter(scope, locals);
    }

    return {
        contains: contains,
        bindFocusBlur: bindFocusBlur,
        scrollActiveOption: scrollActiveOption,
        groupsIsEmpty: groupsIsEmpty,
        getValue: getValue,
        intersection: intersection
    }
}]);

angular.module("oi.select").provider("oiSelectOld",function(){return{options:{debounce:500,searchFilter:"oiSelectOldCloseIcon",dropdownFilter:"oiSelectOldHighlight",listFilter:"oiSelectOldAscSort",editItem:!1,newItem:!1,closeList:!0,saveTrigger:"enter"},version:{full:"0.2.8",major:0,minor:2,dot:8},$get:function(){return{options:this.options,version:this.version}}}}).factory("oiSelectOldEditItem",function(){return function(e,t,n){return n(e)}}).factory("oiUtilsOld",["$document","$timeout",function(e,t){function n(e,t,n){for(var o=t;o&&o.ownerDocument&&11!==o.nodeType;){if(n){if(o===e)return!1;if(o.classList.contains(n))return!0}else if(o===e)return!0;o=o.parentNode}return!1}function o(o,r){function i(e){var i=e.relatedTarget;return i===r[0]?void e.stopImmediatePropagation():(i&&!n(o[0],i)&&(u=!1,t(function(){o.triggerHandler("blur")})),void t(function(){r[0]!==document.activeElement&&(u=!1,o.triggerHandler("blur"))},100))}function s(){u||(u=!0,t(function(){o.triggerHandler("focus")}))}function l(e){var i=e.target,s=n(o[0],i);s&&"INPUT"!==i.nodeName&&t(function(){r[0].focus()}),!s&&u&&(u=!1,t(function(){o.triggerHandler("blur")}))}var u=!1;return e[0].addEventListener("click",l,!0),o[0].addEventListener("blur",i,!0),r.on("focus",s),function(){e[0].removeEventListener("click",l),o[0].removeEventListener("blur",i,!0),r.off("focus",s)}}function r(e,t){var n,o,r,i,l,c;t&&(o=e.offsetHeight,r=u(t,"height","margin"),i=e.scrollTop||0,n=s(t).top-s(e).top+i,l=n,c=n-o+r,n+r>o+i?e.scrollTop=c:i>n&&(e.scrollTop=l))}function i(e,t,n,o,r){function i(e){return parseFloat(r[e])}for(var s=n===(o?"border":"content")?4:"width"===t?1:0,l=0,u=["Top","Right","Bottom","Left"];4>s;s+=2)"margin"===n&&(l+=i(n+u[s])),o?("content"===n&&(l-=i("padding"+u[s])),"margin"!==n&&(l-=i("border"+u[s]+"Width"))):(l+=i("padding"+u[s]),"padding"!==n&&(l+=i("border"+u[s]+"Width")));return l}function s(e){var t,n,o=e.getBoundingClientRect(),r=e&&e.ownerDocument;if(r)return t=r.documentElement,n=l(r),{top:o.top+n.pageYOffset-t.clientTop,left:o.left+n.pageXOffset-t.clientLeft}}function l(e){return null!=e&&e===e.window?e:9===e.nodeType&&e.defaultView}function u(e,t,n){var o=!0,r="width"===t?e.offsetWidth:e.offsetHeight,s=window.getComputedStyle(e,null),l=!1;if(0>=r||null==r){if(r=s[t],(0>r||null==r)&&(r=e.style[t]),m.test(r))return r;r=parseFloat(r)||0}return r+i(e,t,n||(l?"border":"content"),o,s)}function c(e,t){t.css("width",u(e[0],"width","margin")+"px")}function a(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t].length)return!1;return!0}function d(e){var t=[];return angular.forEach(e,function(e,n){"$"!==n.toString().charAt(0)&&t.push(e)}),t}function p(e,t,n,o,r){var i,s,l,u,c,a=r?[].concat(e):[];for(i=0,l=e.length;i<e.length;i++)for(u=n?n(e[i]):e[i],s=0;s<t.length;s++)if(c=o?o(t[s]):t[s],angular.equals(u,c,e,t,i,s)){r?a.splice(i+a.length-l,1):a.push(t[s]);break}return a}function g(e,t,n,o){var r={};return e.split(".").reduce(function(e,n,o,r){return e[n]=o<r.length-1?{}:t},r),o(n,r)}var f=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,m=new RegExp("^("+f+")(?!px)[a-z%]+$","i");return{copyWidth:c,contains:n,bindFocusBlur:o,scrollActiveOption:r,groupsIsEmpty:a,objToArr:d,getValue:g,intersection:p}}]),angular.module("oi.select").directive("oiSelectOld",["$document","$q","$timeout","$parse","$interpolate","$injector","$filter","$animate","oiUtilsOld","oiSelectOld",function(e,t,n,o,r,i,s,l,u,c){var a=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,d=/([^\(\)\s\|\s]*)\s*(\(.*\))?\s*(\|?\s*.+)?/;return{restrict:"AE",templateUrl:"srcOld/template.html",require:"ngModel",scope:{},compile:function(e,p){var g,f=p.oiOptions;if(!(g=f.match(a)))throw new Error("Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_'");var m,h,v=/ as /.test(g[0])&&g[1],b=g[2]||g[1],w=g[5]||g[7],$=g[3]||"",y=g[4]||"",I=g[9]||b,k=g[8].match(d),F=k[1],S=F+(k[3]||""),q=F+(k[2]||""),P=v&&o(v),V=o(b),L=o($),E=o(y),x=o(S),O=o(q),C=o(I),H=angular.isDefined(p.multiple),D=Number(p.multipleLimit)||1/0,A=r(p.placeholder||""),T=o(p.oiSelectOldOptions),_=!1,N=!1,Q=!0;return function(e,o,r,a){function d(){e.listItemHide=!0,e.inputHide=!1}function p(){e.listItemHide=!a.$modelValue,e.inputHide=!!a.$modelValue}function g(t){u.contains(o[0],t.target,"disabled")||e.output.length>=D&&u.contains(o[0],t.target,"select-dropdown")||(e.isOpen&&J.closeList&&"INPUT"!==t.target.nodeName?W({query:J.editItem&&!Z}):R(e.query))}function f(){e.isFocused||(e.isFocused=!0,r.disabled||(e.backspaceFocus=!1))}function v(){e.isFocused=!1,H||(J.cleanModel&&!e.inputHide&&a.$setViewValue(void 0),p()),Q=!0,b("blur"),e.$evalAsync()}function b(o){var r=new RegExp(o).test(J.saveTrigger),i=J.newItem&&e.query,s=angular.isNumber(e.selectorPosition),l=e.order[e.selectorPosition],u=J.newItemFn||J.newItemModelFn,c=t.reject(),a="blur"!==o||e.query||!J.newItem;r&&(i||s&&l)&&(e.showLoader=!0,c=t.when("blur"!==o&&l||e.query&&u(e.query))),c.then(function(t){a&&(e.addItem(t),Q=!0)}).finally(function(){var t=e.order.length-1;e.selectorPosition===t&&j(X,0),J.newItemFn&&!s||n(angular.noop),W()})}function $(){var e=H&&a.$modelValue&&a.$modelValue.length?"":Y;z.attr("placeholder",e)}function y(t){return u.getValue(w,t,e.$parent,C)}function I(t){return u.getValue(w,t,e.$parent,P)}function k(t){return u.getValue(w,t,e.$parent,V)}function S(t){return u.getValue(w,t,e.$parent,E)}function q(t){return u.getValue(w,t,e.$parent,L)||""}function M(t){return u.getValue(F,t,e.$parent,x)}function R(o,r){var i=O(e.$parent,{$query:o,$querySelectAs:r}),l=0;return e.selectorPosition="prompt"===J.newItem?!1:0,o||r||(e.oldQuery=null),m&&(angular.isFunction(i.then)||angular.isFunction(i.$promise))&&(n.cancel(m),l=J.debounce),m=n(function(){return e.showLoader=!0,t.when(i.$promise||i).then(function(t){if(!r){var n=H?e.output:[],i=s(J.listFilter)(u.objToArr(t),o,k),l=u.intersection(i,n,y,y,!0),c=M(l);e.groups=B(c),U()}return t}).finally(function(){e.showLoader=!1})},l)}function U(){var t,n,o,r=[],i=0;e.order=[],e.groupPos={};for(n in e.groups)e.groups.hasOwnProperty(n)&&"$"!=n.charAt(0)&&r.push(n);for(angular.version.major<=1&&angular.version.minor<=3&&r.sort(),t=0;t<r.length;t++)n=r[t],o=e.groups[n],e.order=e.order.concat(o),e.groupPos[n]=i,i+=o.length}function W(t){t=t||{},t.oldQuery||(e.oldQuery=null),t.backspaceFocus||(e.backspaceFocus=!1),t.query||(e.query=""),t.groups||(e.groups={}),t.order||(e.order=[]),t.showLoader||(e.showLoader=!1),t.isOpen||(e.isOpen=!1),m&&n.cancel(m)}function j(t,n){e.selectorPosition=n,u.scrollActiveOption(t[0],t.find("li")[n])}function B(e){for(var t,n,o={"":[]},r=0;r<e.length;r++)t=q(e[r]),(n=o[t])||(n=o[t]=[]),n.push(e[r]);return o}var z=o.find("input"),X=angular.element(o[0].querySelector(".select-dropdown")),Y=A(e),G=T(e.$parent)||{},J=angular.extend({cleanModel:"prompt"===G.newItem},c.options,G),K=J.editItem===!0||"correct"===J.editItem?"oiSelectOldEditItem":J.editItem,Z="correct"===J.editItem,et=K?i.get(K):function(){return""},tt=u.bindFocusBlur(o,z);J.newItemModelFn=function(e){return(T({$query:e})||{}).newItemModel||e},angular.isDefined(r.autofocus)&&n(function(){z[0].focus()}),angular.isDefined(r.readonly)&&z.attr("readonly",!0),angular.isDefined(r.tabindex)&&(z.attr("tabindex",r.tabindex),o[0].removeAttribute("tabindex")),r.$observe("disabled",function(t){z.prop("disabled",t),e.inputHide=t}),e.$on("destroy",tt),e.$parent.$watch(r.ngModel,function(n){var o=n instanceof Array?n:n?[n]:[],r=t.when(o);$(),H||p(),P&&n&&(r=R(null,n).then(function(e){return u.intersection(o,e,null,I)}),m=null),r.then(function(t){e.output=t,t.length!==o.length&&e.removeItem(t.length)})}),e.$watch("query",function(t,n){t===n||e.oldQuery&&!t||N||(X[0].scrollTop=0,t?(R(t),e.oldQuery=null):H&&(W(),N=!0)),N=!1}),e.$watch("groups",function(t){u.groupsIsEmpty(t)?e.isOpen=!1:e.isOpen||r.disabled||(e.isOpen=!0,e.isFocused=!0,u.copyWidth(o,X))}),e.$watch("isFocused",function(e){l[e?"addClass":"removeClass"](o,"focused",{tempClasses:"focused-animate"})}),e.$watch("isOpen",function(e){l[e?"addClass":"removeClass"](o,"open",{tempClasses:"open-animate"})}),e.$watch("showLoader",function(e){l[e?"addClass":"removeClass"](o,"loading",{tempClasses:"loading-animate"})}),e.addItem=function(t){if(h=e.query,!H||!u.intersection(e.output,[t],y,y).length){if(e.output.length>=D)return o.addClass("limited"),void n(function(){o.removeClass("limited")},150);var r=e.groups[q(t)]=e.groups[q(t)]||[],i=P?I(t):t;r.splice(r.indexOf(t),1),H?a.$setViewValue(angular.isArray(a.$modelValue)?a.$modelValue.concat(i):[i]):(a.$setViewValue(i),p()),u.groupsIsEmpty(e.groups)&&(e.groups={}),H||J.closeList||W({query:!0}),Q=!1,e.oldQuery=e.oldQuery||e.query,e.query="",e.backspaceFocus=!1}},e.removeItem=function(t){var n;r.disabled||(H&&t>=0&&(n=a.$modelValue[t],a.$modelValue.splice(t,1),a.$setViewValue([].concat(a.$modelValue))),H||(n=a.$modelValue,d()),Z||!H&&e.backspaceFocus||(e.query=et(n,h,k)),Z=!1,H&&J.closeList&&W({query:!0}))},e.setSelection=function(t){_||e.selectorPosition===t?_=!1:j(X,t)},e.keyUp=function(t){switch(t.keyCode){case 8:e.query.length||H&&e.output.length||W()}},e.keyDown=function(t){var n=0,o=e.order.length-1;switch(t.keyCode){case 38:e.selectorPosition=angular.isNumber(e.selectorPosition)?e.selectorPosition:n,j(X,e.selectorPosition===n?o:e.selectorPosition-1),_=!0;break;case 40:e.selectorPosition=angular.isNumber(e.selectorPosition)?e.selectorPosition:n-1,j(X,e.selectorPosition===o?n:e.selectorPosition+1),_=!0,e.query.length||e.isOpen||R();break;case 37:case 39:break;case 13:b("enter"),t.preventDefault();break;case 27:H||p(),W();break;case 8:if(!e.query.length){if((!H||K)&&(e.backspaceFocus=!0),e.backspaceFocus&&e.output){e.removeItem(e.output.length-1),K&&t.preventDefault();break}e.backspaceFocus=!e.backspaceFocus;break}default:return e.backspaceFocus=!1,!1}},e.getSearchLabel=function(t){var n=k(t);return J.searchFilter&&(n=s(J.searchFilter)(n,e.oldQuery||e.query,t)),n},e.getDropdownLabel=function(t){var n=k(t);return J.dropdownFilter&&(n=s(J.dropdownFilter)(n,e.oldQuery||e.query,t)),n},e.getDisableWhen=S,H&&(a.$isEmpty=function(e){return!e||!e.length}),W(),o[0].addEventListener("click",g,!0),o.on("focus",f),o.on("blur",v)}}}}]),angular.module("oi.select").filter("oiSelectOldCloseIcon",["$sce",function(e){return function(t){var n='<span class="close select-search-list-item_selection-remove">×</span>';return e.trustAsHtml(t+n)}}]).filter("oiSelectOldHighlight",["$sce",function(e){return function(t,n){var o;return n.length>0||angular.isNumber(n)?(t=t.toString(),n=n.toString().replace(/\s+.*/,"").replace(/\\/g,"\\\\"),o=t.replace(new RegExp(n,"gi"),"<strong>$&</strong>")):o=t,e.trustAsHtml(o)}}]).filter("oiSelectOldAscSort",function(){function e(e,t,n){var o,r,i=[],s=[],l=[];if(t){for(t=t.toString().replace(/\s+.*/,"").replace(/\\/g,"\\\\"),o=0;o<e.length;o++)n(e[o]).match(new RegExp(t,"i"))&&i.push(e[o]);for(o=0;o<i.length;o++)n(i[o]).match(new RegExp("^"+t,"i"))?s.push(i[o]):l.push(i[o]);r=s.concat(l)}else r=[].concat(e);return r}return e}).filter("none",function(){return function(e){return e}}),angular.module("oi.select").run(["$templateCache",function(e){e.put("srcOld/template.html",'<div class=select-search><ul class=select-search-list><li class="btn btn-default btn-xs select-search-list-item select-search-list-item_selection" ng-hide=listItemHide ng-repeat="item in output track by $index" ng-class="{focused: backspaceFocus && $last}" ng-click=removeItem($index) ng-bind-html=getSearchLabel(item)></li><li class="select-search-list-item select-search-list-item_input" ng-class="{\'select-search-list-item_hide\': inputHide}"><input autocomplete=off ng-model=query ng-keyup=keyUp($event) ng-keydown=keyDown($event)></li><li class="select-search-list-item select-search-list-item_loader" ng-show=showLoader></li></ul></div><div class=select-dropdown ng-show=isOpen><ul ng-if=isOpen class=select-dropdown-optgroup ng-repeat="(group, options) in groups"><div class=select-dropdown-optgroup-header ng-if="group && options.length" ng-bind=group></div><li class=select-dropdown-optgroup-option ng-init="isDisabled = getDisableWhen(option)" ng-repeat="option in options" ng-class="{\'active\': selectorPosition === groupPos[group] + $index, \'disabled\': isDisabled}" ng-click="isDisabled || addItem(option)" ng-mouseenter="setSelection(groupPos[group] + $index)" ng-bind-html=getDropdownLabel(option)></li></ul></div>')}]);
/**
 * Numeric directive.
 * Version: 0.9.8
 * 
 * Numeric only input. Limits input to:
 * - max value: maximum input value. Default undefined (no max).
 * - min value: minimum input value. Default undefined (no min).
 * - decimals: number of decimals. Default 2.
 * - formatting: apply thousand separator formatting. Default true.
 */
(function () {
    'use strict';

    angular
        .module('purplefox.numeric', [])
        .directive('numeric', numeric);

    numeric.$inject = ['$locale'];

    function numeric($locale) {
        var directive = {
            link: link,
            require: 'ngModel',
            restrict: 'A'
        };
        return directive;


        function link(scope, el, attrs, ngModelCtrl) {
            var decimalSeparator = $locale.NUMBER_FORMATS.DECIMAL_SEP;
            var groupSeparator = $locale.NUMBER_FORMATS.GROUP_SEP;

            var NUMBER_REGEXP = "^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$";
            var regex = new RegExp(NUMBER_REGEXP);

            var formatting = true;
            var maxInputLength = 18;            
            var max = 99999999999999;                            
            var min = 0;                            
            var decimals = 4;                   
            var lastValidValue;                 

            ngModelCtrl.$parsers.push(parseViewValue);
            ngModelCtrl.$parsers.push(minValidator);
            ngModelCtrl.$parsers.push(maxValidator);
            ngModelCtrl.$formatters.push(formatViewValue);

            el.bind('blur', onBlur);        
            el.bind('focus', onFocus);      

            scope.$watch(attrs.min, onMinChanged);
            scope.$watch(attrs.max, onMaxChanged);
            scope.$watch(attrs.decimals, onDecimalsChanged);
            scope.$watch(attrs.formatting, onFormattingChanged);

            if (decimals > -1) {
                ngModelCtrl.$parsers.push(function (value) {
                    return (value) ? round(value) : value;
                });
                ngModelCtrl.$formatters.push(function (value) {
                    return (value) ? formatPrecision(value) : value;
                });
            }

            function onMinChanged(value) {
                if (!angular.isUndefined(value)) {
                    min = parseFloat(value);
                    lastValidValue = minValidator(ngModelCtrl.$modelValue);
                    ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                    ngModelCtrl.$render();
                }
            }

            function onMaxChanged(value) {
                if (!angular.isUndefined(value)) {
                    max = parseFloat(value);
                    maxInputLength = calculateMaxLength(max);
                    lastValidValue = maxValidator(ngModelCtrl.$modelValue);
                    ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                    ngModelCtrl.$render();
                }
            }

            function onDecimalsChanged(value) {
                if (!angular.isUndefined(value)) {
                    decimals = parseFloat(value);
                    maxInputLength = calculateMaxLength(max);
                    if (lastValidValue !== undefined) {
                        ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                        ngModelCtrl.$render();
                    }
                }
            }

            function onFormattingChanged(value) {
                if (!angular.isUndefined(value)) {
                    formatting = (value !== false);
                    ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                    ngModelCtrl.$render();
                }
            }

            /**
             * Round the value to the closest decimal.
             */
            function round(value) {
                var d = Math.pow(10, decimals);
                return Math.round(value * d) / d;
            }

            /**
             * Format a number with the thousand group separator.
             */
            function numberWithCommas(value) {
                if (formatting) {
                    var parts = value.toString().split(decimalSeparator);
                    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
                    return parts.join(decimalSeparator);
                }
                else {
                    return value;
                }
            }

            /**
             * Format a value with thousand group separator and correct decimal char.
             */
            function formatPrecision(value) {
                if (!(value || value === 0)) {
                    return '';
                }
                var formattedValue = parseFloat(value).toFixed(decimals);
                formattedValue = formattedValue.replace('.', decimalSeparator);
                return numberWithCommas(formattedValue);
            }

            function formatViewValue(value) {
                return ngModelCtrl.$isEmpty(value) ? '' : '' + value;
            }

            /**
             * Parse the view value.
             */
            function parseViewValue(value) {
                if (angular.isUndefined(value)) {
                    value = '';
                }
                value = value.toString().replace(decimalSeparator, '.');

                if (value.indexOf('.') === 0) {
                    value = '0' + value;
                }

                if (value.indexOf('-') === 0) {
                    if (min >= 0) {
                        value = null;
                        ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));
                        ngModelCtrl.$render();
                    }
                    else if (value === '-') {
                        value = '';
                    }
                }

                var empty = ngModelCtrl.$isEmpty(value);
                if (empty) {
                    lastValidValue = '';
                } 
                else {
                    if (regex.test(value) && (value.length <= maxInputLength)) {
                        if (value > max) {
                            lastValidValue = max - 1;
                            ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));
                            ngModelCtrl.$render();
                            return lastValidValue;
                        }
                        else if (value < min) {
                            lastValidValue = min;
                        }
                        else {
                            lastValidValue = (value === '') ? null : parseFloat(value);
                        }
                    }
                    else {
                        ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));
                        ngModelCtrl.$render();
                    }
                }

                return lastValidValue;
            }

            /**
             * Calculate the maximum input length in characters.
             * If no maximum the input will be limited to 16; the maximum ECMA script int.
             */
            function calculateMaxLength(value) {
                var length = 18;
                if (!angular.isUndefined(value)) {
                    length = Math.floor(value).toString().length;
                }
                if (decimals > 0) {
                    length += decimals + 1; 
                }
                if (min < 0) {
                    length++;
                }
                return length;
            }

            /**
             * Minimum value validator.
             */
            function minValidator(value) {
                if (!angular.isUndefined(min)) {
                    if (!ngModelCtrl.$isEmpty(value) && (value < min)) {
                        return min;
                    } else {
                        return value;
                    }
                }
                else {
                    return value;
                }
            }

            /**
             * Maximum value validator.
             */
            function maxValidator(value) {
                if (!angular.isUndefined(max)) {
                    if (!ngModelCtrl.$isEmpty(value) && (value > max)) {
                        return max;
                    } else {
                        return value;
                    }
                }
                else {
                    return value;
                }
            }


            /**
             * Function for handeling the blur (leave) event on the control.
             */
            function onBlur() {
                var value = ngModelCtrl.$modelValue;
                if (!angular.isUndefined(value)) {
                    ngModelCtrl.$viewValue = formatPrecision(value);
                    ngModelCtrl.$render();
                }
            }

            
            /**
             * Function for handeling the focus (enter) event on the control.
             * On focus show the value without the group separators.
             */
            function onFocus() {
                var value = ngModelCtrl.$modelValue;
                if (!angular.isUndefined(value)) {
                    ngModelCtrl.$viewValue = value.toString().replace(".", decimalSeparator);
                    ngModelCtrl.$render();
                }
            }
        }
    }

})();

/*
 AngularJS v1.5.0-rc.0
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(A,d,B){'use strict';function l(){return["$animate",function(v){return{restrict:"AE",transclude:"element",priority:1,terminal:!0,require:"^^ngMessages",link:function(n,r,a,b,m){var k=r[0],f,p=a.ngMessage||a.when;a=a.ngMessageExp||a.whenExp;var d=function(a){f=a?w(a)?a:a.split(/[\s,]+/):null;b.reRender()};a?(d(n.$eval(a)),n.$watchCollection(a,d)):d(p);var e,q;b.register(k,q={test:function(a){var g=f;a=g?w(g)?0<=g.indexOf(a):g.hasOwnProperty(a):void 0;return a},attach:function(){e||m(n,function(a){v.enter(a,
null,r);e=a;var g=e.$$attachId=b.getAttachId();e.on("$destroy",function(){e&&e.$$attachId===g&&(b.deregister(k),q.detach())})})},detach:function(){if(e){var a=e;e=null;v.leave(a)}}})}}}]}var w=d.isArray,x=d.forEach,y=d.isString,z=d.element;d.module("ngMessages",[]).directive("ngMessages",["$animate",function(d){function n(a,b){return y(b)&&0===b.length||r(a.$eval(b))}function r(a){return y(a)?a.length:!!a}return{require:"ngMessages",restrict:"AE",controller:["$element","$scope","$attrs",function(a,
b,m){function k(a,b){for(var c=b,f=[];c&&c!==a;){var h=c.$$ngMessageNode;if(h&&h.length)return e[h];c.childNodes.length&&-1==f.indexOf(c)?(f.push(c),c=c.childNodes[c.childNodes.length-1]):c=c.previousSibling||c.parentNode}}var f=this,p=0,l=0;this.getAttachId=function(){return l++};var e=this.messages={},q,s;this.render=function(g){g=g||{};q=!1;s=g;for(var e=n(b,m.ngMessagesMultiple)||n(b,m.multiple),c=[],k={},h=f.head,p=!1,l=0;null!=h;){l++;var t=h.message,u=!1;p||x(g,function(a,c){!u&&r(a)&&t.test(c)&&
!k[c]&&(u=k[c]=!0,t.attach())});u?p=!e:c.push(t);h=h.next}x(c,function(a){a.detach()});c.length!==l?d.setClass(a,"ng-active","ng-inactive"):d.setClass(a,"ng-inactive","ng-active")};b.$watchCollection(m.ngMessages||m["for"],f.render);this.reRender=function(){q||(q=!0,b.$evalAsync(function(){q&&s&&f.render(s)}))};this.register=function(g,b){var c=p.toString();e[c]={message:b};var d=a[0],h=e[c];f.head?(d=k(d,g))?(h.next=d.next,d.next=h):(h.next=f.head,f.head=h):f.head=h;g.$$ngMessageNode=c;p++;f.reRender()};
this.deregister=function(b){var d=b.$$ngMessageNode;delete b.$$ngMessageNode;var c=e[d];(b=k(a[0],b))?b.next=c.next:f.head=c.next;delete e[d];f.reRender()}}]}}]).directive("ngMessagesInclude",["$templateRequest","$document","$compile",function(d,n,l){return{restrict:"AE",require:"^^ngMessages",link:function(a,b,m){var k=m.ngMessagesInclude||m.src;d(k).then(function(d){l(d)(a,function(a){b.after(a);a=z(n[0].createComment(" ngMessagesInclude: "+k+" "));b.after(a);b.remove()})})}}}]).directive("ngMessage",
l()).directive("ngMessageExp",l())})(window,window.angular);

/**
 * adapt-strap
 * @version v2.6.1 - 2016-08-09
 * @link https://github.com/Adaptv/adapt-strap
 * @author Kashyap Patel (kashyap@adap.tv)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
'use strict';
// Source: module.js
angular.module('adaptv.adaptStrap', [
  'adaptv.adaptStrap.utils',
  'adaptv.adaptStrap.treebrowser',
  'adaptv.adaptStrap.tablelite',
  'adaptv.adaptStrap.tableajax',
  'adaptv.adaptStrap.loadingindicator',
  'adaptv.adaptStrap.draggable',
  'adaptv.adaptStrap.infinitedropdown',
  'adaptv.adaptStrap.alerts'
]).provider('$adConfig', function () {
  var iconClasses = this.iconClasses = {
      expand: 'glyphicon glyphicon-plus-sign',
      collapse: 'glyphicon glyphicon-minus-sign',
      loadingSpinner: 'glyphicon glyphicon-refresh ad-spin',
      firstPage: 'glyphicon glyphicon-fast-backward',
      previousPage: 'glyphicon glyphicon-backward',
      nextPage: 'glyphicon glyphicon-forward',
      lastPage: 'glyphicon glyphicon-fast-forward',
      sortAscending: 'glyphicon glyphicon-chevron-up',
      sortDescending: 'glyphicon glyphicon-chevron-down',
      sortable: 'glyphicon glyphicon-resize-vertical',
      draggable: 'glyphicon glyphicon-align-justify',
      selectedItem: 'fa fa-check',
      alertInfoSign: 'glyphicon glyphicon-info-sign',
      alertSuccessSign: 'fa fa-check',
      alertWarningSign: 'glyphicon glyphicon-warning-sign',
      alertDangerSign: 'glyphicon glyphicon-exclamation-sign'
    }, paging = this.paging = {
      request: {
        start: 'skip',
        pageSize: 'limit',
        page: 'page',
        sortField: 'sort',
        sortDirection: 'sort_dir',
        sortAscValue: 'asc',
        sortDescValue: 'desc'
      },
      response: {
        itemsLocation: 'data',
        totalItems: 'pagination.totalCount'
      },
      pageSize: 10,
      pageSizes: [
        10,
        25,
        50
      ]
    }, componentClasses = this.componentClasses = {
      tableLiteClass: 'table',
      tableAjaxClass: 'table'
    };
  this.$get = function () {
    return {
      iconClasses: iconClasses,
      paging: paging,
      componentClasses: componentClasses
    };
  };
});

// Source: alerts.js
angular.module('adaptv.adaptStrap.alerts', []).directive('adAlerts', [function () {
function controllerFunction($scope, $attrs, $adConfig, adAlerts) {
      $scope.iconMap = {
        'info': $adConfig.iconClasses.alertInfoSign,
        'success': $adConfig.iconClasses.alertSuccessSign,
        'warning': $adConfig.iconClasses.alertWarningSign,
        'danger': $adConfig.iconClasses.alertDangerSign
      };
      var timeout = $scope.timeout && !Number(timeout).isNAN ? $scope.timeout : 0;
      var timeoutPromise;
      $scope.close = function () {
        adAlerts.clear();
        if (timeoutPromise) {
          clearTimeout(timeoutPromise);
        }
      };
      $scope.customClasses = $scope.customClasses || '';
      $scope.settings = adAlerts.settings;
      if (timeout !== 0) {
        $scope.$watch('settings.type', function (type) {
          if (type !== '') {
            if (timeoutPromise) {
              clearTimeout(timeoutPromise);
            }
            timeoutPromise = setTimeout($scope.close, timeout);
          }
        });
      }
    }
    return {
      restrict: 'AE',
      scope: {
        timeout: '=',
        customClasses: '@'
      },
      templateUrl: 'alerts/alerts.tpl.html',
      controller: [
        '$scope',
        '$attrs',
        '$adConfig',
        'adAlerts',
        controllerFunction
      ]
    };
  }]);

// Source: alerts.svc.js
angular.module('adaptv.adaptStrap.alerts').factory('adAlerts', [function () {
    var _settings = {
        type: '',
        caption: '',
        message: ''
      };
    function _updateSettings(type, caption, msg) {
      _settings.type = type;
      _settings.caption = caption;
      _settings.message = msg;
    }
    function _warning(cap, msg) {
      _updateSettings('warning', cap, msg);
    }
    function _info(cap, msg) {
      _updateSettings('info', cap, msg);
    }
    function _success(cap, msg) {
      _updateSettings('success', cap, msg);
    }
    function _error(cap, msg) {
      _updateSettings('danger', cap, msg);
    }
    function _clearSettings() {
      _settings.type = '';
      _settings.caption = '';
      _settings.message = '';
    }
    return {
      settings: _settings,
      warning: _warning,
      info: _info,
      success: _success,
      error: _error,
      clear: _clearSettings
    };
  }]);

// Source: draggable.js
angular.module('adaptv.adaptStrap.draggable', []).directive('adDrag', [
  '$rootScope',
  '$parse',
  '$timeout',
  function ($rootScope, $parse, $timeout) {
    function linkFunction(scope, element, attrs) {
      scope.draggable = attrs.adDrag;
      scope.hasHandle = attrs.adDragHandle === 'false' || typeof attrs.adDragHandle === 'undefined' ? false : true;
      scope.onDragStartCallback = $parse(attrs.adDragBegin) || null;
      scope.onDragEndCallback = $parse(attrs.adDragEnd) || null;
      scope.useClonedElement = attrs.adDragCloneElement === 'true';
      scope.data = null;
      var offset, mx, my, tx, ty;
      var hasTouch = 'ontouchstart' in document.documentElement;
      /* -- Events -- */
      var startEvents = 'touchstart mousedown';
      var moveEvents = 'touchmove mousemove';
      var endEvents = 'touchend mouseup';
      var $document = $(document);
      var $window = $(window);
      var dragEnabled = false;
      var pressTimer = null;
      var draggedClone = null;
      function reset() {
        var elem = scope.useClonedElement ? draggedClone : element;
        elem.css({
          left: '',
          top: '',
          position: '',
          'z-index': ''
        });
        var width = elem.data('ad-draggable-temp-width');
        if (width) {
          elem.css({ width: width });
        } else {
          elem.css({ width: '' });
        }
        elem.children().each(function () {
          var width = $(this).data('ad-draggable-temp-width');
          if (width) {
            $(this).css({ width: width });
          } else {
            $(this).css({ width: '' });
          }
        });
      }
      function moveElement(x, y) {
        var elem = scope.useClonedElement ? draggedClone : element;
        elem.css({
          left: x,
          top: y,
          position: 'fixed',
          'z-index': 99999
        });
      }
      function onDragStart(evt, o) {
        if (o.el === element && o.callback) {
          o.callback(evt);
        }
      }
      function onDragEnd(evt, o) {
        if (o.el === element && o.callback) {
          o.callback(evt);
        }
      }
      function onDragBegin(evt) {
        if (!scope.onDragStartCallback) {
          return;
        }
        var elem = scope.useClonedElement ? draggedClone : element;
        scope.$apply(function () {
          scope.onDragStartCallback(scope, {
            $data: scope.data,
            $dragElement: { el: elem },
            $event: evt
          });
        });
      }
      function onDragComplete(evt) {
        if (!scope.onDragEndCallback) {
          return;
        }
        var elem = scope.useClonedElement ? draggedClone : element;
        // To fix a bug issue where onDragEnd happens before
        // onDropEnd. Currently the only way around this
        // Ideally onDropEnd should fire before onDragEnd
        $timeout(function () {
          scope.$apply(function () {
            scope.onDragEndCallback(scope, {
              $data: scope.data,
              $dragElement: { el: elem },
              $event: evt
            });
          });
        }, 100);
      }
      function onMove(evt) {
        var cx, cy;
        if (!dragEnabled) {
          return;
        }
        evt.preventDefault();
        cx = evt.pageX || evt.originalEvent.touches[0].pageX;
        cy = evt.pageY || evt.originalEvent.touches[0].pageY;
        tx = cx - mx + offset.left - $window.scrollLeft();
        ty = cy - my + offset.top - $window.scrollTop();
        cx = cx - $window.scrollLeft();
        cy = cy - $window.scrollTop();
        moveElement(tx, ty);
        var elem = scope.useClonedElement ? draggedClone : element;
        $rootScope.$broadcast('draggable:move', {
          x: mx,
          y: my,
          tx: tx,
          ty: ty,
          cx: cx,
          cy: cy,
          el: elem,
          data: scope.data
        });
      }
      function onRelease(evt) {
        if (!dragEnabled) {
          return;
        }
        evt.preventDefault();
        var elem = scope.useClonedElement ? draggedClone : element;
        $rootScope.$broadcast('draggable:end', {
          x: mx,
          y: my,
          tx: tx,
          ty: ty,
          el: elem,
          data: scope.data,
          callback: onDragComplete
        });
        if (scope.useClonedElement) {
          element.removeClass('ad-dragging');
          elem.remove();
        } else {
          elem.removeClass('ad-dragging');
        }
        reset();
        $document.off(moveEvents, onMove);
        $document.off(endEvents, onRelease);
      }
      function onEnableChange(newVal) {
        dragEnabled = scope.$eval(newVal);
      }
      function onDragDataChange(newVal) {
        scope.data = newVal;
      }
      function getInlineProperty(prop, element) {
        var styles = $(element).attr('style'), value;
        if (styles) {
          styles.split(';').forEach(function (e) {
            var style = e.split(':');
            if ($.trim(style[0]) === prop) {
              value = style[1];
            }
          });
        }
        return value;
      }
      function persistElementWidth() {
        var elem = scope.useClonedElement ? draggedClone : element;
        if (getInlineProperty('width', elem)) {
          elem.data('ad-draggable-temp-width', getInlineProperty('width', elem));
        }
        elem.width(elem.width());
        elem.children().each(function () {
          if (getInlineProperty('width', this)) {
            $(this).data('ad-draggable-temp-width', getInlineProperty('width', this));
          }
          $(this).width($(this).width());
        });
      }
      function onLongPress(evt) {
        if (!dragEnabled) {
          return;
        }
        evt.preventDefault();
        if (scope.useClonedElement) {
          draggedClone = element.clone().appendTo(element.parent());
          draggedClone.css({ position: 'fixed' });
        }
        var elem = scope.useClonedElement ? draggedClone : element;
        offset = element.offset();
        if (scope.hasHandle) {
          offset = element.find('.ad-drag-handle').offset();
        } else {
          offset = element.offset();
        }
        element.addClass('ad-dragging');
        mx = evt.pageX || evt.originalEvent.touches[0].pageX;
        my = evt.pageY || evt.originalEvent.touches[0].pageY;
        tx = offset.left - $window.scrollLeft();
        ty = offset.top - $window.scrollTop();
        persistElementWidth();
        moveElement(tx, ty);
        $document.on(moveEvents, onMove);
        $document.on(endEvents, onRelease);
        $rootScope.$broadcast('draggable:start', {
          x: mx,
          y: my,
          tx: tx,
          ty: ty,
          el: elem,
          data: scope.data,
          callback: onDragBegin
        });
      }
      function cancelPress() {
        clearTimeout(pressTimer);
        $document.off(moveEvents, cancelPress);
        $document.off(endEvents, cancelPress);
      }
      /*
       * When the element is clicked start the drag behaviour
       * On touch devices as a small delay so as not to prevent native window scrolling
       */
      function onPress(evt) {
        if (!dragEnabled) {
          return;
        }
        if ($(evt.target).is('[ad-prevent-drag]') || $(evt.target).parents('[ad-prevent-drag]').length > 0) {
          return;
        }
        if (hasTouch) {
          cancelPress();
          pressTimer = setTimeout(function () {
            cancelPress();
            onLongPress(evt);
          }, 100);
          $document.on(moveEvents, cancelPress);
          $document.on(endEvents, cancelPress);
        } else {
          onLongPress(evt);
          return false;
        }
      }
      function toggleListeners(enable) {
        if (!enable) {
          return;
        }
        // add listeners.
        scope.$on('$destroy', function () {
          toggleListeners(false);
        });
        attrs.$observe('adDrag', onEnableChange);
        scope.$watch(attrs.adDragData, onDragDataChange);
        scope.$on('draggable:start', onDragStart);
        scope.$on('draggable:end', onDragEnd);
        if (scope.hasHandle) {
          element.on(startEvents, '.ad-drag-handle', onPress);
        } else {
          element.on(startEvents, onPress);
          element.addClass('ad-draggable');
        }
      }
      function init() {
        element.attr('draggable', 'false');
        // prevent native drag
        toggleListeners(true);
      }
      init();
    }
    return {
      restrict: 'A',
      link: linkFunction
    };
  }
]).directive('adDrop', [
  '$rootScope',
  '$parse',
  function ($rootScope, $parse) {
    function linkFunction(scope, element, attrs) {
      scope.droppable = attrs.adDrop;
      scope.onDropCallback = $parse(attrs.adDropEnd) || null;
      scope.onDropOverCallback = $parse(attrs.adDropOver) || null;
      scope.onDropLeaveCallback = $parse(attrs.adDropLeave) || null;
      var dropEnabled = false;
      var elem = null;
      var lastDropElement = null;
      var $window = $(window);
      function getCurrentDropElement(x, y) {
        var bounds = element.offset();
        // set drag sensitivity
        var vthold = Math.floor(element.outerHeight() / 6);
        x = x + $window.scrollLeft();
        y = y + $window.scrollTop();
        return y >= bounds.top + vthold && y <= bounds.top + element.outerHeight() - vthold && (x >= bounds.left && x <= bounds.left + element.outerWidth()) && (x >= bounds.left && x <= bounds.left + element.outerWidth()) ? element : null;
      }
      function onEnableChange(newVal) {
        dropEnabled = scope.$eval(newVal);
      }
      function onDropChange(evt, obj) {
        if (elem !== obj.el) {
          elem = null;
        }
      }
      function onDragMove(evt, obj) {
        if (!dropEnabled) {
          return;
        }
        // If the dropElement and the drag element are the same
        if (element === obj.el) {
          return;
        }
        var el = getCurrentDropElement(obj.cx, obj.cy);
        if (el !== null) {
          elem = el;
          lastDropElement = elem;
          obj.el.lastDropElement = elem;
          scope.$apply(function () {
            scope.onDropOverCallback(scope, {
              $data: obj.data,
              $dragElement: { el: obj.el },
              $dropElement: { el: elem },
              $event: evt
            });
          });
          element.addClass('ad-drop-over');
          $rootScope.$broadcast('draggable:change', { el: elem });
        } else {
          if (obj.el.lastDropElement === element) {
            scope.$apply(function () {
              scope.onDropLeaveCallback(scope, {
                $data: obj.data,
                $dragElement: { el: obj.el },
                $dropElement: { el: obj.el.lastDropElement },
                $event: evt
              });
            });
            obj.el.lastDropElement.removeClass('ad-drop-over');
            delete obj.el.lastDropElement;  //elem = null;
          }
        }
      }
      function onDragEnd(evt, obj) {
        if (!dropEnabled) {
          return;
        }
        // call the adDrop element callback
        // Callback should fire only once
        if (elem) {
          scope.$apply(function () {
            scope.onDropCallback(scope, {
              $data: obj.data,
              $dragElement: { el: obj.el },
              $dropElement: { el: elem },
              $lastDropElement: { el: lastDropElement },
              $event: evt
            });
          });
        }
        elem = null;
        lastDropElement = null;
      }
      function toggleListeners(enable) {
        if (!enable) {
          return;
        }
        // add listeners.
        attrs.$observe('adDrop', onEnableChange);
        scope.$on('$destroy', function () {
          toggleListeners(false);
        });
        scope.$on('draggable:move', onDragMove);
        scope.$on('draggable:end', onDragEnd);
        scope.$on('draggable:change', onDropChange);
      }
      function init() {
        toggleListeners(true);
      }
      init();
    }
    return {
      restrict: 'A',
      link: linkFunction
    };
  }
]);

// Source: infinitedropdown.js
angular.module('adaptv.adaptStrap.infinitedropdown', [
  'adaptv.adaptStrap.utils',
  'adaptv.adaptStrap.loadingindicator'
]).directive('adInfiniteDropdown', [
  '$parse',
  '$compile',
  '$timeout',
  '$templateCache',
  '$adConfig',
  'adLoadPage',
  'adDebounce',
  'adStrapUtils',
  'adLoadLocalPage',
  function ($parse, $compile, $timeout, $templateCache, $adConfig, adLoadPage, adDebounce, adStrapUtils, adLoadLocalPage) {
function linkFunction(scope, element, attrs) {
      // scope initialization
      scope.attrs = attrs;
      scope.adStrapUtils = adStrapUtils;
      scope.onDataLoadedCallback = $parse(attrs.onDataLoaded) || null;
      scope.items = {
        list: [],
        paging: {
          currentPage: 1,
          totalPages: undefined,
          pageSize: Number(attrs.pageSize) || 10
        }
      };
      scope.localConfig = {
        loadingData: false,
        singleSelectionMode: $parse(attrs.singleSelectionMode)() ? true : false,
        dimensions: {
          'max-height': attrs.maxHeight || '200px',
          'max-width': attrs.maxWidth || 'auto'
        }
      };
      scope.selectedItems = scope.$eval(attrs.selectedItems) || [];
      scope.ajaxConfig = scope.$eval(attrs.ajaxConfig) || {};
      // ---------- Local data ---------- //
      var lastRequestToken, watchers = [];
      // ---------- ui handlers ---------- //
      scope.addRemoveItem = function (event, item, items) {
        event.stopPropagation();
        if (scope.localConfig.singleSelectionMode) {
          scope.selectedItems[0] = item;
        } else {
          adStrapUtils.addRemoveItemFromList(item, items);
        }
        var callback = scope.$eval(attrs.onItemClick);
        if (callback) {
          callback(item);
        }
        if (scope.localConfig.singleSelectionMode) {
          scope.dropdownStatus.open = false;
          element.find('.dropdown').removeClass('open');
        }
      };
      scope.loadPage = adDebounce(function (page) {
        lastRequestToken = Math.random();
        scope.localConfig.loadingData = true;
        var pageLoader = scope.$eval(attrs.pageLoader) || adLoadPage, params = {
            pageNumber: page,
            pageSize: scope.items.paging.pageSize,
            sortKey: scope.localConfig.predicate,
            sortDirection: scope.localConfig.reverse,
            ajaxConfig: scope.ajaxConfig,
            token: lastRequestToken
          }, successHandler = function (response) {
            if (response.token === lastRequestToken) {
              if (page === 1) {
                scope.items.list = response.items;
              } else {
                scope.items.list = scope.items.list.concat(response.items);
              }
              scope.items.paging.totalPages = response.totalPages;
              scope.items.paging.currentPage = response.currentPage;
              scope.localConfig.loadingData = false;
              if (attrs.onDataLoaded) {
                scope.onDataLoadedCallback(scope, {
                  $success: true,
                  $response: response
                });
              }
            }
          }, errorHandler = function () {
            scope.localConfig.loadingData = false;
            if (attrs.onDataLoaded) {
              scope.onDataLoadedCallback(scope, {
                $success: false,
                $response: null
              });
            }
          };
        if (attrs.localDataSource) {
          params.localData = scope.$eval(attrs.localDataSource);
          successHandler(adLoadLocalPage(params));
        } else {
          pageLoader(params).then(successHandler, errorHandler);
        }
      }, 10);
      scope.loadNextPage = function () {
        if (!scope.localConfig.loadingData) {
          if (scope.items.paging.currentPage + 1 <= scope.items.paging.totalPages) {
            scope.loadPage(scope.items.paging.currentPage + 1);
          }
        }
      };
      scope.dropdownHeaderAreaClicked = function (event) {
        event.stopPropagation();
      };
      // ---------- initialization and event listeners ---------- //
      //We do the compile after injecting the name spacing into the template.
      scope.loadPage(1);
      // ---------- set watchers ---------- //
      // reset on parameter change
      if (attrs.ajaxConfig) {
        scope.$watch(attrs.ajaxConfig, function (value) {
          if (value) {
            scope.loadPage(1);
          }
        }, true);
      }
      if (attrs.localDataSource) {
        watchers.push(scope.$watch(attrs.localDataSource, function (value) {
          if (value) {
            scope.loadPage(1);
          }
        }));
        watchers.push(scope.$watch(attrs.localDataSource + '.length', function (value) {
          if (value) {
            scope.loadPage(1);
          }
        }));
      }
      // for dropdown-header area
      scope.dropdownStatus = scope.$eval(attrs.dropdownStatus) || { open: false };
      watchers.push(scope.$watch('dropdownStatus.open', function (value) {
        if (value === true) {
          $timeout(function () {
            element.find('.dropdown').addClass('open');
          }, 0);
        } else {
          $timeout(function () {
            element.find('.dropdown').removeClass('open');
          }, 0);
        }
      }));
      element.find('.dropdown-toggle').click(function () {
        scope.$apply(function () {
          if (scope.dropdownStatus.open) {
            scope.dropdownStatus.open = false;
          } else {
            scope.dropdownStatus.open = true;
            element.find('.dropdown-header').outerWidth(element.find('.dropdown-menu').outerWidth());
          }
        });
      });
      $(document).click(function () {
        scope.$apply(function () {
          if (scope.dropdownStatus.open) {
            scope.dropdownStatus.open = false;
          }
        });
      });
      // ---------- disable watchers ---------- //
      scope.$on('$destroy', function () {
        watchers.forEach(function (watcher) {
          watcher();
        });
      });
      var listContainer = angular.element(element).find('ul')[0];
      // infinite scroll handler
      var loadFunction = adDebounce(function () {
          // This is for infinite scrolling.
          // When the scroll gets closer to the bottom, load more items.
          if (listContainer.scrollTop + listContainer.offsetHeight >= listContainer.scrollHeight - 300) {
            scope.loadNextPage();
          }
        }, 50);
      angular.element(listContainer).bind('mousewheel DOMMouseScroll scroll', function (event) {
        console.log('scrolling');
        if (event.originalEvent && event.originalEvent.deltaY) {
          listContainer.scrollTop += event.originalEvent.deltaY;
          event.preventDefault();
          event.stopPropagation();
        }
        loadFunction();
      });
    }
    return {
      restrict: 'E',
      scope: true,
      link: linkFunction,
      templateUrl: 'infinitedropdown/infinitedropdown.tpl.html'
    };
  }
]);

// Source: loadingindicator.js
angular.module('adaptv.adaptStrap.loadingindicator', []).directive('adLoadingIcon', [
  '$adConfig',
  '$compile',
  function ($adConfig, $compile) {
    return {
      restrict: 'E',
      compile: function compile() {
        return {
          pre: function preLink(scope, element, attrs) {
            var loadingIconClass = attrs.loadingIconClass || $adConfig.iconClasses.loadingSpinner, ngStyleTemplate = attrs.loadingIconSize ? 'ng-style="{\'font-size\': \'' + attrs.loadingIconSize + '\'}"' : '', template = '<i class="' + loadingIconClass + '" ' + ngStyleTemplate + '></i>';
            element.empty();
            element.append($compile(template)(scope));
          }
        };
      }
    };
  }
]).directive('adLoadingOverlay', [
  '$adConfig',
  function ($adConfig) {
    return {
      restrict: 'E',
      templateUrl: 'loadingindicator/loadingindicator.tpl.html',
      scope: {
        loading: '=',
        zIndex: '@',
        position: '@',
        containerClasses: '@',
        loadingIconClass: '@',
        loadingIconSize: '@'
      },
      compile: function compile() {
        return {
          pre: function preLink(scope) {
            scope.loadingIconClass = scope.loadingIconClass || $adConfig.iconClasses.loading;
            scope.loadingIconSize = scope.loadingIconSize || '3em';
          }
        };
      }
    };
  }
]);

// Source: tableajax.js
angular.module('adaptv.adaptStrap.tableajax', [
  'adaptv.adaptStrap.utils',
  'adaptv.adaptStrap.loadingindicator'
]).directive('adTableAjax', [
  '$parse',
  '$filter',
  '$adConfig',
  'adLoadPage',
  'adDebounce',
  'adStrapUtils',
  function ($parse, $filter, $adConfig, adLoadPage, adDebounce, adStrapUtils) {
function controllerFunction($scope, $attrs) {
      // ---------- $scope initialization ---------- //
      $scope.attrs = $attrs;
      $scope.attrs.state = $scope.attrs.state || {};
      $scope.iconClasses = $adConfig.iconClasses;
      $scope.adStrapUtils = adStrapUtils;
      $scope.tableClasses = $adConfig.componentClasses.tableAjaxClass;
      $scope.onDataLoadedCallback = $parse($attrs.onDataLoaded) || null;
      $scope.items = {
        list: undefined,
        allItems: undefined,
        paging: {
          currentPage: 1,
          totalPages: undefined,
          totalItems: undefined,
          pageSize: Number($attrs.pageSize) || $adConfig.paging.pageSize,
          pageSizes: $parse($attrs.pageSizes)() || $adConfig.paging.pageSizes
        }
      };
      $scope.localConfig = {
        pagingArray: [],
        loadingData: false,
        showNoDataFoundMessage: false,
        tableMaxHeight: $attrs.tableMaxHeight,
        expandedItems: [],
        sortState: {},
        stateChange: $scope.$eval($attrs.onStateChange)
      };
      $scope.selectedItems = $scope.$eval($attrs.selectedItems);
      $scope.onRowClick = function (item, event) {
        var onRowClick = $scope.$parent.$eval($attrs.onRowClick);
        if (onRowClick) {
          onRowClick(item, event);
        }
      };
      $scope.ajaxConfig = $scope.$eval($attrs.ajaxConfig);
      $scope.columnDefinition = $scope.$eval($attrs.columnDefinition);
      $scope.visibleColumnDefinition = $filter('filter')($scope.columnDefinition, $scope.columnVisible);
      // ---------- Local data ---------- //
      var lastRequestToken, watchers = [];
      if (!$scope.items.paging.pageSize && $scope.items.paging.pageSizes[0]) {
        $scope.items.paging.pageSize = $scope.items.paging.pageSizes[0];
      }
      // ---------- ui handlers ---------- //
      $scope.loadPage = adDebounce(function (page) {
        $scope.collapseAll();
        lastRequestToken = Math.random();
        $scope.localConfig.loadingData = true;
        $scope.localConfig.showNoDataFoundMessage = false;
        var pageLoader = $scope.$eval($attrs.pageLoader) || adLoadPage, params = {
            pageNumber: page,
            pageSize: $scope.items.paging.pageSize,
            sortKey: $scope.localConfig.sortState.sortKey,
            sortDirection: $scope.localConfig.sortState.sortDirection === 'DEC',
            ajaxConfig: $scope.ajaxConfig,
            token: lastRequestToken
          }, successHandler = function (response) {
            if (response.token === lastRequestToken) {
              $scope.items.list = response.items;
              $scope.items.allItems = response.items;
              $scope.items.paging.totalPages = response.totalPages;
              $scope.items.paging.totalItems = response.totalItems;
              $scope.items.paging.currentPage = response.currentPage;
              $scope.localConfig.pagingArray = response.pagingArray;
              $scope.localConfig.loadingData = false;
            }
            if (!response.totalPages) {
              $scope.localConfig.showNoDataFoundMessage = true;
            }
            if ($scope.onDataLoadedCallback) {
              $scope.onDataLoadedCallback($scope, {
                $success: true,
                $response: response
              });
            }
          }, errorHandler = function () {
            $scope.localConfig.loadingData = false;
            $scope.localConfig.showNoDataFoundMessage = true;
            if ($scope.onDataLoadedCallback) {
              $scope.onDataLoadedCallback($scope, {
                $success: false,
                $response: null
              });
            }
          };
        pageLoader(params).then(successHandler, errorHandler);
      });
      $scope.loadNextPage = function () {
        if (!$scope.localConfig.loadingData) {
          if ($scope.items.paging.currentPage + 1 <= $scope.items.paging.totalPages) {
            $scope.loadPage($scope.items.paging.currentPage + 1);
          }
        }
      };
      $scope.loadPreviousPage = function () {
        if (!$scope.localConfig.loadingData) {
          if ($scope.items.paging.currentPage - 1 > 0) {
            $scope.loadPage($scope.items.paging.currentPage - 1);
          }
        }
      };
      $scope.loadLastPage = function () {
        if (!$scope.localConfig.loadingData) {
          if ($scope.items.paging.currentPage !== $scope.items.paging.totalPages) {
            $scope.loadPage($scope.items.paging.totalPages);
          }
        }
      };
      $scope.pageSizeChanged = function (size) {
        if (Number(size) !== $scope.items.paging.pageSize) {
          $scope.items.paging.pageSize = Number(size);
          $scope.loadPage(1);
        }
      };
      $scope.columnVisible = function (column) {
        return column.visible !== false;
      };
      $scope.sortByColumn = function (column, preventNotification) {
        var sortDirection = $scope.localConfig.sortState.sortDirection || 'ASC';
        if (column.sortKey) {
          if (column.sortKey !== $scope.localConfig.sortState.sortKey) {
            $scope.localConfig.sortState = {
              sortKey: column.sortKey,
              sortDirection: column.sortDirection ? column.sortDirection : sortDirection
            };
          } else {
            if ($scope.localConfig.sortState.sortDirection === sortDirection) {
              $scope.localConfig.sortState.sortDirection = sortDirection === 'ASC' ? 'DEC' : 'ASC';
            } else {
              $scope.localConfig.sortState = {};
            }
          }
          $scope.loadPage($scope.items.paging.currentPage);
          if (!preventNotification && $scope.localConfig.stateChange) {
            $scope.localConfig.stateChange($scope.localConfig.sortState);
          }
        }
      };
      $scope.collapseAll = function () {
        $scope.localConfig.expandedItems.length = 0;
      };
      $scope.expandCollapseRow = function (index) {
        adStrapUtils.addRemoveItemFromList(index, $scope.localConfig.expandedItems);
      };
      $scope.getRowClass = function (item, index) {
        var rowClass = '';
        rowClass += $attrs.selectedItems && adStrapUtils.itemExistsInList(item, $scope.selectedItems) ? 'ad-selected' : '';
        rowClass += adStrapUtils.itemExistsInList(index, $scope.localConfig.expandedItems) ? ' row-expanded' : '';
        if ($attrs.rowClassProvider) {
          rowClass += ' ' + $scope.$eval($attrs.rowClassProvider)(item, index);
        }
        return rowClass;
      };
      $scope.toggle = function (event, index, item) {
        event.stopPropagation();
        adStrapUtils.addRemoveItemFromList(index, $scope.localConfig.expandedItems);
        if (adStrapUtils.itemExistsInList(index, $scope.localConfig.expandedItems)) {
          var rowExpandCallback = $scope.$eval($attrs.rowExpandCallback);
          if (rowExpandCallback) {
            rowExpandCallback(item);
          }
        }
      };
      // ---------- initialization and event listeners ---------- //
      var state = $scope.$eval($attrs.state) || {};
      var column = {
          sortKey: state.sortKey,
          sortDirection: state.sortDirection
        };
      $scope.sortByColumn(column, true);
      $scope.loadPage(1);
      // ---------- external events ------- //
      $scope.$on('adTableAjaxAction', function (event, data) {
        // Exposed methods for external actions
        var actions = { expandCollapseRow: $scope.expandCollapseRow };
        if (data.tableName === $scope.attrs.tableName) {
          data.action(actions);
        }
      });
      // reset on parameter change
      watchers.push($scope.$watch($attrs.ajaxConfig, function () {
        $scope.loadPage(1);
      }, true));
      watchers.push($scope.$watchCollection($attrs.columnDefinition, function () {
        $scope.columnDefinition = $scope.$eval($attrs.columnDefinition);
        $scope.visibleColumnDefinition = $filter('filter')($scope.columnDefinition, $scope.columnVisible);
      }));
      // ---------- disable watchers ---------- //
      $scope.$on('$destroy', function () {
        watchers.forEach(function (watcher) {
          watcher();
        });
      });
    }
    return {
      restrict: 'E',
      scope: true,
      templateUrl: 'tableajax/tableajax.tpl.html',
      controller: [
        '$scope',
        '$attrs',
        controllerFunction
      ]
    };
  }
]);

// Source: tablelite.js
angular.module('adaptv.adaptStrap.tablelite', ['adaptv.adaptStrap.utils']).directive('adTableLite', [
  '$parse',
  '$http',
  '$compile',
  '$filter',
  '$templateCache',
  '$adConfig',
  'adStrapUtils',
  'adDebounce',
  'adLoadLocalPage',
  function ($parse, $http, $compile, $filter, $templateCache, $adConfig, adStrapUtils, adDebounce, adLoadLocalPage) {
function controllerFunction($scope, $attrs) {
      // ---------- $$scope initialization ---------- //
      $scope.attrs = $attrs;
      $scope.attrs.state = $scope.attrs.state || {};
      $scope.iconClasses = $adConfig.iconClasses;
      $scope.adStrapUtils = adStrapUtils;
      $scope.tableClasses = $adConfig.componentClasses.tableLiteClass;
      $scope.columnDefinition = $scope.$eval($attrs.columnDefinition);
      $scope.visibleColumnDefinition = $filter('filter')($scope.columnDefinition, $scope.columnVisible);
      $scope.items = {
        list: undefined,
        allItems: undefined,
        paging: {
          currentPage: 1,
          totalPages: undefined,
          pageSize: Number($attrs.pageSize) || $adConfig.paging.pageSize,
          pageSizes: $parse($attrs.pageSizes)() || $adConfig.paging.pageSizes
        }
      };
      $scope.filters = {};
      $scope.localConfig = {
        localData: adStrapUtils.parse($scope.$eval($attrs.localDataSource)),
        pagingArray: [],
        dragChange: $scope.$eval($attrs.onDragChange),
        expandedItems: [],
        sortState: {},
        stateChange: $scope.$eval($attrs.onStateChange),
        draggable: $scope.$eval($attrs.draggable) || false
      };
      $scope.selectedItems = $scope.$eval($attrs.selectedItems);
      $scope.searchText = $scope.$eval($attrs.searchText);
      // ---------- Local data ---------- //
      var placeHolder = null, placeHolderInDom = false, pageButtonElement = null, validDrop = false, initialPos, watchers = [];
      function moveElementNode(nodeToMove, relativeNode, dragNode) {
        if (relativeNode.next()[0] === nodeToMove[0]) {
          relativeNode.before(nodeToMove);
        } else if (relativeNode.prev()[0] === nodeToMove[0]) {
          relativeNode.after(nodeToMove);
        } else {
          if (relativeNode.next()[0] === dragNode[0]) {
            relativeNode.before(nodeToMove);
          } else if (relativeNode.prev()[0] === dragNode[0]) {
            relativeNode.after(nodeToMove);
          }
        }
      }
      if (!$scope.items.paging.pageSize && $scope.items.paging.pageSizes[0]) {
        $scope.items.paging.pageSize = $scope.items.paging.pageSizes[0];
      }
      // ---------- ui handlers ---------- //
      $scope.loadPage = adDebounce(function (page) {
        $scope.collapseAll();
        var itemsObject, params, parsedData = adStrapUtils.parse($scope.$eval($attrs.localDataSource)), filterObj = {};
        $scope.localConfig.localData = !!$scope.searchText ? $filter('filter')(parsedData, $scope.searchText) : parsedData;
        if ($attrs.enableColumnSearch && adStrapUtils.hasAtLeastOnePropertyWithValue($scope.filters)) {
          angular.forEach($scope.filters, function (value, key) {
            if (key.indexOf('.') > -1) {
              angular.extend(filterObj, adStrapUtils.createdChainObjectAndInitValue(key, value));
            } else {
              filterObj[key] = value;
            }
          });
          $scope.localConfig.localData = $filter('filter')($scope.localConfig.localData, filterObj);
        }
        itemsObject = $scope.localConfig.localData;
        params = {
          pageNumber: page,
          pageSize: !$attrs.disablePaging ? $scope.items.paging.pageSize : itemsObject.length,
          sortKey: $scope.localConfig.sortState.sortKey,
          sortDirection: $scope.localConfig.sortState.sortDirection === 'DEC',
          localData: itemsObject,
          draggable: $scope.localConfig.draggable
        };
        var response = adLoadLocalPage(params);
        $scope.items.list = response.items;
        $scope.items.allItems = response.allItems;
        $scope.items.paging.currentPage = response.currentPage;
        $scope.items.paging.totalPages = response.totalPages;
        $scope.localConfig.pagingArray = response.pagingArray;
        if (response.items.length === 0) {
          $scope.loadPreviousPage();
          return;
        }
        $scope.$emit('adTableLite:pageChanged', $scope.items.paging);
      }, 100);
      $scope.loadNextPage = function () {
        if ($scope.items.paging.currentPage + 1 <= $scope.items.paging.totalPages) {
          $scope.loadPage($scope.items.paging.currentPage + 1);
        }
      };
      $scope.loadPreviousPage = function () {
        if ($scope.items.paging.currentPage - 1 > 0) {
          $scope.loadPage($scope.items.paging.currentPage - 1);
        }
      };
      $scope.loadLastPage = function () {
        if (!$scope.localConfig.disablePaging) {
          $scope.loadPage($scope.items.paging.totalPages);
        }
      };
      $scope.pageSizeChanged = function (size) {
        $scope.items.paging.pageSize = size;
        $scope.loadPage(1);
      };
      $scope.columnVisible = function (column) {
        return column.visible !== false;
      };
      $scope.sortByColumn = function (column, preventNotification) {
        var sortDirection = $scope.localConfig.sortState.sortDirection || 'ASC';
        if (column.sortKey) {
          if (column.sortKey !== $scope.localConfig.sortState.sortKey) {
            $scope.localConfig.sortState = {
              sortKey: column.sortKey,
              sortDirection: column.sortDirection ? column.sortDirection : sortDirection
            };
          } else {
            if ($scope.localConfig.sortState.sortDirection === sortDirection) {
              $scope.localConfig.sortState.sortDirection = sortDirection === 'ASC' ? 'DEC' : 'ASC';
            } else {
              $scope.localConfig.sortState = {};
            }
          }
          $scope.loadPage($scope.items.paging.currentPage);
          if (!preventNotification && $scope.localConfig.stateChange) {
            $scope.localConfig.stateChange($scope.localConfig.sortState);
          }
        }
      };
      $scope.unSortTable = function () {
        $scope.localConfig.sortState = {};
      };
      $scope.collapseAll = function () {
        $scope.localConfig.expandedItems.length = 0;
      };
      $scope.expandCollapseRow = function (index) {
        adStrapUtils.addRemoveItemFromList(index, $scope.localConfig.expandedItems);
      };
      $scope.onDragStart = function (data, dragElement) {
        $scope.localConfig.expandedItems.length = 0;
        dragElement = dragElement.el;
        var parent = dragElement.parent();
        placeHolder = $('<tr id="row-phldr"><td colspan=' + dragElement.find('td').length + '>&nbsp;</td></tr>');
        initialPos = dragElement.index() + ($scope.items.paging.currentPage - 1) * $scope.items.paging.pageSize;
        if (!placeHolderInDom) {
          if (dragElement[0] !== parent.children().last()[0]) {
            dragElement.next().before(placeHolder);
            placeHolderInDom = true;
          } else {
            parent.append(placeHolder);
            placeHolderInDom = true;
          }
        }
      };
      $scope.onDragEnd = function () {
        $('#row-phldr').remove();
        placeHolderInDom = false;
      };
      $scope.onDragOver = function (data, dragElement, dropElement) {
        if (placeHolder) {
          // Restricts valid drag to current table instance
          moveElementNode(placeHolder, dropElement.el, dragElement.el);
        }
      };
      $scope.onDropEnd = function (data, dragElement) {
        var endPos;
        dragElement = dragElement.el;
        if (placeHolder) {
          // Restricts drop to current table instance
          if (placeHolder.next()[0]) {
            placeHolder.next().before(dragElement);
          } else if (placeHolder.prev()[0]) {
            placeHolder.prev().after(dragElement);
          }
          $('#row-phldr').remove();
          placeHolderInDom = false;
          validDrop = true;
          endPos = dragElement.index() + ($scope.items.paging.currentPage - 1) * $scope.items.paging.pageSize;
          adStrapUtils.moveItemInList(initialPos, endPos, $scope.localConfig.localData);
          if ($scope.localConfig.draggable && $scope.localConfig.dragChange) {
            $scope.localConfig.dragChange(initialPos, endPos, data);
          }
          $scope.unSortTable();
          $scope.loadPage($scope.items.paging.currentPage);
        }
      };
      $scope.onPageButtonOver = function (data, dragElement, dropElement) {
        if (dropElement.el.attr('disabled') !== 'disabled') {
          pageButtonElement = dropElement.el;
          pageButtonElement.parent().addClass('active');
        }
      };
      $scope.onPageButtonLeave = function (data, dragElement, dropElement) {
        if (pageButtonElement && pageButtonElement === dropElement.el) {
          pageButtonElement.parent().removeClass('active');
          pageButtonElement = null;
        }
      };
      $scope.onPageButtonDrop = function (data, dragElement) {
        var endPos;
        if (pageButtonElement) {
          validDrop = true;
          if (pageButtonElement.attr('id') === 'btnPrev') {
            // endPos - 1 due to zero indexing
            endPos = $scope.items.paging.pageSize * ($scope.items.paging.currentPage - 1) - 1;
          }
          if (pageButtonElement.attr('id') === 'btnNext') {
            endPos = $scope.items.paging.pageSize * $scope.items.paging.currentPage;
          }
          adStrapUtils.moveItemInList(initialPos, endPos, $scope.localConfig.localData);
          $scope.loadPage($scope.items.paging.currentPage);
          $('#row-phldr').remove();
          placeHolderInDom = false;
          dragElement.el.remove();
          if ($scope.localConfig.draggable && $scope.localConfig.dragChange) {
            $scope.localConfig.dragChange(initialPos, endPos, data);
          }
          pageButtonElement.parent().removeClass('active');
          pageButtonElement = null;
        }
      };
      $scope.getRowClass = function (item, index) {
        var rowClass = '';
        rowClass += $attrs.selectedItems && adStrapUtils.itemExistsInList(item, $scope.selectedItems) ? 'ad-selected' : '';
        rowClass += adStrapUtils.itemExistsInList(index, $scope.localConfig.expandedItems) ? ' row-expanded' : '';
        if ($attrs.rowClassProvider) {
          rowClass += ' ' + $scope.$eval($attrs.rowClassProvider)(item, index);
        }
        return rowClass;
      };
      $scope.toggle = function (event, index, item) {
        event.stopPropagation();
        adStrapUtils.addRemoveItemFromList(index, $scope.localConfig.expandedItems);
        if (adStrapUtils.itemExistsInList(index, $scope.localConfig.expandedItems)) {
          var rowExpandCallback = $scope.$eval($attrs.rowExpandCallback);
          if (rowExpandCallback) {
            rowExpandCallback(item);
          }
        }
      };
      $scope.onRowClick = function (item, event) {
        var onRowClick = $scope.$parent.$eval($attrs.onRowClick);
        if (onRowClick) {
          onRowClick(item, event);
        }
      };
      // ---------- initialization and event listeners ---------- //
      var state = $scope.$eval($attrs.state) || {};
      var column = {
          sortKey: state.sortKey,
          sortDirection: state.sortDirection
        };
      $scope.sortByColumn(column, true);
      $scope.loadPage(1);
      // ---------- external events ------- //
      $scope.$on('adTableLiteAction', function (event, data) {
        // Exposed methods for external actions
        var actions = { expandCollapseRow: $scope.expandCollapseRow };
        if (data.tableName === $scope.attrs.tableName) {
          data.action(actions);
        }
      });
      // ---------- set watchers ---------- //
      watchers.push($scope.$watch($attrs.localDataSource, function () {
        $scope.loadPage($scope.items.paging.currentPage);
      }));
      watchers.push($scope.$watch($attrs.localDataSource + '.length', function () {
        $scope.loadPage($scope.items.paging.currentPage);
      }));
      watchers.push($scope.$watchCollection($attrs.columnDefinition, function () {
        $scope.columnDefinition = $scope.$eval($attrs.columnDefinition);
        $scope.visibleColumnDefinition = $filter('filter')($scope.columnDefinition, $scope.columnVisible);
      }));
      watchers.push($scope.$watch($attrs.searchText, function () {
        $scope.searchText = $scope.$eval($attrs.searchText);
        $scope.loadPage(1);
      }));
      if ($attrs.enableColumnSearch) {
        var loadFilterPage = adDebounce(function () {
            $scope.loadPage(1);
          }, Number($attrs.columnSearchDebounce) || 400);
        watchers.push($scope.$watch('filters', function () {
          loadFilterPage();
        }, true));
      }
      // ---------- disable watchers ---------- //
      $scope.$on('$destroy', function () {
        watchers.forEach(function (watcher) {
          watcher();
        });
      });
    }
    return {
      restrict: 'E',
      controller: [
        '$scope',
        '$attrs',
        controllerFunction
      ],
      templateUrl: 'tablelite/tablelite.tpl.html',
      scope: true
    };
  }
]);

// Source: treebrowser.js
angular.module('adaptv.adaptStrap.treebrowser', []).directive('adTreeBrowser', [
  '$adConfig',
  function ($adConfig) {
    function controllerFunction($scope, $attrs) {
      var templateToken = Math.random();
      // scope initialization
      $scope.attrs = $attrs;
      $scope.iconClasses = $adConfig.iconClasses;
      $scope.treeRoot = $scope.$eval($attrs.treeRoot) || {};
      $scope.toggle = function (event, item) {
        var toggleCallback;
        event.stopPropagation();
        toggleCallback = $scope.$eval($attrs.toggleCallback);
        if (toggleCallback) {
          toggleCallback(item);
        } else {
          item._ad_expanded = !item._ad_expanded;
        }
      };
      $scope.onRowClick = function (item, level, event) {
        var onRowClick = $scope.$parent.$eval($attrs.onRowClick);
        if (onRowClick) {
          onRowClick(item, level, event);
        }
      };
      var hasChildren = $scope.$eval($attrs.hasChildren);
      $scope.hasChildren = function (item) {
        var found = item[$attrs.childNode] && item[$attrs.childNode].length > 0;
        if (hasChildren) {
          found = hasChildren(item);
        }
        return found;
      };
      // for unique template
      $scope.localConfig = { rendererTemplateId: 'tree-renderer-' + templateToken + '.html' };
    }
    return {
      restrict: 'E',
      scope: true,
      controller: [
        '$scope',
        '$attrs',
        controllerFunction
      ],
      templateUrl: 'treebrowser/treebrowser.tpl.html'
    };
  }
]).directive('adTreeBrowserNode', [
  '$compile',
  '$http',
  '$templateCache',
  function ($compile, $http, $templateCache) {
    var tbNodeTemplate = $templateCache.get('treebrowser/treeBrowserNode.tpl.html');
    var compiledTemplates = {};
    function getTemplate(contentTpl) {
      var tplUrl = contentTpl.config.url;
      var compiledTpl = compiledTemplates[tplUrl];
      if (!compiledTpl) {
        var tbNodeHtml = tbNodeTemplate.replace(/%=nodeTemplate%/g, contentTpl.data);
        compiledTemplates[tplUrl] = $compile(tbNodeHtml);
      }
      return compiledTemplates[tplUrl];
    }
    function linkFunction(scope, element, attrs) {
      function compileTemplate(nodeTemplate) {
        getTemplate(nodeTemplate)(scope, function (clonedElement) {
          element.append(clonedElement);
        });
      }
      $http({
        cache: $templateCache,
        url: scope.$eval(attrs.templateUrl),
        method: 'GET'
      }).then(compileTemplate);
    }
    return {
      link: linkFunction,
      scope: true,
      restrict: 'E'
    };
  }
]).directive('adTreeBrowserNodeToggle', function () {
  return {
    scope: true,
    restrict: 'E',
    replace: true,
    templateUrl: 'treebrowser/treebrowserNodeToggle.tpl.html'
  };
});

// Source: utils.js
angular.module('adaptv.adaptStrap.utils', []).factory('adStrapUtils', [
  '$filter',
  function ($filter) {
    var evalObjectProperty = function (obj, property) {
        var arr = property.split('.');
        if (obj) {
          while (arr.length) {
            var key = arr.shift();
            if (obj) {
              obj = obj[key];
            }
          }
        }
        return obj;
      }, createdChainObjectAndInitValue = function (property, value) {
        var arr = property.split('.');
        var obj = { obj: {} };
        var ob2 = obj.obj;
        while (arr.length) {
          var key = arr.shift();
          if (ob2) {
            if (arr.length === 0) {
              ob2[key] = value;
            } else {
              ob2[key] = {};
              ob2 = ob2[key];
            }
          }
        }
        return obj.obj;
      }, applyFilter = function (value, filter, item) {
        var filterName, filterOptions, optionsIndex;
        if (value && 'function' === typeof value) {
          return value(item);
        }
        if (filter) {
          optionsIndex = filter.indexOf(':');
          if (optionsIndex > -1) {
            filterName = filter.substring(0, optionsIndex);
            filterOptions = filter.substring(optionsIndex + 1);
            value = $filter(filterName)(value, filterOptions);
          } else {
            value = $filter(filter)(value);
          }
        }
        return value;
      }, itemExistsInList = function (compareItem, list) {
        var exist = false;
        list.forEach(function (item) {
          if (angular.equals(compareItem, item)) {
            exist = true;
          }
        });
        return exist;
      }, itemsExistInList = function (items, list) {
        var exist = true, i;
        for (i = 0; i < items.length; i++) {
          if (itemExistsInList(items[i], list) === false) {
            exist = false;
            break;
          }
        }
        return exist;
      }, addItemToList = function (item, list) {
        list.push(item);
      }, removeItemFromList = function (item, list) {
        var i;
        for (i = list.length - 1; i > -1; i--) {
          if (angular.equals(item, list[i])) {
            list.splice(i, 1);
          }
        }
      }, addRemoveItemFromList = function (item, list) {
        var i, found = false;
        for (i = list.length - 1; i > -1; i--) {
          if (angular.equals(item, list[i])) {
            list.splice(i, 1);
            found = true;
          }
        }
        if (found === false) {
          list.push(item);
        }
      }, addItemsToList = function (items, list) {
        items.forEach(function (item) {
          if (!itemExistsInList(item, list)) {
            addRemoveItemFromList(item, list);
          }
        });
      }, addRemoveItemsFromList = function (items, list) {
        if (itemsExistInList(items, list)) {
          list.length = 0;
        } else {
          addItemsToList(items, list);
        }
      }, moveItemInList = function (startPos, endPos, list) {
        if (endPos < list.length) {
          list.splice(endPos, 0, list.splice(startPos, 1)[0]);
        }
      }, parse = function (items) {
        var itemsObject = [];
        if (angular.isArray(items)) {
          itemsObject = items;
        } else {
          angular.forEach(items, function (item) {
            itemsObject.push(item);
          });
        }
        return itemsObject;
      }, getObjectProperty = function (item, property) {
        if (property && 'function' === typeof property) {
          return property(item);
        }
        var arr = property.split('.');
        while (arr.length) {
          item = item[arr.shift()];
        }
        return item;
      }, hasAtLeastOnePropertyWithValue = function (obj) {
        var has = false, name, value;
        for (name in obj) {
          value = obj[name];
          if (value instanceof Array) {
            if (value.length > 0) {
              has = true;
            }
          } else if (!!value) {
            has = true;
          }
          if (has) {
            break;
          }
        }
        return has;
      };
    return {
      evalObjectProperty: evalObjectProperty,
      createdChainObjectAndInitValue: createdChainObjectAndInitValue,
      applyFilter: applyFilter,
      itemExistsInList: itemExistsInList,
      itemsExistInList: itemsExistInList,
      addItemToList: addItemToList,
      removeItemFromList: removeItemFromList,
      addRemoveItemFromList: addRemoveItemFromList,
      addItemsToList: addItemsToList,
      addRemoveItemsFromList: addRemoveItemsFromList,
      moveItemInList: moveItemInList,
      parse: parse,
      getObjectProperty: getObjectProperty,
      hasAtLeastOnePropertyWithValue: hasAtLeastOnePropertyWithValue
    };
  }
]).factory('adDebounce', [
  '$timeout',
  '$q',
  function ($timeout, $q) {
var deb = function (func, delay, immediate, ctx) {
      var timer = null, deferred = $q.defer(), wait = delay || 300;
      return function () {
        var context = ctx || this, args = arguments, callNow = immediate && !timer, later = function () {
            if (!immediate) {
              deferred.resolve(func.apply(context, args));
              deferred = $q.defer();
            }
          };
        if (timer) {
          $timeout.cancel(timer);
        }
        timer = $timeout(later, wait);
        if (callNow) {
          deferred.resolve(func.apply(context, args));
          deferred = $q.defer();
        }
        return deferred.promise;
      };
    };
    return deb;
  }
]).directive('adCompileTemplate', [
  '$compile',
  function ($compile) {
    return function (scope, element, attrs) {
      scope.$watch(function (scope) {
        return scope.$eval(attrs.adCompileTemplate);
      }, function (value) {
        element.html(value);
        $compile(element.contents())(scope);
      });
    };
  }
]).factory('adLoadPage', [
  '$adConfig',
  '$http',
  'adStrapUtils',
  function ($adConfig, $http, adStrapUtils) {
    return function (options) {
      var start = (options.pageNumber - 1) * options.pageSize, pagingConfig = angular.copy($adConfig.paging), ajaxConfig = angular.copy(options.ajaxConfig);
      if (ajaxConfig.paginationConfig && ajaxConfig.paginationConfig.request) {
        angular.extend(pagingConfig.request, ajaxConfig.paginationConfig.request);
      }
      if (ajaxConfig.paginationConfig && ajaxConfig.paginationConfig.response) {
        angular.extend(pagingConfig.response, ajaxConfig.paginationConfig.response);
      }
      ajaxConfig.params = ajaxConfig.params ? ajaxConfig.params : {};
      if (pagingConfig.request.start) {
        ajaxConfig.params[pagingConfig.request.start] = start;
      }
      if (pagingConfig.request.pageSize) {
        ajaxConfig.params[pagingConfig.request.pageSize] = options.pageSize;
      }
      if (pagingConfig.request.page) {
        ajaxConfig.params[pagingConfig.request.page] = options.pageNumber;
      }
      if (options.sortKey && pagingConfig.request.sortField) {
        ajaxConfig.params[pagingConfig.request.sortField] = options.sortKey;
      }
      if (options.sortDirection === false && pagingConfig.request.sortDirection) {
        ajaxConfig.params[pagingConfig.request.sortDirection] = pagingConfig.request.sortAscValue;
      } else if (options.sortDirection === true && pagingConfig.request.sortDirection) {
        ajaxConfig.params[pagingConfig.request.sortDirection] = pagingConfig.request.sortDescValue;
      }
      var promise;
      if (ajaxConfig.method === 'JSONP') {
        promise = $http.jsonp(ajaxConfig.url + '?callback=JSON_CALLBACK', ajaxConfig);
      } else {
        promise = $http(ajaxConfig);
      }
      return promise.then(function (result) {
        var response = {
            items: adStrapUtils.evalObjectProperty(result.data, pagingConfig.response.itemsLocation),
            currentPage: options.pageNumber,
            totalPages: Math.ceil(adStrapUtils.evalObjectProperty(result.data, pagingConfig.response.totalItems) / options.pageSize),
            totalItems: Math.ceil(adStrapUtils.evalObjectProperty(result.data, pagingConfig.response.totalItems)),
            pagingArray: [],
            token: options.token
          };
        var TOTAL_PAGINATION_ITEMS = 5;
        var minimumBound = options.pageNumber - Math.floor(TOTAL_PAGINATION_ITEMS / 2);
        for (var i = minimumBound; i <= options.pageNumber; i++) {
          if (i > 0) {
            response.pagingArray.push(i);
          }
        }
        while (response.pagingArray.length < TOTAL_PAGINATION_ITEMS) {
          if (i > response.totalPages) {
            break;
          }
          response.pagingArray.push(i);
          i++;
        }
        return response;
      });
    };
  }
]).factory('adLoadLocalPage', [
  '$filter',
  function ($filter) {
    return function (options) {
      var response = {
          items: undefined,
          currentPage: options.pageNumber,
          totalPages: undefined,
          pagingArray: [],
          token: options.token
        };
      if (angular.isDefined(options.localData)) {
        var start = (options.pageNumber - 1) * options.pageSize, end = start + options.pageSize, i, itemsObject = options.localData, localItems = itemsObject;
        if (options.sortKey && !options.draggable) {
          localItems = $filter('orderBy')(itemsObject, options.sortKey, options.sortDirection);
        }
        response.items = localItems.slice(start, end);
        response.allItems = itemsObject;
        response.currentPage = options.pageNumber;
        response.totalPages = Math.ceil(itemsObject.length / options.pageSize);
        var TOTAL_PAGINATION_ITEMS = 5;
        var minimumBound = options.pageNumber - Math.floor(TOTAL_PAGINATION_ITEMS / 2);
        for (i = minimumBound; i <= options.pageNumber; i++) {
          if (i > 0) {
            response.pagingArray.push(i);
          }
        }
        while (response.pagingArray.length < TOTAL_PAGINATION_ITEMS) {
          if (i > response.totalPages) {
            break;
          }
          response.pagingArray.push(i);
          i++;
        }
      }
      return response;
    };
  }
]);

})(window, document);

/**
 * adapt-strap
 * @version v2.6.1 - 2016-08-09
 * @link https:
 * @author Kashyap Patel (kashyap@adap.tv)
 * @license MIT License, http:
 */
(function(window, document, undefined) {
'use strict';


angular.module('adaptv.adaptStrap.alerts').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('alerts/alerts.tpl.html', '<div ng-show="settings.type !== \'\'" class="alert alert-{{ settings.type }} alert-dismissible fade in {{ customClasses }}" role="alert"><button type="button" class="close" ng-click="close();" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4><span ng-class="iconMap[settings.type]"></span>&nbsp;&nbsp; <strong>{{ settings.caption }}</strong> {{ settings.message }}</h4></div>');
  }
]);


angular.module('adaptv.adaptStrap.infinitedropdown').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('infinitedropdown/infinitedropdown.tpl.html', '<div class="ad-infinite-list-container"><div class="dropdown"><button type="button" class="dropdown-toggle" ng-class="attrs.btnClasses || \'btn btn-default\'" data-toggle="dropdown"><span ng-if="!attrs.labelDisplayProperty || !selectedItems.length">{{ attrs.initialLabel || \'Select\' }}</span> <span ng-if="attrs.labelDisplayProperty && selectedItems.length">{{ adStrapUtils.getObjectProperty(selectedItems[selectedItems.length - 1], attrs.labelDisplayProperty) }}</span> <span class="caret"></span></button><div class="dropdown-header" ng-show="dropdownStatus.open" ng-click="dropdownHeaderAreaClicked($event)" ng-if="attrs.dropdownHeaderTemplateUrl"><ng-include src="attrs.dropdownHeaderTemplateUrl"></ng-include></div><ul class="dropdown-menu" role="menu" ng-class="{\'with-dropdown-header\': attrs.dropdownHeaderTemplateUrl}" ng-style="localConfig.dimensions"><li class="text-overflow" data-ng-repeat="item in items.list" ng-class="{\'active\': adStrapUtils.itemExistsInList(item, selectedItems)}" ng-click="addRemoveItem($event, item, selectedItems)"><a role="menuitem" tabindex="-1" href=""><span ng-if="attrs.displayProperty">{{ adStrapUtils.getObjectProperty(item, attrs.displayProperty) }}</span> <span ng-if="attrs.template" ad-compile-template="{{ attrs.template }}"></span> <span ng-if="attrs.templateUrl" ng-include="attrs.templateUrl"></span></a></li><li class="text-overflow text-center" ng-show="localConfig.loadingData"><a role="menuitem" tabindex="-1" href=""><ad-loading-icon></ad-loading-icon></a></li></ul></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.loadingindicator').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('loadingindicator/loadingindicator.tpl.html', '<div class="ad-loading-overlay-container" ng-class="containerClasses" ng-style="{\'z-index\': zIndex || \'1000\',\'position\': position || \'absolute\'}" ng-show="loading"><div class="wrapper"><div class="loading-indicator"><ad-loading-icon loading-icon-size="{{ loadingIconSize }}" loading-icon-class="{{ loadingIconClass }}"></ad-loading-icon></div></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.tableajax').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tableajax/tableajax.tpl.html', '<div class="ad-table-ajax-container" ng-if="items.paging.totalPages || localConfig.loadingData || !attrs.itemsNotFoundMessage"><table class="ad-sticky-table {{ attrs.tableClasses || tableClasses }}" ng-if="attrs.tableMaxHeight || attrs.tableFixedHeight" ng-class="{\'ad-fixed-layout\': (attrs.tableMaxHeight || attrs.tableFixedHeight)}"><thead><tr class="ad-user-select-none" ng-include="\'tableajax/headerRowContent.html\'"></tr></thead></table><div class="ad-table-container" ng-style="{\'max-height\': localConfig.tableMaxHeight, \'height\' : attrs.tableFixedHeight}"><table class="{{ attrs.tableClasses || tableClasses }}" ng-class="{\'ad-fixed-layout\': (attrs.tableMaxHeight || attrs.tableFixedHeight)}"><thead><tr class="ad-user-select-none" ng-if="!(localConfig.tableMaxHeight || attrs.tableFixedHeight)" ng-include="\'tableajax/headerRowContent.html\'"></tr></thead><tbody><tr class="ad-first-row" ng-if="attrs.firstRowTemplate" ng-include="attrs.firstRowTemplate"></tr><tr ng-repeat-start="item in items.list" ng-class="getRowClass(item, $index)" ng-include="\'tableajax/rowContent.html\'" ng-click="onRowClick(item, $event)"></tr><tr ng-if="attrs.rowExpandTemplate && adStrapUtils.itemExistsInList($index, localConfig.expandedItems)" class="expandable-row-content" ng-repeat-end><td colspan="{{ visibleColumnDefinition.length + 1}}" ng-include="attrs.rowExpandTemplate"></td></tr><tr class="ad-last-row" ng-if="attrs.lastRowTemplate" ng-include="attrs.lastRowTemplate"></tr></tbody></table><ad-loading-overlay loading="localConfig.loadingData"></ad-loading-overlay></div><ng-include src="\'tableajax/pagination.html\'"></ng-include></div><div ng-if="localConfig.showNoDataFoundMessage && !localConfig.loadingData && attrs.itemsNotFoundMessage"><div class="alert alert-info" role="alert">{{ attrs.itemsNotFoundMessage }}</div></div>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/tablelite.tpl.html', '<div class="ad-table-lite-container" ng-if="items.allItems.length || !attrs.itemsNotFoundMessage || attrs.enableColumnSearch"><table class="ad-sticky-table {{ attrs.tableClasses || tableClasses }}" ng-if="attrs.tableMaxHeight || attrs.tableFixedHeight" ng-class="{\'ad-fixed-layout\': (attrs.tableMaxHeight || attrs.tableFixedHeight)}"><thead><tr class="ad-user-select-none" ng-include="\'tablelite/headerRowContent.html\'"></tr><tr class="ad-user-select-none" ng-if="attrs.enableColumnSearch" ng-include="\'tablelite/headerRowFilterContent.html\'"></tr></thead></table><div class="ad-table-container" ng-style="{\'max-height\': attrs.tableMaxHeight, \'height\': attrs.tableFixedHeight}"><table class="{{ attrs.tableClasses || tableClasses }}" ng-class="{\'ad-fixed-layout\': (attrs.tableMaxHeight || attrs.tableFixedHeight)}"><thead><tr class="ad-user-select-none" ng-if="!(attrs.tableMaxHeight || attrs.tableFixedHeight)" ng-include="\'tablelite/headerRowContent.html\'"></tr><tr class="ad-user-select-none" ng-if="!(attrs.tableMaxHeight || attrs.tableFixedHeight) && attrs.enableColumnSearch" ng-include="\'tablelite/headerRowFilterContent.html\'"></tr></thead><tbody ng-if="!localConfig.draggable" ng-include="\'tablelite/defaultRow.html\'"></tbody><tbody ng-if="localConfig.draggable" ng-include="\'tablelite/draggableRow.html\'"></tbody></table></div><ng-include src="\'tablelite/pagination.html\'"></ng-include></div><div ng-if="!localConfig.localData.length && attrs.itemsNotFoundMessage && !attrs.enableColumnSearch"><div class="alert alert-info" role="alert">{{ attrs.itemsNotFoundMessage }}</div></div>');
  }
]);


angular.module('adaptv.adaptStrap.treebrowser').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('treebrowser/treeBrowserNode.tpl.html', '<div class="content" ng-style="{\'padding-left\': level * (attrs.childrenPadding || 15) + \'px\'}" ng-click="onRowClick(item, level, $event)" ng-class="{{ attrs.rowNgClass }}"><div class="content-holder"><ad-tree-browser-node-toggle ng-if="!attrs.customToggle"></ad-tree-browser-node-toggle><div class="node-content">%=nodeTemplate% <span ng-if="!attrs.nodeTemplateUrl">{{ item.name || "" }}</span></div></div></div><div ng-if="item._ad_expanded"><div class="tree-level tree-sub-level" ng-init="level=level+1" ng-repeat="item in item[attrs.childNode]"><ad-tree-browser-node template-url="attrs.nodeTemplateUrl"></ad-tree-browser-node></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.treebrowser').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('treebrowser/treebrowser.tpl.html', '<div class="ad-tree-browser-container" ng-class="{\'tree-bordered\': attrs.bordered}"><div data-level="0" class="tree-view"><div class="tree"><div><div class="tree-level tree-header-level border" ng-if="attrs.nodeHeaderUrl"><div class="content" ng-style="{\'padding-left\': (attrs.childrenPadding || 15) + \'px\'}"><div class="content-holder"><div></div><div class="node-content ad-user-select-none" ng-include="attrs.nodeHeaderUrl"></div></div></div></div><div class="tree-level tree-top-level border" ng-init="level = 1" ng-repeat="item in treeRoot[attrs.childNode]"><ad-tree-browser-node template-url="attrs.nodeTemplateUrl"></ad-tree-browser-node></div></div></div></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.treebrowser').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('treebrowser/treebrowserNodeToggle.tpl.html', '<div class="toggle" ng-class="{\'custom-toggle\': attrs.customToggle}"><i ng-if="!item._ad_expanded && hasChildren(item) && !item._ad_loading" ng-class="iconClasses.expand" ng-click="toggle($event,item)"></i> <i ng-if="item._ad_expanded && !item._ad_loading" ng-class="iconClasses.collapse" ng-click="toggle($event,item)"></i> <span ng-if="item._ad_loading"><i ng-class="iconClasses.loadingSpinner"></i></span></div>');
  }
]);


angular.module('adaptv.adaptStrap.tableajax').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tableajax/headerRowContent.html', '<th class="ad-select-cell" ng-if="attrs.rowExpandTemplate"><i></i></th><th class="ad-select-cell" ng-if="attrs.selectedItems && items.allItems"><input type="checkbox" class="ad-cursor-pointer" ng-if="!attrs.enableColumnSearch" ng-click="adStrapUtils.addRemoveItemsFromList(items.allItems, selectedItems)" ng-checked="adStrapUtils.itemsExistInList(items.allItems, selectedItems)"></th><th data-ng-repeat="definition in visibleColumnDefinition" ng-click="sortByColumn(definition)" ng-class="{\'ad-cursor-pointer\': definition.sortKey}" ng-style="{\'width\': definition.width}"><ng-include src="\'tableajax/sortIcons.html\'" ng-if="!attrs.snugSortIcons"></ng-include><div class="ad-display-inline-block" ng-if="definition.columnHeaderTemplate" ad-compile-template="definition.columnHeaderTemplate"></div><div class="ad-display-inline-block" ng-if="definition.columnHeaderTemplateUrl"><ng-include src="definition.columnHeaderTemplateUrl"></ng-include></div><div class="ad-display-inline-block" ng-if="definition.columnHeaderDisplayName" ng-bind="definition.columnHeaderDisplayName"></div><ng-include src="\'tableajax/sortIcons.html\'" ng-if="attrs.snugSortIcons"></ng-include></th>');
  }
]);


angular.module('adaptv.adaptStrap.tableajax').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tableajax/pagination.html', '<div class="row ad-table-pagination-container"><div class="col-md-8 col-sm-8"><ul ng-class="attrs.paginationBtnGroupClasses || \'pagination pagination-sm\'"><li><a class="ad-cursor-pointer" ng-click="loadPage(1)" ng-disabled="items.paging.currentPage == 1" title="First Page" aria-label="First Page"><i ng-class="iconClasses.firstPage"></i></a></li><li><a class="ad-cursor-pointer" ng-click="loadPreviousPage()" ng-disabled="items.paging.currentPage == 1" title="Previous Page" aria-label="Previous Page"><i ng-class="iconClasses.previousPage"></i></a></li><li ng-repeat="page in localConfig.pagingArray" ng-class="{active: items.paging.currentPage == page}"><a class="ad-cursor-pointer" ng-click="loadPage(page)">{{ page }}</a></li><li><a class="ad-cursor-pointer" ng-click="loadNextPage()" ng-disabled="items.paging.currentPage == items.paging.totalPages" title="Next Page" aria-label="Next Page"><i ng-class="iconClasses.nextPage"></i></a></li><li><a class="ad-cursor-pointer" ng-click="loadLastPage()" ng-disabled="items.paging.currentPage == items.paging.totalPages" title="Last Page" aria-label="Last Page"><i ng-class="iconClasses.lastPage"></i></a></li></ul></div><div class="col-md-4 col-sm-4 text-right"><ul ng-class="attrs.paginationBtnGroupClasses || \'pagination pagination-sm\'"><li ng-repeat="size in items.paging.pageSizes" ng-class="{active: items.paging.pageSize == size}"><a class="ad-cursor-pointer" ng-click="pageSizeChanged(size)">{{ size }}</a></li></ul></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.tableajax').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tableajax/rowContent.html', '<td class="ad-select-cell ad-cursor-pointer table-ajax-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}" ng-if="attrs.rowExpandTemplate" ng-click="toggle($event, $index, item)"><i ng-class="iconClasses.expand" ng-if="!adStrapUtils.itemExistsInList($index, localConfig.expandedItems)"></i> <i ng-class="iconClasses.collapse" ng-if="adStrapUtils.itemExistsInList($index, localConfig.expandedItems)"></i></td><td class="ad-select-cell table-ajax-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}" ng-if="attrs.selectedItems"><input type="checkbox" class="ad-cursor-pointer" ng-checked="adStrapUtils.itemExistsInList(item, selectedItems)" ng-click="adStrapUtils.addRemoveItemFromList(item, selectedItems)"></td><td data-ng-repeat="definition in visibleColumnDefinition" ng-style="{\'width\': definition.width}" class="table-ajax-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}"><div ng-if="definition.templateUrl"><ng-include src="definition.templateUrl"></ng-include></div><div ng-if="definition.template"><span ad-compile-template="definition.template"></span></div><div ng-if="!definition.templateUrl && !definition.template">{{ adStrapUtils.applyFilter(adStrapUtils.getObjectProperty(item, definition.displayProperty, item), definition.cellFilter) }}</div></td>');
  }
]);


angular.module('adaptv.adaptStrap.tableajax').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tableajax/sortIcons.html', '<div ng-class="{\'ad-display-inline-block\': attrs.snugSortIcons, \'pull-right\': !attrs.snugSortIcons}" ng-if="definition.sortKey && localConfig.sortState.sortKey == definition.sortKey"><i ng-class="iconClasses.sortAscending" ng-show="localConfig.sortState.sortDirection === \'ASC\'"></i> <i ng-class="iconClasses.sortDescending" ng-show="localConfig.sortState.sortDirection === \'DEC\'"></i></div><div ng-class="{\'ad-display-inline-block\': attrs.snugSortIcons, \'pull-right\': !attrs.snugSortIcons}" ng-if="definition.sortKey && localConfig.sortState.sortKey != definition.sortKey"><i ng-class="iconClasses.sortable"></i></div>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/defaultRow.html', '<tr class="ad-first-row" ng-if="attrs.firstRowTemplate" ng-include="attrs.firstRowTemplate"></tr><tr ng-repeat-start="item in items.list" ng-class="getRowClass(item, $index)" ng-include="\'tablelite/rowContent.html\'" ng-click="onRowClick(item, $event)"></tr><tr ng-if="attrs.rowExpandTemplate && adStrapUtils.itemExistsInList($index, localConfig.expandedItems)" class="expandable-row-content" ng-repeat-end><td colspan="{{ visibleColumnDefinition.length + !!attrs.draggable + !!attrs.selectedItems + 1}}" ng-include="attrs.rowExpandTemplate"></td></tr><tr class="ad-last-row" ng-if="attrs.lastRowTemplate" ng-include="attrs.lastRowTemplate"></tr>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/draggableRow.html', '<tr class="ad-first-row" ng-if="attrs.firstRowTemplate" ng-include="attrs.firstRowTemplate"></tr><tr ad-drag="true" ad-drag-handle="true" ad-drop="true" ad-drag-data="item" ad-drop-over="onDragOver($data, $dragElement, $dropElement, $event)" ad-drop-end="onDropEnd($data, $dragElement, $dropElement, $event)" ad-drag-begin="onDragStart($data, $dragElement, $event)" ad-drag-end="onDragEnd($data, $dragElement, $event)" ng-repeat-start="item in items.list" ng-class="getRowClass(item, $index)" ng-include="\'tablelite/rowContent.html\'"></tr><tr ng-if="attrs.rowExpandTemplate && adStrapUtils.itemExistsInList($index, localConfig.expandedItems)" class="expandable-row-content" ng-repeat-end><td colspan="{{ visibleColumnDefinition.length + !!attrs.draggable + !!attrs.selectedItems + 1}}" ng-include="attrs.rowExpandTemplate"></td></tr><tr class="ad-last-row" ng-if="attrs.lastRowTemplate" ng-include="attrs.lastRowTemplate"></tr>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/headerRowContent.html', '<th class="ad-select-cell" ng-if="attrs.draggable"><i></i></th><th class="ad-select-cell" ng-if="attrs.rowExpandTemplate"><i></i></th><th class="ad-select-cell" ng-if="attrs.selectedItems && items.allItems"><input type="checkbox" class="ad-cursor-pointer" ng-if="!attrs.enableColumnSearch" ng-click="adStrapUtils.addRemoveItemsFromList(items.allItems, selectedItems)" ng-checked="adStrapUtils.itemsExistInList(items.allItems, selectedItems)"></th><th data-ng-repeat="definition in visibleColumnDefinition" ng-click="sortByColumn(definition)" ng-class="{\'ad-cursor-pointer\': definition.sortKey}" ng-style="{\'width\': definition.width}"><ng-include src="\'tablelite/sortIcons.html\'" ng-if="!attrs.snugSortIcons"></ng-include><div class="ad-display-inline-block" ng-if="definition.columnHeaderTemplate" ad-compile-template="definition.columnHeaderTemplate"></div><div class="ad-display-inline-block" ng-if="definition.columnHeaderTemplateUrl"><ng-include src="definition.columnHeaderTemplateUrl"></ng-include></div><div class="ad-display-inline-block" ng-bind="definition.columnHeaderDisplayName"></div><ng-include src="\'tablelite/sortIcons.html\'" ng-if="attrs.snugSortIcons"></ng-include></th>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/headerRowFilterContent.html', '<th class="ad-select-cell" ng-if="attrs.draggable"><i></i></th><th class="ad-select-cell" ng-if="attrs.rowExpandTemplate"><i></i></th><th class="ad-select-cell" ng-if="attrs.selectedItems && items.allItems"><input type="checkbox" class="ad-cursor-pointer" ng-if="attrs.enableColumnSearch" ng-click="adStrapUtils.addRemoveItemsFromList(items.allItems, selectedItems)" ng-checked="adStrapUtils.itemsExistInList(items.allItems, selectedItems)"></th><th data-ng-repeat="definition in visibleColumnDefinition"><input ng-if="definition.columnSearchProperty" type="text" class="input-sm form-control" ng-model="filters[definition.columnSearchProperty]"></th>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/pagination.html', '<div class="row ad-table-pagination-container" ng-if="!attrs.disablePaging"><div class="col-md-8 col-sm-8 text-left"><ul ng-class="attrs.paginationBtnGroupClasses || \'pagination pagination-sm\'"><li><a ng-click="loadPage(1)" class="ad-cursor-pointer" ng-disabled="items.paging.currentPage == 1" title="First Page" aria-label="First Page"><i ng-class="iconClasses.firstPage"></i></a></li><li><a ng-if="!attrs.draggable" class="ad-cursor-pointer" ng-click="loadPreviousPage()" ng-disabled="items.paging.currentPage == 1" title="Previous Page" aria-label="Previous Page"><i ng-class="iconClasses.previousPage"></i></a></li><li><a id="btnPrev" class="ad-cursor-pointer" ng-if="attrs.draggable" ad-drop="true" ad-drop-over="onPageButtonOver($data, $dragElement, $dropElement, $event)" ad-drop-leave="onPageButtonLeave($data, $dragElement, $dropElement, $event)" ad-drop-end="onPageButtonDrop($data, $dragElement, $dropElement, $event)" ng-click="loadPreviousPage()" ng-disabled="items.paging.currentPage == 1" title="Previous Page" aria-label="Previous Page"><i ng-class="iconClasses.previousPage"></i></a></li><li ng-repeat="page in localConfig.pagingArray" ng-class="{active: items.paging.currentPage == page}"><a ng-click="loadPage(page)" class="ad-cursor-pointer">{{ page }}</a></li><li><a ng-if="!attrs.draggable" class="ad-cursor-pointer" ng-click="loadNextPage()" ng-disabled="items.paging.currentPage == items.paging.totalPages" title="Next Page" aria-label="Next Page"><i ng-class="iconClasses.nextPage"></i></a></li><li><a id="btnNext" class="ad-cursor-pointer" ng-if="attrs.draggable" ad-drop="true" ad-drop-over="onPageButtonOver($data, $dragElement, $dropElement, $event)" ad-drop-leave="onPageButtonLeave($data, $dragElement, $dropElement, $event)" ad-drop-end="onPageButtonDrop($data, $dragElement, $dropElement, $event)" ng-click="loadNextPage()" ng-disabled="items.paging.currentPage == items.paging.totalPages" title="Next Page" aria-label="Next Page"><i ng-class="iconClasses.nextPage"></i></a></li><li><a ng-click="loadLastPage()" class="ad-cursor-pointer" ng-disabled="items.paging.currentPage == items.paging.totalPages" title="Last Page" aria-label="Last Page"><i ng-class="iconClasses.lastPage"></i></a></li></ul></div><div class="col-md-4 col-sm-4 text-right"><ul ng-class="attrs.paginationBtnGroupClasses || \'pagination pagination-sm\'"><li ng-repeat="size in items.paging.pageSizes" ng-class="{active: items.paging.pageSize == size}"><a ng-click="pageSizeChanged(size)" class="ad-cursor-pointer">{{ size }}</a></li></ul></div></div>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/rowContent.html', '<td class="ad-select-cell ad-cursor-pointer table-lite-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}" ng-if="attrs.rowExpandTemplate" ng-click="toggle($event, $index, item)"><i ng-class="iconClasses.expand" ng-if="!adStrapUtils.itemExistsInList($index, localConfig.expandedItems)"></i> <i ng-class="iconClasses.collapse" ng-if="adStrapUtils.itemExistsInList($index, localConfig.expandedItems)"></i></td><td class="ad-select-cell ad-drag-handle table-lite-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}" ng-if="attrs.draggable"><i ng-class="iconClasses.draggable"></i></td><td class="ad-select-cell table-lite-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}" ng-if="attrs.selectedItems"><input type="checkbox" class="ad-cursor-pointer" ng-checked="adStrapUtils.itemExistsInList(item, selectedItems)" ng-click="adStrapUtils.addRemoveItemFromList(item, selectedItems)"></td><td data-ng-repeat="definition in visibleColumnDefinition" ng-style="{\'width\': definition.width}" class="table-lite-col-{{definition.columnHeaderDisplayName ? definition.columnHeaderDisplayName : $index}}"><div ng-if="definition.templateUrl"><ng-include src="definition.templateUrl"></ng-include></div><div ng-if="definition.template"><span ad-compile-template="definition.template"></span></div><div ng-if="!definition.templateUrl && !definition.template">{{ adStrapUtils.applyFilter(adStrapUtils.getObjectProperty(item, definition.displayProperty), definition.cellFilter) }}</div></td>');
  }
]);


angular.module('adaptv.adaptStrap.tablelite').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('tablelite/sortIcons.html', '<div ng-class="{\'ad-display-inline-block\': attrs.snugSortIcons, \'pull-right\': !attrs.snugSortIcons}" ng-if="definition.sortKey && localConfig.sortState.sortKey == definition.sortKey"><i ng-class="iconClasses.sortAscending" ng-show="localConfig.sortState.sortDirection === \'ASC\'"></i> <i ng-class="iconClasses.sortDescending" ng-show="localConfig.sortState.sortDirection === \'DEC\'"></i></div><div ng-class="{\'ad-display-inline-block\': attrs.snugSortIcons, \'pull-right\': !attrs.snugSortIcons}" ng-if="definition.sortKey && localConfig.sortState.sortKey != definition.sortKey"><i ng-class="iconClasses.sortable"></i></div>');
  }
]);


})(window, document);

/*
 The MIT License (MIT)

 Copyright (c) 2014 Muhammed Ashik

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
/*jshint indent: 2 */
/*global angular: false */

'use strict';
angular.module('multi-select-tree', []).controller('multiSelectTreeCtrl', [
    '$scope',
    '$document',
    function($scope, $document) {
        var activeItem;
        $scope.showTree = false;
        $scope.selectedItems = [];
        $scope.multiSelect = $scope.multiSelect || false;
        /**
         * Clicking on document will hide the tree.
         */
        function docClickHide() {
            closePopup();
            $scope.$apply();
        }
        /**
         * Closes the tree popup.
         */
        function closePopup() {
            $scope.showTree = false;
            if (activeItem) {
                activeItem.isActive = false;
                activeItem = undefined;
            }
            $document.off('click', docClickHide);
        }
        /**
         * Sets the active item.
         *
         * @param item the item element.
         */
        $scope.onActiveItem = function(item) {
            if (activeItem !== item) {
                if (activeItem) {
                    activeItem.isActive = false;
                }
                activeItem = item;
                activeItem.isActive = true;
            }
        };
        /**
         * Copies the selectedItems in to output model.
         */
        $scope.refreshOutputModel = function() {
            $scope.outputModel = angular.copy($scope.selectedItems);
        };
        /**
         * Refreshes the selected Items model.
         */
        $scope.refreshSelectedItems = function() {
            $scope.selectedItems = [];
            setSelectedChildren($scope.inputModel);
        };
        /**
         * Iterates over children and sets the selected items.
         *
         * @param children the children element.
         */
        function setSelectedChildren(children) {
            if (children) {
                for (var i = 0, len = children.length; i < len; i++) {
                    if (children[i].selected === true) {
                        $scope.selectedItems.push(children[i]);
                    }
                    setSelectedChildren(children[i].children);
                }
            }
        }
        /**
         * Deselect the item.
         *
         * @param item the item element
         * @param $event
         */
        $scope.deselectItem = function(item, $event) {
            $event.stopPropagation();
            $scope.selectedItems.splice($scope.selectedItems.indexOf(item), 1);
            item.selected = false;
            this.refreshOutputModel();
        };
        /**
         * Swap the tree popup on control click event.
         *
         * @param $event the click event.
         */
        $scope.onControlClicked = function($event) {
            $event.stopPropagation();
            $scope.showTree = !$scope.showTree;
            if ($scope.showTree) {
                $document.on('click', docClickHide);
            }
        };
        /**
         * Stop the event on filter clicked.
         *
         * @param $event the click event
         */
        $scope.onFilterClicked = function($event) {
            $event.stopPropagation();
        };
        $scope.clearFilter = function($event) {
            $event.stopPropagation();
            $scope.filterKeyword = '';
        };
        /**
         * Wrapper function for can select item callback.
         *
         * @param item the item
         */
        $scope.canSelectItem = function(item) {
            return $scope.callback({
                item: item,
                selectedItems: $scope.selectedItems
            });
        };
        /**
         * Handles the item select event.
         *
         * @param item the selected item.
         */
        $scope.itemSelected = function(item) {
            if ($scope.useCallback && $scope.canSelectItem(item) === false) {
                return;
            }
            if (!$scope.multiSelect) {
                closePopup();
                for (var i = 0; i < $scope.selectedItems.length; i++) {
                    $scope.selectedItems[i].selected = false;
                }
                item.selected = true;
                $scope.selectedItems = [];
                $scope.selectedItems.push(item);
            } else {
                item.selected = true;
                var indexOfItem = $scope.selectedItems.indexOf(item);
                if (indexOfItem > -1) {
                    item.selected = false;
                    $scope.selectedItems.splice(indexOfItem, 1);
                } else {
                    $scope.selectedItems.push(item);
                }
            }
            this.refreshOutputModel();
        };
    }
]).directive('multiSelectTree', function() {
    return {
        require: '?ngModel',
        restrict: 'E',
        templateUrl: 'src/multi-select-tree.tpl.html',
        controller: 'multiSelectTreeCtrl',
        scope: {
            ngModel: '=',
            inputModel: '=',
            outputModel: '=',
            multiSelect: '=?',
            inputArr: '=',
            callback: '&',
            defaultLabel: '@',
            mapField: '=?'
        },
        replace: true,
        link: function(scope, element, attrs, ngModel) {
            if (attrs.callback) {
                scope.useCallback = true;
            }
            ngModel.$render = function() {
                if (ngModel.$viewValue != undefined && ngModel.$viewValue != null) {
                    scope.selectedItems = findSelectItemInArr(ngModel.$viewValue, scope.inputArr, []);
                }else{
                    scope.selectedItems = [];
                }
            };
            /*scope.$watch('inputModel', function(newVal) {
                if (newVal) {
                    scope.refreshSelectedItems();
                    scope.refreshOutputModel();
                }
            });*/

            scope.$watch('filterKeyword', function() {
                if (scope.filterKeyword !== undefined) {
                    angular.forEach(scope.inputModel, function(item) {
                        if (item.name.toLowerCase().indexOf(scope.filterKeyword.toLowerCase()) !== -1) {
                            item.isFiltered = false;
                        } else {
                            item.isFiltered = true;
                        }
                    });
                }
            });
            var findSelectItem = function(renderVal, arr, dataArr) {
                if (arr && arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i][scope.mapField] == renderVal) {
                            dataArr.push(arr[i]);
                            break;
                        }
                        if (angular.isObject(scope.outputModel)) {
                            break;
                        }
                        findSelectItem(arr[i].children, dataArr);
                    }
                }
                return dataArr;
            };
            var findSelectItemInArr = function(renderVal, arr, dataArr) {
                if (arr && arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i][scope.mapField].toString() == renderVal.toString()) {
                            dataArr.push(arr[i]);
                            break;
                        }
                    }
                }
                return dataArr;
            }
        }

    };
}).controller('treeItemCtrl', [
    '$scope',
    function($scope) {
        $scope.item.isExpanded = false;
        /**
         * Shows the expand option.
         *
         * @param item the item
         * @returns {*|boolean}
         */
        $scope.showExpand = function(item) {
            return item.children && item.children.length > 0;
        };
        /**
         * On expand clicked toggle the option.
         *
         * @param item the item
         * @param $event
         */
        $scope.onExpandClicked = function(item, $event) {
            $event.stopPropagation();
            item.isExpanded = !item.isExpanded;
        };
        /**
         * Event on click of select item.
         *
         * @param item the item
         * @param $event
         */
        $scope.clickSelectItem = function(item, $event) {
            $event.stopPropagation();
            if ($scope.itemSelected) {
                $scope.itemSelected({ item: item });
            }
        };
        /**
         * Is leaf selected.
         *
         * @param item the item
         * @param $event
         */
        $scope.subItemSelected = function(item, $event) {
            if ($scope.itemSelected) {
                $scope.itemSelected({ item: item });
            }
        };
        /**
         * Active sub item.
         *
         * @param item the item
         * @param $event
         */
        $scope.activeSubItem = function(item, $event) {
            if ($scope.onActiveItem) {
                $scope.onActiveItem({ item: item });
            }
        };
        /**
         * On mouse over event.
         *
         * @param item the item
         * @param $event
         */
        $scope.onMouseOver = function(item, $event) {
            $event.stopPropagation();
            if ($scope.onActiveItem) {
                $scope.onActiveItem({ item: item });
            }
        };
        /**
         * Can select item.
         *
         * @returns {*}
         */
        $scope.showCheckbox = function() {
            if (!$scope.multiSelect) {
                return false;
            }
            if ($scope.useCallback) {
                return $scope.canSelectItem($scope.item);
            }
            return true;
        };
    }
]).directive('treeItem', [
    '$compile',
    function($compile) {
        return {
            restrict: 'E',
            templateUrl: 'src/tree-item.tpl.html',
            scope: {
                item: '=',
                itemSelected: '&',
                onActiveItem: '&',
                multiSelect: '=?',
                isActive: '=',
                useCallback: '=',
                canSelectItem: '='
            },
            controller: 'treeItemCtrl',
            compile: function(element, attrs, link) {
                
                if (angular.isFunction(link)) {
                    link = { post: link };
                }
                
                var contents = element.contents().remove();
                var compiledContents;
                return {
                    pre: link && link.pre ? link.pre : null,
                    post: function(scope, element, attrs) {
                        
                        if (!compiledContents) {
                            compiledContents = $compile(contents);
                        }
                        
                        compiledContents(scope, function(clone) {
                            element.append(clone);
                        });
                        
                        if (link && link.post) {
                            link.post.apply(null, arguments);
                        }
                    }
                };
            }
        };
    }
]);
angular.module('multi-select-tree').run(['$templateCache', function($templateCache) {
  'use strict';

  $templateCache.put('src/multi-select-tree.tpl.html',
    "<div class=\"tree-control\">\r" +
    "\n" +
    "\r" +
    "\n" +
    "    <div class=\"btn tree-input\" ng-click=\"onControlClicked($event)\">\r" +
    "\n" +
    "    <span ng-if=\"selectedItems.length == 0\" class=\"selected-items\">\r" +
    "\n" +
    "      <span ng-bind=\"defaultLabel\"></span>\r" +
    "\n" +
    "    </span>\r" +
    "\n" +
    "    <span ng-if=\"selectedItems.length > 0\" class=\"selected-items\">\r" +
    "\n" +
    "      <span ng-repeat=\"i in selectedItems\" class=\"selected-item\">{{i.name}} <span class=\"selected-item-close\"\r" +
    "\n" +
    "                                                                                  ng-click=\"deselectItem(i, $event)\"></span></span>\r" +
    "\n" +
    "        <span class=\"caret\"></span>\r" +
    "\n" +
    "    </span>\r" +
    "\n" +
    "        <!-- <input type=\"text\" class=\"blend-in\" /> -->\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "    <div class=\"tree-view\" ng-show=\"showTree\">\r" +
    "\n" +
    "        <div class=\"helper-container\">\r" +
    "\n" +
    "            <!-- <div class=\"line\" >\r" +
    "\n" +
    "                 <button type=\"button\" ng-click=\"select( 'none', $event );\" class=\"helper-button\">×&nbsp; Select None</button>\r" +
    "\n" +
    "                 <button type=\"button\" ng-click=\"select( 'reset', $event );\" class=\"helper-button\">↶&nbsp; Reset</button>\r" +
    "\n" +
    "             </div>-->\r" +
    "\n" +
    "            <div class=\"line\">\r" +
    "\n" +
    "                <input placeholder=\"Search...\" type=\"text\" ng-model=\"filterKeyword\" ng-click=\"onFilterClicked($event)\"\r" +
    "\n" +
    "                       class=\"input-filter\">\r" +
    "\n" +
    "                <span class=\"clear-button\" ng-click=\"clearFilter($event)\">×</span>\r" +
    "\n" +
    "            </div>\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "        <ul class=\"tree-container\">\r" +
    "\n" +
    "            <tree-item class=\"top-level\" ng-repeat=\"item in inputModel\" item=\"item\" ng-show=\"!item.isFiltered\"\r" +
    "\n" +
    "                       use-callback=\"useCallback\" can-select-item=\"canSelectItem\"\r" +
    "\n" +
    "                       multi-select=\"multiSelect\" item-selected=\"itemSelected(item)\"\r" +
    "\n" +
    "                       on-active-item=\"onActiveItem(item)\"></tree-item>\r" +
    "\n" +
    "        </ul>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "</div>\r" +
    "\n"
  );


  $templateCache.put('src/tree-item.tpl.html',
    "<li>\r" +
    "\n" +
    "    <div class=\"item-container\" ng-class=\"{active: item.isActive, selected: item.selected}\"\r" +
    "\n" +
    "         ng-click=\"clickSelectItem(item, $event)\" ng-mouseover=\"onMouseOver(item, $event)\">\r" +
    "\n" +
    "        <span ng-if=\"showExpand(item)\" class=\"expand\" ng-class=\"{'expand-opened': item.isExpanded}\"\r" +
    "\n" +
    "              ng-click=\"onExpandClicked(item, $event)\"></span>\r" +
    "\n" +
    "\r" +
    "\n" +
    "        <div class=\"item-details\"><input class=\"tree-checkbox\" type=\"checkbox\" ng-if=\"showCheckbox()\"\r" +
    "\n" +
    "                                         ng-checked=\"item.selected\"/>{{item.name}}\r" +
    "\n" +
    "        </div>\r" +
    "\n" +
    "    </div>\r" +
    "\n" +
    "    <ul ng-repeat=\"child in item.children\" ng-if=\"item.isExpanded\">\r" +
    "\n" +
    "        <tree-item item=\"child\" item-selected=\"subItemSelected(item)\" use-callback=\"useCallback\"\r" +
    "\n" +
    "                   can-select-item=\"canSelectItem\" multi-select=\"multiSelect\"\r" +
    "\n" +
    "                   on-active-item=\"activeSubItem(item, $event)\"></tree-item>\r" +
    "\n" +
    "    </ul>\r" +
    "\n" +
    "</li>\r" +
    "\n"
  );

}]);

/** Directive for rendering html into plain text */

angular.module('ng-htmlCompiler', [], function($compileProvider) {
      $compileProvider.directive('compile', function($compile) {
            return function(scope, element, attrs) {
                  scope.$watch(
                        function(scope) {
                              return scope.$eval(attrs.compile);
                        },
                        function(value) {
                              element.html(value);
                              $compile(element.contents())(scope);
                        }
                  );
            };
      });
});